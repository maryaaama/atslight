/* eslint-disable */
import { gql } from '@apollo/client';
import * as Apollo from '@apollo/client';
export type Maybe<T> = T | null;
export type InputMaybe<T> = Maybe<T>;
export type Exact<T extends { [key: string]: unknown }> = { [K in keyof T]: T[K] };
export type MakeOptional<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]?: Maybe<T[SubKey]> };
export type MakeMaybe<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]: Maybe<T[SubKey]> };
export type MakeEmpty<T extends { [key: string]: unknown }, K extends keyof T> = { [_ in K]?: never };
export type Incremental<T> = T | { [P in keyof T]?: P extends ' $fragmentName' | '__typename' ? T[P] : never };
const defaultOptions = {} as const;
/** All built-in and custom scalars, mapped to their actual values */
export type Scalars = {
  ID: { input: string; output: string; }
  String: { input: string; output: string; }
  Boolean: { input: boolean; output: boolean; }
  Int: { input: number; output: number; }
  Float: { input: number; output: number; }
  Cursor: { input: any; output: any; }
  Date: { input: any; output: any; }
  Datetime: { input: any; output: any; }
  Html: { input: any; output: any; }
  JSON: { input: any; output: any; }
  UUID: { input: any; output: any; }
};

/** All input for the `acceptInvitation` mutation. */
export type AcceptInvitationInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  token: Scalars['UUID']['input'];
};

/** The output of our `acceptInvitation` mutation. */
export type AcceptInvitationPayload = {
  __typename?: 'AcceptInvitationPayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  companyId?: Maybe<Scalars['Int']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};

export type AllTagsInput = {
  limit: Scalars['Int']['input'];
  search?: InputMaybe<Scalars['String']['input']>;
};

export type AllTagsPayload = {
  __typename?: 'AllTagsPayload';
  tags: CustomTagsConnection;
};

/** All input for the `assignJobs` mutation. */
export type AssignJobsInput = {
  candidatesId?: InputMaybe<Array<InputMaybe<Scalars['Int']['input']>>>;
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  jobsId?: InputMaybe<Array<InputMaybe<Scalars['Int']['input']>>>;
};

/** The output of our `assignJobs` mutation. */
export type AssignJobsPayload = {
  __typename?: 'AssignJobsPayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  jobsApplications?: Maybe<Array<JobsApplication>>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};

/** A filter to be used against Boolean fields. All fields are combined with a logical ‘and.’ */
export type BooleanFilter = {
  /** Not equal to the specified value, treating null like an ordinary value. */
  distinctFrom?: InputMaybe<Scalars['Boolean']['input']>;
  /** Equal to the specified value. */
  equalTo?: InputMaybe<Scalars['Boolean']['input']>;
  /** Greater than the specified value. */
  greaterThan?: InputMaybe<Scalars['Boolean']['input']>;
  /** Greater than or equal to the specified value. */
  greaterThanOrEqualTo?: InputMaybe<Scalars['Boolean']['input']>;
  /** Included in the specified list. */
  in?: InputMaybe<Array<Scalars['Boolean']['input']>>;
  /** Is null (if `true` is specified) or is not null (if `false` is specified). */
  isNull?: InputMaybe<Scalars['Boolean']['input']>;
  /** Less than the specified value. */
  lessThan?: InputMaybe<Scalars['Boolean']['input']>;
  /** Less than or equal to the specified value. */
  lessThanOrEqualTo?: InputMaybe<Scalars['Boolean']['input']>;
  /** Equal to the specified value, treating null like an ordinary value. */
  notDistinctFrom?: InputMaybe<Scalars['Boolean']['input']>;
  /** Not equal to the specified value. */
  notEqualTo?: InputMaybe<Scalars['Boolean']['input']>;
  /** Not included in the specified list. */
  notIn?: InputMaybe<Array<Scalars['Boolean']['input']>>;
};

export type Candidate = Node & {
  __typename?: 'Candidate';
  birthday?: Maybe<Scalars['Date']['output']>;
  canEdit?: Maybe<Scalars['Boolean']['output']>;
  /** Reads and enables pagination through a set of `DraftEvaluation`. */
  candidateDraftEvaluations: DraftEvaluationsConnection;
  /** Reads and enables pagination through a set of `EventDraftEvaluation`. */
  candidateEventDraftEvaluations: EventDraftEvaluationsConnection;
  /** Reads a single `CandidateImportCandidate` that is related to this `Candidate`. */
  candidateImportCandidateByCandidateId?: Maybe<CandidateImportCandidate>;
  /** Reads and enables pagination through a set of `CandidateQuestionnaire`. */
  candidateQuestionnaires: CandidateQuestionnairesConnection;
  /** Reads and enables pagination through a set of `CandidateQuestion`. */
  candidateQuestions: CandidateQuestionsConnection;
  /** Reads and enables pagination through a set of `CandidateTag`. */
  candidateTags: CandidateTagsConnection;
  createdAt: Scalars['Datetime']['output'];
  cvText?: Maybe<Array<Maybe<Scalars['String']['output']>>>;
  /** Reads and enables pagination through a set of `DisqualifyReason`. */
  disqualifyReasons: CandidateDisqualifyReasonsByJobsApplicationCandidateIdAndDisqualifyReasonIdManyToManyConnection;
  /** Reads and enables pagination through a set of `DraftEvaluation`. */
  draftEvaluations: CandidateDraftEvaluationsByEvaluationCandidateIdAndDraftEvaluationIdManyToManyConnection;
  emails?: Maybe<Array<Maybe<Scalars['String']['output']>>>;
  evaluation?: Maybe<Scalars['Int']['output']>;
  /** Reads and enables pagination through a set of `Evaluation`. */
  evaluations: EvaluationsConnection;
  /** Reads and enables pagination through a set of `EventCandidate`. */
  eventCandidates: EventCandidatesConnection;
  /** Reads and enables pagination through a set of `EventDraftEvaluation`. */
  eventDraftEvaluations: CandidateEventDraftEvaluationsByEvaluationCandidateIdAndEventDraftEvaluationIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Event`. */
  events: CandidateEventsByEventCandidateCandidateIdAndEventIdManyToManyConnection;
  extractedText?: Maybe<Array<Maybe<Scalars['String']['output']>>>;
  /** Reads and enables pagination through a set of `CandidateFile`. */
  files: CandidateFilesConnection;
  gender?: Maybe<Gender>;
  id: Scalars['Int']['output'];
  /** Reads and enables pagination through a set of `Job`. */
  jobs: CandidateJobsByJobsApplicationCandidateIdAndJobIdManyToManyConnection;
  /** Reads and enables pagination through a set of `JobsApplication`. */
  jobsApplications: JobsApplicationsConnection;
  language: Language;
  links?: Maybe<Array<Maybe<Scalars['String']['output']>>>;
  militaryStatus?: Maybe<MilitaryStatus>;
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  phones?: Maybe<Array<Maybe<Scalars['String']['output']>>>;
  photoExternalId?: Maybe<Scalars['UUID']['output']>;
  photoUrl?: Maybe<Scalars['String']['output']>;
  /** Reads and enables pagination through a set of `PipelineStage`. */
  pipelineStages: CandidatePipelineStagesByJobsApplicationCandidateIdAndPipelineStageIdManyToManyConnection;
  /** Reads and enables pagination through a set of `QuestionOption`. */
  questionOptions: CandidateQuestionOptionsByCandidateQuestionCandidateIdAndQuestionOptionIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Questionnaire`. */
  questionnaires: CandidateQuestionnairesByCandidateQuestionnaireCandidateIdAndQuestionnaireIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Question`. */
  questions: CandidateQuestionsByCandidateQuestionCandidateIdAndQuestionIdManyToManyConnection;
  resumeExternalId?: Maybe<Scalars['UUID']['output']>;
  resumeUrl?: Maybe<Scalars['String']['output']>;
  socialLinks?: Maybe<Array<Maybe<Scalars['String']['output']>>>;
  /** Reads and enables pagination through a set of `Tag`. */
  tags: CandidateTagsByCandidateTagCandidateIdAndTagIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Thread`. */
  threads: ThreadsConnection;
  /** Reads and enables pagination through a set of `CandidateTranslation`. */
  translations: CandidateTranslationsConnection;
  updatedAt: Scalars['Datetime']['output'];
  /** Reads and enables pagination through a set of `User`. */
  users: CandidateUsersByThreadCandidateIdAndUserIdManyToManyConnection;
};


export type CandidateCandidateDraftEvaluationsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<DraftEvaluationCondition>;
  filter?: InputMaybe<DraftEvaluationFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<DraftEvaluationsOrderBy>>;
};


export type CandidateCandidateEventDraftEvaluationsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<EventDraftEvaluationCondition>;
  filter?: InputMaybe<EventDraftEvaluationFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<EventDraftEvaluationsOrderBy>>;
};


export type CandidateCandidateQuestionnairesArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<CandidateQuestionnaireCondition>;
  filter?: InputMaybe<CandidateQuestionnaireFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<CandidateQuestionnairesOrderBy>>;
};


export type CandidateCandidateQuestionsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<CandidateQuestionCondition>;
  filter?: InputMaybe<CandidateQuestionFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<CandidateQuestionsOrderBy>>;
};


export type CandidateCandidateTagsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<CandidateTagCondition>;
  filter?: InputMaybe<CandidateTagFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<CandidateTagsOrderBy>>;
};


export type CandidateDisqualifyReasonsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<DisqualifyReasonCondition>;
  filter?: InputMaybe<DisqualifyReasonFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<DisqualifyReasonsOrderBy>>;
};


export type CandidateDraftEvaluationsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<DraftEvaluationCondition>;
  filter?: InputMaybe<DraftEvaluationFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<DraftEvaluationsOrderBy>>;
};


export type CandidateEvaluationsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<EvaluationCondition>;
  filter?: InputMaybe<EvaluationFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<EvaluationsOrderBy>>;
};


export type CandidateEventCandidatesArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<EventCandidateCondition>;
  filter?: InputMaybe<EventCandidateFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<EventCandidatesOrderBy>>;
};


export type CandidateEventDraftEvaluationsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<EventDraftEvaluationCondition>;
  filter?: InputMaybe<EventDraftEvaluationFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<EventDraftEvaluationsOrderBy>>;
};


export type CandidateEventsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<EventCondition>;
  filter?: InputMaybe<EventFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<EventsOrderBy>>;
};


export type CandidateFilesArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<CandidateFileCondition>;
  filter?: InputMaybe<CandidateFileFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<CandidateFilesOrderBy>>;
};


export type CandidateJobsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<JobCondition>;
  filter?: InputMaybe<JobFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<JobsOrderBy>>;
};


export type CandidateJobsApplicationsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<JobsApplicationCondition>;
  filter?: InputMaybe<JobsApplicationFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<JobsApplicationsOrderBy>>;
};


export type CandidatePipelineStagesArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<PipelineStageCondition>;
  filter?: InputMaybe<PipelineStageFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<PipelineStagesOrderBy>>;
};


export type CandidateQuestionOptionsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<QuestionOptionCondition>;
  filter?: InputMaybe<QuestionOptionFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<QuestionOptionsOrderBy>>;
};


export type CandidateQuestionnairesArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<QuestionnaireCondition>;
  filter?: InputMaybe<QuestionnaireFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<QuestionnairesOrderBy>>;
};


export type CandidateQuestionsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<QuestionCondition>;
  filter?: InputMaybe<QuestionFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<QuestionsOrderBy>>;
};


export type CandidateTagsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<TagCondition>;
  filter?: InputMaybe<TagFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<TagsOrderBy>>;
};


export type CandidateThreadsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<ThreadCondition>;
  filter?: InputMaybe<ThreadFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<ThreadsOrderBy>>;
};


export type CandidateTranslationsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<CandidateTranslationCondition>;
  filter?: InputMaybe<CandidateTranslationFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<CandidateTranslationsOrderBy>>;
};


export type CandidateUsersArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<UserCondition>;
  filter?: InputMaybe<UserFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<UsersOrderBy>>;
};

/** The fields on `candidate` to look up the row to connect. */
export type CandidateCandidatesPkeyConnect = {
  id: Scalars['Int']['input'];
};

/** A condition to be used against `Candidate` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type CandidateCondition = {
  /** Checks for equality with the object’s `createdAt` field. */
  createdAt?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `emails` field. */
  emails?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  /** Checks for equality with the object’s `extractedText` field. */
  extractedText?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  /** Checks for equality with the object’s `gender` field. */
  gender?: InputMaybe<Gender>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `militaryStatus` field. */
  militaryStatus?: InputMaybe<MilitaryStatus>;
  /** Checks for equality with the object’s `phones` field. */
  phones?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  /** Checks for equality with the object’s `updatedAt` field. */
  updatedAt?: InputMaybe<Scalars['Datetime']['input']>;
};

/** A connection to a list of `DisqualifyReason` values, with data from `JobsApplication`. */
export type CandidateDisqualifyReasonsByJobsApplicationCandidateIdAndDisqualifyReasonIdManyToManyConnection = {
  __typename?: 'CandidateDisqualifyReasonsByJobsApplicationCandidateIdAndDisqualifyReasonIdManyToManyConnection';
  /** A list of edges which contains the `DisqualifyReason`, info from the `JobsApplication`, and the cursor to aid in pagination. */
  edges: Array<CandidateDisqualifyReasonsByJobsApplicationCandidateIdAndDisqualifyReasonIdManyToManyEdge>;
  /** A list of `DisqualifyReason` objects. */
  nodes: Array<DisqualifyReason>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `DisqualifyReason` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `DisqualifyReason` edge in the connection, with data from `JobsApplication`. */
export type CandidateDisqualifyReasonsByJobsApplicationCandidateIdAndDisqualifyReasonIdManyToManyEdge = {
  __typename?: 'CandidateDisqualifyReasonsByJobsApplicationCandidateIdAndDisqualifyReasonIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** Reads and enables pagination through a set of `JobsApplication`. */
  jobsApplications: JobsApplicationsConnection;
  /** The `DisqualifyReason` at the end of the edge. */
  node: DisqualifyReason;
};


/** A `DisqualifyReason` edge in the connection, with data from `JobsApplication`. */
export type CandidateDisqualifyReasonsByJobsApplicationCandidateIdAndDisqualifyReasonIdManyToManyEdgeJobsApplicationsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<JobsApplicationCondition>;
  filter?: InputMaybe<JobsApplicationFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<JobsApplicationsOrderBy>>;
};

/** A connection to a list of `DraftEvaluation` values, with data from `Evaluation`. */
export type CandidateDraftEvaluationsByEvaluationCandidateIdAndDraftEvaluationIdManyToManyConnection = {
  __typename?: 'CandidateDraftEvaluationsByEvaluationCandidateIdAndDraftEvaluationIdManyToManyConnection';
  /** A list of edges which contains the `DraftEvaluation`, info from the `Evaluation`, and the cursor to aid in pagination. */
  edges: Array<CandidateDraftEvaluationsByEvaluationCandidateIdAndDraftEvaluationIdManyToManyEdge>;
  /** A list of `DraftEvaluation` objects. */
  nodes: Array<DraftEvaluation>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `DraftEvaluation` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `DraftEvaluation` edge in the connection, with data from `Evaluation`. */
export type CandidateDraftEvaluationsByEvaluationCandidateIdAndDraftEvaluationIdManyToManyEdge = {
  __typename?: 'CandidateDraftEvaluationsByEvaluationCandidateIdAndDraftEvaluationIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** Reads and enables pagination through a set of `Evaluation`. */
  evaluations: EvaluationsConnection;
  /** The `DraftEvaluation` at the end of the edge. */
  node: DraftEvaluation;
};


/** A `DraftEvaluation` edge in the connection, with data from `Evaluation`. */
export type CandidateDraftEvaluationsByEvaluationCandidateIdAndDraftEvaluationIdManyToManyEdgeEvaluationsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<EvaluationCondition>;
  filter?: InputMaybe<EvaluationFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<EvaluationsOrderBy>>;
};

/** A connection to a list of `EventDraftEvaluation` values, with data from `Evaluation`. */
export type CandidateEventDraftEvaluationsByEvaluationCandidateIdAndEventDraftEvaluationIdManyToManyConnection = {
  __typename?: 'CandidateEventDraftEvaluationsByEvaluationCandidateIdAndEventDraftEvaluationIdManyToManyConnection';
  /** A list of edges which contains the `EventDraftEvaluation`, info from the `Evaluation`, and the cursor to aid in pagination. */
  edges: Array<CandidateEventDraftEvaluationsByEvaluationCandidateIdAndEventDraftEvaluationIdManyToManyEdge>;
  /** A list of `EventDraftEvaluation` objects. */
  nodes: Array<EventDraftEvaluation>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `EventDraftEvaluation` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `EventDraftEvaluation` edge in the connection, with data from `Evaluation`. */
export type CandidateEventDraftEvaluationsByEvaluationCandidateIdAndEventDraftEvaluationIdManyToManyEdge = {
  __typename?: 'CandidateEventDraftEvaluationsByEvaluationCandidateIdAndEventDraftEvaluationIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** Reads and enables pagination through a set of `Evaluation`. */
  evaluations: EvaluationsConnection;
  /** The `EventDraftEvaluation` at the end of the edge. */
  node: EventDraftEvaluation;
};


/** A `EventDraftEvaluation` edge in the connection, with data from `Evaluation`. */
export type CandidateEventDraftEvaluationsByEvaluationCandidateIdAndEventDraftEvaluationIdManyToManyEdgeEvaluationsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<EvaluationCondition>;
  filter?: InputMaybe<EvaluationFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<EvaluationsOrderBy>>;
};

/** A connection to a list of `Event` values, with data from `EventCandidate`. */
export type CandidateEventsByEventCandidateCandidateIdAndEventIdManyToManyConnection = {
  __typename?: 'CandidateEventsByEventCandidateCandidateIdAndEventIdManyToManyConnection';
  /** A list of edges which contains the `Event`, info from the `EventCandidate`, and the cursor to aid in pagination. */
  edges: Array<CandidateEventsByEventCandidateCandidateIdAndEventIdManyToManyEdge>;
  /** A list of `Event` objects. */
  nodes: Array<Event>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Event` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `Event` edge in the connection, with data from `EventCandidate`. */
export type CandidateEventsByEventCandidateCandidateIdAndEventIdManyToManyEdge = {
  __typename?: 'CandidateEventsByEventCandidateCandidateIdAndEventIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** Reads and enables pagination through a set of `EventCandidate`. */
  eventCandidates: EventCandidatesConnection;
  /** The `Event` at the end of the edge. */
  node: Event;
};


/** A `Event` edge in the connection, with data from `EventCandidate`. */
export type CandidateEventsByEventCandidateCandidateIdAndEventIdManyToManyEdgeEventCandidatesArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<EventCandidateCondition>;
  filter?: InputMaybe<EventCandidateFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<EventCandidatesOrderBy>>;
};

export type CandidateFile = Node & {
  __typename?: 'CandidateFile';
  /** Reads a single `Candidate` that is related to this `CandidateFile`. */
  candidate?: Maybe<Candidate>;
  candidateId: Scalars['Int']['output'];
  /** Reads and enables pagination through a set of `CandidateQuestion`. */
  candidateQuestionsByFileValueExternalId: CandidateQuestionsConnection;
  createdAt: Scalars['Datetime']['output'];
  externalId: Scalars['UUID']['output'];
  extractedText?: Maybe<Scalars['String']['output']>;
  name: Scalars['String']['output'];
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
};


export type CandidateFileCandidateQuestionsByFileValueExternalIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<CandidateQuestionCondition>;
  filter?: InputMaybe<CandidateQuestionFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<CandidateQuestionsOrderBy>>;
};

/** The fields on `candidateFile` to look up the row to connect. */
export type CandidateFileCandidateFilesPkeyConnect = {
  externalId: Scalars['UUID']['input'];
};

/** The fields on `candidateFile` to look up the row to delete. */
export type CandidateFileCandidateFilesPkeyDelete = {
  externalId: Scalars['UUID']['input'];
};

/** A condition to be used against `CandidateFile` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type CandidateFileCondition = {
  /** Checks for equality with the object’s `candidateId` field. */
  candidateId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `externalId` field. */
  externalId?: InputMaybe<Scalars['UUID']['input']>;
  /** Checks for equality with the object’s `extractedText` field. */
  extractedText?: InputMaybe<Scalars['String']['input']>;
};

/** A filter to be used against `CandidateFile` object types. All fields are combined with a logical ‘and.’ */
export type CandidateFileFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<CandidateFileFilter>>;
  /** Filter by the object’s `candidate` relation. */
  candidate?: InputMaybe<CandidateFilter>;
  /** Filter by the object’s `candidateId` field. */
  candidateId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `candidateQuestionsByFileValueExternalId` relation. */
  candidateQuestionsByFileValueExternalId?: InputMaybe<CandidateFileToManyCandidateQuestionFilter>;
  /** Some related `candidateQuestionsByFileValueExternalId` exist. */
  candidateQuestionsByFileValueExternalIdExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `externalId` field. */
  externalId?: InputMaybe<UuidFilter>;
  /** Filter by the object’s `extractedText` field. */
  extractedText?: InputMaybe<StringFilter>;
  /** Negates the expression. */
  not?: InputMaybe<CandidateFileFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<CandidateFileFilter>>;
};

/** An input for mutations affecting `CandidateFile` */
export type CandidateFileInput = {
  candidate?: InputMaybe<CandidateFilesCandidateIdFkeyInput>;
  candidateId?: InputMaybe<Scalars['Int']['input']>;
  candidateQuestions?: InputMaybe<CandidateQuestionsFileValueExternalIdFkeyInverseInput>;
  externalId: Scalars['UUID']['input'];
  extractedText?: InputMaybe<Scalars['String']['input']>;
  name: Scalars['String']['input'];
};

/** The globally unique `ID` look up for the row to connect. */
export type CandidateFileNodeIdConnect = {
  /** The globally unique `ID` which identifies a single `candidateFile` to be connected. */
  nodeId: Scalars['ID']['input'];
};

/** The globally unique `ID` look up for the row to delete. */
export type CandidateFileNodeIdDelete = {
  /** The globally unique `ID` which identifies a single `candidateFile` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** The globally unique `ID` look up for the row to update. */
export type CandidateFileOnCandidateFileForCandidateFilesCandidateIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `candidate` to be connected. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `candidate` being updated. */
  patch: CandidatePatch;
};

/** The fields on `candidateFile` to look up the row to update. */
export type CandidateFileOnCandidateFileForCandidateFilesCandidateIdFkeyUsingCandidateFilesPkeyUpdate = {
  externalId: Scalars['UUID']['input'];
  /** An object where the defined keys will be set on the `candidateFile` being updated. */
  patch: UpdateCandidateFileOnCandidateFileForCandidateFilesCandidateIdFkeyPatch;
};

/** The globally unique `ID` look up for the row to update. */
export type CandidateFileOnCandidateQuestionForCandidateQuestionsFileValueExternalIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `candidateQuestion` to be connected. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `candidateQuestion` being updated. */
  patch: CandidateQuestionPatch;
};

/** The fields on `candidateFile` to look up the row to update. */
export type CandidateFileOnCandidateQuestionForCandidateQuestionsFileValueExternalIdFkeyUsingCandidateFilesPkeyUpdate = {
  externalId: Scalars['UUID']['input'];
  /** An object where the defined keys will be set on the `candidateFile` being updated. */
  patch: UpdateCandidateFileOnCandidateQuestionForCandidateQuestionsFileValueExternalIdFkeyPatch;
};

/** Represents an update to a `CandidateFile`. Fields that are set will be updated. */
export type CandidateFilePatch = {
  candidate?: InputMaybe<CandidateFilesCandidateIdFkeyInput>;
  candidateId?: InputMaybe<Scalars['Int']['input']>;
  candidateQuestions?: InputMaybe<CandidateQuestionsFileValueExternalIdFkeyInverseInput>;
};

/** A filter to be used against many `CandidateQuestion` object types. All fields are combined with a logical ‘and.’ */
export type CandidateFileToManyCandidateQuestionFilter = {
  /** Every related `CandidateQuestion` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<CandidateQuestionFilter>;
  /** No related `CandidateQuestion` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<CandidateQuestionFilter>;
  /** Some related `CandidateQuestion` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<CandidateQuestionFilter>;
};

/** The `candidateFile` to be created by this mutation. */
export type CandidateFilesCandidateIdFkeyCandidateFilesCreateInput = {
  candidate?: InputMaybe<CandidateFilesCandidateIdFkeyInput>;
  candidateQuestions?: InputMaybe<CandidateQuestionsFileValueExternalIdFkeyInverseInput>;
  externalId: Scalars['UUID']['input'];
  extractedText?: InputMaybe<Scalars['String']['input']>;
  name: Scalars['String']['input'];
};

/** The `candidate` to be created by this mutation. */
export type CandidateFilesCandidateIdFkeyCandidatesCreateInput = {
  birthday?: InputMaybe<Scalars['Date']['input']>;
  candidateDraftEvaluations?: InputMaybe<DraftEvaluationsCandidateIdFkeyInverseInput>;
  candidateEventDraftEvaluations?: InputMaybe<EventDraftEvaluationsCandidateIdFkeyInverseInput>;
  candidateImportCandidate?: InputMaybe<CandidateImportCandidatesCandidateIdFkeyInverseInput>;
  candidateQuestionnaires?: InputMaybe<CandidateQuestionnairesCandidateIdFkeyInverseInput>;
  candidateQuestions?: InputMaybe<CandidateQuestionsCandidateIdFkeyInverseInput>;
  candidateTags?: InputMaybe<CandidateTagsCandidateIdFkeyInverseInput>;
  cvText?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  emails?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  evaluations?: InputMaybe<EvaluationsCandidateIdFkeyInverseInput>;
  eventCandidates?: InputMaybe<EventCandidatesCandidateIdFkeyInverseInput>;
  files?: InputMaybe<CandidateFilesCandidateIdFkeyInverseInput>;
  gender?: InputMaybe<Gender>;
  jobsApplications?: InputMaybe<JobsApplicationsCandidateIdFkeyInverseInput>;
  language: Language;
  links?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  militaryStatus?: InputMaybe<MilitaryStatus>;
  phones?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  photoExternalId?: InputMaybe<Scalars['UUID']['input']>;
  resumeExternalId?: InputMaybe<Scalars['UUID']['input']>;
  socialLinks?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  sources?: InputMaybe<Array<Scalars['String']['input']>>;
  tags?: InputMaybe<Array<Scalars['String']['input']>>;
  threads?: InputMaybe<ThreadsCandidateIdFkeyInverseInput>;
  translations?: InputMaybe<CandidateTranslationsCandidateIdFkeyInverseInput>;
};

/** Input for the nested mutation of `candidate` in the `CandidateFileInput` mutation. */
export type CandidateFilesCandidateIdFkeyInput = {
  /** The primary key(s) for `candidate` for the far side of the relationship. */
  connectById?: InputMaybe<CandidateCandidatesPkeyConnect>;
  /** The primary key(s) for `candidate` for the far side of the relationship. */
  connectByNodeId?: InputMaybe<CandidateNodeIdConnect>;
  /** A `CandidateInput` object that will be created and connected to this object. */
  create?: InputMaybe<CandidateFilesCandidateIdFkeyCandidatesCreateInput>;
  /** The primary key(s) and patch data for `candidate` for the far side of the relationship. */
  updateById?: InputMaybe<CandidateOnCandidateFileForCandidateFilesCandidateIdFkeyUsingCandidatesPkeyUpdate>;
  /** The primary key(s) and patch data for `candidate` for the far side of the relationship. */
  updateByNodeId?: InputMaybe<CandidateFileOnCandidateFileForCandidateFilesCandidateIdFkeyNodeIdUpdate>;
};

/** Input for the nested mutation of `candidateFile` in the `CandidateInput` mutation. */
export type CandidateFilesCandidateIdFkeyInverseInput = {
  /** The primary key(s) for `candidateFile` for the far side of the relationship. */
  connectByExternalId?: InputMaybe<Array<CandidateFileCandidateFilesPkeyConnect>>;
  /** The primary key(s) for `candidateFile` for the far side of the relationship. */
  connectByNodeId?: InputMaybe<Array<CandidateFileNodeIdConnect>>;
  /** A `CandidateFileInput` object that will be created and connected to this object. */
  create?: InputMaybe<Array<CandidateFilesCandidateIdFkeyCandidateFilesCreateInput>>;
  /** The primary key(s) for `candidateFile` for the far side of the relationship. */
  deleteByExternalId?: InputMaybe<Array<CandidateFileCandidateFilesPkeyDelete>>;
  /** The primary key(s) for `candidateFile` for the far side of the relationship. */
  deleteByNodeId?: InputMaybe<Array<CandidateFileNodeIdDelete>>;
  /** Flag indicating whether all other `candidateFile` records that match this relationship should be removed. */
  deleteOthers?: InputMaybe<Scalars['Boolean']['input']>;
  /** The primary key(s) and patch data for `candidateFile` for the far side of the relationship. */
  updateByExternalId?: InputMaybe<Array<CandidateFileOnCandidateFileForCandidateFilesCandidateIdFkeyUsingCandidateFilesPkeyUpdate>>;
  /** The primary key(s) and patch data for `candidateFile` for the far side of the relationship. */
  updateByNodeId?: InputMaybe<Array<CandidateOnCandidateFileForCandidateFilesCandidateIdFkeyNodeIdUpdate>>;
};

/** A connection to a list of `CandidateFile` values. */
export type CandidateFilesConnection = {
  __typename?: 'CandidateFilesConnection';
  /** A list of edges which contains the `CandidateFile` and cursor to aid in pagination. */
  edges: Array<CandidateFilesEdge>;
  /** A list of `CandidateFile` objects. */
  nodes: Array<CandidateFile>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `CandidateFile` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `CandidateFile` edge in the connection. */
export type CandidateFilesEdge = {
  __typename?: 'CandidateFilesEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `CandidateFile` at the end of the edge. */
  node: CandidateFile;
};

/** Methods to use when ordering `CandidateFile`. */
export enum CandidateFilesOrderBy {
  CandidateIdAsc = 'CANDIDATE_ID_ASC',
  CandidateIdDesc = 'CANDIDATE_ID_DESC',
  ExternalIdAsc = 'EXTERNAL_ID_ASC',
  ExternalIdDesc = 'EXTERNAL_ID_DESC',
  ExtractedTextAsc = 'EXTRACTED_TEXT_ASC',
  ExtractedTextDesc = 'EXTRACTED_TEXT_DESC',
  Natural = 'NATURAL',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC'
}

/** A filter to be used against `Candidate` object types. All fields are combined with a logical ‘and.’ */
export type CandidateFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<CandidateFilter>>;
  /** Filter by the object’s `canEdit` field. */
  canEdit?: InputMaybe<BooleanFilter>;
  /** Filter by the object’s `candidateDraftEvaluations` relation. */
  candidateDraftEvaluations?: InputMaybe<CandidateToManyDraftEvaluationFilter>;
  /** Some related `candidateDraftEvaluations` exist. */
  candidateDraftEvaluationsExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `candidateEventDraftEvaluations` relation. */
  candidateEventDraftEvaluations?: InputMaybe<CandidateToManyEventDraftEvaluationFilter>;
  /** Some related `candidateEventDraftEvaluations` exist. */
  candidateEventDraftEvaluationsExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `candidateImportCandidateByCandidateId` relation. */
  candidateImportCandidateByCandidateId?: InputMaybe<CandidateImportCandidateFilter>;
  /** A related `candidateImportCandidateByCandidateId` exists. */
  candidateImportCandidateByCandidateIdExists?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `candidateQuestionnaires` relation. */
  candidateQuestionnaires?: InputMaybe<CandidateToManyCandidateQuestionnaireFilter>;
  /** Some related `candidateQuestionnaires` exist. */
  candidateQuestionnairesExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `candidateQuestions` relation. */
  candidateQuestions?: InputMaybe<CandidateToManyCandidateQuestionFilter>;
  /** Some related `candidateQuestions` exist. */
  candidateQuestionsExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `candidateTags` relation. */
  candidateTags?: InputMaybe<CandidateToManyCandidateTagFilter>;
  /** Some related `candidateTags` exist. */
  candidateTagsExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `createdAt` field. */
  createdAt?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `emails` field. */
  emails?: InputMaybe<StringListFilter>;
  /** Filter by the object’s `evaluations` relation. */
  evaluations?: InputMaybe<CandidateToManyEvaluationFilter>;
  /** Some related `evaluations` exist. */
  evaluationsExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `eventCandidates` relation. */
  eventCandidates?: InputMaybe<CandidateToManyEventCandidateFilter>;
  /** Some related `eventCandidates` exist. */
  eventCandidatesExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `extractedText` field. */
  extractedText?: InputMaybe<StringListFilter>;
  /** Filter by the object’s `files` relation. */
  files?: InputMaybe<CandidateToManyCandidateFileFilter>;
  /** Some related `files` exist. */
  filesExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `gender` field. */
  gender?: InputMaybe<GenderFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<IntFilter>;
  /** Filter by the object’s `jobsApplications` relation. */
  jobsApplications?: InputMaybe<CandidateToManyJobsApplicationFilter>;
  /** Some related `jobsApplications` exist. */
  jobsApplicationsExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `militaryStatus` field. */
  militaryStatus?: InputMaybe<MilitaryStatusFilter>;
  /** Negates the expression. */
  not?: InputMaybe<CandidateFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<CandidateFilter>>;
  /** Filter by the object’s `phones` field. */
  phones?: InputMaybe<StringListFilter>;
  /** Filter by the object’s `threads` relation. */
  threads?: InputMaybe<CandidateToManyThreadFilter>;
  /** Some related `threads` exist. */
  threadsExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `translations` relation. */
  translations?: InputMaybe<CandidateToManyCandidateTranslationFilter>;
  /** Some related `translations` exist. */
  translationsExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `updatedAt` field. */
  updatedAt?: InputMaybe<DatetimeFilter>;
};

export type CandidateImport = Node & {
  __typename?: 'CandidateImport';
  /** Reads and enables pagination through a set of `CandidateImportCandidate`. */
  candidateImportCandidates: CandidateImportCandidatesConnection;
  createdAt: Scalars['Datetime']['output'];
  /** Reads and enables pagination through a set of `CandidateImportFile`. */
  files: CandidateImportFilesConnection;
  id: Scalars['Int']['output'];
  jobIds?: Maybe<Array<Maybe<Scalars['Int']['output']>>>;
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  sources?: Maybe<Array<Maybe<Scalars['String']['output']>>>;
  tags?: Maybe<Array<Maybe<Scalars['String']['output']>>>;
};


export type CandidateImportCandidateImportCandidatesArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<CandidateImportCandidateCondition>;
  filter?: InputMaybe<CandidateImportCandidateFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<CandidateImportCandidatesOrderBy>>;
};


export type CandidateImportFilesArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<CandidateImportFileCondition>;
  filter?: InputMaybe<CandidateImportFileFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<CandidateImportFilesOrderBy>>;
};

export type CandidateImportCandidate = Node & {
  __typename?: 'CandidateImportCandidate';
  /** Reads a single `Candidate` that is related to this `CandidateImportCandidate`. */
  candidate?: Maybe<Candidate>;
  candidateId: Scalars['Int']['output'];
  /** Reads a single `CandidateImport` that is related to this `CandidateImportCandidate`. */
  candidateImport?: Maybe<CandidateImport>;
  candidateImportFileExternalId: Scalars['UUID']['output'];
  candidateImportId: Scalars['Int']['output'];
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
};

/** The fields on `candidateImportCandidate` to look up the row to connect. */
export type CandidateImportCandidateCandidateImportCandidatesPkeyConnect = {
  candidateId: Scalars['Int']['input'];
};

/** A condition to be used against `CandidateImportCandidate` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type CandidateImportCandidateCondition = {
  /** Checks for equality with the object’s `candidateId` field. */
  candidateId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `candidateImportFileExternalId` field. */
  candidateImportFileExternalId?: InputMaybe<Scalars['UUID']['input']>;
  /** Checks for equality with the object’s `candidateImportId` field. */
  candidateImportId?: InputMaybe<Scalars['Int']['input']>;
};

/** A filter to be used against `CandidateImportCandidate` object types. All fields are combined with a logical ‘and.’ */
export type CandidateImportCandidateFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<CandidateImportCandidateFilter>>;
  /** Filter by the object’s `candidate` relation. */
  candidate?: InputMaybe<CandidateFilter>;
  /** Filter by the object’s `candidateId` field. */
  candidateId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `candidateImport` relation. */
  candidateImport?: InputMaybe<CandidateImportFilter>;
  /** Filter by the object’s `candidateImportFileExternalId` field. */
  candidateImportFileExternalId?: InputMaybe<UuidFilter>;
  /** Filter by the object’s `candidateImportId` field. */
  candidateImportId?: InputMaybe<IntFilter>;
  /** Negates the expression. */
  not?: InputMaybe<CandidateImportCandidateFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<CandidateImportCandidateFilter>>;
};

/** The fields on `candidateImport` to look up the row to connect. */
export type CandidateImportCandidateImportsPkeyConnect = {
  id: Scalars['Int']['input'];
};

/** An input for mutations affecting `CandidateImportCandidate` */
export type CandidateImportCandidateInput = {
  candidate?: InputMaybe<CandidateImportCandidatesCandidateIdFkeyInput>;
  candidateId?: InputMaybe<Scalars['Int']['input']>;
  candidateImport?: InputMaybe<CandidateImportCandidatesCandidateImportIdFkeyInput>;
  candidateImportFileExternalId: Scalars['UUID']['input'];
  candidateImportId?: InputMaybe<Scalars['Int']['input']>;
};

/** The globally unique `ID` look up for the row to connect. */
export type CandidateImportCandidateNodeIdConnect = {
  /** The globally unique `ID` which identifies a single `candidateImportCandidate` to be connected. */
  nodeId: Scalars['ID']['input'];
};

/** The globally unique `ID` look up for the row to update. */
export type CandidateImportCandidateOnCandidateImportCandidateForCandidateImportCandidatesCandidateIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `candidate` to be connected. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `candidate` being updated. */
  patch: CandidatePatch;
};

/** The fields on `candidateImportCandidate` to look up the row to update. */
export type CandidateImportCandidateOnCandidateImportCandidateForCandidateImportCandidatesCandidateIdFkeyUsingCandidateImportCandidatesPkeyUpdate = {
  candidateId: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `candidateImportCandidate` being updated. */
  patch: UpdateCandidateImportCandidateOnCandidateImportCandidateForCandidateImportCandidatesCandidateIdFkeyPatch;
};

/** The globally unique `ID` look up for the row to update. */
export type CandidateImportCandidateOnCandidateImportCandidateForCandidateImportCandidatesCandidateImportIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `candidateImport` to be connected. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `candidateImport` being updated. */
  patch: CandidateImportPatch;
};

/** The fields on `candidateImportCandidate` to look up the row to update. */
export type CandidateImportCandidateOnCandidateImportCandidateForCandidateImportCandidatesCandidateImportIdFkeyUsingCandidateImportCandidatesPkeyUpdate = {
  candidateId: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `candidateImportCandidate` being updated. */
  patch: UpdateCandidateImportCandidateOnCandidateImportCandidateForCandidateImportCandidatesCandidateImportIdFkeyPatch;
};

/** Represents an update to a `CandidateImportCandidate`. Fields that are set will be updated. */
export type CandidateImportCandidatePatch = {
  candidate?: InputMaybe<CandidateImportCandidatesCandidateIdFkeyInput>;
  candidateId?: InputMaybe<Scalars['Int']['input']>;
  candidateImport?: InputMaybe<CandidateImportCandidatesCandidateImportIdFkeyInput>;
  candidateImportId?: InputMaybe<Scalars['Int']['input']>;
};

/** The `candidateImportCandidate` to be created by this mutation. */
export type CandidateImportCandidatesCandidateIdFkeyCandidateImportCandidatesCreateInput = {
  candidate?: InputMaybe<CandidateImportCandidatesCandidateIdFkeyInput>;
  candidateImport?: InputMaybe<CandidateImportCandidatesCandidateImportIdFkeyInput>;
  candidateImportFileExternalId: Scalars['UUID']['input'];
  candidateImportId?: InputMaybe<Scalars['Int']['input']>;
};

/** The `candidate` to be created by this mutation. */
export type CandidateImportCandidatesCandidateIdFkeyCandidatesCreateInput = {
  birthday?: InputMaybe<Scalars['Date']['input']>;
  candidateDraftEvaluations?: InputMaybe<DraftEvaluationsCandidateIdFkeyInverseInput>;
  candidateEventDraftEvaluations?: InputMaybe<EventDraftEvaluationsCandidateIdFkeyInverseInput>;
  candidateImportCandidate?: InputMaybe<CandidateImportCandidatesCandidateIdFkeyInverseInput>;
  candidateQuestionnaires?: InputMaybe<CandidateQuestionnairesCandidateIdFkeyInverseInput>;
  candidateQuestions?: InputMaybe<CandidateQuestionsCandidateIdFkeyInverseInput>;
  candidateTags?: InputMaybe<CandidateTagsCandidateIdFkeyInverseInput>;
  cvText?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  emails?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  evaluations?: InputMaybe<EvaluationsCandidateIdFkeyInverseInput>;
  eventCandidates?: InputMaybe<EventCandidatesCandidateIdFkeyInverseInput>;
  files?: InputMaybe<CandidateFilesCandidateIdFkeyInverseInput>;
  gender?: InputMaybe<Gender>;
  jobsApplications?: InputMaybe<JobsApplicationsCandidateIdFkeyInverseInput>;
  language: Language;
  links?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  militaryStatus?: InputMaybe<MilitaryStatus>;
  phones?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  photoExternalId?: InputMaybe<Scalars['UUID']['input']>;
  resumeExternalId?: InputMaybe<Scalars['UUID']['input']>;
  socialLinks?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  sources?: InputMaybe<Array<Scalars['String']['input']>>;
  tags?: InputMaybe<Array<Scalars['String']['input']>>;
  threads?: InputMaybe<ThreadsCandidateIdFkeyInverseInput>;
  translations?: InputMaybe<CandidateTranslationsCandidateIdFkeyInverseInput>;
};

/** Input for the nested mutation of `candidate` in the `CandidateImportCandidateInput` mutation. */
export type CandidateImportCandidatesCandidateIdFkeyInput = {
  /** The primary key(s) for `candidate` for the far side of the relationship. */
  connectById?: InputMaybe<CandidateCandidatesPkeyConnect>;
  /** The primary key(s) for `candidate` for the far side of the relationship. */
  connectByNodeId?: InputMaybe<CandidateNodeIdConnect>;
  /** A `CandidateInput` object that will be created and connected to this object. */
  create?: InputMaybe<CandidateImportCandidatesCandidateIdFkeyCandidatesCreateInput>;
  /** The primary key(s) and patch data for `candidate` for the far side of the relationship. */
  updateById?: InputMaybe<CandidateOnCandidateImportCandidateForCandidateImportCandidatesCandidateIdFkeyUsingCandidatesPkeyUpdate>;
  /** The primary key(s) and patch data for `candidate` for the far side of the relationship. */
  updateByNodeId?: InputMaybe<CandidateImportCandidateOnCandidateImportCandidateForCandidateImportCandidatesCandidateIdFkeyNodeIdUpdate>;
};

/** Input for the nested mutation of `candidateImportCandidate` in the `CandidateInput` mutation. */
export type CandidateImportCandidatesCandidateIdFkeyInverseInput = {
  /** The primary key(s) for `candidateImportCandidate` for the far side of the relationship. */
  connectByCandidateId?: InputMaybe<CandidateImportCandidateCandidateImportCandidatesPkeyConnect>;
  /** The primary key(s) for `candidateImportCandidate` for the far side of the relationship. */
  connectByNodeId?: InputMaybe<CandidateImportCandidateNodeIdConnect>;
  /** A `CandidateImportCandidateInput` object that will be created and connected to this object. */
  create?: InputMaybe<Array<CandidateImportCandidatesCandidateIdFkeyCandidateImportCandidatesCreateInput>>;
  /** The primary key(s) and patch data for `candidateImportCandidate` for the far side of the relationship. */
  updateByCandidateId?: InputMaybe<CandidateImportCandidateOnCandidateImportCandidateForCandidateImportCandidatesCandidateIdFkeyUsingCandidateImportCandidatesPkeyUpdate>;
  /** The primary key(s) and patch data for `candidateImportCandidate` for the far side of the relationship. */
  updateByNodeId?: InputMaybe<CandidateOnCandidateImportCandidateForCandidateImportCandidatesCandidateIdFkeyNodeIdUpdate>;
};

/** The `candidateImportCandidate` to be created by this mutation. */
export type CandidateImportCandidatesCandidateImportIdFkeyCandidateImportCandidatesCreateInput = {
  candidate?: InputMaybe<CandidateImportCandidatesCandidateIdFkeyInput>;
  candidateId?: InputMaybe<Scalars['Int']['input']>;
  candidateImport?: InputMaybe<CandidateImportCandidatesCandidateImportIdFkeyInput>;
  candidateImportFileExternalId: Scalars['UUID']['input'];
};

/** The `candidateImport` to be created by this mutation. */
export type CandidateImportCandidatesCandidateImportIdFkeyCandidateImportsCreateInput = {
  candidateImportCandidates?: InputMaybe<CandidateImportCandidatesCandidateImportIdFkeyInverseInput>;
  files?: InputMaybe<CandidateImportFilesCandidateImportIdFkeyInverseInput>;
  jobIds?: InputMaybe<Array<InputMaybe<Scalars['Int']['input']>>>;
  sources?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  tags?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
};

/** Input for the nested mutation of `candidateImport` in the `CandidateImportCandidateInput` mutation. */
export type CandidateImportCandidatesCandidateImportIdFkeyInput = {
  /** The primary key(s) for `candidateImport` for the far side of the relationship. */
  connectById?: InputMaybe<CandidateImportCandidateImportsPkeyConnect>;
  /** The primary key(s) for `candidateImport` for the far side of the relationship. */
  connectByNodeId?: InputMaybe<CandidateImportNodeIdConnect>;
  /** A `CandidateImportInput` object that will be created and connected to this object. */
  create?: InputMaybe<CandidateImportCandidatesCandidateImportIdFkeyCandidateImportsCreateInput>;
  /** The primary key(s) and patch data for `candidateImport` for the far side of the relationship. */
  updateById?: InputMaybe<CandidateImportOnCandidateImportCandidateForCandidateImportCandidatesCandidateImportIdFkeyUsingCandidateImportsPkeyUpdate>;
  /** The primary key(s) and patch data for `candidateImport` for the far side of the relationship. */
  updateByNodeId?: InputMaybe<CandidateImportCandidateOnCandidateImportCandidateForCandidateImportCandidatesCandidateImportIdFkeyNodeIdUpdate>;
};

/** Input for the nested mutation of `candidateImportCandidate` in the `CandidateImportInput` mutation. */
export type CandidateImportCandidatesCandidateImportIdFkeyInverseInput = {
  /** The primary key(s) for `candidateImportCandidate` for the far side of the relationship. */
  connectByCandidateId?: InputMaybe<Array<CandidateImportCandidateCandidateImportCandidatesPkeyConnect>>;
  /** The primary key(s) for `candidateImportCandidate` for the far side of the relationship. */
  connectByNodeId?: InputMaybe<Array<CandidateImportCandidateNodeIdConnect>>;
  /** A `CandidateImportCandidateInput` object that will be created and connected to this object. */
  create?: InputMaybe<Array<CandidateImportCandidatesCandidateImportIdFkeyCandidateImportCandidatesCreateInput>>;
  /** The primary key(s) and patch data for `candidateImportCandidate` for the far side of the relationship. */
  updateByCandidateId?: InputMaybe<Array<CandidateImportCandidateOnCandidateImportCandidateForCandidateImportCandidatesCandidateImportIdFkeyUsingCandidateImportCandidatesPkeyUpdate>>;
  /** The primary key(s) and patch data for `candidateImportCandidate` for the far side of the relationship. */
  updateByNodeId?: InputMaybe<Array<CandidateImportOnCandidateImportCandidateForCandidateImportCandidatesCandidateImportIdFkeyNodeIdUpdate>>;
};

/** A connection to a list of `CandidateImportCandidate` values. */
export type CandidateImportCandidatesConnection = {
  __typename?: 'CandidateImportCandidatesConnection';
  /** A list of edges which contains the `CandidateImportCandidate` and cursor to aid in pagination. */
  edges: Array<CandidateImportCandidatesEdge>;
  /** A list of `CandidateImportCandidate` objects. */
  nodes: Array<CandidateImportCandidate>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `CandidateImportCandidate` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `CandidateImportCandidate` edge in the connection. */
export type CandidateImportCandidatesEdge = {
  __typename?: 'CandidateImportCandidatesEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `CandidateImportCandidate` at the end of the edge. */
  node: CandidateImportCandidate;
};

/** Methods to use when ordering `CandidateImportCandidate`. */
export enum CandidateImportCandidatesOrderBy {
  CandidateIdAsc = 'CANDIDATE_ID_ASC',
  CandidateIdDesc = 'CANDIDATE_ID_DESC',
  CandidateImportFileExternalIdAsc = 'CANDIDATE_IMPORT_FILE_EXTERNAL_ID_ASC',
  CandidateImportFileExternalIdDesc = 'CANDIDATE_IMPORT_FILE_EXTERNAL_ID_DESC',
  CandidateImportIdAsc = 'CANDIDATE_IMPORT_ID_ASC',
  CandidateImportIdDesc = 'CANDIDATE_IMPORT_ID_DESC',
  Natural = 'NATURAL',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC'
}

/** A condition to be used against `CandidateImport` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type CandidateImportCondition = {
  /** Checks for equality with the object’s `createdAt` field. */
  createdAt?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['Int']['input']>;
};

export type CandidateImportFile = Node & {
  __typename?: 'CandidateImportFile';
  /** Reads a single `CandidateImport` that is related to this `CandidateImportFile`. */
  candidateImport?: Maybe<CandidateImport>;
  candidateImportId: Scalars['Int']['output'];
  externalId: Scalars['UUID']['output'];
  name: Scalars['String']['output'];
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  url?: Maybe<Scalars['String']['output']>;
};

/** The fields on `candidateImportFile` to look up the row to connect. */
export type CandidateImportFileCandidateImportFilesPkeyConnect = {
  externalId: Scalars['UUID']['input'];
};

/** A condition to be used against `CandidateImportFile` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type CandidateImportFileCondition = {
  /** Checks for equality with the object’s `candidateImportId` field. */
  candidateImportId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `externalId` field. */
  externalId?: InputMaybe<Scalars['UUID']['input']>;
};

/** A filter to be used against `CandidateImportFile` object types. All fields are combined with a logical ‘and.’ */
export type CandidateImportFileFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<CandidateImportFileFilter>>;
  /** Filter by the object’s `candidateImport` relation. */
  candidateImport?: InputMaybe<CandidateImportFilter>;
  /** Filter by the object’s `candidateImportId` field. */
  candidateImportId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `externalId` field. */
  externalId?: InputMaybe<UuidFilter>;
  /** Negates the expression. */
  not?: InputMaybe<CandidateImportFileFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<CandidateImportFileFilter>>;
};

/** An input for mutations affecting `CandidateImportFile` */
export type CandidateImportFileInput = {
  candidateImport?: InputMaybe<CandidateImportFilesCandidateImportIdFkeyInput>;
  candidateImportId?: InputMaybe<Scalars['Int']['input']>;
  externalId: Scalars['UUID']['input'];
  name: Scalars['String']['input'];
};

/** The globally unique `ID` look up for the row to connect. */
export type CandidateImportFileNodeIdConnect = {
  /** The globally unique `ID` which identifies a single `candidateImportFile` to be connected. */
  nodeId: Scalars['ID']['input'];
};

/** The globally unique `ID` look up for the row to update. */
export type CandidateImportFileOnCandidateImportFileForCandidateImportFilesCandidateImportIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `candidateImport` to be connected. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `candidateImport` being updated. */
  patch: CandidateImportPatch;
};

/** The fields on `candidateImportFile` to look up the row to update. */
export type CandidateImportFileOnCandidateImportFileForCandidateImportFilesCandidateImportIdFkeyUsingCandidateImportFilesPkeyUpdate = {
  externalId: Scalars['UUID']['input'];
  /** An object where the defined keys will be set on the `candidateImportFile` being updated. */
  patch: UpdateCandidateImportFileOnCandidateImportFileForCandidateImportFilesCandidateImportIdFkeyPatch;
};

/** Represents an update to a `CandidateImportFile`. Fields that are set will be updated. */
export type CandidateImportFilePatch = {
  candidateImport?: InputMaybe<CandidateImportFilesCandidateImportIdFkeyInput>;
  candidateImportId?: InputMaybe<Scalars['Int']['input']>;
};

/** The `candidateImportFile` to be created by this mutation. */
export type CandidateImportFilesCandidateImportIdFkeyCandidateImportFilesCreateInput = {
  candidateImport?: InputMaybe<CandidateImportFilesCandidateImportIdFkeyInput>;
  externalId: Scalars['UUID']['input'];
  name: Scalars['String']['input'];
};

/** The `candidateImport` to be created by this mutation. */
export type CandidateImportFilesCandidateImportIdFkeyCandidateImportsCreateInput = {
  candidateImportCandidates?: InputMaybe<CandidateImportCandidatesCandidateImportIdFkeyInverseInput>;
  files?: InputMaybe<CandidateImportFilesCandidateImportIdFkeyInverseInput>;
  jobIds?: InputMaybe<Array<InputMaybe<Scalars['Int']['input']>>>;
  sources?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  tags?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
};

/** Input for the nested mutation of `candidateImport` in the `CandidateImportFileInput` mutation. */
export type CandidateImportFilesCandidateImportIdFkeyInput = {
  /** The primary key(s) for `candidateImport` for the far side of the relationship. */
  connectById?: InputMaybe<CandidateImportCandidateImportsPkeyConnect>;
  /** The primary key(s) for `candidateImport` for the far side of the relationship. */
  connectByNodeId?: InputMaybe<CandidateImportNodeIdConnect>;
  /** A `CandidateImportInput` object that will be created and connected to this object. */
  create?: InputMaybe<CandidateImportFilesCandidateImportIdFkeyCandidateImportsCreateInput>;
  /** The primary key(s) and patch data for `candidateImport` for the far side of the relationship. */
  updateById?: InputMaybe<CandidateImportOnCandidateImportFileForCandidateImportFilesCandidateImportIdFkeyUsingCandidateImportsPkeyUpdate>;
  /** The primary key(s) and patch data for `candidateImport` for the far side of the relationship. */
  updateByNodeId?: InputMaybe<CandidateImportFileOnCandidateImportFileForCandidateImportFilesCandidateImportIdFkeyNodeIdUpdate>;
};

/** Input for the nested mutation of `candidateImportFile` in the `CandidateImportInput` mutation. */
export type CandidateImportFilesCandidateImportIdFkeyInverseInput = {
  /** The primary key(s) for `candidateImportFile` for the far side of the relationship. */
  connectByExternalId?: InputMaybe<Array<CandidateImportFileCandidateImportFilesPkeyConnect>>;
  /** The primary key(s) for `candidateImportFile` for the far side of the relationship. */
  connectByNodeId?: InputMaybe<Array<CandidateImportFileNodeIdConnect>>;
  /** A `CandidateImportFileInput` object that will be created and connected to this object. */
  create?: InputMaybe<Array<CandidateImportFilesCandidateImportIdFkeyCandidateImportFilesCreateInput>>;
  /** The primary key(s) and patch data for `candidateImportFile` for the far side of the relationship. */
  updateByExternalId?: InputMaybe<Array<CandidateImportFileOnCandidateImportFileForCandidateImportFilesCandidateImportIdFkeyUsingCandidateImportFilesPkeyUpdate>>;
  /** The primary key(s) and patch data for `candidateImportFile` for the far side of the relationship. */
  updateByNodeId?: InputMaybe<Array<CandidateImportOnCandidateImportFileForCandidateImportFilesCandidateImportIdFkeyNodeIdUpdate>>;
};

/** A connection to a list of `CandidateImportFile` values. */
export type CandidateImportFilesConnection = {
  __typename?: 'CandidateImportFilesConnection';
  /** A list of edges which contains the `CandidateImportFile` and cursor to aid in pagination. */
  edges: Array<CandidateImportFilesEdge>;
  /** A list of `CandidateImportFile` objects. */
  nodes: Array<CandidateImportFile>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `CandidateImportFile` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `CandidateImportFile` edge in the connection. */
export type CandidateImportFilesEdge = {
  __typename?: 'CandidateImportFilesEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `CandidateImportFile` at the end of the edge. */
  node: CandidateImportFile;
};

/** Methods to use when ordering `CandidateImportFile`. */
export enum CandidateImportFilesOrderBy {
  CandidateImportIdAsc = 'CANDIDATE_IMPORT_ID_ASC',
  CandidateImportIdDesc = 'CANDIDATE_IMPORT_ID_DESC',
  ExternalIdAsc = 'EXTERNAL_ID_ASC',
  ExternalIdDesc = 'EXTERNAL_ID_DESC',
  Natural = 'NATURAL',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC'
}

/** A filter to be used against `CandidateImport` object types. All fields are combined with a logical ‘and.’ */
export type CandidateImportFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<CandidateImportFilter>>;
  /** Filter by the object’s `candidateImportCandidates` relation. */
  candidateImportCandidates?: InputMaybe<CandidateImportToManyCandidateImportCandidateFilter>;
  /** Some related `candidateImportCandidates` exist. */
  candidateImportCandidatesExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `createdAt` field. */
  createdAt?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `files` relation. */
  files?: InputMaybe<CandidateImportToManyCandidateImportFileFilter>;
  /** Some related `files` exist. */
  filesExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<IntFilter>;
  /** Negates the expression. */
  not?: InputMaybe<CandidateImportFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<CandidateImportFilter>>;
};

/** An input for mutations affecting `CandidateImport` */
export type CandidateImportInput = {
  candidateImportCandidates?: InputMaybe<CandidateImportCandidatesCandidateImportIdFkeyInverseInput>;
  files?: InputMaybe<CandidateImportFilesCandidateImportIdFkeyInverseInput>;
  jobIds?: InputMaybe<Array<InputMaybe<Scalars['Int']['input']>>>;
  sources?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  tags?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
};

/** The globally unique `ID` look up for the row to connect. */
export type CandidateImportNodeIdConnect = {
  /** The globally unique `ID` which identifies a single `candidateImport` to be connected. */
  nodeId: Scalars['ID']['input'];
};

/** The globally unique `ID` look up for the row to update. */
export type CandidateImportOnCandidateImportCandidateForCandidateImportCandidatesCandidateImportIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `candidateImportCandidate` to be connected. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `candidateImportCandidate` being updated. */
  patch: CandidateImportCandidatePatch;
};

/** The fields on `candidateImport` to look up the row to update. */
export type CandidateImportOnCandidateImportCandidateForCandidateImportCandidatesCandidateImportIdFkeyUsingCandidateImportsPkeyUpdate = {
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `candidateImport` being updated. */
  patch: UpdateCandidateImportOnCandidateImportCandidateForCandidateImportCandidatesCandidateImportIdFkeyPatch;
};

/** The globally unique `ID` look up for the row to update. */
export type CandidateImportOnCandidateImportFileForCandidateImportFilesCandidateImportIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `candidateImportFile` to be connected. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `candidateImportFile` being updated. */
  patch: CandidateImportFilePatch;
};

/** The fields on `candidateImport` to look up the row to update. */
export type CandidateImportOnCandidateImportFileForCandidateImportFilesCandidateImportIdFkeyUsingCandidateImportsPkeyUpdate = {
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `candidateImport` being updated. */
  patch: UpdateCandidateImportOnCandidateImportFileForCandidateImportFilesCandidateImportIdFkeyPatch;
};

/** Represents an update to a `CandidateImport`. Fields that are set will be updated. */
export type CandidateImportPatch = {
  candidateImportCandidates?: InputMaybe<CandidateImportCandidatesCandidateImportIdFkeyInverseInput>;
  files?: InputMaybe<CandidateImportFilesCandidateImportIdFkeyInverseInput>;
};

/** A filter to be used against many `CandidateImportCandidate` object types. All fields are combined with a logical ‘and.’ */
export type CandidateImportToManyCandidateImportCandidateFilter = {
  /** Every related `CandidateImportCandidate` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<CandidateImportCandidateFilter>;
  /** No related `CandidateImportCandidate` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<CandidateImportCandidateFilter>;
  /** Some related `CandidateImportCandidate` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<CandidateImportCandidateFilter>;
};

/** A filter to be used against many `CandidateImportFile` object types. All fields are combined with a logical ‘and.’ */
export type CandidateImportToManyCandidateImportFileFilter = {
  /** Every related `CandidateImportFile` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<CandidateImportFileFilter>;
  /** No related `CandidateImportFile` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<CandidateImportFileFilter>;
  /** Some related `CandidateImportFile` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<CandidateImportFileFilter>;
};

/** A connection to a list of `CandidateImport` values. */
export type CandidateImportsConnection = {
  __typename?: 'CandidateImportsConnection';
  /** A list of edges which contains the `CandidateImport` and cursor to aid in pagination. */
  edges: Array<CandidateImportsEdge>;
  /** A list of `CandidateImport` objects. */
  nodes: Array<CandidateImport>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `CandidateImport` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `CandidateImport` edge in the connection. */
export type CandidateImportsEdge = {
  __typename?: 'CandidateImportsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `CandidateImport` at the end of the edge. */
  node: CandidateImport;
};

/** Methods to use when ordering `CandidateImport`. */
export enum CandidateImportsOrderBy {
  CreatedAtAsc = 'CREATED_AT_ASC',
  CreatedAtDesc = 'CREATED_AT_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  Natural = 'NATURAL',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC'
}

/** An input for mutations affecting `Candidate` */
export type CandidateInput = {
  birthday?: InputMaybe<Scalars['Date']['input']>;
  candidateDraftEvaluations?: InputMaybe<DraftEvaluationsCandidateIdFkeyInverseInput>;
  candidateEventDraftEvaluations?: InputMaybe<EventDraftEvaluationsCandidateIdFkeyInverseInput>;
  candidateImportCandidate?: InputMaybe<CandidateImportCandidatesCandidateIdFkeyInverseInput>;
  candidateQuestionnaires?: InputMaybe<CandidateQuestionnairesCandidateIdFkeyInverseInput>;
  candidateQuestions?: InputMaybe<CandidateQuestionsCandidateIdFkeyInverseInput>;
  candidateTags?: InputMaybe<CandidateTagsCandidateIdFkeyInverseInput>;
  cvText?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  emails?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  evaluations?: InputMaybe<EvaluationsCandidateIdFkeyInverseInput>;
  eventCandidates?: InputMaybe<EventCandidatesCandidateIdFkeyInverseInput>;
  files?: InputMaybe<CandidateFilesCandidateIdFkeyInverseInput>;
  gender?: InputMaybe<Gender>;
  jobsApplications?: InputMaybe<JobsApplicationsCandidateIdFkeyInverseInput>;
  language: Language;
  links?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  militaryStatus?: InputMaybe<MilitaryStatus>;
  phones?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  photoExternalId?: InputMaybe<Scalars['UUID']['input']>;
  resumeExternalId?: InputMaybe<Scalars['UUID']['input']>;
  socialLinks?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  sources?: InputMaybe<Array<Scalars['String']['input']>>;
  tags?: InputMaybe<Array<Scalars['String']['input']>>;
  threads?: InputMaybe<ThreadsCandidateIdFkeyInverseInput>;
  translations?: InputMaybe<CandidateTranslationsCandidateIdFkeyInverseInput>;
};

/** A connection to a list of `Job` values, with data from `JobsApplication`. */
export type CandidateJobsByJobsApplicationCandidateIdAndJobIdManyToManyConnection = {
  __typename?: 'CandidateJobsByJobsApplicationCandidateIdAndJobIdManyToManyConnection';
  /** A list of edges which contains the `Job`, info from the `JobsApplication`, and the cursor to aid in pagination. */
  edges: Array<CandidateJobsByJobsApplicationCandidateIdAndJobIdManyToManyEdge>;
  /** A list of `Job` objects. */
  nodes: Array<Job>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Job` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `Job` edge in the connection, with data from `JobsApplication`. */
export type CandidateJobsByJobsApplicationCandidateIdAndJobIdManyToManyEdge = {
  __typename?: 'CandidateJobsByJobsApplicationCandidateIdAndJobIdManyToManyEdge';
  coverLetter?: Maybe<Scalars['String']['output']>;
  createdAt: Scalars['Datetime']['output'];
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  disqualifiedAt?: Maybe<Scalars['Datetime']['output']>;
  disqualifyReasonId?: Maybe<Scalars['Int']['output']>;
  evaluation?: Maybe<Scalars['Int']['output']>;
  id: Scalars['Int']['output'];
  /** The `Job` at the end of the edge. */
  node: Job;
  pipelineStageId: Scalars['Int']['output'];
  previousId: Scalars['Int']['output'];
  updatedAt: Scalars['Datetime']['output'];
};

/** The globally unique `ID` look up for the row to connect. */
export type CandidateNodeIdConnect = {
  /** The globally unique `ID` which identifies a single `candidate` to be connected. */
  nodeId: Scalars['ID']['input'];
};

/** The globally unique `ID` look up for the row to update. */
export type CandidateOnCandidateFileForCandidateFilesCandidateIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `candidateFile` to be connected. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `candidateFile` being updated. */
  patch: CandidateFilePatch;
};

/** The fields on `candidate` to look up the row to update. */
export type CandidateOnCandidateFileForCandidateFilesCandidateIdFkeyUsingCandidatesPkeyUpdate = {
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `candidate` being updated. */
  patch: UpdateCandidateOnCandidateFileForCandidateFilesCandidateIdFkeyPatch;
};

/** The globally unique `ID` look up for the row to update. */
export type CandidateOnCandidateImportCandidateForCandidateImportCandidatesCandidateIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `candidateImportCandidate` to be connected. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `candidateImportCandidate` being updated. */
  patch: CandidateImportCandidatePatch;
};

/** The fields on `candidate` to look up the row to update. */
export type CandidateOnCandidateImportCandidateForCandidateImportCandidatesCandidateIdFkeyUsingCandidatesPkeyUpdate = {
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `candidate` being updated. */
  patch: UpdateCandidateOnCandidateImportCandidateForCandidateImportCandidatesCandidateIdFkeyPatch;
};

/** The globally unique `ID` look up for the row to update. */
export type CandidateOnCandidateQuestionForCandidateQuestionsCandidateIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `candidateQuestion` to be connected. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `candidateQuestion` being updated. */
  patch: CandidateQuestionPatch;
};

/** The fields on `candidate` to look up the row to update. */
export type CandidateOnCandidateQuestionForCandidateQuestionsCandidateIdFkeyUsingCandidatesPkeyUpdate = {
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `candidate` being updated. */
  patch: UpdateCandidateOnCandidateQuestionForCandidateQuestionsCandidateIdFkeyPatch;
};

/** The globally unique `ID` look up for the row to update. */
export type CandidateOnCandidateQuestionnaireForCandidateQuestionnairesCandidateIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `candidateQuestionnaire` to be connected. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `candidateQuestionnaire` being updated. */
  patch: CandidateQuestionnairePatch;
};

/** The fields on `candidate` to look up the row to update. */
export type CandidateOnCandidateQuestionnaireForCandidateQuestionnairesCandidateIdFkeyUsingCandidatesPkeyUpdate = {
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `candidate` being updated. */
  patch: UpdateCandidateOnCandidateQuestionnaireForCandidateQuestionnairesCandidateIdFkeyPatch;
};

/** The globally unique `ID` look up for the row to update. */
export type CandidateOnCandidateTagForCandidateTagsCandidateIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `candidateTag` to be connected. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `candidateTag` being updated. */
  patch: CandidateTagPatch;
};

/** The fields on `candidate` to look up the row to update. */
export type CandidateOnCandidateTagForCandidateTagsCandidateIdFkeyUsingCandidatesPkeyUpdate = {
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `candidate` being updated. */
  patch: UpdateCandidateOnCandidateTagForCandidateTagsCandidateIdFkeyPatch;
};

/** The globally unique `ID` look up for the row to update. */
export type CandidateOnCandidateTranslationForCandidateTranslationsCandidateIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `candidateTranslation` to be connected. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `candidateTranslation` being updated. */
  patch: CandidateTranslationPatch;
};

/** The fields on `candidate` to look up the row to update. */
export type CandidateOnCandidateTranslationForCandidateTranslationsCandidateIdFkeyUsingCandidatesPkeyUpdate = {
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `candidate` being updated. */
  patch: UpdateCandidateOnCandidateTranslationForCandidateTranslationsCandidateIdFkeyPatch;
};

/** The globally unique `ID` look up for the row to update. */
export type CandidateOnDraftEvaluationForDraftEvaluationsCandidateIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `draftEvaluation` to be connected. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `draftEvaluation` being updated. */
  patch: DraftEvaluationPatch;
};

/** The fields on `candidate` to look up the row to update. */
export type CandidateOnDraftEvaluationForDraftEvaluationsCandidateIdFkeyUsingCandidatesPkeyUpdate = {
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `candidate` being updated. */
  patch: UpdateCandidateOnDraftEvaluationForDraftEvaluationsCandidateIdFkeyPatch;
};

/** The globally unique `ID` look up for the row to update. */
export type CandidateOnEvaluationForEvaluationsCandidateIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `evaluation` to be connected. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `evaluation` being updated. */
  patch: EvaluationPatch;
};

/** The fields on `candidate` to look up the row to update. */
export type CandidateOnEvaluationForEvaluationsCandidateIdFkeyUsingCandidatesPkeyUpdate = {
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `candidate` being updated. */
  patch: UpdateCandidateOnEvaluationForEvaluationsCandidateIdFkeyPatch;
};

/** The globally unique `ID` look up for the row to update. */
export type CandidateOnEventCandidateForEventCandidatesCandidateIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `eventCandidate` to be connected. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `eventCandidate` being updated. */
  patch: EventCandidatePatch;
};

/** The fields on `candidate` to look up the row to update. */
export type CandidateOnEventCandidateForEventCandidatesCandidateIdFkeyUsingCandidatesPkeyUpdate = {
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `candidate` being updated. */
  patch: UpdateCandidateOnEventCandidateForEventCandidatesCandidateIdFkeyPatch;
};

/** The globally unique `ID` look up for the row to update. */
export type CandidateOnEventDraftEvaluationForEventDraftEvaluationsCandidateIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `eventDraftEvaluation` to be connected. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `eventDraftEvaluation` being updated. */
  patch: EventDraftEvaluationPatch;
};

/** The fields on `candidate` to look up the row to update. */
export type CandidateOnEventDraftEvaluationForEventDraftEvaluationsCandidateIdFkeyUsingCandidatesPkeyUpdate = {
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `candidate` being updated. */
  patch: UpdateCandidateOnEventDraftEvaluationForEventDraftEvaluationsCandidateIdFkeyPatch;
};

/** The globally unique `ID` look up for the row to update. */
export type CandidateOnJobsApplicationForJobsApplicationsCandidateIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `jobsApplication` to be connected. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `jobsApplication` being updated. */
  patch: JobsApplicationPatch;
};

/** The fields on `candidate` to look up the row to update. */
export type CandidateOnJobsApplicationForJobsApplicationsCandidateIdFkeyUsingCandidatesPkeyUpdate = {
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `candidate` being updated. */
  patch: UpdateCandidateOnJobsApplicationForJobsApplicationsCandidateIdFkeyPatch;
};

/** The globally unique `ID` look up for the row to update. */
export type CandidateOnThreadForThreadsCandidateIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `thread` to be connected. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `thread` being updated. */
  patch: ThreadPatch;
};

/** The fields on `candidate` to look up the row to update. */
export type CandidateOnThreadForThreadsCandidateIdFkeyUsingCandidatesPkeyUpdate = {
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `candidate` being updated. */
  patch: UpdateCandidateOnThreadForThreadsCandidateIdFkeyPatch;
};

/** Represents an update to a `Candidate`. Fields that are set will be updated. */
export type CandidatePatch = {
  birthday?: InputMaybe<Scalars['Date']['input']>;
  candidateDraftEvaluations?: InputMaybe<DraftEvaluationsCandidateIdFkeyInverseInput>;
  candidateEventDraftEvaluations?: InputMaybe<EventDraftEvaluationsCandidateIdFkeyInverseInput>;
  candidateImportCandidate?: InputMaybe<CandidateImportCandidatesCandidateIdFkeyInverseInput>;
  candidateQuestionnaires?: InputMaybe<CandidateQuestionnairesCandidateIdFkeyInverseInput>;
  candidateQuestions?: InputMaybe<CandidateQuestionsCandidateIdFkeyInverseInput>;
  candidateTags?: InputMaybe<CandidateTagsCandidateIdFkeyInverseInput>;
  emails?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  evaluations?: InputMaybe<EvaluationsCandidateIdFkeyInverseInput>;
  eventCandidates?: InputMaybe<EventCandidatesCandidateIdFkeyInverseInput>;
  files?: InputMaybe<CandidateFilesCandidateIdFkeyInverseInput>;
  gender?: InputMaybe<Gender>;
  jobsApplications?: InputMaybe<JobsApplicationsCandidateIdFkeyInverseInput>;
  language?: InputMaybe<Language>;
  links?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  militaryStatus?: InputMaybe<MilitaryStatus>;
  phones?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  photoExternalId?: InputMaybe<Scalars['UUID']['input']>;
  resumeExternalId?: InputMaybe<Scalars['UUID']['input']>;
  socialLinks?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  sources?: InputMaybe<Array<Scalars['String']['input']>>;
  tags?: InputMaybe<Array<Scalars['String']['input']>>;
  threads?: InputMaybe<ThreadsCandidateIdFkeyInverseInput>;
  translations?: InputMaybe<CandidateTranslationsCandidateIdFkeyInverseInput>;
};

export type CandidatePerDayReport = {
  __typename?: 'CandidatePerDayReport';
  count: Scalars['Int']['output'];
  date: Scalars['Date']['output'];
};

/** A connection to a list of `PipelineStage` values, with data from `JobsApplication`. */
export type CandidatePipelineStagesByJobsApplicationCandidateIdAndPipelineStageIdManyToManyConnection = {
  __typename?: 'CandidatePipelineStagesByJobsApplicationCandidateIdAndPipelineStageIdManyToManyConnection';
  /** A list of edges which contains the `PipelineStage`, info from the `JobsApplication`, and the cursor to aid in pagination. */
  edges: Array<CandidatePipelineStagesByJobsApplicationCandidateIdAndPipelineStageIdManyToManyEdge>;
  /** A list of `PipelineStage` objects. */
  nodes: Array<PipelineStage>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `PipelineStage` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `PipelineStage` edge in the connection, with data from `JobsApplication`. */
export type CandidatePipelineStagesByJobsApplicationCandidateIdAndPipelineStageIdManyToManyEdge = {
  __typename?: 'CandidatePipelineStagesByJobsApplicationCandidateIdAndPipelineStageIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** Reads and enables pagination through a set of `JobsApplication`. */
  jobsApplications: JobsApplicationsConnection;
  /** The `PipelineStage` at the end of the edge. */
  node: PipelineStage;
};


/** A `PipelineStage` edge in the connection, with data from `JobsApplication`. */
export type CandidatePipelineStagesByJobsApplicationCandidateIdAndPipelineStageIdManyToManyEdgeJobsApplicationsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<JobsApplicationCondition>;
  filter?: InputMaybe<JobsApplicationFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<JobsApplicationsOrderBy>>;
};

export type CandidateQuestion = Node & {
  __typename?: 'CandidateQuestion';
  booleanValue?: Maybe<Scalars['Boolean']['output']>;
  /** Reads a single `Candidate` that is related to this `CandidateQuestion`. */
  candidate?: Maybe<Candidate>;
  candidateId: Scalars['Int']['output'];
  createdAt: Scalars['Datetime']['output'];
  dateValue?: Maybe<Scalars['Datetime']['output']>;
  /** Reads a single `Evaluation` that is related to this `CandidateQuestion`. */
  evaluation?: Maybe<Evaluation>;
  evaluationId?: Maybe<Scalars['Int']['output']>;
  /** Reads a single `CandidateFile` that is related to this `CandidateQuestion`. */
  fileValueExternal?: Maybe<CandidateFile>;
  fileValueExternalId?: Maybe<Scalars['UUID']['output']>;
  id: Scalars['Int']['output'];
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  numberValue?: Maybe<Scalars['Int']['output']>;
  /** Reads a single `Question` that is related to this `CandidateQuestion`. */
  question?: Maybe<Question>;
  questionId: Scalars['Int']['output'];
  /** Reads a single `QuestionOption` that is related to this `CandidateQuestion`. */
  questionOption?: Maybe<QuestionOption>;
  questionOptionId?: Maybe<Scalars['Int']['output']>;
  /** Reads a single `Questionnaire` that is related to this `CandidateQuestion`. */
  questionnaire?: Maybe<Questionnaire>;
  questionnaireId: Scalars['Int']['output'];
  textValue?: Maybe<Scalars['String']['output']>;
};

/** The fields on `candidateQuestion` to look up the row to connect. */
export type CandidateQuestionCandidateQuestionsPkeyConnect = {
  id: Scalars['Int']['input'];
};

/** A condition to be used against `CandidateQuestion` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type CandidateQuestionCondition = {
  /** Checks for equality with the object’s `candidateId` field. */
  candidateId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `evaluationId` field. */
  evaluationId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `fileValueExternalId` field. */
  fileValueExternalId?: InputMaybe<Scalars['UUID']['input']>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `questionId` field. */
  questionId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `questionOptionId` field. */
  questionOptionId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `questionnaireId` field. */
  questionnaireId?: InputMaybe<Scalars['Int']['input']>;
};

/** A filter to be used against `CandidateQuestion` object types. All fields are combined with a logical ‘and.’ */
export type CandidateQuestionFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<CandidateQuestionFilter>>;
  /** Filter by the object’s `candidate` relation. */
  candidate?: InputMaybe<CandidateFilter>;
  /** Filter by the object’s `candidateId` field. */
  candidateId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `evaluation` relation. */
  evaluation?: InputMaybe<EvaluationFilter>;
  /** A related `evaluation` exists. */
  evaluationExists?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `evaluationId` field. */
  evaluationId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `fileValueExternal` relation. */
  fileValueExternal?: InputMaybe<CandidateFileFilter>;
  /** A related `fileValueExternal` exists. */
  fileValueExternalExists?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `fileValueExternalId` field. */
  fileValueExternalId?: InputMaybe<UuidFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<IntFilter>;
  /** Negates the expression. */
  not?: InputMaybe<CandidateQuestionFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<CandidateQuestionFilter>>;
  /** Filter by the object’s `question` relation. */
  question?: InputMaybe<QuestionFilter>;
  /** Filter by the object’s `questionId` field. */
  questionId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `questionOption` relation. */
  questionOption?: InputMaybe<QuestionOptionFilter>;
  /** A related `questionOption` exists. */
  questionOptionExists?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `questionOptionId` field. */
  questionOptionId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `questionnaire` relation. */
  questionnaire?: InputMaybe<QuestionnaireFilter>;
  /** Filter by the object’s `questionnaireId` field. */
  questionnaireId?: InputMaybe<IntFilter>;
};

/** An input for mutations affecting `CandidateQuestion` */
export type CandidateQuestionInput = {
  booleanValue?: InputMaybe<Scalars['Boolean']['input']>;
  candidate?: InputMaybe<CandidateQuestionsCandidateIdFkeyInput>;
  candidateFile?: InputMaybe<CandidateQuestionsFileValueExternalIdFkeyInput>;
  candidateId?: InputMaybe<Scalars['Int']['input']>;
  dateValue?: InputMaybe<Scalars['Datetime']['input']>;
  evaluation?: InputMaybe<CandidateQuestionsEvaluationIdFkeyInput>;
  evaluationId?: InputMaybe<Scalars['Int']['input']>;
  fileValueExternalId?: InputMaybe<Scalars['UUID']['input']>;
  numberValue?: InputMaybe<Scalars['Int']['input']>;
  question?: InputMaybe<CandidateQuestionsQuestionIdFkeyInput>;
  questionId?: InputMaybe<Scalars['Int']['input']>;
  questionOption?: InputMaybe<CandidateQuestionsQuestionValueIdFkeyInput>;
  questionOptionId?: InputMaybe<Scalars['Int']['input']>;
  questionnaire?: InputMaybe<CandidateQuestionsQuestionnaireIdFkeyInput>;
  questionnaireId?: InputMaybe<Scalars['Int']['input']>;
  textValue?: InputMaybe<Scalars['String']['input']>;
};

/** The globally unique `ID` look up for the row to connect. */
export type CandidateQuestionNodeIdConnect = {
  /** The globally unique `ID` which identifies a single `candidateQuestion` to be connected. */
  nodeId: Scalars['ID']['input'];
};

/** The globally unique `ID` look up for the row to update. */
export type CandidateQuestionOnCandidateQuestionForCandidateQuestionsCandidateIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `candidate` to be connected. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `candidate` being updated. */
  patch: CandidatePatch;
};

/** The fields on `candidateQuestion` to look up the row to update. */
export type CandidateQuestionOnCandidateQuestionForCandidateQuestionsCandidateIdFkeyUsingCandidateQuestionsPkeyUpdate = {
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `candidateQuestion` being updated. */
  patch: UpdateCandidateQuestionOnCandidateQuestionForCandidateQuestionsCandidateIdFkeyPatch;
};

/** The globally unique `ID` look up for the row to update. */
export type CandidateQuestionOnCandidateQuestionForCandidateQuestionsEvaluationIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `evaluation` to be connected. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `evaluation` being updated. */
  patch: EvaluationPatch;
};

/** The fields on `candidateQuestion` to look up the row to update. */
export type CandidateQuestionOnCandidateQuestionForCandidateQuestionsEvaluationIdFkeyUsingCandidateQuestionsPkeyUpdate = {
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `candidateQuestion` being updated. */
  patch: UpdateCandidateQuestionOnCandidateQuestionForCandidateQuestionsEvaluationIdFkeyPatch;
};

/** The globally unique `ID` look up for the row to update. */
export type CandidateQuestionOnCandidateQuestionForCandidateQuestionsFileValueExternalIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `candidateFile` to be connected. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `candidateFile` being updated. */
  patch: CandidateFilePatch;
};

/** The fields on `candidateQuestion` to look up the row to update. */
export type CandidateQuestionOnCandidateQuestionForCandidateQuestionsFileValueExternalIdFkeyUsingCandidateQuestionsPkeyUpdate = {
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `candidateQuestion` being updated. */
  patch: UpdateCandidateQuestionOnCandidateQuestionForCandidateQuestionsFileValueExternalIdFkeyPatch;
};

/** The globally unique `ID` look up for the row to update. */
export type CandidateQuestionOnCandidateQuestionForCandidateQuestionsQuestionIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `question` to be connected. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `question` being updated. */
  patch: QuestionPatch;
};

/** The fields on `candidateQuestion` to look up the row to update. */
export type CandidateQuestionOnCandidateQuestionForCandidateQuestionsQuestionIdFkeyUsingCandidateQuestionsPkeyUpdate = {
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `candidateQuestion` being updated. */
  patch: UpdateCandidateQuestionOnCandidateQuestionForCandidateQuestionsQuestionIdFkeyPatch;
};

/** The globally unique `ID` look up for the row to update. */
export type CandidateQuestionOnCandidateQuestionForCandidateQuestionsQuestionValueIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `questionOption` to be connected. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `questionOption` being updated. */
  patch: QuestionOptionPatch;
};

/** The fields on `candidateQuestion` to look up the row to update. */
export type CandidateQuestionOnCandidateQuestionForCandidateQuestionsQuestionValueIdFkeyUsingCandidateQuestionsPkeyUpdate = {
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `candidateQuestion` being updated. */
  patch: UpdateCandidateQuestionOnCandidateQuestionForCandidateQuestionsQuestionValueIdFkeyPatch;
};

/** The globally unique `ID` look up for the row to update. */
export type CandidateQuestionOnCandidateQuestionForCandidateQuestionsQuestionnaireIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `questionnaire` to be connected. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `questionnaire` being updated. */
  patch: QuestionnairePatch;
};

/** The fields on `candidateQuestion` to look up the row to update. */
export type CandidateQuestionOnCandidateQuestionForCandidateQuestionsQuestionnaireIdFkeyUsingCandidateQuestionsPkeyUpdate = {
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `candidateQuestion` being updated. */
  patch: UpdateCandidateQuestionOnCandidateQuestionForCandidateQuestionsQuestionnaireIdFkeyPatch;
};

/** A connection to a list of `QuestionOption` values, with data from `CandidateQuestion`. */
export type CandidateQuestionOptionsByCandidateQuestionCandidateIdAndQuestionOptionIdManyToManyConnection = {
  __typename?: 'CandidateQuestionOptionsByCandidateQuestionCandidateIdAndQuestionOptionIdManyToManyConnection';
  /** A list of edges which contains the `QuestionOption`, info from the `CandidateQuestion`, and the cursor to aid in pagination. */
  edges: Array<CandidateQuestionOptionsByCandidateQuestionCandidateIdAndQuestionOptionIdManyToManyEdge>;
  /** A list of `QuestionOption` objects. */
  nodes: Array<QuestionOption>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `QuestionOption` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `QuestionOption` edge in the connection, with data from `CandidateQuestion`. */
export type CandidateQuestionOptionsByCandidateQuestionCandidateIdAndQuestionOptionIdManyToManyEdge = {
  __typename?: 'CandidateQuestionOptionsByCandidateQuestionCandidateIdAndQuestionOptionIdManyToManyEdge';
  /** Reads and enables pagination through a set of `CandidateQuestion`. */
  candidateQuestions: CandidateQuestionsConnection;
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `QuestionOption` at the end of the edge. */
  node: QuestionOption;
};


/** A `QuestionOption` edge in the connection, with data from `CandidateQuestion`. */
export type CandidateQuestionOptionsByCandidateQuestionCandidateIdAndQuestionOptionIdManyToManyEdgeCandidateQuestionsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<CandidateQuestionCondition>;
  filter?: InputMaybe<CandidateQuestionFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<CandidateQuestionsOrderBy>>;
};

/** Represents an update to a `CandidateQuestion`. Fields that are set will be updated. */
export type CandidateQuestionPatch = {
  booleanValue?: InputMaybe<Scalars['Boolean']['input']>;
  candidate?: InputMaybe<CandidateQuestionsCandidateIdFkeyInput>;
  candidateFile?: InputMaybe<CandidateQuestionsFileValueExternalIdFkeyInput>;
  candidateId?: InputMaybe<Scalars['Int']['input']>;
  dateValue?: InputMaybe<Scalars['Datetime']['input']>;
  evaluation?: InputMaybe<CandidateQuestionsEvaluationIdFkeyInput>;
  evaluationId?: InputMaybe<Scalars['Int']['input']>;
  fileValueExternalId?: InputMaybe<Scalars['UUID']['input']>;
  numberValue?: InputMaybe<Scalars['Int']['input']>;
  question?: InputMaybe<CandidateQuestionsQuestionIdFkeyInput>;
  questionId?: InputMaybe<Scalars['Int']['input']>;
  questionOption?: InputMaybe<CandidateQuestionsQuestionValueIdFkeyInput>;
  questionOptionId?: InputMaybe<Scalars['Int']['input']>;
  questionnaire?: InputMaybe<CandidateQuestionsQuestionnaireIdFkeyInput>;
  questionnaireId?: InputMaybe<Scalars['Int']['input']>;
  textValue?: InputMaybe<Scalars['String']['input']>;
};

export type CandidateQuestionnaire = Node & {
  __typename?: 'CandidateQuestionnaire';
  /** Reads a single `Candidate` that is related to this `CandidateQuestionnaire`. */
  candidate?: Maybe<Candidate>;
  candidateId: Scalars['Int']['output'];
  createdAt: Scalars['Datetime']['output'];
  /** Reads a single `Evaluation` that is related to this `CandidateQuestionnaire`. */
  evaluation?: Maybe<Evaluation>;
  evaluationId?: Maybe<Scalars['Int']['output']>;
  id: Scalars['Int']['output'];
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  /** Reads a single `Questionnaire` that is related to this `CandidateQuestionnaire`. */
  questionnaire?: Maybe<Questionnaire>;
  questionnaireId: Scalars['Int']['output'];
};

/** The fields on `candidateQuestionnaire` to look up the row to connect. */
export type CandidateQuestionnaireCandidateQuestionnairesPkeyConnect = {
  id: Scalars['Int']['input'];
};

/** A condition to be used against `CandidateQuestionnaire` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type CandidateQuestionnaireCondition = {
  /** Checks for equality with the object’s `candidateId` field. */
  candidateId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `evaluationId` field. */
  evaluationId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `questionnaireId` field. */
  questionnaireId?: InputMaybe<Scalars['Int']['input']>;
};

/** A filter to be used against `CandidateQuestionnaire` object types. All fields are combined with a logical ‘and.’ */
export type CandidateQuestionnaireFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<CandidateQuestionnaireFilter>>;
  /** Filter by the object’s `candidate` relation. */
  candidate?: InputMaybe<CandidateFilter>;
  /** Filter by the object’s `candidateId` field. */
  candidateId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `evaluation` relation. */
  evaluation?: InputMaybe<EvaluationFilter>;
  /** A related `evaluation` exists. */
  evaluationExists?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `evaluationId` field. */
  evaluationId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<IntFilter>;
  /** Negates the expression. */
  not?: InputMaybe<CandidateQuestionnaireFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<CandidateQuestionnaireFilter>>;
  /** Filter by the object’s `questionnaire` relation. */
  questionnaire?: InputMaybe<QuestionnaireFilter>;
  /** Filter by the object’s `questionnaireId` field. */
  questionnaireId?: InputMaybe<IntFilter>;
};

/** An input for mutations affecting `CandidateQuestionnaire` */
export type CandidateQuestionnaireInput = {
  candidate?: InputMaybe<CandidateQuestionnairesCandidateIdFkeyInput>;
  candidateId?: InputMaybe<Scalars['Int']['input']>;
  evaluation?: InputMaybe<CandidateQuestionnairesEvaluationIdFkeyInput>;
  evaluationId?: InputMaybe<Scalars['Int']['input']>;
  questionnaire?: InputMaybe<CandidateQuestionnairesQuestionnaireIdFkeyInput>;
  questionnaireId?: InputMaybe<Scalars['Int']['input']>;
};

/** The globally unique `ID` look up for the row to connect. */
export type CandidateQuestionnaireNodeIdConnect = {
  /** The globally unique `ID` which identifies a single `candidateQuestionnaire` to be connected. */
  nodeId: Scalars['ID']['input'];
};

/** The globally unique `ID` look up for the row to update. */
export type CandidateQuestionnaireOnCandidateQuestionnaireForCandidateQuestionnairesCandidateIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `candidate` to be connected. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `candidate` being updated. */
  patch: CandidatePatch;
};

/** The fields on `candidateQuestionnaire` to look up the row to update. */
export type CandidateQuestionnaireOnCandidateQuestionnaireForCandidateQuestionnairesCandidateIdFkeyUsingCandidateQuestionnairesPkeyUpdate = {
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `candidateQuestionnaire` being updated. */
  patch: UpdateCandidateQuestionnaireOnCandidateQuestionnaireForCandidateQuestionnairesCandidateIdFkeyPatch;
};

/** The globally unique `ID` look up for the row to update. */
export type CandidateQuestionnaireOnCandidateQuestionnaireForCandidateQuestionnairesEvaluationIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `evaluation` to be connected. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `evaluation` being updated. */
  patch: EvaluationPatch;
};

/** The fields on `candidateQuestionnaire` to look up the row to update. */
export type CandidateQuestionnaireOnCandidateQuestionnaireForCandidateQuestionnairesEvaluationIdFkeyUsingCandidateQuestionnairesPkeyUpdate = {
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `candidateQuestionnaire` being updated. */
  patch: UpdateCandidateQuestionnaireOnCandidateQuestionnaireForCandidateQuestionnairesEvaluationIdFkeyPatch;
};

/** The globally unique `ID` look up for the row to update. */
export type CandidateQuestionnaireOnCandidateQuestionnaireForCandidateQuestionnairesQuestionnaireIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `questionnaire` to be connected. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `questionnaire` being updated. */
  patch: QuestionnairePatch;
};

/** The fields on `candidateQuestionnaire` to look up the row to update. */
export type CandidateQuestionnaireOnCandidateQuestionnaireForCandidateQuestionnairesQuestionnaireIdFkeyUsingCandidateQuestionnairesPkeyUpdate = {
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `candidateQuestionnaire` being updated. */
  patch: UpdateCandidateQuestionnaireOnCandidateQuestionnaireForCandidateQuestionnairesQuestionnaireIdFkeyPatch;
};

/** Represents an update to a `CandidateQuestionnaire`. Fields that are set will be updated. */
export type CandidateQuestionnairePatch = {
  candidate?: InputMaybe<CandidateQuestionnairesCandidateIdFkeyInput>;
  candidateId?: InputMaybe<Scalars['Int']['input']>;
  evaluation?: InputMaybe<CandidateQuestionnairesEvaluationIdFkeyInput>;
  evaluationId?: InputMaybe<Scalars['Int']['input']>;
  questionnaire?: InputMaybe<CandidateQuestionnairesQuestionnaireIdFkeyInput>;
  questionnaireId?: InputMaybe<Scalars['Int']['input']>;
};

/** A connection to a list of `Questionnaire` values, with data from `CandidateQuestionnaire`. */
export type CandidateQuestionnairesByCandidateQuestionnaireCandidateIdAndQuestionnaireIdManyToManyConnection = {
  __typename?: 'CandidateQuestionnairesByCandidateQuestionnaireCandidateIdAndQuestionnaireIdManyToManyConnection';
  /** A list of edges which contains the `Questionnaire`, info from the `CandidateQuestionnaire`, and the cursor to aid in pagination. */
  edges: Array<CandidateQuestionnairesByCandidateQuestionnaireCandidateIdAndQuestionnaireIdManyToManyEdge>;
  /** A list of `Questionnaire` objects. */
  nodes: Array<Questionnaire>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Questionnaire` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `Questionnaire` edge in the connection, with data from `CandidateQuestionnaire`. */
export type CandidateQuestionnairesByCandidateQuestionnaireCandidateIdAndQuestionnaireIdManyToManyEdge = {
  __typename?: 'CandidateQuestionnairesByCandidateQuestionnaireCandidateIdAndQuestionnaireIdManyToManyEdge';
  /** Reads and enables pagination through a set of `CandidateQuestionnaire`. */
  candidateQuestionnaires: CandidateQuestionnairesConnection;
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Questionnaire` at the end of the edge. */
  node: Questionnaire;
};


/** A `Questionnaire` edge in the connection, with data from `CandidateQuestionnaire`. */
export type CandidateQuestionnairesByCandidateQuestionnaireCandidateIdAndQuestionnaireIdManyToManyEdgeCandidateQuestionnairesArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<CandidateQuestionnaireCondition>;
  filter?: InputMaybe<CandidateQuestionnaireFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<CandidateQuestionnairesOrderBy>>;
};

/** The `candidateQuestionnaire` to be created by this mutation. */
export type CandidateQuestionnairesCandidateIdFkeyCandidateQuestionnairesCreateInput = {
  candidate?: InputMaybe<CandidateQuestionnairesCandidateIdFkeyInput>;
  evaluation?: InputMaybe<CandidateQuestionnairesEvaluationIdFkeyInput>;
  evaluationId?: InputMaybe<Scalars['Int']['input']>;
  questionnaire?: InputMaybe<CandidateQuestionnairesQuestionnaireIdFkeyInput>;
  questionnaireId?: InputMaybe<Scalars['Int']['input']>;
};

/** The `candidate` to be created by this mutation. */
export type CandidateQuestionnairesCandidateIdFkeyCandidatesCreateInput = {
  birthday?: InputMaybe<Scalars['Date']['input']>;
  candidateDraftEvaluations?: InputMaybe<DraftEvaluationsCandidateIdFkeyInverseInput>;
  candidateEventDraftEvaluations?: InputMaybe<EventDraftEvaluationsCandidateIdFkeyInverseInput>;
  candidateImportCandidate?: InputMaybe<CandidateImportCandidatesCandidateIdFkeyInverseInput>;
  candidateQuestionnaires?: InputMaybe<CandidateQuestionnairesCandidateIdFkeyInverseInput>;
  candidateQuestions?: InputMaybe<CandidateQuestionsCandidateIdFkeyInverseInput>;
  candidateTags?: InputMaybe<CandidateTagsCandidateIdFkeyInverseInput>;
  cvText?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  emails?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  evaluations?: InputMaybe<EvaluationsCandidateIdFkeyInverseInput>;
  eventCandidates?: InputMaybe<EventCandidatesCandidateIdFkeyInverseInput>;
  files?: InputMaybe<CandidateFilesCandidateIdFkeyInverseInput>;
  gender?: InputMaybe<Gender>;
  jobsApplications?: InputMaybe<JobsApplicationsCandidateIdFkeyInverseInput>;
  language: Language;
  links?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  militaryStatus?: InputMaybe<MilitaryStatus>;
  phones?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  photoExternalId?: InputMaybe<Scalars['UUID']['input']>;
  resumeExternalId?: InputMaybe<Scalars['UUID']['input']>;
  socialLinks?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  sources?: InputMaybe<Array<Scalars['String']['input']>>;
  tags?: InputMaybe<Array<Scalars['String']['input']>>;
  threads?: InputMaybe<ThreadsCandidateIdFkeyInverseInput>;
  translations?: InputMaybe<CandidateTranslationsCandidateIdFkeyInverseInput>;
};

/** Input for the nested mutation of `candidate` in the `CandidateQuestionnaireInput` mutation. */
export type CandidateQuestionnairesCandidateIdFkeyInput = {
  /** The primary key(s) for `candidate` for the far side of the relationship. */
  connectById?: InputMaybe<CandidateCandidatesPkeyConnect>;
  /** The primary key(s) for `candidate` for the far side of the relationship. */
  connectByNodeId?: InputMaybe<CandidateNodeIdConnect>;
  /** A `CandidateInput` object that will be created and connected to this object. */
  create?: InputMaybe<CandidateQuestionnairesCandidateIdFkeyCandidatesCreateInput>;
  /** The primary key(s) and patch data for `candidate` for the far side of the relationship. */
  updateById?: InputMaybe<CandidateOnCandidateQuestionnaireForCandidateQuestionnairesCandidateIdFkeyUsingCandidatesPkeyUpdate>;
  /** The primary key(s) and patch data for `candidate` for the far side of the relationship. */
  updateByNodeId?: InputMaybe<CandidateQuestionnaireOnCandidateQuestionnaireForCandidateQuestionnairesCandidateIdFkeyNodeIdUpdate>;
};

/** Input for the nested mutation of `candidateQuestionnaire` in the `CandidateInput` mutation. */
export type CandidateQuestionnairesCandidateIdFkeyInverseInput = {
  /** The primary key(s) for `candidateQuestionnaire` for the far side of the relationship. */
  connectById?: InputMaybe<Array<CandidateQuestionnaireCandidateQuestionnairesPkeyConnect>>;
  /** The primary key(s) for `candidateQuestionnaire` for the far side of the relationship. */
  connectByNodeId?: InputMaybe<Array<CandidateQuestionnaireNodeIdConnect>>;
  /** A `CandidateQuestionnaireInput` object that will be created and connected to this object. */
  create?: InputMaybe<Array<CandidateQuestionnairesCandidateIdFkeyCandidateQuestionnairesCreateInput>>;
  /** The primary key(s) and patch data for `candidateQuestionnaire` for the far side of the relationship. */
  updateById?: InputMaybe<Array<CandidateQuestionnaireOnCandidateQuestionnaireForCandidateQuestionnairesCandidateIdFkeyUsingCandidateQuestionnairesPkeyUpdate>>;
  /** The primary key(s) and patch data for `candidateQuestionnaire` for the far side of the relationship. */
  updateByNodeId?: InputMaybe<Array<CandidateOnCandidateQuestionnaireForCandidateQuestionnairesCandidateIdFkeyNodeIdUpdate>>;
};

/** A connection to a list of `CandidateQuestionnaire` values. */
export type CandidateQuestionnairesConnection = {
  __typename?: 'CandidateQuestionnairesConnection';
  /** A list of edges which contains the `CandidateQuestionnaire` and cursor to aid in pagination. */
  edges: Array<CandidateQuestionnairesEdge>;
  /** A list of `CandidateQuestionnaire` objects. */
  nodes: Array<CandidateQuestionnaire>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `CandidateQuestionnaire` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `CandidateQuestionnaire` edge in the connection. */
export type CandidateQuestionnairesEdge = {
  __typename?: 'CandidateQuestionnairesEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `CandidateQuestionnaire` at the end of the edge. */
  node: CandidateQuestionnaire;
};

/** The `candidateQuestionnaire` to be created by this mutation. */
export type CandidateQuestionnairesEvaluationIdFkeyCandidateQuestionnairesCreateInput = {
  candidate?: InputMaybe<CandidateQuestionnairesCandidateIdFkeyInput>;
  candidateId?: InputMaybe<Scalars['Int']['input']>;
  evaluation?: InputMaybe<CandidateQuestionnairesEvaluationIdFkeyInput>;
  questionnaire?: InputMaybe<CandidateQuestionnairesQuestionnaireIdFkeyInput>;
  questionnaireId?: InputMaybe<Scalars['Int']['input']>;
};

/** The `evaluation` to be created by this mutation. */
export type CandidateQuestionnairesEvaluationIdFkeyEvaluationsCreateInput = {
  candidate?: InputMaybe<EvaluationsCandidateIdFkeyInput>;
  candidateId?: InputMaybe<Scalars['Int']['input']>;
  candidateQuestionnaires?: InputMaybe<CandidateQuestionnairesEvaluationIdFkeyInverseInput>;
  candidateQuestions?: InputMaybe<CandidateQuestionsEvaluationIdFkeyInverseInput>;
  comment?: InputMaybe<Scalars['String']['input']>;
  draftEvaluation?: InputMaybe<EvaluationsDraftEvaluationIdFkeyInput>;
  draftEvaluationId?: InputMaybe<Scalars['Int']['input']>;
  evaluationScorecards?: InputMaybe<EvaluationScorecardsEvaluationIdFkeyInverseInput>;
  eventDraftEvaluation?: InputMaybe<EvaluationsEventDraftEvaluationIdFkeyInput>;
  eventDraftEvaluationId?: InputMaybe<Scalars['Int']['input']>;
  job?: InputMaybe<EvaluationsJobIdFkeyInput>;
  jobId?: InputMaybe<Scalars['Int']['input']>;
  point: Scalars['Int']['input'];
  user?: InputMaybe<EvaluationsUserIdFkeyInput>;
  userId?: InputMaybe<Scalars['Int']['input']>;
};

/** Input for the nested mutation of `evaluation` in the `CandidateQuestionnaireInput` mutation. */
export type CandidateQuestionnairesEvaluationIdFkeyInput = {
  /** The primary key(s) for `evaluation` for the far side of the relationship. */
  connectById?: InputMaybe<EvaluationEvaluationsPkeyConnect>;
  /** The primary key(s) for `evaluation` for the far side of the relationship. */
  connectByNodeId?: InputMaybe<EvaluationNodeIdConnect>;
  /** A `EvaluationInput` object that will be created and connected to this object. */
  create?: InputMaybe<CandidateQuestionnairesEvaluationIdFkeyEvaluationsCreateInput>;
  /** The primary key(s) and patch data for `evaluation` for the far side of the relationship. */
  updateById?: InputMaybe<EvaluationOnCandidateQuestionnaireForCandidateQuestionnairesEvaluationIdFkeyUsingEvaluationsPkeyUpdate>;
  /** The primary key(s) and patch data for `evaluation` for the far side of the relationship. */
  updateByNodeId?: InputMaybe<CandidateQuestionnaireOnCandidateQuestionnaireForCandidateQuestionnairesEvaluationIdFkeyNodeIdUpdate>;
};

/** Input for the nested mutation of `candidateQuestionnaire` in the `EvaluationInput` mutation. */
export type CandidateQuestionnairesEvaluationIdFkeyInverseInput = {
  /** The primary key(s) for `candidateQuestionnaire` for the far side of the relationship. */
  connectById?: InputMaybe<Array<CandidateQuestionnaireCandidateQuestionnairesPkeyConnect>>;
  /** The primary key(s) for `candidateQuestionnaire` for the far side of the relationship. */
  connectByNodeId?: InputMaybe<Array<CandidateQuestionnaireNodeIdConnect>>;
  /** A `CandidateQuestionnaireInput` object that will be created and connected to this object. */
  create?: InputMaybe<Array<CandidateQuestionnairesEvaluationIdFkeyCandidateQuestionnairesCreateInput>>;
  /** The primary key(s) and patch data for `candidateQuestionnaire` for the far side of the relationship. */
  updateById?: InputMaybe<Array<CandidateQuestionnaireOnCandidateQuestionnaireForCandidateQuestionnairesEvaluationIdFkeyUsingCandidateQuestionnairesPkeyUpdate>>;
  /** The primary key(s) and patch data for `candidateQuestionnaire` for the far side of the relationship. */
  updateByNodeId?: InputMaybe<Array<EvaluationOnCandidateQuestionnaireForCandidateQuestionnairesEvaluationIdFkeyNodeIdUpdate>>;
};

/** Methods to use when ordering `CandidateQuestionnaire`. */
export enum CandidateQuestionnairesOrderBy {
  CandidateIdAsc = 'CANDIDATE_ID_ASC',
  CandidateIdDesc = 'CANDIDATE_ID_DESC',
  EvaluationIdAsc = 'EVALUATION_ID_ASC',
  EvaluationIdDesc = 'EVALUATION_ID_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  Natural = 'NATURAL',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  QuestionnaireIdAsc = 'QUESTIONNAIRE_ID_ASC',
  QuestionnaireIdDesc = 'QUESTIONNAIRE_ID_DESC'
}

/** The `candidateQuestionnaire` to be created by this mutation. */
export type CandidateQuestionnairesQuestionnaireIdFkeyCandidateQuestionnairesCreateInput = {
  candidate?: InputMaybe<CandidateQuestionnairesCandidateIdFkeyInput>;
  candidateId?: InputMaybe<Scalars['Int']['input']>;
  evaluation?: InputMaybe<CandidateQuestionnairesEvaluationIdFkeyInput>;
  evaluationId?: InputMaybe<Scalars['Int']['input']>;
  questionnaire?: InputMaybe<CandidateQuestionnairesQuestionnaireIdFkeyInput>;
};

/** Input for the nested mutation of `questionnaire` in the `CandidateQuestionnaireInput` mutation. */
export type CandidateQuestionnairesQuestionnaireIdFkeyInput = {
  /** The primary key(s) for `questionnaire` for the far side of the relationship. */
  connectById?: InputMaybe<QuestionnaireQuestionnairesPkeyConnect>;
  /** The primary key(s) for `questionnaire` for the far side of the relationship. */
  connectByNodeId?: InputMaybe<QuestionnaireNodeIdConnect>;
  /** A `QuestionnaireInput` object that will be created and connected to this object. */
  create?: InputMaybe<CandidateQuestionnairesQuestionnaireIdFkeyQuestionnairesCreateInput>;
  /** The primary key(s) and patch data for `questionnaire` for the far side of the relationship. */
  updateById?: InputMaybe<QuestionnaireOnCandidateQuestionnaireForCandidateQuestionnairesQuestionnaireIdFkeyUsingQuestionnairesPkeyUpdate>;
  /** The primary key(s) and patch data for `questionnaire` for the far side of the relationship. */
  updateByNodeId?: InputMaybe<CandidateQuestionnaireOnCandidateQuestionnaireForCandidateQuestionnairesQuestionnaireIdFkeyNodeIdUpdate>;
};

/** Input for the nested mutation of `candidateQuestionnaire` in the `QuestionnaireInput` mutation. */
export type CandidateQuestionnairesQuestionnaireIdFkeyInverseInput = {
  /** The primary key(s) for `candidateQuestionnaire` for the far side of the relationship. */
  connectById?: InputMaybe<Array<CandidateQuestionnaireCandidateQuestionnairesPkeyConnect>>;
  /** The primary key(s) for `candidateQuestionnaire` for the far side of the relationship. */
  connectByNodeId?: InputMaybe<Array<CandidateQuestionnaireNodeIdConnect>>;
  /** A `CandidateQuestionnaireInput` object that will be created and connected to this object. */
  create?: InputMaybe<Array<CandidateQuestionnairesQuestionnaireIdFkeyCandidateQuestionnairesCreateInput>>;
  /** The primary key(s) and patch data for `candidateQuestionnaire` for the far side of the relationship. */
  updateById?: InputMaybe<Array<CandidateQuestionnaireOnCandidateQuestionnaireForCandidateQuestionnairesQuestionnaireIdFkeyUsingCandidateQuestionnairesPkeyUpdate>>;
  /** The primary key(s) and patch data for `candidateQuestionnaire` for the far side of the relationship. */
  updateByNodeId?: InputMaybe<Array<QuestionnaireOnCandidateQuestionnaireForCandidateQuestionnairesQuestionnaireIdFkeyNodeIdUpdate>>;
};

/** The `questionnaire` to be created by this mutation. */
export type CandidateQuestionnairesQuestionnaireIdFkeyQuestionnairesCreateInput = {
  candidateQuestionnaires?: InputMaybe<CandidateQuestionnairesQuestionnaireIdFkeyInverseInput>;
  candidateQuestions?: InputMaybe<CandidateQuestionsQuestionnaireIdFkeyInverseInput>;
  category: Scalars['String']['input'];
  deletedAt?: InputMaybe<Scalars['Datetime']['input']>;
  jobQuestionnaires?: InputMaybe<JobQuestionnairesQuestionnaireIdFkeyInverseInput>;
  questionnaireQuestions?: InputMaybe<QuestionnaireQuestionsQuestionnaireIdFkeyInverseInput>;
  translations?: InputMaybe<QuestionnaireTranslationsQuestionnaireIdFkeyInverseInput>;
};

/** A connection to a list of `Question` values, with data from `CandidateQuestion`. */
export type CandidateQuestionsByCandidateQuestionCandidateIdAndQuestionIdManyToManyConnection = {
  __typename?: 'CandidateQuestionsByCandidateQuestionCandidateIdAndQuestionIdManyToManyConnection';
  /** A list of edges which contains the `Question`, info from the `CandidateQuestion`, and the cursor to aid in pagination. */
  edges: Array<CandidateQuestionsByCandidateQuestionCandidateIdAndQuestionIdManyToManyEdge>;
  /** A list of `Question` objects. */
  nodes: Array<Question>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Question` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `Question` edge in the connection, with data from `CandidateQuestion`. */
export type CandidateQuestionsByCandidateQuestionCandidateIdAndQuestionIdManyToManyEdge = {
  __typename?: 'CandidateQuestionsByCandidateQuestionCandidateIdAndQuestionIdManyToManyEdge';
  /** Reads and enables pagination through a set of `CandidateQuestion`. */
  candidateQuestions: CandidateQuestionsConnection;
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Question` at the end of the edge. */
  node: Question;
};


/** A `Question` edge in the connection, with data from `CandidateQuestion`. */
export type CandidateQuestionsByCandidateQuestionCandidateIdAndQuestionIdManyToManyEdgeCandidateQuestionsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<CandidateQuestionCondition>;
  filter?: InputMaybe<CandidateQuestionFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<CandidateQuestionsOrderBy>>;
};

/** The `candidateQuestion` to be created by this mutation. */
export type CandidateQuestionsCandidateIdFkeyCandidateQuestionsCreateInput = {
  booleanValue?: InputMaybe<Scalars['Boolean']['input']>;
  candidate?: InputMaybe<CandidateQuestionsCandidateIdFkeyInput>;
  candidateFile?: InputMaybe<CandidateQuestionsFileValueExternalIdFkeyInput>;
  dateValue?: InputMaybe<Scalars['Datetime']['input']>;
  evaluation?: InputMaybe<CandidateQuestionsEvaluationIdFkeyInput>;
  evaluationId?: InputMaybe<Scalars['Int']['input']>;
  fileValueExternalId?: InputMaybe<Scalars['UUID']['input']>;
  numberValue?: InputMaybe<Scalars['Int']['input']>;
  question?: InputMaybe<CandidateQuestionsQuestionIdFkeyInput>;
  questionId?: InputMaybe<Scalars['Int']['input']>;
  questionOption?: InputMaybe<CandidateQuestionsQuestionValueIdFkeyInput>;
  questionOptionId?: InputMaybe<Scalars['Int']['input']>;
  questionnaire?: InputMaybe<CandidateQuestionsQuestionnaireIdFkeyInput>;
  questionnaireId?: InputMaybe<Scalars['Int']['input']>;
  textValue?: InputMaybe<Scalars['String']['input']>;
};

/** The `candidate` to be created by this mutation. */
export type CandidateQuestionsCandidateIdFkeyCandidatesCreateInput = {
  birthday?: InputMaybe<Scalars['Date']['input']>;
  candidateDraftEvaluations?: InputMaybe<DraftEvaluationsCandidateIdFkeyInverseInput>;
  candidateEventDraftEvaluations?: InputMaybe<EventDraftEvaluationsCandidateIdFkeyInverseInput>;
  candidateImportCandidate?: InputMaybe<CandidateImportCandidatesCandidateIdFkeyInverseInput>;
  candidateQuestionnaires?: InputMaybe<CandidateQuestionnairesCandidateIdFkeyInverseInput>;
  candidateQuestions?: InputMaybe<CandidateQuestionsCandidateIdFkeyInverseInput>;
  candidateTags?: InputMaybe<CandidateTagsCandidateIdFkeyInverseInput>;
  cvText?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  emails?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  evaluations?: InputMaybe<EvaluationsCandidateIdFkeyInverseInput>;
  eventCandidates?: InputMaybe<EventCandidatesCandidateIdFkeyInverseInput>;
  files?: InputMaybe<CandidateFilesCandidateIdFkeyInverseInput>;
  gender?: InputMaybe<Gender>;
  jobsApplications?: InputMaybe<JobsApplicationsCandidateIdFkeyInverseInput>;
  language: Language;
  links?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  militaryStatus?: InputMaybe<MilitaryStatus>;
  phones?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  photoExternalId?: InputMaybe<Scalars['UUID']['input']>;
  resumeExternalId?: InputMaybe<Scalars['UUID']['input']>;
  socialLinks?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  sources?: InputMaybe<Array<Scalars['String']['input']>>;
  tags?: InputMaybe<Array<Scalars['String']['input']>>;
  threads?: InputMaybe<ThreadsCandidateIdFkeyInverseInput>;
  translations?: InputMaybe<CandidateTranslationsCandidateIdFkeyInverseInput>;
};

/** Input for the nested mutation of `candidate` in the `CandidateQuestionInput` mutation. */
export type CandidateQuestionsCandidateIdFkeyInput = {
  /** The primary key(s) for `candidate` for the far side of the relationship. */
  connectById?: InputMaybe<CandidateCandidatesPkeyConnect>;
  /** The primary key(s) for `candidate` for the far side of the relationship. */
  connectByNodeId?: InputMaybe<CandidateNodeIdConnect>;
  /** A `CandidateInput` object that will be created and connected to this object. */
  create?: InputMaybe<CandidateQuestionsCandidateIdFkeyCandidatesCreateInput>;
  /** The primary key(s) and patch data for `candidate` for the far side of the relationship. */
  updateById?: InputMaybe<CandidateOnCandidateQuestionForCandidateQuestionsCandidateIdFkeyUsingCandidatesPkeyUpdate>;
  /** The primary key(s) and patch data for `candidate` for the far side of the relationship. */
  updateByNodeId?: InputMaybe<CandidateQuestionOnCandidateQuestionForCandidateQuestionsCandidateIdFkeyNodeIdUpdate>;
};

/** Input for the nested mutation of `candidateQuestion` in the `CandidateInput` mutation. */
export type CandidateQuestionsCandidateIdFkeyInverseInput = {
  /** The primary key(s) for `candidateQuestion` for the far side of the relationship. */
  connectById?: InputMaybe<Array<CandidateQuestionCandidateQuestionsPkeyConnect>>;
  /** The primary key(s) for `candidateQuestion` for the far side of the relationship. */
  connectByNodeId?: InputMaybe<Array<CandidateQuestionNodeIdConnect>>;
  /** A `CandidateQuestionInput` object that will be created and connected to this object. */
  create?: InputMaybe<Array<CandidateQuestionsCandidateIdFkeyCandidateQuestionsCreateInput>>;
  /** The primary key(s) and patch data for `candidateQuestion` for the far side of the relationship. */
  updateById?: InputMaybe<Array<CandidateQuestionOnCandidateQuestionForCandidateQuestionsCandidateIdFkeyUsingCandidateQuestionsPkeyUpdate>>;
  /** The primary key(s) and patch data for `candidateQuestion` for the far side of the relationship. */
  updateByNodeId?: InputMaybe<Array<CandidateOnCandidateQuestionForCandidateQuestionsCandidateIdFkeyNodeIdUpdate>>;
};

/** A connection to a list of `CandidateQuestion` values. */
export type CandidateQuestionsConnection = {
  __typename?: 'CandidateQuestionsConnection';
  /** A list of edges which contains the `CandidateQuestion` and cursor to aid in pagination. */
  edges: Array<CandidateQuestionsEdge>;
  /** A list of `CandidateQuestion` objects. */
  nodes: Array<CandidateQuestion>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `CandidateQuestion` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `CandidateQuestion` edge in the connection. */
export type CandidateQuestionsEdge = {
  __typename?: 'CandidateQuestionsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `CandidateQuestion` at the end of the edge. */
  node: CandidateQuestion;
};

/** The `candidateQuestion` to be created by this mutation. */
export type CandidateQuestionsEvaluationIdFkeyCandidateQuestionsCreateInput = {
  booleanValue?: InputMaybe<Scalars['Boolean']['input']>;
  candidate?: InputMaybe<CandidateQuestionsCandidateIdFkeyInput>;
  candidateFile?: InputMaybe<CandidateQuestionsFileValueExternalIdFkeyInput>;
  candidateId?: InputMaybe<Scalars['Int']['input']>;
  dateValue?: InputMaybe<Scalars['Datetime']['input']>;
  evaluation?: InputMaybe<CandidateQuestionsEvaluationIdFkeyInput>;
  fileValueExternalId?: InputMaybe<Scalars['UUID']['input']>;
  numberValue?: InputMaybe<Scalars['Int']['input']>;
  question?: InputMaybe<CandidateQuestionsQuestionIdFkeyInput>;
  questionId?: InputMaybe<Scalars['Int']['input']>;
  questionOption?: InputMaybe<CandidateQuestionsQuestionValueIdFkeyInput>;
  questionOptionId?: InputMaybe<Scalars['Int']['input']>;
  questionnaire?: InputMaybe<CandidateQuestionsQuestionnaireIdFkeyInput>;
  questionnaireId?: InputMaybe<Scalars['Int']['input']>;
  textValue?: InputMaybe<Scalars['String']['input']>;
};

/** The `evaluation` to be created by this mutation. */
export type CandidateQuestionsEvaluationIdFkeyEvaluationsCreateInput = {
  candidate?: InputMaybe<EvaluationsCandidateIdFkeyInput>;
  candidateId?: InputMaybe<Scalars['Int']['input']>;
  candidateQuestionnaires?: InputMaybe<CandidateQuestionnairesEvaluationIdFkeyInverseInput>;
  candidateQuestions?: InputMaybe<CandidateQuestionsEvaluationIdFkeyInverseInput>;
  comment?: InputMaybe<Scalars['String']['input']>;
  draftEvaluation?: InputMaybe<EvaluationsDraftEvaluationIdFkeyInput>;
  draftEvaluationId?: InputMaybe<Scalars['Int']['input']>;
  evaluationScorecards?: InputMaybe<EvaluationScorecardsEvaluationIdFkeyInverseInput>;
  eventDraftEvaluation?: InputMaybe<EvaluationsEventDraftEvaluationIdFkeyInput>;
  eventDraftEvaluationId?: InputMaybe<Scalars['Int']['input']>;
  job?: InputMaybe<EvaluationsJobIdFkeyInput>;
  jobId?: InputMaybe<Scalars['Int']['input']>;
  point: Scalars['Int']['input'];
  user?: InputMaybe<EvaluationsUserIdFkeyInput>;
  userId?: InputMaybe<Scalars['Int']['input']>;
};

/** Input for the nested mutation of `evaluation` in the `CandidateQuestionInput` mutation. */
export type CandidateQuestionsEvaluationIdFkeyInput = {
  /** The primary key(s) for `evaluation` for the far side of the relationship. */
  connectById?: InputMaybe<EvaluationEvaluationsPkeyConnect>;
  /** The primary key(s) for `evaluation` for the far side of the relationship. */
  connectByNodeId?: InputMaybe<EvaluationNodeIdConnect>;
  /** A `EvaluationInput` object that will be created and connected to this object. */
  create?: InputMaybe<CandidateQuestionsEvaluationIdFkeyEvaluationsCreateInput>;
  /** The primary key(s) and patch data for `evaluation` for the far side of the relationship. */
  updateById?: InputMaybe<EvaluationOnCandidateQuestionForCandidateQuestionsEvaluationIdFkeyUsingEvaluationsPkeyUpdate>;
  /** The primary key(s) and patch data for `evaluation` for the far side of the relationship. */
  updateByNodeId?: InputMaybe<CandidateQuestionOnCandidateQuestionForCandidateQuestionsEvaluationIdFkeyNodeIdUpdate>;
};

/** Input for the nested mutation of `candidateQuestion` in the `EvaluationInput` mutation. */
export type CandidateQuestionsEvaluationIdFkeyInverseInput = {
  /** The primary key(s) for `candidateQuestion` for the far side of the relationship. */
  connectById?: InputMaybe<Array<CandidateQuestionCandidateQuestionsPkeyConnect>>;
  /** The primary key(s) for `candidateQuestion` for the far side of the relationship. */
  connectByNodeId?: InputMaybe<Array<CandidateQuestionNodeIdConnect>>;
  /** A `CandidateQuestionInput` object that will be created and connected to this object. */
  create?: InputMaybe<Array<CandidateQuestionsEvaluationIdFkeyCandidateQuestionsCreateInput>>;
  /** The primary key(s) and patch data for `candidateQuestion` for the far side of the relationship. */
  updateById?: InputMaybe<Array<CandidateQuestionOnCandidateQuestionForCandidateQuestionsEvaluationIdFkeyUsingCandidateQuestionsPkeyUpdate>>;
  /** The primary key(s) and patch data for `candidateQuestion` for the far side of the relationship. */
  updateByNodeId?: InputMaybe<Array<EvaluationOnCandidateQuestionForCandidateQuestionsEvaluationIdFkeyNodeIdUpdate>>;
};

/** The `candidateFile` to be created by this mutation. */
export type CandidateQuestionsFileValueExternalIdFkeyCandidateFilesCreateInput = {
  candidate?: InputMaybe<CandidateFilesCandidateIdFkeyInput>;
  candidateId?: InputMaybe<Scalars['Int']['input']>;
  candidateQuestions?: InputMaybe<CandidateQuestionsFileValueExternalIdFkeyInverseInput>;
  externalId: Scalars['UUID']['input'];
  extractedText?: InputMaybe<Scalars['String']['input']>;
  name: Scalars['String']['input'];
};

/** The `candidateQuestion` to be created by this mutation. */
export type CandidateQuestionsFileValueExternalIdFkeyCandidateQuestionsCreateInput = {
  booleanValue?: InputMaybe<Scalars['Boolean']['input']>;
  candidate?: InputMaybe<CandidateQuestionsCandidateIdFkeyInput>;
  candidateFile?: InputMaybe<CandidateQuestionsFileValueExternalIdFkeyInput>;
  candidateId?: InputMaybe<Scalars['Int']['input']>;
  dateValue?: InputMaybe<Scalars['Datetime']['input']>;
  evaluation?: InputMaybe<CandidateQuestionsEvaluationIdFkeyInput>;
  evaluationId?: InputMaybe<Scalars['Int']['input']>;
  numberValue?: InputMaybe<Scalars['Int']['input']>;
  question?: InputMaybe<CandidateQuestionsQuestionIdFkeyInput>;
  questionId?: InputMaybe<Scalars['Int']['input']>;
  questionOption?: InputMaybe<CandidateQuestionsQuestionValueIdFkeyInput>;
  questionOptionId?: InputMaybe<Scalars['Int']['input']>;
  questionnaire?: InputMaybe<CandidateQuestionsQuestionnaireIdFkeyInput>;
  questionnaireId?: InputMaybe<Scalars['Int']['input']>;
  textValue?: InputMaybe<Scalars['String']['input']>;
};

/** Input for the nested mutation of `candidateFile` in the `CandidateQuestionInput` mutation. */
export type CandidateQuestionsFileValueExternalIdFkeyInput = {
  /** The primary key(s) for `candidateFile` for the far side of the relationship. */
  connectByExternalId?: InputMaybe<CandidateFileCandidateFilesPkeyConnect>;
  /** The primary key(s) for `candidateFile` for the far side of the relationship. */
  connectByNodeId?: InputMaybe<CandidateFileNodeIdConnect>;
  /** A `CandidateFileInput` object that will be created and connected to this object. */
  create?: InputMaybe<CandidateQuestionsFileValueExternalIdFkeyCandidateFilesCreateInput>;
  /** The primary key(s) for `candidateFile` for the far side of the relationship. */
  deleteByExternalId?: InputMaybe<CandidateFileCandidateFilesPkeyDelete>;
  /** The primary key(s) for `candidateFile` for the far side of the relationship. */
  deleteByNodeId?: InputMaybe<CandidateFileNodeIdDelete>;
  /** The primary key(s) and patch data for `candidateFile` for the far side of the relationship. */
  updateByExternalId?: InputMaybe<CandidateFileOnCandidateQuestionForCandidateQuestionsFileValueExternalIdFkeyUsingCandidateFilesPkeyUpdate>;
  /** The primary key(s) and patch data for `candidateFile` for the far side of the relationship. */
  updateByNodeId?: InputMaybe<CandidateQuestionOnCandidateQuestionForCandidateQuestionsFileValueExternalIdFkeyNodeIdUpdate>;
};

/** Input for the nested mutation of `candidateQuestion` in the `CandidateFileInput` mutation. */
export type CandidateQuestionsFileValueExternalIdFkeyInverseInput = {
  /** The primary key(s) for `candidateQuestion` for the far side of the relationship. */
  connectById?: InputMaybe<Array<CandidateQuestionCandidateQuestionsPkeyConnect>>;
  /** The primary key(s) for `candidateQuestion` for the far side of the relationship. */
  connectByNodeId?: InputMaybe<Array<CandidateQuestionNodeIdConnect>>;
  /** A `CandidateQuestionInput` object that will be created and connected to this object. */
  create?: InputMaybe<Array<CandidateQuestionsFileValueExternalIdFkeyCandidateQuestionsCreateInput>>;
  /** The primary key(s) and patch data for `candidateQuestion` for the far side of the relationship. */
  updateById?: InputMaybe<Array<CandidateQuestionOnCandidateQuestionForCandidateQuestionsFileValueExternalIdFkeyUsingCandidateQuestionsPkeyUpdate>>;
  /** The primary key(s) and patch data for `candidateQuestion` for the far side of the relationship. */
  updateByNodeId?: InputMaybe<Array<CandidateFileOnCandidateQuestionForCandidateQuestionsFileValueExternalIdFkeyNodeIdUpdate>>;
};

/** An input for mutations affecting `CandidateQuestionsInputRecord` */
export type CandidateQuestionsInputRecordInput = {
  booleanValue?: InputMaybe<Scalars['Boolean']['input']>;
  dateValue?: InputMaybe<Scalars['Datetime']['input']>;
  fileValueExternalId?: InputMaybe<Scalars['UUID']['input']>;
  numberValue?: InputMaybe<Scalars['Int']['input']>;
  questionId?: InputMaybe<Scalars['Int']['input']>;
  questionOptionId?: InputMaybe<Scalars['Int']['input']>;
  questionnaireId?: InputMaybe<Scalars['Int']['input']>;
  textValue?: InputMaybe<Scalars['String']['input']>;
};

/** Methods to use when ordering `CandidateQuestion`. */
export enum CandidateQuestionsOrderBy {
  CandidateIdAsc = 'CANDIDATE_ID_ASC',
  CandidateIdDesc = 'CANDIDATE_ID_DESC',
  EvaluationIdAsc = 'EVALUATION_ID_ASC',
  EvaluationIdDesc = 'EVALUATION_ID_DESC',
  FileValueExternalIdAsc = 'FILE_VALUE_EXTERNAL_ID_ASC',
  FileValueExternalIdDesc = 'FILE_VALUE_EXTERNAL_ID_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  Natural = 'NATURAL',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  QuestionnaireIdAsc = 'QUESTIONNAIRE_ID_ASC',
  QuestionnaireIdDesc = 'QUESTIONNAIRE_ID_DESC',
  QuestionIdAsc = 'QUESTION_ID_ASC',
  QuestionIdDesc = 'QUESTION_ID_DESC',
  QuestionOptionIdAsc = 'QUESTION_OPTION_ID_ASC',
  QuestionOptionIdDesc = 'QUESTION_OPTION_ID_DESC'
}

/** The `candidateQuestion` to be created by this mutation. */
export type CandidateQuestionsQuestionIdFkeyCandidateQuestionsCreateInput = {
  booleanValue?: InputMaybe<Scalars['Boolean']['input']>;
  candidate?: InputMaybe<CandidateQuestionsCandidateIdFkeyInput>;
  candidateFile?: InputMaybe<CandidateQuestionsFileValueExternalIdFkeyInput>;
  candidateId?: InputMaybe<Scalars['Int']['input']>;
  dateValue?: InputMaybe<Scalars['Datetime']['input']>;
  evaluation?: InputMaybe<CandidateQuestionsEvaluationIdFkeyInput>;
  evaluationId?: InputMaybe<Scalars['Int']['input']>;
  fileValueExternalId?: InputMaybe<Scalars['UUID']['input']>;
  numberValue?: InputMaybe<Scalars['Int']['input']>;
  question?: InputMaybe<CandidateQuestionsQuestionIdFkeyInput>;
  questionOption?: InputMaybe<CandidateQuestionsQuestionValueIdFkeyInput>;
  questionOptionId?: InputMaybe<Scalars['Int']['input']>;
  questionnaire?: InputMaybe<CandidateQuestionsQuestionnaireIdFkeyInput>;
  questionnaireId?: InputMaybe<Scalars['Int']['input']>;
  textValue?: InputMaybe<Scalars['String']['input']>;
};

/** Input for the nested mutation of `question` in the `CandidateQuestionInput` mutation. */
export type CandidateQuestionsQuestionIdFkeyInput = {
  /** The primary key(s) for `question` for the far side of the relationship. */
  connectById?: InputMaybe<QuestionQuestionsPkeyConnect>;
  /** The primary key(s) for `question` for the far side of the relationship. */
  connectByNodeId?: InputMaybe<QuestionNodeIdConnect>;
  /** A `QuestionInput` object that will be created and connected to this object. */
  create?: InputMaybe<CandidateQuestionsQuestionIdFkeyQuestionsCreateInput>;
  /** The primary key(s) and patch data for `question` for the far side of the relationship. */
  updateById?: InputMaybe<QuestionOnCandidateQuestionForCandidateQuestionsQuestionIdFkeyUsingQuestionsPkeyUpdate>;
  /** The primary key(s) and patch data for `question` for the far side of the relationship. */
  updateByNodeId?: InputMaybe<CandidateQuestionOnCandidateQuestionForCandidateQuestionsQuestionIdFkeyNodeIdUpdate>;
};

/** Input for the nested mutation of `candidateQuestion` in the `QuestionInput` mutation. */
export type CandidateQuestionsQuestionIdFkeyInverseInput = {
  /** The primary key(s) for `candidateQuestion` for the far side of the relationship. */
  connectById?: InputMaybe<Array<CandidateQuestionCandidateQuestionsPkeyConnect>>;
  /** The primary key(s) for `candidateQuestion` for the far side of the relationship. */
  connectByNodeId?: InputMaybe<Array<CandidateQuestionNodeIdConnect>>;
  /** A `CandidateQuestionInput` object that will be created and connected to this object. */
  create?: InputMaybe<Array<CandidateQuestionsQuestionIdFkeyCandidateQuestionsCreateInput>>;
  /** The primary key(s) and patch data for `candidateQuestion` for the far side of the relationship. */
  updateById?: InputMaybe<Array<CandidateQuestionOnCandidateQuestionForCandidateQuestionsQuestionIdFkeyUsingCandidateQuestionsPkeyUpdate>>;
  /** The primary key(s) and patch data for `candidateQuestion` for the far side of the relationship. */
  updateByNodeId?: InputMaybe<Array<QuestionOnCandidateQuestionForCandidateQuestionsQuestionIdFkeyNodeIdUpdate>>;
};

/** The `question` to be created by this mutation. */
export type CandidateQuestionsQuestionIdFkeyQuestionsCreateInput = {
  candidateQuestions?: InputMaybe<CandidateQuestionsQuestionIdFkeyInverseInput>;
  options?: InputMaybe<QuestionOptionsQuestionIdFkeyInverseInput>;
  questionnaireQuestions?: InputMaybe<QuestionnaireQuestionsQuestionIdFkeyInverseInput>;
  required: Scalars['Boolean']['input'];
  translations?: InputMaybe<QuestionTranslationsQuestionIdFkeyInverseInput>;
  type: QuestionType;
};

/** The `candidateQuestion` to be created by this mutation. */
export type CandidateQuestionsQuestionValueIdFkeyCandidateQuestionsCreateInput = {
  booleanValue?: InputMaybe<Scalars['Boolean']['input']>;
  candidate?: InputMaybe<CandidateQuestionsCandidateIdFkeyInput>;
  candidateFile?: InputMaybe<CandidateQuestionsFileValueExternalIdFkeyInput>;
  candidateId?: InputMaybe<Scalars['Int']['input']>;
  dateValue?: InputMaybe<Scalars['Datetime']['input']>;
  evaluation?: InputMaybe<CandidateQuestionsEvaluationIdFkeyInput>;
  evaluationId?: InputMaybe<Scalars['Int']['input']>;
  fileValueExternalId?: InputMaybe<Scalars['UUID']['input']>;
  numberValue?: InputMaybe<Scalars['Int']['input']>;
  question?: InputMaybe<CandidateQuestionsQuestionIdFkeyInput>;
  questionId?: InputMaybe<Scalars['Int']['input']>;
  questionOption?: InputMaybe<CandidateQuestionsQuestionValueIdFkeyInput>;
  questionnaire?: InputMaybe<CandidateQuestionsQuestionnaireIdFkeyInput>;
  questionnaireId?: InputMaybe<Scalars['Int']['input']>;
  textValue?: InputMaybe<Scalars['String']['input']>;
};

/** Input for the nested mutation of `questionOption` in the `CandidateQuestionInput` mutation. */
export type CandidateQuestionsQuestionValueIdFkeyInput = {
  /** The primary key(s) for `questionOption` for the far side of the relationship. */
  connectById?: InputMaybe<QuestionOptionQuestionOptionsPkeyConnect>;
  /** The primary key(s) for `questionOption` for the far side of the relationship. */
  connectByNodeId?: InputMaybe<QuestionOptionNodeIdConnect>;
  /** A `QuestionOptionInput` object that will be created and connected to this object. */
  create?: InputMaybe<CandidateQuestionsQuestionValueIdFkeyQuestionOptionsCreateInput>;
  /** The primary key(s) for `questionOption` for the far side of the relationship. */
  deleteById?: InputMaybe<QuestionOptionQuestionOptionsPkeyDelete>;
  /** The primary key(s) for `questionOption` for the far side of the relationship. */
  deleteByNodeId?: InputMaybe<QuestionOptionNodeIdDelete>;
  /** The primary key(s) and patch data for `questionOption` for the far side of the relationship. */
  updateById?: InputMaybe<QuestionOptionOnCandidateQuestionForCandidateQuestionsQuestionValueIdFkeyUsingQuestionOptionsPkeyUpdate>;
  /** The primary key(s) and patch data for `questionOption` for the far side of the relationship. */
  updateByNodeId?: InputMaybe<CandidateQuestionOnCandidateQuestionForCandidateQuestionsQuestionValueIdFkeyNodeIdUpdate>;
};

/** Input for the nested mutation of `candidateQuestion` in the `QuestionOptionInput` mutation. */
export type CandidateQuestionsQuestionValueIdFkeyInverseInput = {
  /** The primary key(s) for `candidateQuestion` for the far side of the relationship. */
  connectById?: InputMaybe<Array<CandidateQuestionCandidateQuestionsPkeyConnect>>;
  /** The primary key(s) for `candidateQuestion` for the far side of the relationship. */
  connectByNodeId?: InputMaybe<Array<CandidateQuestionNodeIdConnect>>;
  /** A `CandidateQuestionInput` object that will be created and connected to this object. */
  create?: InputMaybe<Array<CandidateQuestionsQuestionValueIdFkeyCandidateQuestionsCreateInput>>;
  /** The primary key(s) and patch data for `candidateQuestion` for the far side of the relationship. */
  updateById?: InputMaybe<Array<CandidateQuestionOnCandidateQuestionForCandidateQuestionsQuestionValueIdFkeyUsingCandidateQuestionsPkeyUpdate>>;
  /** The primary key(s) and patch data for `candidateQuestion` for the far side of the relationship. */
  updateByNodeId?: InputMaybe<Array<QuestionOptionOnCandidateQuestionForCandidateQuestionsQuestionValueIdFkeyNodeIdUpdate>>;
};

/** The `questionOption` to be created by this mutation. */
export type CandidateQuestionsQuestionValueIdFkeyQuestionOptionsCreateInput = {
  candidateQuestions?: InputMaybe<CandidateQuestionsQuestionValueIdFkeyInverseInput>;
  position: Scalars['Int']['input'];
  question?: InputMaybe<QuestionOptionsQuestionIdFkeyInput>;
  questionId?: InputMaybe<Scalars['Int']['input']>;
  translations?: InputMaybe<QuestionOptionTranslationsQuestionOptionIdFkeyInverseInput>;
};

/** The `candidateQuestion` to be created by this mutation. */
export type CandidateQuestionsQuestionnaireIdFkeyCandidateQuestionsCreateInput = {
  booleanValue?: InputMaybe<Scalars['Boolean']['input']>;
  candidate?: InputMaybe<CandidateQuestionsCandidateIdFkeyInput>;
  candidateFile?: InputMaybe<CandidateQuestionsFileValueExternalIdFkeyInput>;
  candidateId?: InputMaybe<Scalars['Int']['input']>;
  dateValue?: InputMaybe<Scalars['Datetime']['input']>;
  evaluation?: InputMaybe<CandidateQuestionsEvaluationIdFkeyInput>;
  evaluationId?: InputMaybe<Scalars['Int']['input']>;
  fileValueExternalId?: InputMaybe<Scalars['UUID']['input']>;
  numberValue?: InputMaybe<Scalars['Int']['input']>;
  question?: InputMaybe<CandidateQuestionsQuestionIdFkeyInput>;
  questionId?: InputMaybe<Scalars['Int']['input']>;
  questionOption?: InputMaybe<CandidateQuestionsQuestionValueIdFkeyInput>;
  questionOptionId?: InputMaybe<Scalars['Int']['input']>;
  questionnaire?: InputMaybe<CandidateQuestionsQuestionnaireIdFkeyInput>;
  textValue?: InputMaybe<Scalars['String']['input']>;
};

/** Input for the nested mutation of `questionnaire` in the `CandidateQuestionInput` mutation. */
export type CandidateQuestionsQuestionnaireIdFkeyInput = {
  /** The primary key(s) for `questionnaire` for the far side of the relationship. */
  connectById?: InputMaybe<QuestionnaireQuestionnairesPkeyConnect>;
  /** The primary key(s) for `questionnaire` for the far side of the relationship. */
  connectByNodeId?: InputMaybe<QuestionnaireNodeIdConnect>;
  /** A `QuestionnaireInput` object that will be created and connected to this object. */
  create?: InputMaybe<CandidateQuestionsQuestionnaireIdFkeyQuestionnairesCreateInput>;
  /** The primary key(s) and patch data for `questionnaire` for the far side of the relationship. */
  updateById?: InputMaybe<QuestionnaireOnCandidateQuestionForCandidateQuestionsQuestionnaireIdFkeyUsingQuestionnairesPkeyUpdate>;
  /** The primary key(s) and patch data for `questionnaire` for the far side of the relationship. */
  updateByNodeId?: InputMaybe<CandidateQuestionOnCandidateQuestionForCandidateQuestionsQuestionnaireIdFkeyNodeIdUpdate>;
};

/** Input for the nested mutation of `candidateQuestion` in the `QuestionnaireInput` mutation. */
export type CandidateQuestionsQuestionnaireIdFkeyInverseInput = {
  /** The primary key(s) for `candidateQuestion` for the far side of the relationship. */
  connectById?: InputMaybe<Array<CandidateQuestionCandidateQuestionsPkeyConnect>>;
  /** The primary key(s) for `candidateQuestion` for the far side of the relationship. */
  connectByNodeId?: InputMaybe<Array<CandidateQuestionNodeIdConnect>>;
  /** A `CandidateQuestionInput` object that will be created and connected to this object. */
  create?: InputMaybe<Array<CandidateQuestionsQuestionnaireIdFkeyCandidateQuestionsCreateInput>>;
  /** The primary key(s) and patch data for `candidateQuestion` for the far side of the relationship. */
  updateById?: InputMaybe<Array<CandidateQuestionOnCandidateQuestionForCandidateQuestionsQuestionnaireIdFkeyUsingCandidateQuestionsPkeyUpdate>>;
  /** The primary key(s) and patch data for `candidateQuestion` for the far side of the relationship. */
  updateByNodeId?: InputMaybe<Array<QuestionnaireOnCandidateQuestionForCandidateQuestionsQuestionnaireIdFkeyNodeIdUpdate>>;
};

/** The `questionnaire` to be created by this mutation. */
export type CandidateQuestionsQuestionnaireIdFkeyQuestionnairesCreateInput = {
  candidateQuestionnaires?: InputMaybe<CandidateQuestionnairesQuestionnaireIdFkeyInverseInput>;
  candidateQuestions?: InputMaybe<CandidateQuestionsQuestionnaireIdFkeyInverseInput>;
  category: Scalars['String']['input'];
  deletedAt?: InputMaybe<Scalars['Datetime']['input']>;
  jobQuestionnaires?: InputMaybe<JobQuestionnairesQuestionnaireIdFkeyInverseInput>;
  questionnaireQuestions?: InputMaybe<QuestionnaireQuestionsQuestionnaireIdFkeyInverseInput>;
  translations?: InputMaybe<QuestionnaireTranslationsQuestionnaireIdFkeyInverseInput>;
};

export type CandidateTag = Node & {
  __typename?: 'CandidateTag';
  /** Reads a single `Candidate` that is related to this `CandidateTag`. */
  candidate?: Maybe<Candidate>;
  candidateId: Scalars['Int']['output'];
  createdAt: Scalars['Datetime']['output'];
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  /** Reads a single `Tag` that is related to this `CandidateTag`. */
  tag?: Maybe<Tag>;
  tagId: Scalars['Int']['output'];
  type: CandidateTagType;
};

/** The fields on `candidateTag` to look up the row to connect. */
export type CandidateTagCandidateTagsPkeyConnect = {
  candidateId: Scalars['Int']['input'];
  tagId: Scalars['Int']['input'];
  type: CandidateTagType;
};

/** The fields on `candidateTag` to look up the row to delete. */
export type CandidateTagCandidateTagsPkeyDelete = {
  candidateId: Scalars['Int']['input'];
  tagId: Scalars['Int']['input'];
  type: CandidateTagType;
};

/** A condition to be used against `CandidateTag` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type CandidateTagCondition = {
  /** Checks for equality with the object’s `candidateId` field. */
  candidateId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `tagId` field. */
  tagId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `type` field. */
  type?: InputMaybe<CandidateTagType>;
};

/** A filter to be used against `CandidateTag` object types. All fields are combined with a logical ‘and.’ */
export type CandidateTagFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<CandidateTagFilter>>;
  /** Filter by the object’s `candidate` relation. */
  candidate?: InputMaybe<CandidateFilter>;
  /** Filter by the object’s `candidateId` field. */
  candidateId?: InputMaybe<IntFilter>;
  /** Negates the expression. */
  not?: InputMaybe<CandidateTagFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<CandidateTagFilter>>;
  /** Filter by the object’s `tag` relation. */
  tag?: InputMaybe<TagFilter>;
  /** Filter by the object’s `tagId` field. */
  tagId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `type` field. */
  type?: InputMaybe<CandidateTagTypeFilter>;
};

/** An input for mutations affecting `CandidateTag` */
export type CandidateTagInput = {
  candidate?: InputMaybe<CandidateTagsCandidateIdFkeyInput>;
  candidateId?: InputMaybe<Scalars['Int']['input']>;
  tag?: InputMaybe<CandidateTagsTagIdFkeyInput>;
  tagId?: InputMaybe<Scalars['Int']['input']>;
  type: CandidateTagType;
};

/** The globally unique `ID` look up for the row to connect. */
export type CandidateTagNodeIdConnect = {
  /** The globally unique `ID` which identifies a single `candidateTag` to be connected. */
  nodeId: Scalars['ID']['input'];
};

/** The globally unique `ID` look up for the row to delete. */
export type CandidateTagNodeIdDelete = {
  /** The globally unique `ID` which identifies a single `candidateTag` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** The globally unique `ID` look up for the row to update. */
export type CandidateTagOnCandidateTagForCandidateTagsCandidateIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `candidate` to be connected. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `candidate` being updated. */
  patch: CandidatePatch;
};

/** The fields on `candidateTag` to look up the row to update. */
export type CandidateTagOnCandidateTagForCandidateTagsCandidateIdFkeyUsingCandidateTagsPkeyUpdate = {
  candidateId: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `candidateTag` being updated. */
  patch: UpdateCandidateTagOnCandidateTagForCandidateTagsCandidateIdFkeyPatch;
  tagId: Scalars['Int']['input'];
  type: CandidateTagType;
};

/** The globally unique `ID` look up for the row to update. */
export type CandidateTagOnCandidateTagForCandidateTagsTagIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `tag` to be connected. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `tag` being updated. */
  patch: TagPatch;
};

/** The fields on `candidateTag` to look up the row to update. */
export type CandidateTagOnCandidateTagForCandidateTagsTagIdFkeyUsingCandidateTagsPkeyUpdate = {
  candidateId: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `candidateTag` being updated. */
  patch: UpdateCandidateTagOnCandidateTagForCandidateTagsTagIdFkeyPatch;
  tagId: Scalars['Int']['input'];
  type: CandidateTagType;
};

/** Represents an update to a `CandidateTag`. Fields that are set will be updated. */
export type CandidateTagPatch = {
  candidate?: InputMaybe<CandidateTagsCandidateIdFkeyInput>;
  candidateId?: InputMaybe<Scalars['Int']['input']>;
  tag?: InputMaybe<CandidateTagsTagIdFkeyInput>;
  tagId?: InputMaybe<Scalars['Int']['input']>;
  type?: InputMaybe<CandidateTagType>;
};

export enum CandidateTagType {
  Source = 'SOURCE',
  Tag = 'TAG'
}

/** A filter to be used against CandidateTagType fields. All fields are combined with a logical ‘and.’ */
export type CandidateTagTypeFilter = {
  /** Not equal to the specified value, treating null like an ordinary value. */
  distinctFrom?: InputMaybe<CandidateTagType>;
  /** Equal to the specified value. */
  equalTo?: InputMaybe<CandidateTagType>;
  /** Greater than the specified value. */
  greaterThan?: InputMaybe<CandidateTagType>;
  /** Greater than or equal to the specified value. */
  greaterThanOrEqualTo?: InputMaybe<CandidateTagType>;
  /** Included in the specified list. */
  in?: InputMaybe<Array<CandidateTagType>>;
  /** Is null (if `true` is specified) or is not null (if `false` is specified). */
  isNull?: InputMaybe<Scalars['Boolean']['input']>;
  /** Less than the specified value. */
  lessThan?: InputMaybe<CandidateTagType>;
  /** Less than or equal to the specified value. */
  lessThanOrEqualTo?: InputMaybe<CandidateTagType>;
  /** Equal to the specified value, treating null like an ordinary value. */
  notDistinctFrom?: InputMaybe<CandidateTagType>;
  /** Not equal to the specified value. */
  notEqualTo?: InputMaybe<CandidateTagType>;
  /** Not included in the specified list. */
  notIn?: InputMaybe<Array<CandidateTagType>>;
};

/** A connection to a list of `Tag` values, with data from `CandidateTag`. */
export type CandidateTagsByCandidateTagCandidateIdAndTagIdManyToManyConnection = {
  __typename?: 'CandidateTagsByCandidateTagCandidateIdAndTagIdManyToManyConnection';
  /** A list of edges which contains the `Tag`, info from the `CandidateTag`, and the cursor to aid in pagination. */
  edges: Array<CandidateTagsByCandidateTagCandidateIdAndTagIdManyToManyEdge>;
  /** A list of `Tag` objects. */
  nodes: Array<Tag>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Tag` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `Tag` edge in the connection, with data from `CandidateTag`. */
export type CandidateTagsByCandidateTagCandidateIdAndTagIdManyToManyEdge = {
  __typename?: 'CandidateTagsByCandidateTagCandidateIdAndTagIdManyToManyEdge';
  /** Reads and enables pagination through a set of `CandidateTag`. */
  candidateTags: CandidateTagsConnection;
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Tag` at the end of the edge. */
  node: Tag;
};


/** A `Tag` edge in the connection, with data from `CandidateTag`. */
export type CandidateTagsByCandidateTagCandidateIdAndTagIdManyToManyEdgeCandidateTagsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<CandidateTagCondition>;
  filter?: InputMaybe<CandidateTagFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<CandidateTagsOrderBy>>;
};

/** The `candidateTag` to be created by this mutation. */
export type CandidateTagsCandidateIdFkeyCandidateTagsCreateInput = {
  candidate?: InputMaybe<CandidateTagsCandidateIdFkeyInput>;
  tag?: InputMaybe<CandidateTagsTagIdFkeyInput>;
  tagId?: InputMaybe<Scalars['Int']['input']>;
  type: CandidateTagType;
};

/** The `candidate` to be created by this mutation. */
export type CandidateTagsCandidateIdFkeyCandidatesCreateInput = {
  birthday?: InputMaybe<Scalars['Date']['input']>;
  candidateDraftEvaluations?: InputMaybe<DraftEvaluationsCandidateIdFkeyInverseInput>;
  candidateEventDraftEvaluations?: InputMaybe<EventDraftEvaluationsCandidateIdFkeyInverseInput>;
  candidateImportCandidate?: InputMaybe<CandidateImportCandidatesCandidateIdFkeyInverseInput>;
  candidateQuestionnaires?: InputMaybe<CandidateQuestionnairesCandidateIdFkeyInverseInput>;
  candidateQuestions?: InputMaybe<CandidateQuestionsCandidateIdFkeyInverseInput>;
  candidateTags?: InputMaybe<CandidateTagsCandidateIdFkeyInverseInput>;
  cvText?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  emails?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  evaluations?: InputMaybe<EvaluationsCandidateIdFkeyInverseInput>;
  eventCandidates?: InputMaybe<EventCandidatesCandidateIdFkeyInverseInput>;
  files?: InputMaybe<CandidateFilesCandidateIdFkeyInverseInput>;
  gender?: InputMaybe<Gender>;
  jobsApplications?: InputMaybe<JobsApplicationsCandidateIdFkeyInverseInput>;
  language: Language;
  links?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  militaryStatus?: InputMaybe<MilitaryStatus>;
  phones?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  photoExternalId?: InputMaybe<Scalars['UUID']['input']>;
  resumeExternalId?: InputMaybe<Scalars['UUID']['input']>;
  socialLinks?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  sources?: InputMaybe<Array<Scalars['String']['input']>>;
  tags?: InputMaybe<Array<Scalars['String']['input']>>;
  threads?: InputMaybe<ThreadsCandidateIdFkeyInverseInput>;
  translations?: InputMaybe<CandidateTranslationsCandidateIdFkeyInverseInput>;
};

/** Input for the nested mutation of `candidate` in the `CandidateTagInput` mutation. */
export type CandidateTagsCandidateIdFkeyInput = {
  /** The primary key(s) for `candidate` for the far side of the relationship. */
  connectById?: InputMaybe<CandidateCandidatesPkeyConnect>;
  /** The primary key(s) for `candidate` for the far side of the relationship. */
  connectByNodeId?: InputMaybe<CandidateNodeIdConnect>;
  /** A `CandidateInput` object that will be created and connected to this object. */
  create?: InputMaybe<CandidateTagsCandidateIdFkeyCandidatesCreateInput>;
  /** The primary key(s) and patch data for `candidate` for the far side of the relationship. */
  updateById?: InputMaybe<CandidateOnCandidateTagForCandidateTagsCandidateIdFkeyUsingCandidatesPkeyUpdate>;
  /** The primary key(s) and patch data for `candidate` for the far side of the relationship. */
  updateByNodeId?: InputMaybe<CandidateTagOnCandidateTagForCandidateTagsCandidateIdFkeyNodeIdUpdate>;
};

/** Input for the nested mutation of `candidateTag` in the `CandidateInput` mutation. */
export type CandidateTagsCandidateIdFkeyInverseInput = {
  /** The primary key(s) for `candidateTag` for the far side of the relationship. */
  connectByNodeId?: InputMaybe<Array<CandidateTagNodeIdConnect>>;
  /** The primary key(s) for `candidateTag` for the far side of the relationship. */
  connectByTagIdAndCandidateIdAndType?: InputMaybe<Array<CandidateTagCandidateTagsPkeyConnect>>;
  /** A `CandidateTagInput` object that will be created and connected to this object. */
  create?: InputMaybe<Array<CandidateTagsCandidateIdFkeyCandidateTagsCreateInput>>;
  /** The primary key(s) for `candidateTag` for the far side of the relationship. */
  deleteByNodeId?: InputMaybe<Array<CandidateTagNodeIdDelete>>;
  /** The primary key(s) for `candidateTag` for the far side of the relationship. */
  deleteByTagIdAndCandidateIdAndType?: InputMaybe<Array<CandidateTagCandidateTagsPkeyDelete>>;
  /** Flag indicating whether all other `candidateTag` records that match this relationship should be removed. */
  deleteOthers?: InputMaybe<Scalars['Boolean']['input']>;
  /** The primary key(s) and patch data for `candidateTag` for the far side of the relationship. */
  updateByNodeId?: InputMaybe<Array<CandidateOnCandidateTagForCandidateTagsCandidateIdFkeyNodeIdUpdate>>;
  /** The primary key(s) and patch data for `candidateTag` for the far side of the relationship. */
  updateByTagIdAndCandidateIdAndType?: InputMaybe<Array<CandidateTagOnCandidateTagForCandidateTagsCandidateIdFkeyUsingCandidateTagsPkeyUpdate>>;
};

/** A connection to a list of `CandidateTag` values. */
export type CandidateTagsConnection = {
  __typename?: 'CandidateTagsConnection';
  /** A list of edges which contains the `CandidateTag` and cursor to aid in pagination. */
  edges: Array<CandidateTagsEdge>;
  /** A list of `CandidateTag` objects. */
  nodes: Array<CandidateTag>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `CandidateTag` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `CandidateTag` edge in the connection. */
export type CandidateTagsEdge = {
  __typename?: 'CandidateTagsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `CandidateTag` at the end of the edge. */
  node: CandidateTag;
};

/** Methods to use when ordering `CandidateTag`. */
export enum CandidateTagsOrderBy {
  CandidateIdAsc = 'CANDIDATE_ID_ASC',
  CandidateIdDesc = 'CANDIDATE_ID_DESC',
  Natural = 'NATURAL',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  TagIdAsc = 'TAG_ID_ASC',
  TagIdDesc = 'TAG_ID_DESC',
  TypeAsc = 'TYPE_ASC',
  TypeDesc = 'TYPE_DESC'
}

/** The `candidateTag` to be created by this mutation. */
export type CandidateTagsTagIdFkeyCandidateTagsCreateInput = {
  candidate?: InputMaybe<CandidateTagsCandidateIdFkeyInput>;
  candidateId?: InputMaybe<Scalars['Int']['input']>;
  tag?: InputMaybe<CandidateTagsTagIdFkeyInput>;
  type: CandidateTagType;
};

/** Input for the nested mutation of `tag` in the `CandidateTagInput` mutation. */
export type CandidateTagsTagIdFkeyInput = {
  /** The primary key(s) for `tag` for the far side of the relationship. */
  connectById?: InputMaybe<TagTagsPkeyConnect>;
  /** The primary key(s) for `tag` for the far side of the relationship. */
  connectByNodeId?: InputMaybe<TagNodeIdConnect>;
  /** A `TagInput` object that will be created and connected to this object. */
  create?: InputMaybe<CandidateTagsTagIdFkeyTagsCreateInput>;
  /** The primary key(s) and patch data for `tag` for the far side of the relationship. */
  updateById?: InputMaybe<TagOnCandidateTagForCandidateTagsTagIdFkeyUsingTagsPkeyUpdate>;
  /** The primary key(s) and patch data for `tag` for the far side of the relationship. */
  updateByNodeId?: InputMaybe<CandidateTagOnCandidateTagForCandidateTagsTagIdFkeyNodeIdUpdate>;
};

/** Input for the nested mutation of `candidateTag` in the `TagInput` mutation. */
export type CandidateTagsTagIdFkeyInverseInput = {
  /** The primary key(s) for `candidateTag` for the far side of the relationship. */
  connectByNodeId?: InputMaybe<Array<CandidateTagNodeIdConnect>>;
  /** The primary key(s) for `candidateTag` for the far side of the relationship. */
  connectByTagIdAndCandidateIdAndType?: InputMaybe<Array<CandidateTagCandidateTagsPkeyConnect>>;
  /** A `CandidateTagInput` object that will be created and connected to this object. */
  create?: InputMaybe<Array<CandidateTagsTagIdFkeyCandidateTagsCreateInput>>;
  /** The primary key(s) for `candidateTag` for the far side of the relationship. */
  deleteByNodeId?: InputMaybe<Array<CandidateTagNodeIdDelete>>;
  /** The primary key(s) for `candidateTag` for the far side of the relationship. */
  deleteByTagIdAndCandidateIdAndType?: InputMaybe<Array<CandidateTagCandidateTagsPkeyDelete>>;
  /** Flag indicating whether all other `candidateTag` records that match this relationship should be removed. */
  deleteOthers?: InputMaybe<Scalars['Boolean']['input']>;
  /** The primary key(s) and patch data for `candidateTag` for the far side of the relationship. */
  updateByNodeId?: InputMaybe<Array<TagOnCandidateTagForCandidateTagsTagIdFkeyNodeIdUpdate>>;
  /** The primary key(s) and patch data for `candidateTag` for the far side of the relationship. */
  updateByTagIdAndCandidateIdAndType?: InputMaybe<Array<CandidateTagOnCandidateTagForCandidateTagsTagIdFkeyUsingCandidateTagsPkeyUpdate>>;
};

/** The `tag` to be created by this mutation. */
export type CandidateTagsTagIdFkeyTagsCreateInput = {
  candidateTags?: InputMaybe<CandidateTagsTagIdFkeyInverseInput>;
  jobTags?: InputMaybe<JobTagsTagIdFkeyInverseInput>;
  title: Scalars['String']['input'];
};

/** A filter to be used against many `CandidateFile` object types. All fields are combined with a logical ‘and.’ */
export type CandidateToManyCandidateFileFilter = {
  /** Every related `CandidateFile` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<CandidateFileFilter>;
  /** No related `CandidateFile` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<CandidateFileFilter>;
  /** Some related `CandidateFile` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<CandidateFileFilter>;
};

/** A filter to be used against many `CandidateQuestion` object types. All fields are combined with a logical ‘and.’ */
export type CandidateToManyCandidateQuestionFilter = {
  /** Every related `CandidateQuestion` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<CandidateQuestionFilter>;
  /** No related `CandidateQuestion` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<CandidateQuestionFilter>;
  /** Some related `CandidateQuestion` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<CandidateQuestionFilter>;
};

/** A filter to be used against many `CandidateQuestionnaire` object types. All fields are combined with a logical ‘and.’ */
export type CandidateToManyCandidateQuestionnaireFilter = {
  /** Every related `CandidateQuestionnaire` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<CandidateQuestionnaireFilter>;
  /** No related `CandidateQuestionnaire` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<CandidateQuestionnaireFilter>;
  /** Some related `CandidateQuestionnaire` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<CandidateQuestionnaireFilter>;
};

/** A filter to be used against many `CandidateTag` object types. All fields are combined with a logical ‘and.’ */
export type CandidateToManyCandidateTagFilter = {
  /** Every related `CandidateTag` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<CandidateTagFilter>;
  /** No related `CandidateTag` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<CandidateTagFilter>;
  /** Some related `CandidateTag` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<CandidateTagFilter>;
};

/** A filter to be used against many `CandidateTranslation` object types. All fields are combined with a logical ‘and.’ */
export type CandidateToManyCandidateTranslationFilter = {
  /** Every related `CandidateTranslation` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<CandidateTranslationFilter>;
  /** No related `CandidateTranslation` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<CandidateTranslationFilter>;
  /** Some related `CandidateTranslation` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<CandidateTranslationFilter>;
};

/** A filter to be used against many `DraftEvaluation` object types. All fields are combined with a logical ‘and.’ */
export type CandidateToManyDraftEvaluationFilter = {
  /** Every related `DraftEvaluation` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<DraftEvaluationFilter>;
  /** No related `DraftEvaluation` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<DraftEvaluationFilter>;
  /** Some related `DraftEvaluation` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<DraftEvaluationFilter>;
};

/** A filter to be used against many `Evaluation` object types. All fields are combined with a logical ‘and.’ */
export type CandidateToManyEvaluationFilter = {
  /** Every related `Evaluation` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<EvaluationFilter>;
  /** No related `Evaluation` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<EvaluationFilter>;
  /** Some related `Evaluation` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<EvaluationFilter>;
};

/** A filter to be used against many `EventCandidate` object types. All fields are combined with a logical ‘and.’ */
export type CandidateToManyEventCandidateFilter = {
  /** Every related `EventCandidate` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<EventCandidateFilter>;
  /** No related `EventCandidate` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<EventCandidateFilter>;
  /** Some related `EventCandidate` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<EventCandidateFilter>;
};

/** A filter to be used against many `EventDraftEvaluation` object types. All fields are combined with a logical ‘and.’ */
export type CandidateToManyEventDraftEvaluationFilter = {
  /** Every related `EventDraftEvaluation` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<EventDraftEvaluationFilter>;
  /** No related `EventDraftEvaluation` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<EventDraftEvaluationFilter>;
  /** Some related `EventDraftEvaluation` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<EventDraftEvaluationFilter>;
};

/** A filter to be used against many `JobsApplication` object types. All fields are combined with a logical ‘and.’ */
export type CandidateToManyJobsApplicationFilter = {
  /** Every related `JobsApplication` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<JobsApplicationFilter>;
  /** No related `JobsApplication` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<JobsApplicationFilter>;
  /** Some related `JobsApplication` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<JobsApplicationFilter>;
};

/** A filter to be used against many `Thread` object types. All fields are combined with a logical ‘and.’ */
export type CandidateToManyThreadFilter = {
  /** Every related `Thread` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<ThreadFilter>;
  /** No related `Thread` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<ThreadFilter>;
  /** Some related `Thread` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<ThreadFilter>;
};

export type CandidateTranslation = Node & {
  __typename?: 'CandidateTranslation';
  /** Reads a single `Candidate` that is related to this `CandidateTranslation`. */
  candidate?: Maybe<Candidate>;
  candidateId: Scalars['Int']['output'];
  lang: Language;
  name: Scalars['String']['output'];
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
};

/** The fields on `candidateTranslation` to look up the row to connect. */
export type CandidateTranslationCandidateTranslationsPkeyConnect = {
  candidateId: Scalars['Int']['input'];
  lang: Language;
};

/** The fields on `candidateTranslation` to look up the row to delete. */
export type CandidateTranslationCandidateTranslationsPkeyDelete = {
  candidateId: Scalars['Int']['input'];
  lang: Language;
};

/** A condition to be used against `CandidateTranslation` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type CandidateTranslationCondition = {
  /** Checks for equality with the object’s `candidateId` field. */
  candidateId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `name` field. */
  name?: InputMaybe<Scalars['String']['input']>;
};

/** A filter to be used against `CandidateTranslation` object types. All fields are combined with a logical ‘and.’ */
export type CandidateTranslationFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<CandidateTranslationFilter>>;
  /** Filter by the object’s `candidate` relation. */
  candidate?: InputMaybe<CandidateFilter>;
  /** Filter by the object’s `candidateId` field. */
  candidateId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `name` field. */
  name?: InputMaybe<StringFilter>;
  /** Negates the expression. */
  not?: InputMaybe<CandidateTranslationFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<CandidateTranslationFilter>>;
};

/** An input for mutations affecting `CandidateTranslation` */
export type CandidateTranslationInput = {
  candidate?: InputMaybe<CandidateTranslationsCandidateIdFkeyInput>;
  candidateId?: InputMaybe<Scalars['Int']['input']>;
  lang: Language;
  name: Scalars['String']['input'];
};

/** The globally unique `ID` look up for the row to connect. */
export type CandidateTranslationNodeIdConnect = {
  /** The globally unique `ID` which identifies a single `candidateTranslation` to be connected. */
  nodeId: Scalars['ID']['input'];
};

/** The globally unique `ID` look up for the row to delete. */
export type CandidateTranslationNodeIdDelete = {
  /** The globally unique `ID` which identifies a single `candidateTranslation` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** The globally unique `ID` look up for the row to update. */
export type CandidateTranslationOnCandidateTranslationForCandidateTranslationsCandidateIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `candidate` to be connected. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `candidate` being updated. */
  patch: CandidatePatch;
};

/** The fields on `candidateTranslation` to look up the row to update. */
export type CandidateTranslationOnCandidateTranslationForCandidateTranslationsCandidateIdFkeyUsingCandidateTranslationsPkeyUpdate = {
  candidateId: Scalars['Int']['input'];
  lang: Language;
  /** An object where the defined keys will be set on the `candidateTranslation` being updated. */
  patch: UpdateCandidateTranslationOnCandidateTranslationForCandidateTranslationsCandidateIdFkeyPatch;
};

/** Represents an update to a `CandidateTranslation`. Fields that are set will be updated. */
export type CandidateTranslationPatch = {
  candidate?: InputMaybe<CandidateTranslationsCandidateIdFkeyInput>;
  candidateId?: InputMaybe<Scalars['Int']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
};

/** The `candidateTranslation` to be created by this mutation. */
export type CandidateTranslationsCandidateIdFkeyCandidateTranslationsCreateInput = {
  candidate?: InputMaybe<CandidateTranslationsCandidateIdFkeyInput>;
  lang: Language;
  name: Scalars['String']['input'];
};

/** The `candidate` to be created by this mutation. */
export type CandidateTranslationsCandidateIdFkeyCandidatesCreateInput = {
  birthday?: InputMaybe<Scalars['Date']['input']>;
  candidateDraftEvaluations?: InputMaybe<DraftEvaluationsCandidateIdFkeyInverseInput>;
  candidateEventDraftEvaluations?: InputMaybe<EventDraftEvaluationsCandidateIdFkeyInverseInput>;
  candidateImportCandidate?: InputMaybe<CandidateImportCandidatesCandidateIdFkeyInverseInput>;
  candidateQuestionnaires?: InputMaybe<CandidateQuestionnairesCandidateIdFkeyInverseInput>;
  candidateQuestions?: InputMaybe<CandidateQuestionsCandidateIdFkeyInverseInput>;
  candidateTags?: InputMaybe<CandidateTagsCandidateIdFkeyInverseInput>;
  cvText?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  emails?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  evaluations?: InputMaybe<EvaluationsCandidateIdFkeyInverseInput>;
  eventCandidates?: InputMaybe<EventCandidatesCandidateIdFkeyInverseInput>;
  files?: InputMaybe<CandidateFilesCandidateIdFkeyInverseInput>;
  gender?: InputMaybe<Gender>;
  jobsApplications?: InputMaybe<JobsApplicationsCandidateIdFkeyInverseInput>;
  language: Language;
  links?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  militaryStatus?: InputMaybe<MilitaryStatus>;
  phones?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  photoExternalId?: InputMaybe<Scalars['UUID']['input']>;
  resumeExternalId?: InputMaybe<Scalars['UUID']['input']>;
  socialLinks?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  sources?: InputMaybe<Array<Scalars['String']['input']>>;
  tags?: InputMaybe<Array<Scalars['String']['input']>>;
  threads?: InputMaybe<ThreadsCandidateIdFkeyInverseInput>;
  translations?: InputMaybe<CandidateTranslationsCandidateIdFkeyInverseInput>;
};

/** Input for the nested mutation of `candidate` in the `CandidateTranslationInput` mutation. */
export type CandidateTranslationsCandidateIdFkeyInput = {
  /** The primary key(s) for `candidate` for the far side of the relationship. */
  connectById?: InputMaybe<CandidateCandidatesPkeyConnect>;
  /** The primary key(s) for `candidate` for the far side of the relationship. */
  connectByNodeId?: InputMaybe<CandidateNodeIdConnect>;
  /** A `CandidateInput` object that will be created and connected to this object. */
  create?: InputMaybe<CandidateTranslationsCandidateIdFkeyCandidatesCreateInput>;
  /** The primary key(s) and patch data for `candidate` for the far side of the relationship. */
  updateById?: InputMaybe<CandidateOnCandidateTranslationForCandidateTranslationsCandidateIdFkeyUsingCandidatesPkeyUpdate>;
  /** The primary key(s) and patch data for `candidate` for the far side of the relationship. */
  updateByNodeId?: InputMaybe<CandidateTranslationOnCandidateTranslationForCandidateTranslationsCandidateIdFkeyNodeIdUpdate>;
};

/** Input for the nested mutation of `candidateTranslation` in the `CandidateInput` mutation. */
export type CandidateTranslationsCandidateIdFkeyInverseInput = {
  /** The primary key(s) for `candidateTranslation` for the far side of the relationship. */
  connectByCandidateIdAndLang?: InputMaybe<Array<CandidateTranslationCandidateTranslationsPkeyConnect>>;
  /** The primary key(s) for `candidateTranslation` for the far side of the relationship. */
  connectByNodeId?: InputMaybe<Array<CandidateTranslationNodeIdConnect>>;
  /** A `CandidateTranslationInput` object that will be created and connected to this object. */
  create?: InputMaybe<Array<CandidateTranslationsCandidateIdFkeyCandidateTranslationsCreateInput>>;
  /** The primary key(s) for `candidateTranslation` for the far side of the relationship. */
  deleteByCandidateIdAndLang?: InputMaybe<Array<CandidateTranslationCandidateTranslationsPkeyDelete>>;
  /** The primary key(s) for `candidateTranslation` for the far side of the relationship. */
  deleteByNodeId?: InputMaybe<Array<CandidateTranslationNodeIdDelete>>;
  /** Flag indicating whether all other `candidateTranslation` records that match this relationship should be removed. */
  deleteOthers?: InputMaybe<Scalars['Boolean']['input']>;
  /** The primary key(s) and patch data for `candidateTranslation` for the far side of the relationship. */
  updateByCandidateIdAndLang?: InputMaybe<Array<CandidateTranslationOnCandidateTranslationForCandidateTranslationsCandidateIdFkeyUsingCandidateTranslationsPkeyUpdate>>;
  /** The primary key(s) and patch data for `candidateTranslation` for the far side of the relationship. */
  updateByNodeId?: InputMaybe<Array<CandidateOnCandidateTranslationForCandidateTranslationsCandidateIdFkeyNodeIdUpdate>>;
};

/** A connection to a list of `CandidateTranslation` values. */
export type CandidateTranslationsConnection = {
  __typename?: 'CandidateTranslationsConnection';
  /** A list of edges which contains the `CandidateTranslation` and cursor to aid in pagination. */
  edges: Array<CandidateTranslationsEdge>;
  /** A list of `CandidateTranslation` objects. */
  nodes: Array<CandidateTranslation>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `CandidateTranslation` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `CandidateTranslation` edge in the connection. */
export type CandidateTranslationsEdge = {
  __typename?: 'CandidateTranslationsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `CandidateTranslation` at the end of the edge. */
  node: CandidateTranslation;
};

/** Methods to use when ordering `CandidateTranslation`. */
export enum CandidateTranslationsOrderBy {
  CandidateIdAsc = 'CANDIDATE_ID_ASC',
  CandidateIdDesc = 'CANDIDATE_ID_DESC',
  NameAsc = 'NAME_ASC',
  NameDesc = 'NAME_DESC',
  Natural = 'NATURAL',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC'
}

/** A connection to a list of `User` values, with data from `Thread`. */
export type CandidateUsersByThreadCandidateIdAndUserIdManyToManyConnection = {
  __typename?: 'CandidateUsersByThreadCandidateIdAndUserIdManyToManyConnection';
  /** A list of edges which contains the `User`, info from the `Thread`, and the cursor to aid in pagination. */
  edges: Array<CandidateUsersByThreadCandidateIdAndUserIdManyToManyEdge>;
  /** A list of `User` objects. */
  nodes: Array<User>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `User` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `User` edge in the connection, with data from `Thread`. */
export type CandidateUsersByThreadCandidateIdAndUserIdManyToManyEdge = {
  __typename?: 'CandidateUsersByThreadCandidateIdAndUserIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `User` at the end of the edge. */
  node: User;
  /** Reads and enables pagination through a set of `Thread`. */
  threads: ThreadsConnection;
};


/** A `User` edge in the connection, with data from `Thread`. */
export type CandidateUsersByThreadCandidateIdAndUserIdManyToManyEdgeThreadsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<ThreadCondition>;
  filter?: InputMaybe<ThreadFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<ThreadsOrderBy>>;
};

/** A connection to a list of `Candidate` values. */
export type CandidatesConnection = {
  __typename?: 'CandidatesConnection';
  /** A list of edges which contains the `Candidate` and cursor to aid in pagination. */
  edges: Array<CandidatesEdge>;
  /** A list of `Candidate` objects. */
  nodes: Array<Candidate>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Candidate` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `Candidate` edge in the connection. */
export type CandidatesEdge = {
  __typename?: 'CandidatesEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Candidate` at the end of the edge. */
  node: Candidate;
};

/** Methods to use when ordering `Candidate`. */
export enum CandidatesOrderBy {
  CreatedAtAsc = 'CREATED_AT_ASC',
  CreatedAtDesc = 'CREATED_AT_DESC',
  EmailsAsc = 'EMAILS_ASC',
  EmailsDesc = 'EMAILS_DESC',
  ExtractedTextAsc = 'EXTRACTED_TEXT_ASC',
  ExtractedTextDesc = 'EXTRACTED_TEXT_DESC',
  GenderAsc = 'GENDER_ASC',
  GenderDesc = 'GENDER_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  MilitaryStatusAsc = 'MILITARY_STATUS_ASC',
  MilitaryStatusDesc = 'MILITARY_STATUS_DESC',
  Natural = 'NATURAL',
  PhonesAsc = 'PHONES_ASC',
  PhonesDesc = 'PHONES_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  UpdatedAtAsc = 'UPDATED_AT_ASC',
  UpdatedAtDesc = 'UPDATED_AT_DESC'
}

export type CandidatesPerDepartment = {
  __typename?: 'CandidatesPerDepartment';
  count: Scalars['Int']['output'];
  departmentId?: Maybe<Scalars['Int']['output']>;
};

export type CandidatesPerPipelineStage = {
  __typename?: 'CandidatesPerPipelineStage';
  count: Scalars['Int']['output'];
  type: PipelineStageType;
};

export type CompaniesByTagIdsAndJobSearchInput = {
  genders?: InputMaybe<Array<InputMaybe<Gender>>>;
  jobSearch?: InputMaybe<Scalars['String']['input']>;
  tagTitles?: InputMaybe<Array<Scalars['String']['input']>>;
};

export type CompaniesByTagIdsAndJobSearchPayload = {
  __typename?: 'CompaniesByTagIdsAndJobSearchPayload';
  companies: CustomCompaniesConnection;
};

/** A connection to a list of `Company` values. */
export type CompaniesConnection = {
  __typename?: 'CompaniesConnection';
  /** A list of edges which contains the `Company` and cursor to aid in pagination. */
  edges: Array<CompaniesEdge>;
  /** A list of `Company` objects. */
  nodes: Array<Company>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Company` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `Company` edge in the connection. */
export type CompaniesEdge = {
  __typename?: 'CompaniesEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Company` at the end of the edge. */
  node: Company;
};

/** Methods to use when ordering `Company`. */
export enum CompaniesOrderBy {
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  Natural = 'NATURAL',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  SlugAsc = 'SLUG_ASC',
  SlugDesc = 'SLUG_DESC'
}

export type Company = Node & {
  __typename?: 'Company';
  activeInvoice?: Maybe<Invoice>;
  category: CompanyCategory;
  companySize: CompanySize;
  createdAt: Scalars['Datetime']['output'];
  customWebsiteHost?: Maybe<Scalars['String']['output']>;
  /** Reads and enables pagination through a set of `DraftEvaluation`. */
  draftEvaluations: DraftEvaluationsConnection;
  /** Reads and enables pagination through a set of `EventDraftEvaluation`. */
  eventDraftEvaluations: EventDraftEvaluationsConnection;
  /** Reads and enables pagination through a set of `Event`. */
  events: CompanyEventsByEventDraftEvaluationCompanyIdAndEventIdManyToManyConnection;
  id: Scalars['Int']['output'];
  /** Reads and enables pagination through a set of `Invoice`. */
  invoices: InvoicesConnection;
  /** Reads and enables pagination through a set of `Job`. */
  jobs: CompanyJobsByDraftEvaluationCompanyIdAndJobIdManyToManyConnection;
  languages: Array<Maybe<Language>>;
  logoUrl?: Maybe<Scalars['String']['output']>;
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  slug: Scalars['String']['output'];
  /** Reads and enables pagination through a set of `Subscription`. */
  subscriptions: CompanySubscriptionsByInvoiceCompanyIdAndSubscriptionIdManyToManyConnection;
  /** Reads and enables pagination through a set of `CompanyTranslation`. */
  translations: CompanyTranslationsConnection;
  updatedAt: Scalars['Datetime']['output'];
  websiteUrl?: Maybe<Scalars['String']['output']>;
};


export type CompanyDraftEvaluationsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<DraftEvaluationCondition>;
  filter?: InputMaybe<DraftEvaluationFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<DraftEvaluationsOrderBy>>;
};


export type CompanyEventDraftEvaluationsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<EventDraftEvaluationCondition>;
  filter?: InputMaybe<EventDraftEvaluationFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<EventDraftEvaluationsOrderBy>>;
};


export type CompanyEventsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<EventCondition>;
  filter?: InputMaybe<EventFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<EventsOrderBy>>;
};


export type CompanyInvoicesArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<InvoiceCondition>;
  filter?: InputMaybe<InvoiceFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<InvoicesOrderBy>>;
};


export type CompanyJobsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<JobCondition>;
  filter?: InputMaybe<JobFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<JobsOrderBy>>;
};


export type CompanySubscriptionsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<SubscriptionCondition>;
  filter?: InputMaybe<SubscriptionFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<SubscriptionsOrderBy>>;
};


export type CompanyTranslationsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<CompanyTranslationCondition>;
  filter?: InputMaybe<CompanyTranslationFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<CompanyTranslationsOrderBy>>;
};

export enum CompanyCategory {
  Educational = 'EDUCATIONAL',
  IndustrialAndTechnical = 'INDUSTRIAL_AND_TECHNICAL',
  Other = 'OTHER',
  Producer = 'PRODUCER',
  Reseller = 'RESELLER',
  Retailer = 'RETAILER',
  SalesRepresentative = 'SALES_REPRESENTATIVE',
  Services = 'SERVICES'
}

/** The fields on `company` to look up the row to connect. */
export type CompanyCompaniesPkeyConnect = {
  id: Scalars['Int']['input'];
};

/** The fields on `company` to look up the row to connect. */
export type CompanyCompaniesSlugKeyConnect = {
  slug: Scalars['String']['input'];
};

/** A condition to be used against `Company` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type CompanyCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `slug` field. */
  slug?: InputMaybe<Scalars['String']['input']>;
};

/** A connection to a list of `Event` values, with data from `EventDraftEvaluation`. */
export type CompanyEventsByEventDraftEvaluationCompanyIdAndEventIdManyToManyConnection = {
  __typename?: 'CompanyEventsByEventDraftEvaluationCompanyIdAndEventIdManyToManyConnection';
  /** A list of edges which contains the `Event`, info from the `EventDraftEvaluation`, and the cursor to aid in pagination. */
  edges: Array<CompanyEventsByEventDraftEvaluationCompanyIdAndEventIdManyToManyEdge>;
  /** A list of `Event` objects. */
  nodes: Array<Event>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Event` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `Event` edge in the connection, with data from `EventDraftEvaluation`. */
export type CompanyEventsByEventDraftEvaluationCompanyIdAndEventIdManyToManyEdge = {
  __typename?: 'CompanyEventsByEventDraftEvaluationCompanyIdAndEventIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** Reads and enables pagination through a set of `EventDraftEvaluation`. */
  eventDraftEvaluations: EventDraftEvaluationsConnection;
  /** The `Event` at the end of the edge. */
  node: Event;
};


/** A `Event` edge in the connection, with data from `EventDraftEvaluation`. */
export type CompanyEventsByEventDraftEvaluationCompanyIdAndEventIdManyToManyEdgeEventDraftEvaluationsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<EventDraftEvaluationCondition>;
  filter?: InputMaybe<EventDraftEvaluationFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<EventDraftEvaluationsOrderBy>>;
};

/** A filter to be used against `Company` object types. All fields are combined with a logical ‘and.’ */
export type CompanyFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<CompanyFilter>>;
  /** Filter by the object’s `customWebsiteHost` field. */
  customWebsiteHost?: InputMaybe<StringFilter>;
  /** Filter by the object’s `draftEvaluations` relation. */
  draftEvaluations?: InputMaybe<CompanyToManyDraftEvaluationFilter>;
  /** Some related `draftEvaluations` exist. */
  draftEvaluationsExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `eventDraftEvaluations` relation. */
  eventDraftEvaluations?: InputMaybe<CompanyToManyEventDraftEvaluationFilter>;
  /** Some related `eventDraftEvaluations` exist. */
  eventDraftEvaluationsExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<IntFilter>;
  /** Filter by the object’s `invoices` relation. */
  invoices?: InputMaybe<CompanyToManyInvoiceFilter>;
  /** Some related `invoices` exist. */
  invoicesExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Negates the expression. */
  not?: InputMaybe<CompanyFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<CompanyFilter>>;
  /** Filter by the object’s `slug` field. */
  slug?: InputMaybe<StringFilter>;
  /** Filter by the object’s `translations` relation. */
  translations?: InputMaybe<CompanyToManyCompanyTranslationFilter>;
  /** Some related `translations` exist. */
  translationsExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `websiteUrl` field. */
  websiteUrl?: InputMaybe<StringFilter>;
};

/** A connection to a list of `Job` values, with data from `DraftEvaluation`. */
export type CompanyJobsByDraftEvaluationCompanyIdAndJobIdManyToManyConnection = {
  __typename?: 'CompanyJobsByDraftEvaluationCompanyIdAndJobIdManyToManyConnection';
  /** A list of edges which contains the `Job`, info from the `DraftEvaluation`, and the cursor to aid in pagination. */
  edges: Array<CompanyJobsByDraftEvaluationCompanyIdAndJobIdManyToManyEdge>;
  /** A list of `Job` objects. */
  nodes: Array<Job>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Job` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `Job` edge in the connection, with data from `DraftEvaluation`. */
export type CompanyJobsByDraftEvaluationCompanyIdAndJobIdManyToManyEdge = {
  __typename?: 'CompanyJobsByDraftEvaluationCompanyIdAndJobIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** Reads and enables pagination through a set of `DraftEvaluation`. */
  draftEvaluations: DraftEvaluationsConnection;
  /** The `Job` at the end of the edge. */
  node: Job;
};


/** A `Job` edge in the connection, with data from `DraftEvaluation`. */
export type CompanyJobsByDraftEvaluationCompanyIdAndJobIdManyToManyEdgeDraftEvaluationsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<DraftEvaluationCondition>;
  filter?: InputMaybe<DraftEvaluationFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<DraftEvaluationsOrderBy>>;
};

/** The globally unique `ID` look up for the row to connect. */
export type CompanyNodeIdConnect = {
  /** The globally unique `ID` which identifies a single `company` to be connected. */
  nodeId: Scalars['ID']['input'];
};

/** The globally unique `ID` look up for the row to update. */
export type CompanyOnCompanyTranslationForCompanyTranslationsCompanyIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `companyTranslation` to be connected. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `companyTranslation` being updated. */
  patch: CompanyTranslationPatch;
};

/** The fields on `company` to look up the row to update. */
export type CompanyOnCompanyTranslationForCompanyTranslationsCompanyIdFkeyUsingCompaniesPkeyUpdate = {
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `company` being updated. */
  patch: UpdateCompanyOnCompanyTranslationForCompanyTranslationsCompanyIdFkeyPatch;
};

/** The fields on `company` to look up the row to update. */
export type CompanyOnCompanyTranslationForCompanyTranslationsCompanyIdFkeyUsingCompaniesSlugKeyUpdate = {
  /** An object where the defined keys will be set on the `company` being updated. */
  patch: UpdateCompanyOnCompanyTranslationForCompanyTranslationsCompanyIdFkeyPatch;
  slug: Scalars['String']['input'];
};

/** The globally unique `ID` look up for the row to update. */
export type CompanyOnDraftEvaluationForDraftEvaluationsCompanyIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `draftEvaluation` to be connected. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `draftEvaluation` being updated. */
  patch: DraftEvaluationPatch;
};

/** The fields on `company` to look up the row to update. */
export type CompanyOnDraftEvaluationForDraftEvaluationsCompanyIdFkeyUsingCompaniesPkeyUpdate = {
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `company` being updated. */
  patch: UpdateCompanyOnDraftEvaluationForDraftEvaluationsCompanyIdFkeyPatch;
};

/** The fields on `company` to look up the row to update. */
export type CompanyOnDraftEvaluationForDraftEvaluationsCompanyIdFkeyUsingCompaniesSlugKeyUpdate = {
  /** An object where the defined keys will be set on the `company` being updated. */
  patch: UpdateCompanyOnDraftEvaluationForDraftEvaluationsCompanyIdFkeyPatch;
  slug: Scalars['String']['input'];
};

/** The globally unique `ID` look up for the row to update. */
export type CompanyOnEventDraftEvaluationForEventDraftEvaluationsCompanyIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `eventDraftEvaluation` to be connected. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `eventDraftEvaluation` being updated. */
  patch: EventDraftEvaluationPatch;
};

/** The fields on `company` to look up the row to update. */
export type CompanyOnEventDraftEvaluationForEventDraftEvaluationsCompanyIdFkeyUsingCompaniesPkeyUpdate = {
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `company` being updated. */
  patch: UpdateCompanyOnEventDraftEvaluationForEventDraftEvaluationsCompanyIdFkeyPatch;
};

/** The fields on `company` to look up the row to update. */
export type CompanyOnEventDraftEvaluationForEventDraftEvaluationsCompanyIdFkeyUsingCompaniesSlugKeyUpdate = {
  /** An object where the defined keys will be set on the `company` being updated. */
  patch: UpdateCompanyOnEventDraftEvaluationForEventDraftEvaluationsCompanyIdFkeyPatch;
  slug: Scalars['String']['input'];
};

/** The globally unique `ID` look up for the row to update. */
export type CompanyOnInvoiceForInvoicesCompanyIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `invoice` to be connected. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `invoice` being updated. */
  patch: InvoicePatch;
};

/** The fields on `company` to look up the row to update. */
export type CompanyOnInvoiceForInvoicesCompanyIdFkeyUsingCompaniesPkeyUpdate = {
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `company` being updated. */
  patch: UpdateCompanyOnInvoiceForInvoicesCompanyIdFkeyPatch;
};

/** The fields on `company` to look up the row to update. */
export type CompanyOnInvoiceForInvoicesCompanyIdFkeyUsingCompaniesSlugKeyUpdate = {
  /** An object where the defined keys will be set on the `company` being updated. */
  patch: UpdateCompanyOnInvoiceForInvoicesCompanyIdFkeyPatch;
  slug: Scalars['String']['input'];
};

/** Represents an update to a `Company`. Fields that are set will be updated. */
export type CompanyPatch = {
  category?: InputMaybe<CompanyCategory>;
  companySize?: InputMaybe<CompanySize>;
  createdAt?: InputMaybe<Scalars['Datetime']['input']>;
  draftEvaluations?: InputMaybe<DraftEvaluationsCompanyIdFkeyInverseInput>;
  eventDraftEvaluations?: InputMaybe<EventDraftEvaluationsCompanyIdFkeyInverseInput>;
  id?: InputMaybe<Scalars['Int']['input']>;
  invoices?: InputMaybe<InvoicesCompanyIdFkeyInverseInput>;
  languages?: InputMaybe<Array<InputMaybe<Language>>>;
  slug?: InputMaybe<Scalars['String']['input']>;
  translations?: InputMaybe<CompanyTranslationsCompanyIdFkeyInverseInput>;
  updatedAt?: InputMaybe<Scalars['Datetime']['input']>;
};

/** An input for mutations affecting `CompanyPatchRecord` */
export type CompanyPatchRecordInput = {
  category?: InputMaybe<CompanyCategory>;
  companySize?: InputMaybe<CompanySize>;
  customWebsiteHost?: InputMaybe<Scalars['String']['input']>;
  languages?: InputMaybe<Array<InputMaybe<Language>>>;
  logoExternalId?: InputMaybe<Scalars['UUID']['input']>;
  translations?: InputMaybe<Array<InputMaybe<CompanyTranslationInput>>>;
};

export enum CompanySize {
  MoreThan_200 = 'MORE_THAN_200',
  '1To_10' = '_1_TO_10',
  '11To_50' = '_11_TO_50',
  '51To_200' = '_51_TO_200'
}

/** A connection to a list of `Subscription` values, with data from `Invoice`. */
export type CompanySubscriptionsByInvoiceCompanyIdAndSubscriptionIdManyToManyConnection = {
  __typename?: 'CompanySubscriptionsByInvoiceCompanyIdAndSubscriptionIdManyToManyConnection';
  /** A list of edges which contains the `Subscription`, info from the `Invoice`, and the cursor to aid in pagination. */
  edges: Array<CompanySubscriptionsByInvoiceCompanyIdAndSubscriptionIdManyToManyEdge>;
  /** A list of `Subscription` objects. */
  nodes: Array<Subscription>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Subscription` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `Subscription` edge in the connection, with data from `Invoice`. */
export type CompanySubscriptionsByInvoiceCompanyIdAndSubscriptionIdManyToManyEdge = {
  __typename?: 'CompanySubscriptionsByInvoiceCompanyIdAndSubscriptionIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** Reads and enables pagination through a set of `Invoice`. */
  invoices: InvoicesConnection;
  /** The `Subscription` at the end of the edge. */
  node: Subscription;
};


/** A `Subscription` edge in the connection, with data from `Invoice`. */
export type CompanySubscriptionsByInvoiceCompanyIdAndSubscriptionIdManyToManyEdgeInvoicesArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<InvoiceCondition>;
  filter?: InputMaybe<InvoiceFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<InvoicesOrderBy>>;
};

/** A filter to be used against many `CompanyTranslation` object types. All fields are combined with a logical ‘and.’ */
export type CompanyToManyCompanyTranslationFilter = {
  /** Every related `CompanyTranslation` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<CompanyTranslationFilter>;
  /** No related `CompanyTranslation` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<CompanyTranslationFilter>;
  /** Some related `CompanyTranslation` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<CompanyTranslationFilter>;
};

/** A filter to be used against many `DraftEvaluation` object types. All fields are combined with a logical ‘and.’ */
export type CompanyToManyDraftEvaluationFilter = {
  /** Every related `DraftEvaluation` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<DraftEvaluationFilter>;
  /** No related `DraftEvaluation` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<DraftEvaluationFilter>;
  /** Some related `DraftEvaluation` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<DraftEvaluationFilter>;
};

/** A filter to be used against many `EventDraftEvaluation` object types. All fields are combined with a logical ‘and.’ */
export type CompanyToManyEventDraftEvaluationFilter = {
  /** Every related `EventDraftEvaluation` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<EventDraftEvaluationFilter>;
  /** No related `EventDraftEvaluation` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<EventDraftEvaluationFilter>;
  /** Some related `EventDraftEvaluation` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<EventDraftEvaluationFilter>;
};

/** A filter to be used against many `Invoice` object types. All fields are combined with a logical ‘and.’ */
export type CompanyToManyInvoiceFilter = {
  /** Every related `Invoice` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<InvoiceFilter>;
  /** No related `Invoice` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<InvoiceFilter>;
  /** Some related `Invoice` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<InvoiceFilter>;
};

export type CompanyTranslation = Node & {
  __typename?: 'CompanyTranslation';
  /** Reads a single `Company` that is related to this `CompanyTranslation`. */
  company?: Maybe<Company>;
  companyId: Scalars['Int']['output'];
  lang: Language;
  name: Scalars['String']['output'];
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
};

/** The fields on `companyTranslation` to look up the row to connect. */
export type CompanyTranslationCompanyTranslationsPkeyConnect = {
  companyId: Scalars['Int']['input'];
  lang: Language;
};

/** A condition to be used against `CompanyTranslation` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type CompanyTranslationCondition = {
  /** Checks for equality with the object’s `name` field. */
  name?: InputMaybe<Scalars['String']['input']>;
};

/** A filter to be used against `CompanyTranslation` object types. All fields are combined with a logical ‘and.’ */
export type CompanyTranslationFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<CompanyTranslationFilter>>;
  /** Filter by the object’s `company` relation. */
  company?: InputMaybe<CompanyFilter>;
  /** Filter by the object’s `name` field. */
  name?: InputMaybe<StringFilter>;
  /** Negates the expression. */
  not?: InputMaybe<CompanyTranslationFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<CompanyTranslationFilter>>;
};

/** An input for mutations affecting `CompanyTranslation` */
export type CompanyTranslationInput = {
  company?: InputMaybe<CompanyTranslationsCompanyIdFkeyInput>;
  companyId?: InputMaybe<Scalars['Int']['input']>;
  lang: Language;
  name: Scalars['String']['input'];
};

/** The globally unique `ID` look up for the row to connect. */
export type CompanyTranslationNodeIdConnect = {
  /** The globally unique `ID` which identifies a single `companyTranslation` to be connected. */
  nodeId: Scalars['ID']['input'];
};

/** The globally unique `ID` look up for the row to update. */
export type CompanyTranslationOnCompanyTranslationForCompanyTranslationsCompanyIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `company` to be connected. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `company` being updated. */
  patch: CompanyPatch;
};

/** The fields on `companyTranslation` to look up the row to update. */
export type CompanyTranslationOnCompanyTranslationForCompanyTranslationsCompanyIdFkeyUsingCompanyTranslationsPkeyUpdate = {
  companyId: Scalars['Int']['input'];
  lang: Language;
  /** An object where the defined keys will be set on the `companyTranslation` being updated. */
  patch: UpdateCompanyTranslationOnCompanyTranslationForCompanyTranslationsCompanyIdFkeyPatch;
};

/** Represents an update to a `CompanyTranslation`. Fields that are set will be updated. */
export type CompanyTranslationPatch = {
  company?: InputMaybe<CompanyTranslationsCompanyIdFkeyInput>;
  companyId?: InputMaybe<Scalars['Int']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
};

/** Input for the nested mutation of `company` in the `CompanyTranslationInput` mutation. */
export type CompanyTranslationsCompanyIdFkeyInput = {
  /** The primary key(s) for `company` for the far side of the relationship. */
  connectById?: InputMaybe<CompanyCompaniesPkeyConnect>;
  /** The primary key(s) for `company` for the far side of the relationship. */
  connectByNodeId?: InputMaybe<CompanyNodeIdConnect>;
  /** The primary key(s) for `company` for the far side of the relationship. */
  connectBySlug?: InputMaybe<CompanyCompaniesSlugKeyConnect>;
  /** The primary key(s) and patch data for `company` for the far side of the relationship. */
  updateById?: InputMaybe<CompanyOnCompanyTranslationForCompanyTranslationsCompanyIdFkeyUsingCompaniesPkeyUpdate>;
  /** The primary key(s) and patch data for `company` for the far side of the relationship. */
  updateByNodeId?: InputMaybe<CompanyTranslationOnCompanyTranslationForCompanyTranslationsCompanyIdFkeyNodeIdUpdate>;
  /** The primary key(s) and patch data for `company` for the far side of the relationship. */
  updateBySlug?: InputMaybe<CompanyOnCompanyTranslationForCompanyTranslationsCompanyIdFkeyUsingCompaniesSlugKeyUpdate>;
};

/** Input for the nested mutation of `companyTranslation` in the `CompanyInput` mutation. */
export type CompanyTranslationsCompanyIdFkeyInverseInput = {
  /** The primary key(s) for `companyTranslation` for the far side of the relationship. */
  connectByCompanyIdAndLang?: InputMaybe<Array<CompanyTranslationCompanyTranslationsPkeyConnect>>;
  /** The primary key(s) for `companyTranslation` for the far side of the relationship. */
  connectByNodeId?: InputMaybe<Array<CompanyTranslationNodeIdConnect>>;
  /** The primary key(s) and patch data for `companyTranslation` for the far side of the relationship. */
  updateByCompanyIdAndLang?: InputMaybe<Array<CompanyTranslationOnCompanyTranslationForCompanyTranslationsCompanyIdFkeyUsingCompanyTranslationsPkeyUpdate>>;
  /** The primary key(s) and patch data for `companyTranslation` for the far side of the relationship. */
  updateByNodeId?: InputMaybe<Array<CompanyOnCompanyTranslationForCompanyTranslationsCompanyIdFkeyNodeIdUpdate>>;
};

/** A connection to a list of `CompanyTranslation` values. */
export type CompanyTranslationsConnection = {
  __typename?: 'CompanyTranslationsConnection';
  /** A list of edges which contains the `CompanyTranslation` and cursor to aid in pagination. */
  edges: Array<CompanyTranslationsEdge>;
  /** A list of `CompanyTranslation` objects. */
  nodes: Array<CompanyTranslation>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `CompanyTranslation` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `CompanyTranslation` edge in the connection. */
export type CompanyTranslationsEdge = {
  __typename?: 'CompanyTranslationsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `CompanyTranslation` at the end of the edge. */
  node: CompanyTranslation;
};

/** Methods to use when ordering `CompanyTranslation`. */
export enum CompanyTranslationsOrderBy {
  CompanyIdAsc = 'COMPANY_ID_ASC',
  CompanyIdDesc = 'COMPANY_ID_DESC',
  NameAsc = 'NAME_ASC',
  NameDesc = 'NAME_DESC',
  Natural = 'NATURAL',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC'
}

export type CompanyUser = Node & {
  __typename?: 'CompanyUser';
  createdAt: Scalars['Datetime']['output'];
  disabledAt?: Maybe<Scalars['Datetime']['output']>;
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  /** Reads a single `Role` that is related to this `CompanyUser`. */
  role?: Maybe<Role>;
  roleId: Scalars['Int']['output'];
  updatedAt: Scalars['Datetime']['output'];
  /** Reads a single `User` that is related to this `CompanyUser`. */
  user?: Maybe<User>;
  userId: Scalars['Int']['output'];
};

/** A condition to be used against `CompanyUser` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type CompanyUserCondition = {
  /** Checks for equality with the object’s `disabledAt` field. */
  disabledAt?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `roleId` field. */
  roleId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `userId` field. */
  userId?: InputMaybe<Scalars['Int']['input']>;
};

/** A filter to be used against `CompanyUser` object types. All fields are combined with a logical ‘and.’ */
export type CompanyUserFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<CompanyUserFilter>>;
  /** Filter by the object’s `disabledAt` field. */
  disabledAt?: InputMaybe<DatetimeFilter>;
  /** Negates the expression. */
  not?: InputMaybe<CompanyUserFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<CompanyUserFilter>>;
  /** Filter by the object’s `role` relation. */
  role?: InputMaybe<RoleFilter>;
  /** Filter by the object’s `roleId` field. */
  roleId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `user` relation. */
  user?: InputMaybe<UserFilter>;
  /** Filter by the object’s `userId` field. */
  userId?: InputMaybe<IntFilter>;
};

/** An input for mutations affecting `CompanyUser` */
export type CompanyUserInput = {
  role?: InputMaybe<CompanyUsersRoleIdFkeyInput>;
  roleId?: InputMaybe<Scalars['Int']['input']>;
  user?: InputMaybe<CompanyUsersUserIdFkeyInput>;
  userId?: InputMaybe<Scalars['Int']['input']>;
};

/** The globally unique `ID` look up for the row to connect. */
export type CompanyUserNodeIdConnect = {
  /** The globally unique `ID` which identifies a single `companyUser` to be connected. */
  nodeId: Scalars['ID']['input'];
};

/** The globally unique `ID` look up for the row to delete. */
export type CompanyUserNodeIdDelete = {
  /** The globally unique `ID` which identifies a single `companyUser` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** The globally unique `ID` look up for the row to update. */
export type CompanyUserOnCompanyUserForCompanyUsersRoleIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `role` to be connected. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `role` being updated. */
  patch: RolePatch;
};

/** The globally unique `ID` look up for the row to update. */
export type CompanyUserOnCompanyUserForCompanyUsersUserIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `user` to be connected. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `user` being updated. */
  patch: UserPatch;
};

/** Represents an update to a `CompanyUser`. Fields that are set will be updated. */
export type CompanyUserPatch = {
  disabledAt?: InputMaybe<Scalars['Datetime']['input']>;
  role?: InputMaybe<CompanyUsersRoleIdFkeyInput>;
  roleId?: InputMaybe<Scalars['Int']['input']>;
  user?: InputMaybe<CompanyUsersUserIdFkeyInput>;
  userId?: InputMaybe<Scalars['Int']['input']>;
};

/** A connection to a list of `CompanyUser` values. */
export type CompanyUsersConnection = {
  __typename?: 'CompanyUsersConnection';
  /** A list of edges which contains the `CompanyUser` and cursor to aid in pagination. */
  edges: Array<CompanyUsersEdge>;
  /** A list of `CompanyUser` objects. */
  nodes: Array<CompanyUser>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `CompanyUser` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `CompanyUser` edge in the connection. */
export type CompanyUsersEdge = {
  __typename?: 'CompanyUsersEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `CompanyUser` at the end of the edge. */
  node: CompanyUser;
};

/** Methods to use when ordering `CompanyUser`. */
export enum CompanyUsersOrderBy {
  DisabledAtAsc = 'DISABLED_AT_ASC',
  DisabledAtDesc = 'DISABLED_AT_DESC',
  Natural = 'NATURAL',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  RoleIdAsc = 'ROLE_ID_ASC',
  RoleIdDesc = 'ROLE_ID_DESC',
  UserIdAsc = 'USER_ID_ASC',
  UserIdDesc = 'USER_ID_DESC'
}

/** The `companyUser` to be created by this mutation. */
export type CompanyUsersRoleIdFkeyCompanyUsersCreateInput = {
  role?: InputMaybe<CompanyUsersRoleIdFkeyInput>;
  user?: InputMaybe<CompanyUsersUserIdFkeyInput>;
  userId?: InputMaybe<Scalars['Int']['input']>;
};

/** Input for the nested mutation of `role` in the `CompanyUserInput` mutation. */
export type CompanyUsersRoleIdFkeyInput = {
  /** The primary key(s) for `role` for the far side of the relationship. */
  connectById?: InputMaybe<RoleRolesPkeyConnect>;
  /** The primary key(s) for `role` for the far side of the relationship. */
  connectByNodeId?: InputMaybe<RoleNodeIdConnect>;
  /** A `RoleInput` object that will be created and connected to this object. */
  create?: InputMaybe<CompanyUsersRoleIdFkeyRolesCreateInput>;
  /** The primary key(s) and patch data for `role` for the far side of the relationship. */
  updateById?: InputMaybe<RoleOnCompanyUserForCompanyUsersRoleIdFkeyUsingRolesPkeyUpdate>;
  /** The primary key(s) and patch data for `role` for the far side of the relationship. */
  updateByNodeId?: InputMaybe<CompanyUserOnCompanyUserForCompanyUsersRoleIdFkeyNodeIdUpdate>;
};

/** Input for the nested mutation of `companyUser` in the `RoleInput` mutation. */
export type CompanyUsersRoleIdFkeyInverseInput = {
  /** The primary key(s) for `companyUser` for the far side of the relationship. */
  connectByNodeId?: InputMaybe<Array<CompanyUserNodeIdConnect>>;
  /** A `CompanyUserInput` object that will be created and connected to this object. */
  create?: InputMaybe<Array<CompanyUsersRoleIdFkeyCompanyUsersCreateInput>>;
  /** The primary key(s) for `companyUser` for the far side of the relationship. */
  deleteByNodeId?: InputMaybe<Array<CompanyUserNodeIdDelete>>;
  /** Flag indicating whether all other `companyUser` records that match this relationship should be removed. */
  deleteOthers?: InputMaybe<Scalars['Boolean']['input']>;
  /** The primary key(s) and patch data for `companyUser` for the far side of the relationship. */
  updateByNodeId?: InputMaybe<Array<RoleOnCompanyUserForCompanyUsersRoleIdFkeyNodeIdUpdate>>;
};

/** The `role` to be created by this mutation. */
export type CompanyUsersRoleIdFkeyRolesCreateInput = {
  abilities: Array<InputMaybe<Roleability>>;
  companyUsers?: InputMaybe<CompanyUsersRoleIdFkeyInverseInput>;
  translations?: InputMaybe<RoleTranslationsRoleIdFkeyInverseInput>;
  userInvitations?: InputMaybe<UserInvitationsRoleIdFkeyInverseInput>;
};

/** The `companyUser` to be created by this mutation. */
export type CompanyUsersUserIdFkeyCompanyUsersCreateInput = {
  role?: InputMaybe<CompanyUsersRoleIdFkeyInput>;
  roleId?: InputMaybe<Scalars['Int']['input']>;
  user?: InputMaybe<CompanyUsersUserIdFkeyInput>;
};

/** Input for the nested mutation of `user` in the `CompanyUserInput` mutation. */
export type CompanyUsersUserIdFkeyInput = {
  /** The primary key(s) for `user` for the far side of the relationship. */
  connectByEmail?: InputMaybe<UserUsersEmailKeyConnect>;
  /** The primary key(s) for `user` for the far side of the relationship. */
  connectById?: InputMaybe<UserUsersPkeyConnect>;
  /** The primary key(s) for `user` for the far side of the relationship. */
  connectByNodeId?: InputMaybe<UserNodeIdConnect>;
  /** The primary key(s) and patch data for `user` for the far side of the relationship. */
  updateByEmail?: InputMaybe<UserOnCompanyUserForCompanyUsersUserIdFkeyUsingUsersEmailKeyUpdate>;
  /** The primary key(s) and patch data for `user` for the far side of the relationship. */
  updateById?: InputMaybe<UserOnCompanyUserForCompanyUsersUserIdFkeyUsingUsersPkeyUpdate>;
  /** The primary key(s) and patch data for `user` for the far side of the relationship. */
  updateByNodeId?: InputMaybe<CompanyUserOnCompanyUserForCompanyUsersUserIdFkeyNodeIdUpdate>;
};

/** Input for the nested mutation of `companyUser` in the `UserInput` mutation. */
export type CompanyUsersUserIdFkeyInverseInput = {
  /** The primary key(s) for `companyUser` for the far side of the relationship. */
  connectByNodeId?: InputMaybe<Array<CompanyUserNodeIdConnect>>;
  /** A `CompanyUserInput` object that will be created and connected to this object. */
  create?: InputMaybe<Array<CompanyUsersUserIdFkeyCompanyUsersCreateInput>>;
  /** The primary key(s) for `companyUser` for the far side of the relationship. */
  deleteByNodeId?: InputMaybe<Array<CompanyUserNodeIdDelete>>;
  /** Flag indicating whether all other `companyUser` records that match this relationship should be removed. */
  deleteOthers?: InputMaybe<Scalars['Boolean']['input']>;
  /** The primary key(s) and patch data for `companyUser` for the far side of the relationship. */
  updateByNodeId?: InputMaybe<Array<UserOnCompanyUserForCompanyUsersUserIdFkeyNodeIdUpdate>>;
};

/** A connection to a list of `Competency` values. */
export type CompetenciesConnection = {
  __typename?: 'CompetenciesConnection';
  /** A list of edges which contains the `Competency` and cursor to aid in pagination. */
  edges: Array<CompetenciesEdge>;
  /** A list of `Competency` objects. */
  nodes: Array<Competency>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Competency` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `Competency` edge in the connection. */
export type CompetenciesEdge = {
  __typename?: 'CompetenciesEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Competency` at the end of the edge. */
  node: Competency;
};

/** Methods to use when ordering `Competency`. */
export enum CompetenciesOrderBy {
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  Natural = 'NATURAL',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  TitleAsc = 'TITLE_ASC',
  TitleDesc = 'TITLE_DESC'
}

export type Competency = Node & {
  __typename?: 'Competency';
  createdAt: Scalars['Datetime']['output'];
  id: Scalars['Int']['output'];
  /** Reads and enables pagination through a set of `JobCompetency`. */
  jobCompetenciesByCompetenceId: JobCompetenciesConnection;
  /** Reads and enables pagination through a set of `Job`. */
  jobs: CompetencyJobsByJobCompetencyCompetenceIdAndJobIdManyToManyConnection;
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  title: Scalars['String']['output'];
};


export type CompetencyJobCompetenciesByCompetenceIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<JobCompetencyCondition>;
  filter?: InputMaybe<JobCompetencyFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<JobCompetenciesOrderBy>>;
};


export type CompetencyJobsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<JobCondition>;
  filter?: InputMaybe<JobFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<JobsOrderBy>>;
};

/** The fields on `competency` to look up the row to connect. */
export type CompetencyCompetenciesPkeyConnect = {
  id: Scalars['Int']['input'];
};

/** A condition to be used against `Competency` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type CompetencyCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `title` field. */
  title?: InputMaybe<Scalars['String']['input']>;
};

/** A filter to be used against `Competency` object types. All fields are combined with a logical ‘and.’ */
export type CompetencyFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<CompetencyFilter>>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<IntFilter>;
  /** Filter by the object’s `jobCompetenciesByCompetenceId` relation. */
  jobCompetenciesByCompetenceId?: InputMaybe<CompetencyToManyJobCompetencyFilter>;
  /** Some related `jobCompetenciesByCompetenceId` exist. */
  jobCompetenciesByCompetenceIdExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Negates the expression. */
  not?: InputMaybe<CompetencyFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<CompetencyFilter>>;
  /** Filter by the object’s `title` field. */
  title?: InputMaybe<StringFilter>;
};

/** An input for mutations affecting `Competency` */
export type CompetencyInput = {
  jobCompetencies?: InputMaybe<JobCompetenciesCompetenceIdFkeyInverseInput>;
  title: Scalars['String']['input'];
};

/** A connection to a list of `Job` values, with data from `JobCompetency`. */
export type CompetencyJobsByJobCompetencyCompetenceIdAndJobIdManyToManyConnection = {
  __typename?: 'CompetencyJobsByJobCompetencyCompetenceIdAndJobIdManyToManyConnection';
  /** A list of edges which contains the `Job`, info from the `JobCompetency`, and the cursor to aid in pagination. */
  edges: Array<CompetencyJobsByJobCompetencyCompetenceIdAndJobIdManyToManyEdge>;
  /** A list of `Job` objects. */
  nodes: Array<Job>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Job` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `Job` edge in the connection, with data from `JobCompetency`. */
export type CompetencyJobsByJobCompetencyCompetenceIdAndJobIdManyToManyEdge = {
  __typename?: 'CompetencyJobsByJobCompetencyCompetenceIdAndJobIdManyToManyEdge';
  createdAt: Scalars['Datetime']['output'];
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Job` at the end of the edge. */
  node: Job;
};

/** The globally unique `ID` look up for the row to connect. */
export type CompetencyNodeIdConnect = {
  /** The globally unique `ID` which identifies a single `competency` to be connected. */
  nodeId: Scalars['ID']['input'];
};

/** The globally unique `ID` look up for the row to update. */
export type CompetencyOnJobCompetencyForJobCompetenciesCompetenceIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `jobCompetency` to be connected. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `jobCompetency` being updated. */
  patch: JobCompetencyPatch;
};

/** The fields on `competency` to look up the row to update. */
export type CompetencyOnJobCompetencyForJobCompetenciesCompetenceIdFkeyUsingCompetenciesPkeyUpdate = {
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `competency` being updated. */
  patch: UpdateCompetencyOnJobCompetencyForJobCompetenciesCompetenceIdFkeyPatch;
};

/** Represents an update to a `Competency`. Fields that are set will be updated. */
export type CompetencyPatch = {
  jobCompetencies?: InputMaybe<JobCompetenciesCompetenceIdFkeyInverseInput>;
  title?: InputMaybe<Scalars['String']['input']>;
};

/** A filter to be used against many `JobCompetency` object types. All fields are combined with a logical ‘and.’ */
export type CompetencyToManyJobCompetencyFilter = {
  /** Every related `JobCompetency` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<JobCompetencyFilter>;
  /** No related `JobCompetency` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<JobCompetencyFilter>;
  /** Some related `JobCompetency` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<JobCompetencyFilter>;
};

export type CopyFileToTempInput = {
  externalId: Scalars['UUID']['input'];
  fileType?: InputMaybe<ExternalFileType>;
};

export type CopyFileToTempPayload = {
  __typename?: 'CopyFileToTempPayload';
  fileKey: Scalars['UUID']['output'];
};

/** All input for the create `CandidateFile` mutation. */
export type CreateCandidateFileInput = {
  /** The `CandidateFile` to be created by this mutation. */
  candidateFile: CandidateFileInput;
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
};

/** The output of our create `CandidateFile` mutation. */
export type CreateCandidateFilePayload = {
  __typename?: 'CreateCandidateFilePayload';
  /** Reads a single `Candidate` that is related to this `CandidateFile`. */
  candidate?: Maybe<Candidate>;
  /** The `CandidateFile` that was created by this mutation. */
  candidateFile?: Maybe<CandidateFile>;
  /** An edge for our `CandidateFile`. May be used by Relay 1. */
  candidateFileEdge?: Maybe<CandidateFilesEdge>;
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our create `CandidateFile` mutation. */
export type CreateCandidateFilePayloadCandidateFileEdgeArgs = {
  orderBy?: InputMaybe<Array<CandidateFilesOrderBy>>;
};

/** All input for the create `CandidateImportCandidate` mutation. */
export type CreateCandidateImportCandidateInput = {
  /** The `CandidateImportCandidate` to be created by this mutation. */
  candidateImportCandidate: CandidateImportCandidateInput;
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
};

/** The output of our create `CandidateImportCandidate` mutation. */
export type CreateCandidateImportCandidatePayload = {
  __typename?: 'CreateCandidateImportCandidatePayload';
  /** Reads a single `Candidate` that is related to this `CandidateImportCandidate`. */
  candidate?: Maybe<Candidate>;
  /** Reads a single `CandidateImport` that is related to this `CandidateImportCandidate`. */
  candidateImport?: Maybe<CandidateImport>;
  /** The `CandidateImportCandidate` that was created by this mutation. */
  candidateImportCandidate?: Maybe<CandidateImportCandidate>;
  /** An edge for our `CandidateImportCandidate`. May be used by Relay 1. */
  candidateImportCandidateEdge?: Maybe<CandidateImportCandidatesEdge>;
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our create `CandidateImportCandidate` mutation. */
export type CreateCandidateImportCandidatePayloadCandidateImportCandidateEdgeArgs = {
  orderBy?: InputMaybe<Array<CandidateImportCandidatesOrderBy>>;
};

/** All input for the create `CandidateImportFile` mutation. */
export type CreateCandidateImportFileInput = {
  /** The `CandidateImportFile` to be created by this mutation. */
  candidateImportFile: CandidateImportFileInput;
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
};

/** The output of our create `CandidateImportFile` mutation. */
export type CreateCandidateImportFilePayload = {
  __typename?: 'CreateCandidateImportFilePayload';
  /** Reads a single `CandidateImport` that is related to this `CandidateImportFile`. */
  candidateImport?: Maybe<CandidateImport>;
  /** The `CandidateImportFile` that was created by this mutation. */
  candidateImportFile?: Maybe<CandidateImportFile>;
  /** An edge for our `CandidateImportFile`. May be used by Relay 1. */
  candidateImportFileEdge?: Maybe<CandidateImportFilesEdge>;
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our create `CandidateImportFile` mutation. */
export type CreateCandidateImportFilePayloadCandidateImportFileEdgeArgs = {
  orderBy?: InputMaybe<Array<CandidateImportFilesOrderBy>>;
};

/** All input for the create `CandidateImport` mutation. */
export type CreateCandidateImportInput = {
  /** The `CandidateImport` to be created by this mutation. */
  candidateImport: CandidateImportInput;
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
};

/** The output of our create `CandidateImport` mutation. */
export type CreateCandidateImportPayload = {
  __typename?: 'CreateCandidateImportPayload';
  /** The `CandidateImport` that was created by this mutation. */
  candidateImport?: Maybe<CandidateImport>;
  /** An edge for our `CandidateImport`. May be used by Relay 1. */
  candidateImportEdge?: Maybe<CandidateImportsEdge>;
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our create `CandidateImport` mutation. */
export type CreateCandidateImportPayloadCandidateImportEdgeArgs = {
  orderBy?: InputMaybe<Array<CandidateImportsOrderBy>>;
};

/** All input for the create `Candidate` mutation. */
export type CreateCandidateInput = {
  /** The `Candidate` to be created by this mutation. */
  candidate: CandidateInput;
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
};

/** The output of our create `Candidate` mutation. */
export type CreateCandidatePayload = {
  __typename?: 'CreateCandidatePayload';
  /** The `Candidate` that was created by this mutation. */
  candidate?: Maybe<Candidate>;
  /** An edge for our `Candidate`. May be used by Relay 1. */
  candidateEdge?: Maybe<CandidatesEdge>;
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our create `Candidate` mutation. */
export type CreateCandidatePayloadCandidateEdgeArgs = {
  orderBy?: InputMaybe<Array<CandidatesOrderBy>>;
};

/** All input for the create `CandidateQuestion` mutation. */
export type CreateCandidateQuestionInput = {
  /** The `CandidateQuestion` to be created by this mutation. */
  candidateQuestion: CandidateQuestionInput;
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
};

/** The output of our create `CandidateQuestion` mutation. */
export type CreateCandidateQuestionPayload = {
  __typename?: 'CreateCandidateQuestionPayload';
  /** Reads a single `Candidate` that is related to this `CandidateQuestion`. */
  candidate?: Maybe<Candidate>;
  /** The `CandidateQuestion` that was created by this mutation. */
  candidateQuestion?: Maybe<CandidateQuestion>;
  /** An edge for our `CandidateQuestion`. May be used by Relay 1. */
  candidateQuestionEdge?: Maybe<CandidateQuestionsEdge>;
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Reads a single `Evaluation` that is related to this `CandidateQuestion`. */
  evaluation?: Maybe<Evaluation>;
  /** Reads a single `CandidateFile` that is related to this `CandidateQuestion`. */
  fileValueExternal?: Maybe<CandidateFile>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `Question` that is related to this `CandidateQuestion`. */
  question?: Maybe<Question>;
  /** Reads a single `QuestionOption` that is related to this `CandidateQuestion`. */
  questionOption?: Maybe<QuestionOption>;
  /** Reads a single `Questionnaire` that is related to this `CandidateQuestion`. */
  questionnaire?: Maybe<Questionnaire>;
};


/** The output of our create `CandidateQuestion` mutation. */
export type CreateCandidateQuestionPayloadCandidateQuestionEdgeArgs = {
  orderBy?: InputMaybe<Array<CandidateQuestionsOrderBy>>;
};

/** All input for the create `CandidateQuestionnaire` mutation. */
export type CreateCandidateQuestionnaireInput = {
  /** The `CandidateQuestionnaire` to be created by this mutation. */
  candidateQuestionnaire: CandidateQuestionnaireInput;
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
};

/** The output of our create `CandidateQuestionnaire` mutation. */
export type CreateCandidateQuestionnairePayload = {
  __typename?: 'CreateCandidateQuestionnairePayload';
  /** Reads a single `Candidate` that is related to this `CandidateQuestionnaire`. */
  candidate?: Maybe<Candidate>;
  /** The `CandidateQuestionnaire` that was created by this mutation. */
  candidateQuestionnaire?: Maybe<CandidateQuestionnaire>;
  /** An edge for our `CandidateQuestionnaire`. May be used by Relay 1. */
  candidateQuestionnaireEdge?: Maybe<CandidateQuestionnairesEdge>;
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Reads a single `Evaluation` that is related to this `CandidateQuestionnaire`. */
  evaluation?: Maybe<Evaluation>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `Questionnaire` that is related to this `CandidateQuestionnaire`. */
  questionnaire?: Maybe<Questionnaire>;
};


/** The output of our create `CandidateQuestionnaire` mutation. */
export type CreateCandidateQuestionnairePayloadCandidateQuestionnaireEdgeArgs = {
  orderBy?: InputMaybe<Array<CandidateQuestionnairesOrderBy>>;
};

/** All input for the create `CandidateTag` mutation. */
export type CreateCandidateTagInput = {
  /** The `CandidateTag` to be created by this mutation. */
  candidateTag: CandidateTagInput;
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
};

/** The output of our create `CandidateTag` mutation. */
export type CreateCandidateTagPayload = {
  __typename?: 'CreateCandidateTagPayload';
  /** Reads a single `Candidate` that is related to this `CandidateTag`. */
  candidate?: Maybe<Candidate>;
  /** The `CandidateTag` that was created by this mutation. */
  candidateTag?: Maybe<CandidateTag>;
  /** An edge for our `CandidateTag`. May be used by Relay 1. */
  candidateTagEdge?: Maybe<CandidateTagsEdge>;
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `Tag` that is related to this `CandidateTag`. */
  tag?: Maybe<Tag>;
};


/** The output of our create `CandidateTag` mutation. */
export type CreateCandidateTagPayloadCandidateTagEdgeArgs = {
  orderBy?: InputMaybe<Array<CandidateTagsOrderBy>>;
};

/** All input for the create `CandidateTranslation` mutation. */
export type CreateCandidateTranslationInput = {
  /** The `CandidateTranslation` to be created by this mutation. */
  candidateTranslation: CandidateTranslationInput;
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
};

/** The output of our create `CandidateTranslation` mutation. */
export type CreateCandidateTranslationPayload = {
  __typename?: 'CreateCandidateTranslationPayload';
  /** Reads a single `Candidate` that is related to this `CandidateTranslation`. */
  candidate?: Maybe<Candidate>;
  /** The `CandidateTranslation` that was created by this mutation. */
  candidateTranslation?: Maybe<CandidateTranslation>;
  /** An edge for our `CandidateTranslation`. May be used by Relay 1. */
  candidateTranslationEdge?: Maybe<CandidateTranslationsEdge>;
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our create `CandidateTranslation` mutation. */
export type CreateCandidateTranslationPayloadCandidateTranslationEdgeArgs = {
  orderBy?: InputMaybe<Array<CandidateTranslationsOrderBy>>;
};

/** All input for the `createCompany` mutation. */
export type CreateCompanyInput = {
  category: CompanyCategory;
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  companySize: CompanySize;
  languages: Array<InputMaybe<Language>>;
  translations: Array<InputMaybe<CompanyTranslationInput>>;
};

/** The output of our `createCompany` mutation. */
export type CreateCompanyPayload = {
  __typename?: 'CreateCompanyPayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  company?: Maybe<Company>;
  /** An edge for our `Company`. May be used by Relay 1. */
  companyEdge?: Maybe<CompaniesEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our `createCompany` mutation. */
export type CreateCompanyPayloadCompanyEdgeArgs = {
  orderBy?: InputMaybe<Array<CompaniesOrderBy>>;
};

/** All input for the create `CompanyUser` mutation. */
export type CreateCompanyUserInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The `CompanyUser` to be created by this mutation. */
  companyUser: CompanyUserInput;
};

/** The output of our create `CompanyUser` mutation. */
export type CreateCompanyUserPayload = {
  __typename?: 'CreateCompanyUserPayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The `CompanyUser` that was created by this mutation. */
  companyUser?: Maybe<CompanyUser>;
  /** An edge for our `CompanyUser`. May be used by Relay 1. */
  companyUserEdge?: Maybe<CompanyUsersEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `Role` that is related to this `CompanyUser`. */
  role?: Maybe<Role>;
  /** Reads a single `User` that is related to this `CompanyUser`. */
  user?: Maybe<User>;
};


/** The output of our create `CompanyUser` mutation. */
export type CreateCompanyUserPayloadCompanyUserEdgeArgs = {
  orderBy?: InputMaybe<Array<CompanyUsersOrderBy>>;
};

/** All input for the `createCompanyUserTokenByCompanyId` mutation. */
export type CreateCompanyUserTokenByCompanyIdInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  companyId: Scalars['Int']['input'];
  rememberMe: Scalars['Boolean']['input'];
};

/** The output of our `createCompanyUserTokenByCompanyId` mutation. */
export type CreateCompanyUserTokenByCompanyIdPayload = {
  __typename?: 'CreateCompanyUserTokenByCompanyIdPayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  userToken?: Maybe<UserToken>;
};

/** All input for the `createCompanyUserToken` mutation. */
export type CreateCompanyUserTokenInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  companyId: Scalars['Int']['input'];
  email: Scalars['String']['input'];
  password: Scalars['String']['input'];
  rememberMe: Scalars['Boolean']['input'];
};

/** The output of our `createCompanyUserToken` mutation. */
export type CreateCompanyUserTokenPayload = {
  __typename?: 'CreateCompanyUserTokenPayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  userToken?: Maybe<UserToken>;
};

/** All input for the create `Competency` mutation. */
export type CreateCompetencyInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The `Competency` to be created by this mutation. */
  competency: CompetencyInput;
};

/** The output of our create `Competency` mutation. */
export type CreateCompetencyPayload = {
  __typename?: 'CreateCompetencyPayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The `Competency` that was created by this mutation. */
  competency?: Maybe<Competency>;
  /** An edge for our `Competency`. May be used by Relay 1. */
  competencyEdge?: Maybe<CompetenciesEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our create `Competency` mutation. */
export type CreateCompetencyPayloadCompetencyEdgeArgs = {
  orderBy?: InputMaybe<Array<CompetenciesOrderBy>>;
};

export type CreateCustomJobfairPaymentPayload = {
  __typename?: 'CreateCustomJobfairPaymentPayload';
  success: Scalars['Boolean']['output'];
};

/** All input for the create `Department` mutation. */
export type CreateDepartmentInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The `Department` to be created by this mutation. */
  department: DepartmentInput;
};

/** The output of our create `Department` mutation. */
export type CreateDepartmentPayload = {
  __typename?: 'CreateDepartmentPayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The `Department` that was created by this mutation. */
  department?: Maybe<Department>;
  /** An edge for our `Department`. May be used by Relay 1. */
  departmentEdge?: Maybe<DepartmentsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our create `Department` mutation. */
export type CreateDepartmentPayloadDepartmentEdgeArgs = {
  orderBy?: InputMaybe<Array<DepartmentsOrderBy>>;
};

/** All input for the create `DepartmentTranslation` mutation. */
export type CreateDepartmentTranslationInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The `DepartmentTranslation` to be created by this mutation. */
  departmentTranslation: DepartmentTranslationInput;
};

/** The output of our create `DepartmentTranslation` mutation. */
export type CreateDepartmentTranslationPayload = {
  __typename?: 'CreateDepartmentTranslationPayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Reads a single `Department` that is related to this `DepartmentTranslation`. */
  department?: Maybe<Department>;
  /** The `DepartmentTranslation` that was created by this mutation. */
  departmentTranslation?: Maybe<DepartmentTranslation>;
  /** An edge for our `DepartmentTranslation`. May be used by Relay 1. */
  departmentTranslationEdge?: Maybe<DepartmentTranslationsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our create `DepartmentTranslation` mutation. */
export type CreateDepartmentTranslationPayloadDepartmentTranslationEdgeArgs = {
  orderBy?: InputMaybe<Array<DepartmentTranslationsOrderBy>>;
};

/** All input for the create `DisqualifyReason` mutation. */
export type CreateDisqualifyReasonInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The `DisqualifyReason` to be created by this mutation. */
  disqualifyReason: DisqualifyReasonInput;
};

/** The output of our create `DisqualifyReason` mutation. */
export type CreateDisqualifyReasonPayload = {
  __typename?: 'CreateDisqualifyReasonPayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The `DisqualifyReason` that was created by this mutation. */
  disqualifyReason?: Maybe<DisqualifyReason>;
  /** An edge for our `DisqualifyReason`. May be used by Relay 1. */
  disqualifyReasonEdge?: Maybe<DisqualifyReasonsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our create `DisqualifyReason` mutation. */
export type CreateDisqualifyReasonPayloadDisqualifyReasonEdgeArgs = {
  orderBy?: InputMaybe<Array<DisqualifyReasonsOrderBy>>;
};

/** All input for the create `DisqualifyReasonTranslation` mutation. */
export type CreateDisqualifyReasonTranslationInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The `DisqualifyReasonTranslation` to be created by this mutation. */
  disqualifyReasonTranslation: DisqualifyReasonTranslationInput;
};

/** The output of our create `DisqualifyReasonTranslation` mutation. */
export type CreateDisqualifyReasonTranslationPayload = {
  __typename?: 'CreateDisqualifyReasonTranslationPayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Reads a single `DisqualifyReason` that is related to this `DisqualifyReasonTranslation`. */
  disqualifyReason?: Maybe<DisqualifyReason>;
  /** The `DisqualifyReasonTranslation` that was created by this mutation. */
  disqualifyReasonTranslation?: Maybe<DisqualifyReasonTranslation>;
  /** An edge for our `DisqualifyReasonTranslation`. May be used by Relay 1. */
  disqualifyReasonTranslationEdge?: Maybe<DisqualifyReasonTranslationsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our create `DisqualifyReasonTranslation` mutation. */
export type CreateDisqualifyReasonTranslationPayloadDisqualifyReasonTranslationEdgeArgs = {
  orderBy?: InputMaybe<Array<DisqualifyReasonTranslationsOrderBy>>;
};

/** All input for the create `Evaluation` mutation. */
export type CreateEvaluationInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The `Evaluation` to be created by this mutation. */
  evaluation: EvaluationInput;
};

/** The output of our create `Evaluation` mutation. */
export type CreateEvaluationPayload = {
  __typename?: 'CreateEvaluationPayload';
  /** Reads a single `Candidate` that is related to this `Evaluation`. */
  candidate?: Maybe<Candidate>;
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Reads a single `DraftEvaluation` that is related to this `Evaluation`. */
  draftEvaluation?: Maybe<DraftEvaluation>;
  /** The `Evaluation` that was created by this mutation. */
  evaluation?: Maybe<Evaluation>;
  /** An edge for our `Evaluation`. May be used by Relay 1. */
  evaluationEdge?: Maybe<EvaluationsEdge>;
  /** Reads a single `EventDraftEvaluation` that is related to this `Evaluation`. */
  eventDraftEvaluation?: Maybe<EventDraftEvaluation>;
  /** Reads a single `Job` that is related to this `Evaluation`. */
  job?: Maybe<Job>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `User` that is related to this `Evaluation`. */
  user?: Maybe<User>;
};


/** The output of our create `Evaluation` mutation. */
export type CreateEvaluationPayloadEvaluationEdgeArgs = {
  orderBy?: InputMaybe<Array<EvaluationsOrderBy>>;
};

/** All input for the create `EvaluationScorecardCriteria` mutation. */
export type CreateEvaluationScorecardCriteriaInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The `EvaluationScorecardCriteria` to be created by this mutation. */
  evaluationScorecardCriteria: EvaluationScorecardCriteriaInput;
};

/** The output of our create `EvaluationScorecardCriteria` mutation. */
export type CreateEvaluationScorecardCriteriaPayload = {
  __typename?: 'CreateEvaluationScorecardCriteriaPayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Reads a single `ScorecardCriteria` that is related to this `EvaluationScorecardCriteria`. */
  criteria?: Maybe<ScorecardCriteria>;
  /** Reads a single `EvaluationScorecard` that is related to this `EvaluationScorecardCriteria`. */
  evaluationScorecard?: Maybe<EvaluationScorecard>;
  /** The `EvaluationScorecardCriteria` that was created by this mutation. */
  evaluationScorecardCriteria?: Maybe<EvaluationScorecardCriteria>;
  /** An edge for our `EvaluationScorecardCriteria`. May be used by Relay 1. */
  evaluationScorecardCriteriaEdge?: Maybe<EvaluationScorecardCriteriaEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our create `EvaluationScorecardCriteria` mutation. */
export type CreateEvaluationScorecardCriteriaPayloadEvaluationScorecardCriteriaEdgeArgs = {
  orderBy?: InputMaybe<Array<EvaluationScorecardCriteriaOrderBy>>;
};

/** All input for the create `EvaluationScorecard` mutation. */
export type CreateEvaluationScorecardInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The `EvaluationScorecard` to be created by this mutation. */
  evaluationScorecard: EvaluationScorecardInput;
};

/** The output of our create `EvaluationScorecard` mutation. */
export type CreateEvaluationScorecardPayload = {
  __typename?: 'CreateEvaluationScorecardPayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Reads a single `Evaluation` that is related to this `EvaluationScorecard`. */
  evaluation?: Maybe<Evaluation>;
  /** The `EvaluationScorecard` that was created by this mutation. */
  evaluationScorecard?: Maybe<EvaluationScorecard>;
  /** An edge for our `EvaluationScorecard`. May be used by Relay 1. */
  evaluationScorecardEdge?: Maybe<EvaluationScorecardsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `Scorecard` that is related to this `EvaluationScorecard`. */
  scorecard?: Maybe<Scorecard>;
};


/** The output of our create `EvaluationScorecard` mutation. */
export type CreateEvaluationScorecardPayloadEvaluationScorecardEdgeArgs = {
  orderBy?: InputMaybe<Array<EvaluationScorecardsOrderBy>>;
};

/** All input for the create `EventCandidate` mutation. */
export type CreateEventCandidateInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The `EventCandidate` to be created by this mutation. */
  eventCandidate: EventCandidateInput;
};

/** The output of our create `EventCandidate` mutation. */
export type CreateEventCandidatePayload = {
  __typename?: 'CreateEventCandidatePayload';
  /** Reads a single `Candidate` that is related to this `EventCandidate`. */
  candidate?: Maybe<Candidate>;
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Reads a single `Event` that is related to this `EventCandidate`. */
  event?: Maybe<Event>;
  /** The `EventCandidate` that was created by this mutation. */
  eventCandidate?: Maybe<EventCandidate>;
  /** An edge for our `EventCandidate`. May be used by Relay 1. */
  eventCandidateEdge?: Maybe<EventCandidatesEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our create `EventCandidate` mutation. */
export type CreateEventCandidatePayloadEventCandidateEdgeArgs = {
  orderBy?: InputMaybe<Array<EventCandidatesOrderBy>>;
};

/** All input for the create `Event` mutation. */
export type CreateEventInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The `Event` to be created by this mutation. */
  event: EventInput;
};

/** The output of our create `Event` mutation. */
export type CreateEventPayload = {
  __typename?: 'CreateEventPayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The `Event` that was created by this mutation. */
  event?: Maybe<Event>;
  /** An edge for our `Event`. May be used by Relay 1. */
  eventEdge?: Maybe<EventsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our create `Event` mutation. */
export type CreateEventPayloadEventEdgeArgs = {
  orderBy?: InputMaybe<Array<EventsOrderBy>>;
};

/** All input for the create `EventScorecard` mutation. */
export type CreateEventScorecardInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The `EventScorecard` to be created by this mutation. */
  eventScorecard: EventScorecardInput;
};

/** The output of our create `EventScorecard` mutation. */
export type CreateEventScorecardPayload = {
  __typename?: 'CreateEventScorecardPayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Reads a single `Event` that is related to this `EventScorecard`. */
  event?: Maybe<Event>;
  /** The `EventScorecard` that was created by this mutation. */
  eventScorecard?: Maybe<EventScorecard>;
  /** An edge for our `EventScorecard`. May be used by Relay 1. */
  eventScorecardEdge?: Maybe<EventScorecardsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `Scorecard` that is related to this `EventScorecard`. */
  scorecard?: Maybe<Scorecard>;
};


/** The output of our create `EventScorecard` mutation. */
export type CreateEventScorecardPayloadEventScorecardEdgeArgs = {
  orderBy?: InputMaybe<Array<EventScorecardsOrderBy>>;
};

/** All input for the create `EventUser` mutation. */
export type CreateEventUserInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The `EventUser` to be created by this mutation. */
  eventUser: EventUserInput;
};

/** The output of our create `EventUser` mutation. */
export type CreateEventUserPayload = {
  __typename?: 'CreateEventUserPayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Reads a single `Event` that is related to this `EventUser`. */
  event?: Maybe<Event>;
  /** The `EventUser` that was created by this mutation. */
  eventUser?: Maybe<EventUser>;
  /** An edge for our `EventUser`. May be used by Relay 1. */
  eventUserEdge?: Maybe<EventUsersEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `User` that is related to this `EventUser`. */
  user?: Maybe<User>;
};


/** The output of our create `EventUser` mutation. */
export type CreateEventUserPayloadEventUserEdgeArgs = {
  orderBy?: InputMaybe<Array<EventUsersOrderBy>>;
};

/** All input for the create `Field` mutation. */
export type CreateFieldInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The `Field` to be created by this mutation. */
  field: FieldInput;
};

/** The output of our create `Field` mutation. */
export type CreateFieldPayload = {
  __typename?: 'CreateFieldPayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The `Field` that was created by this mutation. */
  field?: Maybe<Field>;
  /** An edge for our `Field`. May be used by Relay 1. */
  fieldEdge?: Maybe<FieldsEdge>;
  /** Reads a single `Job` that is related to this `Field`. */
  job?: Maybe<Job>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our create `Field` mutation. */
export type CreateFieldPayloadFieldEdgeArgs = {
  orderBy?: InputMaybe<Array<FieldsOrderBy>>;
};

/** All input for the `createForgotPasswordToken` mutation. */
export type CreateForgotPasswordTokenInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  email: Scalars['String']['input'];
};

/** The output of our `createForgotPasswordToken` mutation. */
export type CreateForgotPasswordTokenPayload = {
  __typename?: 'CreateForgotPasswordTokenPayload';
  boolean?: Maybe<Scalars['Boolean']['output']>;
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};

/** All input for the create `Invoice` mutation. */
export type CreateInvoiceInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The `Invoice` to be created by this mutation. */
  invoice: InvoiceInput;
};

/** The output of our create `Invoice` mutation. */
export type CreateInvoicePayload = {
  __typename?: 'CreateInvoicePayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Reads a single `Company` that is related to this `Invoice`. */
  company?: Maybe<Company>;
  /** The `Invoice` that was created by this mutation. */
  invoice?: Maybe<Invoice>;
  /** An edge for our `Invoice`. May be used by Relay 1. */
  invoiceEdge?: Maybe<InvoicesEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `Subscription` that is related to this `Invoice`. */
  subscription?: Maybe<Subscription>;
};


/** The output of our create `Invoice` mutation. */
export type CreateInvoicePayloadInvoiceEdgeArgs = {
  orderBy?: InputMaybe<Array<InvoicesOrderBy>>;
};

/** All input for the `createJobApplicationPublic` mutation. */
export type CreateJobApplicationPublicInput = {
  application?: InputMaybe<CreateJobApplicationPublicInputRecordInput>;
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  jobId?: InputMaybe<Scalars['Int']['input']>;
  questionAnswers?: InputMaybe<Array<InputMaybe<CandidateQuestionsInputRecordInput>>>;
  questionnaireIds?: InputMaybe<Array<InputMaybe<Scalars['Int']['input']>>>;
};

/** An input for mutations affecting `CreateJobApplicationPublicInputRecord` */
export type CreateJobApplicationPublicInputRecordInput = {
  address?: InputMaybe<Scalars['String']['input']>;
  birthday?: InputMaybe<Scalars['Date']['input']>;
  coverLetter?: InputMaybe<Scalars['String']['input']>;
  emails?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  gender?: InputMaybe<Gender>;
  language?: InputMaybe<Language>;
  militaryStatus?: InputMaybe<MilitaryStatus>;
  phones?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  photoExternalId?: InputMaybe<Scalars['UUID']['input']>;
  questionaires?: InputMaybe<Array<InputMaybe<QuestionnaireInput>>>;
  resumeExternalId?: InputMaybe<Scalars['UUID']['input']>;
  resumeFileName?: InputMaybe<Scalars['String']['input']>;
  translations?: InputMaybe<Array<InputMaybe<CandidateTranslationInput>>>;
};

/** The output of our `createJobApplicationPublic` mutation. */
export type CreateJobApplicationPublicPayload = {
  __typename?: 'CreateJobApplicationPublicPayload';
  boolean?: Maybe<Scalars['Boolean']['output']>;
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};

/** All input for the create `JobCompetency` mutation. */
export type CreateJobCompetencyInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The `JobCompetency` to be created by this mutation. */
  jobCompetency: JobCompetencyInput;
};

/** The output of our create `JobCompetency` mutation. */
export type CreateJobCompetencyPayload = {
  __typename?: 'CreateJobCompetencyPayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Reads a single `Competency` that is related to this `JobCompetency`. */
  competence?: Maybe<Competency>;
  /** Reads a single `Job` that is related to this `JobCompetency`. */
  job?: Maybe<Job>;
  /** The `JobCompetency` that was created by this mutation. */
  jobCompetency?: Maybe<JobCompetency>;
  /** An edge for our `JobCompetency`. May be used by Relay 1. */
  jobCompetencyEdge?: Maybe<JobCompetenciesEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our create `JobCompetency` mutation. */
export type CreateJobCompetencyPayloadJobCompetencyEdgeArgs = {
  orderBy?: InputMaybe<Array<JobCompetenciesOrderBy>>;
};

/** All input for the create `Job` mutation. */
export type CreateJobInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The `Job` to be created by this mutation. */
  job: JobInput;
};

/** All input for the create `JobKnowledge` mutation. */
export type CreateJobKnowledgeInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The `JobKnowledge` to be created by this mutation. */
  jobKnowledge: JobKnowledgeInput;
};

/** The output of our create `JobKnowledge` mutation. */
export type CreateJobKnowledgePayload = {
  __typename?: 'CreateJobKnowledgePayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Reads a single `Job` that is related to this `JobKnowledge`. */
  job?: Maybe<Job>;
  /** The `JobKnowledge` that was created by this mutation. */
  jobKnowledge?: Maybe<JobKnowledge>;
  /** An edge for our `JobKnowledge`. May be used by Relay 1. */
  jobKnowledgeEdge?: Maybe<JobKnowledgesEdge>;
  /** Reads a single `Knowledge` that is related to this `JobKnowledge`. */
  knowledge?: Maybe<Knowledge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our create `JobKnowledge` mutation. */
export type CreateJobKnowledgePayloadJobKnowledgeEdgeArgs = {
  orderBy?: InputMaybe<Array<JobKnowledgesOrderBy>>;
};

/** All input for the create `JobOwner` mutation. */
export type CreateJobOwnerInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The `JobOwner` to be created by this mutation. */
  jobOwner: JobOwnerInput;
};

/** The output of our create `JobOwner` mutation. */
export type CreateJobOwnerPayload = {
  __typename?: 'CreateJobOwnerPayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Reads a single `Job` that is related to this `JobOwner`. */
  job?: Maybe<Job>;
  /** The `JobOwner` that was created by this mutation. */
  jobOwner?: Maybe<JobOwner>;
  /** An edge for our `JobOwner`. May be used by Relay 1. */
  jobOwnerEdge?: Maybe<JobOwnersEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `User` that is related to this `JobOwner`. */
  user?: Maybe<User>;
};


/** The output of our create `JobOwner` mutation. */
export type CreateJobOwnerPayloadJobOwnerEdgeArgs = {
  orderBy?: InputMaybe<Array<JobOwnersOrderBy>>;
};

/** The output of our create `Job` mutation. */
export type CreateJobPayload = {
  __typename?: 'CreateJobPayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Reads a single `Department` that is related to this `Job`. */
  department?: Maybe<Department>;
  /** The `Job` that was created by this mutation. */
  job?: Maybe<Job>;
  /** An edge for our `Job`. May be used by Relay 1. */
  jobEdge?: Maybe<JobsEdge>;
  /** Reads a single `Pipeline` that is related to this `Job`. */
  pipeline?: Maybe<Pipeline>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our create `Job` mutation. */
export type CreateJobPayloadJobEdgeArgs = {
  orderBy?: InputMaybe<Array<JobsOrderBy>>;
};

/** All input for the create `JobQuestionnaire` mutation. */
export type CreateJobQuestionnaireInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The `JobQuestionnaire` to be created by this mutation. */
  jobQuestionnaire: JobQuestionnaireInput;
};

/** The output of our create `JobQuestionnaire` mutation. */
export type CreateJobQuestionnairePayload = {
  __typename?: 'CreateJobQuestionnairePayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Reads a single `Job` that is related to this `JobQuestionnaire`. */
  job?: Maybe<Job>;
  /** The `JobQuestionnaire` that was created by this mutation. */
  jobQuestionnaire?: Maybe<JobQuestionnaire>;
  /** An edge for our `JobQuestionnaire`. May be used by Relay 1. */
  jobQuestionnaireEdge?: Maybe<JobQuestionnairesEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `Questionnaire` that is related to this `JobQuestionnaire`. */
  questionnaire?: Maybe<Questionnaire>;
};


/** The output of our create `JobQuestionnaire` mutation. */
export type CreateJobQuestionnairePayloadJobQuestionnaireEdgeArgs = {
  orderBy?: InputMaybe<Array<JobQuestionnairesOrderBy>>;
};

/** All input for the create `JobSkill` mutation. */
export type CreateJobSkillInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The `JobSkill` to be created by this mutation. */
  jobSkill: JobSkillInput;
};

/** The output of our create `JobSkill` mutation. */
export type CreateJobSkillPayload = {
  __typename?: 'CreateJobSkillPayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Reads a single `Job` that is related to this `JobSkill`. */
  job?: Maybe<Job>;
  /** The `JobSkill` that was created by this mutation. */
  jobSkill?: Maybe<JobSkill>;
  /** An edge for our `JobSkill`. May be used by Relay 1. */
  jobSkillEdge?: Maybe<JobSkillsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `Skill` that is related to this `JobSkill`. */
  skill?: Maybe<Skill>;
};


/** The output of our create `JobSkill` mutation. */
export type CreateJobSkillPayloadJobSkillEdgeArgs = {
  orderBy?: InputMaybe<Array<JobSkillsOrderBy>>;
};

/** All input for the create `JobTag` mutation. */
export type CreateJobTagInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The `JobTag` to be created by this mutation. */
  jobTag: JobTagInput;
};

/** The output of our create `JobTag` mutation. */
export type CreateJobTagPayload = {
  __typename?: 'CreateJobTagPayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Reads a single `Job` that is related to this `JobTag`. */
  job?: Maybe<Job>;
  /** The `JobTag` that was created by this mutation. */
  jobTag?: Maybe<JobTag>;
  /** An edge for our `JobTag`. May be used by Relay 1. */
  jobTagEdge?: Maybe<JobTagsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `Tag` that is related to this `JobTag`. */
  tag?: Maybe<Tag>;
};


/** The output of our create `JobTag` mutation. */
export type CreateJobTagPayloadJobTagEdgeArgs = {
  orderBy?: InputMaybe<Array<JobTagsOrderBy>>;
};

/** All input for the create `JobTranslation` mutation. */
export type CreateJobTranslationInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The `JobTranslation` to be created by this mutation. */
  jobTranslation: JobTranslationInput;
};

/** The output of our create `JobTranslation` mutation. */
export type CreateJobTranslationPayload = {
  __typename?: 'CreateJobTranslationPayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Reads a single `Job` that is related to this `JobTranslation`. */
  job?: Maybe<Job>;
  /** The `JobTranslation` that was created by this mutation. */
  jobTranslation?: Maybe<JobTranslation>;
  /** An edge for our `JobTranslation`. May be used by Relay 1. */
  jobTranslationEdge?: Maybe<JobTranslationsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our create `JobTranslation` mutation. */
export type CreateJobTranslationPayloadJobTranslationEdgeArgs = {
  orderBy?: InputMaybe<Array<JobTranslationsOrderBy>>;
};

/** All input for the create `JobsApplication` mutation. */
export type CreateJobsApplicationInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The `JobsApplication` to be created by this mutation. */
  jobsApplication: JobsApplicationInput;
};

/** The output of our create `JobsApplication` mutation. */
export type CreateJobsApplicationPayload = {
  __typename?: 'CreateJobsApplicationPayload';
  /** Reads a single `Candidate` that is related to this `JobsApplication`. */
  candidate?: Maybe<Candidate>;
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Reads a single `DisqualifyReason` that is related to this `JobsApplication`. */
  disqualifyReason?: Maybe<DisqualifyReason>;
  /** Reads a single `Job` that is related to this `JobsApplication`. */
  job?: Maybe<Job>;
  /** The `JobsApplication` that was created by this mutation. */
  jobsApplication?: Maybe<JobsApplication>;
  /** An edge for our `JobsApplication`. May be used by Relay 1. */
  jobsApplicationEdge?: Maybe<JobsApplicationsEdge>;
  /** Reads a single `PipelineStage` that is related to this `JobsApplication`. */
  pipelineStage?: Maybe<PipelineStage>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our create `JobsApplication` mutation. */
export type CreateJobsApplicationPayloadJobsApplicationEdgeArgs = {
  orderBy?: InputMaybe<Array<JobsApplicationsOrderBy>>;
};

/** All input for the create `Knowledge` mutation. */
export type CreateKnowledgeInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The `Knowledge` to be created by this mutation. */
  knowledge: KnowledgeInput;
};

/** The output of our create `Knowledge` mutation. */
export type CreateKnowledgePayload = {
  __typename?: 'CreateKnowledgePayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The `Knowledge` that was created by this mutation. */
  knowledge?: Maybe<Knowledge>;
  /** An edge for our `Knowledge`. May be used by Relay 1. */
  knowledgeEdge?: Maybe<KnowledgesEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our create `Knowledge` mutation. */
export type CreateKnowledgePayloadKnowledgeEdgeArgs = {
  orderBy?: InputMaybe<Array<KnowledgesOrderBy>>;
};

/** All input for the create `MessageFile` mutation. */
export type CreateMessageFileInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The `MessageFile` to be created by this mutation. */
  messageFile: MessageFileInput;
};

/** The output of our create `MessageFile` mutation. */
export type CreateMessageFilePayload = {
  __typename?: 'CreateMessageFilePayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Reads a single `Message` that is related to this `MessageFile`. */
  message?: Maybe<Message>;
  /** The `MessageFile` that was created by this mutation. */
  messageFile?: Maybe<MessageFile>;
  /** An edge for our `MessageFile`. May be used by Relay 1. */
  messageFileEdge?: Maybe<MessageFilesEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our create `MessageFile` mutation. */
export type CreateMessageFilePayloadMessageFileEdgeArgs = {
  orderBy?: InputMaybe<Array<MessageFilesOrderBy>>;
};

/** All input for the create `Message` mutation. */
export type CreateMessageInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The `Message` to be created by this mutation. */
  message: MessageInput;
};

/** The output of our create `Message` mutation. */
export type CreateMessagePayload = {
  __typename?: 'CreateMessagePayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The `Message` that was created by this mutation. */
  message?: Maybe<Message>;
  /** An edge for our `Message`. May be used by Relay 1. */
  messageEdge?: Maybe<MessagesEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `Thread` that is related to this `Message`. */
  thread?: Maybe<Thread>;
  /** Reads a single `User` that is related to this `Message`. */
  user?: Maybe<User>;
};


/** The output of our create `Message` mutation. */
export type CreateMessagePayloadMessageEdgeArgs = {
  orderBy?: InputMaybe<Array<MessagesOrderBy>>;
};

export type CreatePaymentLinkInput = {
  subscriptionId: Scalars['Int']['input'];
};

export type CreatePaymentLinkPaylod = {
  __typename?: 'CreatePaymentLinkPaylod';
  bankUrl: Scalars['String']['output'];
  invoiceId: Scalars['Int']['output'];
};

/** All input for the create `Pipeline` mutation. */
export type CreatePipelineInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The `Pipeline` to be created by this mutation. */
  pipeline: PipelineInput;
};

/** The output of our create `Pipeline` mutation. */
export type CreatePipelinePayload = {
  __typename?: 'CreatePipelinePayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The `Pipeline` that was created by this mutation. */
  pipeline?: Maybe<Pipeline>;
  /** An edge for our `Pipeline`. May be used by Relay 1. */
  pipelineEdge?: Maybe<PipelinesEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our create `Pipeline` mutation. */
export type CreatePipelinePayloadPipelineEdgeArgs = {
  orderBy?: InputMaybe<Array<PipelinesOrderBy>>;
};

/** All input for the create `PipelineStage` mutation. */
export type CreatePipelineStageInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The `PipelineStage` to be created by this mutation. */
  pipelineStage: PipelineStageInput;
};

/** The output of our create `PipelineStage` mutation. */
export type CreatePipelineStagePayload = {
  __typename?: 'CreatePipelineStagePayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Reads a single `Pipeline` that is related to this `PipelineStage`. */
  pipeline?: Maybe<Pipeline>;
  /** The `PipelineStage` that was created by this mutation. */
  pipelineStage?: Maybe<PipelineStage>;
  /** An edge for our `PipelineStage`. May be used by Relay 1. */
  pipelineStageEdge?: Maybe<PipelineStagesEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our create `PipelineStage` mutation. */
export type CreatePipelineStagePayloadPipelineStageEdgeArgs = {
  orderBy?: InputMaybe<Array<PipelineStagesOrderBy>>;
};

/** All input for the create `PipelineStageScorecard` mutation. */
export type CreatePipelineStageScorecardInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The `PipelineStageScorecard` to be created by this mutation. */
  pipelineStageScorecard: PipelineStageScorecardInput;
};

/** The output of our create `PipelineStageScorecard` mutation. */
export type CreatePipelineStageScorecardPayload = {
  __typename?: 'CreatePipelineStageScorecardPayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Reads a single `PipelineStage` that is related to this `PipelineStageScorecard`. */
  pipelineStage?: Maybe<PipelineStage>;
  /** The `PipelineStageScorecard` that was created by this mutation. */
  pipelineStageScorecard?: Maybe<PipelineStageScorecard>;
  /** An edge for our `PipelineStageScorecard`. May be used by Relay 1. */
  pipelineStageScorecardEdge?: Maybe<PipelineStageScorecardsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `Scorecard` that is related to this `PipelineStageScorecard`. */
  scorecard?: Maybe<Scorecard>;
};


/** The output of our create `PipelineStageScorecard` mutation. */
export type CreatePipelineStageScorecardPayloadPipelineStageScorecardEdgeArgs = {
  orderBy?: InputMaybe<Array<PipelineStageScorecardsOrderBy>>;
};

/** All input for the create `PipelineStageTranslation` mutation. */
export type CreatePipelineStageTranslationInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The `PipelineStageTranslation` to be created by this mutation. */
  pipelineStageTranslation: PipelineStageTranslationInput;
};

/** The output of our create `PipelineStageTranslation` mutation. */
export type CreatePipelineStageTranslationPayload = {
  __typename?: 'CreatePipelineStageTranslationPayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Reads a single `PipelineStage` that is related to this `PipelineStageTranslation`. */
  pipelineStage?: Maybe<PipelineStage>;
  /** The `PipelineStageTranslation` that was created by this mutation. */
  pipelineStageTranslation?: Maybe<PipelineStageTranslation>;
  /** An edge for our `PipelineStageTranslation`. May be used by Relay 1. */
  pipelineStageTranslationEdge?: Maybe<PipelineStageTranslationsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our create `PipelineStageTranslation` mutation. */
export type CreatePipelineStageTranslationPayloadPipelineStageTranslationEdgeArgs = {
  orderBy?: InputMaybe<Array<PipelineStageTranslationsOrderBy>>;
};

/** All input for the create `PipelineStageUser` mutation. */
export type CreatePipelineStageUserInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The `PipelineStageUser` to be created by this mutation. */
  pipelineStageUser: PipelineStageUserInput;
};

/** The output of our create `PipelineStageUser` mutation. */
export type CreatePipelineStageUserPayload = {
  __typename?: 'CreatePipelineStageUserPayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Reads a single `PipelineStage` that is related to this `PipelineStageUser`. */
  pipelineStage?: Maybe<PipelineStage>;
  /** The `PipelineStageUser` that was created by this mutation. */
  pipelineStageUser?: Maybe<PipelineStageUser>;
  /** An edge for our `PipelineStageUser`. May be used by Relay 1. */
  pipelineStageUserEdge?: Maybe<PipelineStageUsersEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `User` that is related to this `PipelineStageUser`. */
  user?: Maybe<User>;
};


/** The output of our create `PipelineStageUser` mutation. */
export type CreatePipelineStageUserPayloadPipelineStageUserEdgeArgs = {
  orderBy?: InputMaybe<Array<PipelineStageUsersOrderBy>>;
};

/** All input for the create `PipelineTranslation` mutation. */
export type CreatePipelineTranslationInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The `PipelineTranslation` to be created by this mutation. */
  pipelineTranslation: PipelineTranslationInput;
};

/** The output of our create `PipelineTranslation` mutation. */
export type CreatePipelineTranslationPayload = {
  __typename?: 'CreatePipelineTranslationPayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Reads a single `Pipeline` that is related to this `PipelineTranslation`. */
  pipeline?: Maybe<Pipeline>;
  /** The `PipelineTranslation` that was created by this mutation. */
  pipelineTranslation?: Maybe<PipelineTranslation>;
  /** An edge for our `PipelineTranslation`. May be used by Relay 1. */
  pipelineTranslationEdge?: Maybe<PipelineTranslationsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our create `PipelineTranslation` mutation. */
export type CreatePipelineTranslationPayloadPipelineTranslationEdgeArgs = {
  orderBy?: InputMaybe<Array<PipelineTranslationsOrderBy>>;
};

export type CreatePresignedUploadLinkInput = {
  mimeType: Scalars['String']['input'];
};

export type CreatePresignedUploadLinkPayload = {
  __typename?: 'CreatePresignedUploadLinkPayload';
  fileKey: Scalars['UUID']['output'];
  formData: Scalars['JSON']['output'];
  getURL: Scalars['String']['output'];
  postURL: Scalars['String']['output'];
};

/** All input for the create `Question` mutation. */
export type CreateQuestionInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The `Question` to be created by this mutation. */
  question: QuestionInput;
};

/** All input for the create `QuestionOption` mutation. */
export type CreateQuestionOptionInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The `QuestionOption` to be created by this mutation. */
  questionOption: QuestionOptionInput;
};

/** The output of our create `QuestionOption` mutation. */
export type CreateQuestionOptionPayload = {
  __typename?: 'CreateQuestionOptionPayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `Question` that is related to this `QuestionOption`. */
  question?: Maybe<Question>;
  /** The `QuestionOption` that was created by this mutation. */
  questionOption?: Maybe<QuestionOption>;
  /** An edge for our `QuestionOption`. May be used by Relay 1. */
  questionOptionEdge?: Maybe<QuestionOptionsEdge>;
};


/** The output of our create `QuestionOption` mutation. */
export type CreateQuestionOptionPayloadQuestionOptionEdgeArgs = {
  orderBy?: InputMaybe<Array<QuestionOptionsOrderBy>>;
};

/** All input for the create `QuestionOptionTranslation` mutation. */
export type CreateQuestionOptionTranslationInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The `QuestionOptionTranslation` to be created by this mutation. */
  questionOptionTranslation: QuestionOptionTranslationInput;
};

/** The output of our create `QuestionOptionTranslation` mutation. */
export type CreateQuestionOptionTranslationPayload = {
  __typename?: 'CreateQuestionOptionTranslationPayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `QuestionOption` that is related to this `QuestionOptionTranslation`. */
  questionOption?: Maybe<QuestionOption>;
  /** The `QuestionOptionTranslation` that was created by this mutation. */
  questionOptionTranslation?: Maybe<QuestionOptionTranslation>;
  /** An edge for our `QuestionOptionTranslation`. May be used by Relay 1. */
  questionOptionTranslationEdge?: Maybe<QuestionOptionTranslationsEdge>;
};


/** The output of our create `QuestionOptionTranslation` mutation. */
export type CreateQuestionOptionTranslationPayloadQuestionOptionTranslationEdgeArgs = {
  orderBy?: InputMaybe<Array<QuestionOptionTranslationsOrderBy>>;
};

/** The output of our create `Question` mutation. */
export type CreateQuestionPayload = {
  __typename?: 'CreateQuestionPayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** The `Question` that was created by this mutation. */
  question?: Maybe<Question>;
  /** An edge for our `Question`. May be used by Relay 1. */
  questionEdge?: Maybe<QuestionsEdge>;
};


/** The output of our create `Question` mutation. */
export type CreateQuestionPayloadQuestionEdgeArgs = {
  orderBy?: InputMaybe<Array<QuestionsOrderBy>>;
};

/** All input for the create `QuestionTranslation` mutation. */
export type CreateQuestionTranslationInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The `QuestionTranslation` to be created by this mutation. */
  questionTranslation: QuestionTranslationInput;
};

/** The output of our create `QuestionTranslation` mutation. */
export type CreateQuestionTranslationPayload = {
  __typename?: 'CreateQuestionTranslationPayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `Question` that is related to this `QuestionTranslation`. */
  question?: Maybe<Question>;
  /** The `QuestionTranslation` that was created by this mutation. */
  questionTranslation?: Maybe<QuestionTranslation>;
  /** An edge for our `QuestionTranslation`. May be used by Relay 1. */
  questionTranslationEdge?: Maybe<QuestionTranslationsEdge>;
};


/** The output of our create `QuestionTranslation` mutation. */
export type CreateQuestionTranslationPayloadQuestionTranslationEdgeArgs = {
  orderBy?: InputMaybe<Array<QuestionTranslationsOrderBy>>;
};

/** All input for the create `Questionnaire` mutation. */
export type CreateQuestionnaireInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The `Questionnaire` to be created by this mutation. */
  questionnaire: QuestionnaireInput;
};

/** The output of our create `Questionnaire` mutation. */
export type CreateQuestionnairePayload = {
  __typename?: 'CreateQuestionnairePayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** The `Questionnaire` that was created by this mutation. */
  questionnaire?: Maybe<Questionnaire>;
  /** An edge for our `Questionnaire`. May be used by Relay 1. */
  questionnaireEdge?: Maybe<QuestionnairesEdge>;
};


/** The output of our create `Questionnaire` mutation. */
export type CreateQuestionnairePayloadQuestionnaireEdgeArgs = {
  orderBy?: InputMaybe<Array<QuestionnairesOrderBy>>;
};

/** All input for the create `QuestionnaireQuestion` mutation. */
export type CreateQuestionnaireQuestionInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The `QuestionnaireQuestion` to be created by this mutation. */
  questionnaireQuestion: QuestionnaireQuestionInput;
};

/** The output of our create `QuestionnaireQuestion` mutation. */
export type CreateQuestionnaireQuestionPayload = {
  __typename?: 'CreateQuestionnaireQuestionPayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `Question` that is related to this `QuestionnaireQuestion`. */
  question?: Maybe<Question>;
  /** Reads a single `Questionnaire` that is related to this `QuestionnaireQuestion`. */
  questionnaire?: Maybe<Questionnaire>;
  /** The `QuestionnaireQuestion` that was created by this mutation. */
  questionnaireQuestion?: Maybe<QuestionnaireQuestion>;
  /** An edge for our `QuestionnaireQuestion`. May be used by Relay 1. */
  questionnaireQuestionEdge?: Maybe<QuestionnaireQuestionsEdge>;
};


/** The output of our create `QuestionnaireQuestion` mutation. */
export type CreateQuestionnaireQuestionPayloadQuestionnaireQuestionEdgeArgs = {
  orderBy?: InputMaybe<Array<QuestionnaireQuestionsOrderBy>>;
};

/** All input for the create `QuestionnaireTranslation` mutation. */
export type CreateQuestionnaireTranslationInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The `QuestionnaireTranslation` to be created by this mutation. */
  questionnaireTranslation: QuestionnaireTranslationInput;
};

/** The output of our create `QuestionnaireTranslation` mutation. */
export type CreateQuestionnaireTranslationPayload = {
  __typename?: 'CreateQuestionnaireTranslationPayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `Questionnaire` that is related to this `QuestionnaireTranslation`. */
  questionnaire?: Maybe<Questionnaire>;
  /** The `QuestionnaireTranslation` that was created by this mutation. */
  questionnaireTranslation?: Maybe<QuestionnaireTranslation>;
  /** An edge for our `QuestionnaireTranslation`. May be used by Relay 1. */
  questionnaireTranslationEdge?: Maybe<QuestionnaireTranslationsEdge>;
};


/** The output of our create `QuestionnaireTranslation` mutation. */
export type CreateQuestionnaireTranslationPayloadQuestionnaireTranslationEdgeArgs = {
  orderBy?: InputMaybe<Array<QuestionnaireTranslationsOrderBy>>;
};

/** All input for the create `Role` mutation. */
export type CreateRoleInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The `Role` to be created by this mutation. */
  role: RoleInput;
};

/** The output of our create `Role` mutation. */
export type CreateRolePayload = {
  __typename?: 'CreateRolePayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** The `Role` that was created by this mutation. */
  role?: Maybe<Role>;
  /** An edge for our `Role`. May be used by Relay 1. */
  roleEdge?: Maybe<RolesEdge>;
};


/** The output of our create `Role` mutation. */
export type CreateRolePayloadRoleEdgeArgs = {
  orderBy?: InputMaybe<Array<RolesOrderBy>>;
};

/** All input for the create `RoleTranslation` mutation. */
export type CreateRoleTranslationInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The `RoleTranslation` to be created by this mutation. */
  roleTranslation: RoleTranslationInput;
};

/** The output of our create `RoleTranslation` mutation. */
export type CreateRoleTranslationPayload = {
  __typename?: 'CreateRoleTranslationPayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `Role` that is related to this `RoleTranslation`. */
  role?: Maybe<Role>;
  /** The `RoleTranslation` that was created by this mutation. */
  roleTranslation?: Maybe<RoleTranslation>;
  /** An edge for our `RoleTranslation`. May be used by Relay 1. */
  roleTranslationEdge?: Maybe<RoleTranslationsEdge>;
};


/** The output of our create `RoleTranslation` mutation. */
export type CreateRoleTranslationPayloadRoleTranslationEdgeArgs = {
  orderBy?: InputMaybe<Array<RoleTranslationsOrderBy>>;
};

/** All input for the create `ScorecardCriteria` mutation. */
export type CreateScorecardCriteriaInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The `ScorecardCriteria` to be created by this mutation. */
  scorecardCriteria: ScorecardCriteriaInput;
};

/** The output of our create `ScorecardCriteria` mutation. */
export type CreateScorecardCriteriaPayload = {
  __typename?: 'CreateScorecardCriteriaPayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `Scorecard` that is related to this `ScorecardCriteria`. */
  scorecard?: Maybe<Scorecard>;
  /** The `ScorecardCriteria` that was created by this mutation. */
  scorecardCriteria?: Maybe<ScorecardCriteria>;
  /** An edge for our `ScorecardCriteria`. May be used by Relay 1. */
  scorecardCriteriaEdge?: Maybe<ScorecardCriteriaEdge>;
};


/** The output of our create `ScorecardCriteria` mutation. */
export type CreateScorecardCriteriaPayloadScorecardCriteriaEdgeArgs = {
  orderBy?: InputMaybe<Array<ScorecardCriteriaOrderBy>>;
};

/** All input for the create `ScorecardCriteriaTranslation` mutation. */
export type CreateScorecardCriteriaTranslationInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The `ScorecardCriteriaTranslation` to be created by this mutation. */
  scorecardCriteriaTranslation: ScorecardCriteriaTranslationInput;
};

/** The output of our create `ScorecardCriteriaTranslation` mutation. */
export type CreateScorecardCriteriaTranslationPayload = {
  __typename?: 'CreateScorecardCriteriaTranslationPayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `ScorecardCriteria` that is related to this `ScorecardCriteriaTranslation`. */
  scorecardCriteria?: Maybe<ScorecardCriteria>;
  /** The `ScorecardCriteriaTranslation` that was created by this mutation. */
  scorecardCriteriaTranslation?: Maybe<ScorecardCriteriaTranslation>;
  /** An edge for our `ScorecardCriteriaTranslation`. May be used by Relay 1. */
  scorecardCriteriaTranslationEdge?: Maybe<ScorecardCriteriaTranslationsEdge>;
};


/** The output of our create `ScorecardCriteriaTranslation` mutation. */
export type CreateScorecardCriteriaTranslationPayloadScorecardCriteriaTranslationEdgeArgs = {
  orderBy?: InputMaybe<Array<ScorecardCriteriaTranslationsOrderBy>>;
};

/** All input for the create `Scorecard` mutation. */
export type CreateScorecardInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The `Scorecard` to be created by this mutation. */
  scorecard: ScorecardInput;
};

/** The output of our create `Scorecard` mutation. */
export type CreateScorecardPayload = {
  __typename?: 'CreateScorecardPayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** The `Scorecard` that was created by this mutation. */
  scorecard?: Maybe<Scorecard>;
  /** An edge for our `Scorecard`. May be used by Relay 1. */
  scorecardEdge?: Maybe<ScorecardsEdge>;
};


/** The output of our create `Scorecard` mutation. */
export type CreateScorecardPayloadScorecardEdgeArgs = {
  orderBy?: InputMaybe<Array<ScorecardsOrderBy>>;
};

/** All input for the create `ScorecardTranslation` mutation. */
export type CreateScorecardTranslationInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The `ScorecardTranslation` to be created by this mutation. */
  scorecardTranslation: ScorecardTranslationInput;
};

/** The output of our create `ScorecardTranslation` mutation. */
export type CreateScorecardTranslationPayload = {
  __typename?: 'CreateScorecardTranslationPayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `Scorecard` that is related to this `ScorecardTranslation`. */
  scorecard?: Maybe<Scorecard>;
  /** The `ScorecardTranslation` that was created by this mutation. */
  scorecardTranslation?: Maybe<ScorecardTranslation>;
  /** An edge for our `ScorecardTranslation`. May be used by Relay 1. */
  scorecardTranslationEdge?: Maybe<ScorecardTranslationsEdge>;
};


/** The output of our create `ScorecardTranslation` mutation. */
export type CreateScorecardTranslationPayloadScorecardTranslationEdgeArgs = {
  orderBy?: InputMaybe<Array<ScorecardTranslationsOrderBy>>;
};

/** All input for the create `Skill` mutation. */
export type CreateSkillInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The `Skill` to be created by this mutation. */
  skill: SkillInput;
};

/** The output of our create `Skill` mutation. */
export type CreateSkillPayload = {
  __typename?: 'CreateSkillPayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** The `Skill` that was created by this mutation. */
  skill?: Maybe<Skill>;
  /** An edge for our `Skill`. May be used by Relay 1. */
  skillEdge?: Maybe<SkillsEdge>;
};


/** The output of our create `Skill` mutation. */
export type CreateSkillPayloadSkillEdgeArgs = {
  orderBy?: InputMaybe<Array<SkillsOrderBy>>;
};

/** All input for the create `Tag` mutation. */
export type CreateTagInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The `Tag` to be created by this mutation. */
  tag: TagInput;
};

/** The output of our create `Tag` mutation. */
export type CreateTagPayload = {
  __typename?: 'CreateTagPayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** The `Tag` that was created by this mutation. */
  tag?: Maybe<Tag>;
  /** An edge for our `Tag`. May be used by Relay 1. */
  tagEdge?: Maybe<TagsEdge>;
};


/** The output of our create `Tag` mutation. */
export type CreateTagPayloadTagEdgeArgs = {
  orderBy?: InputMaybe<Array<TagsOrderBy>>;
};

/** All input for the create `Thread` mutation. */
export type CreateThreadInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The `Thread` to be created by this mutation. */
  thread: ThreadInput;
};

/** The output of our create `Thread` mutation. */
export type CreateThreadPayload = {
  __typename?: 'CreateThreadPayload';
  /** Reads a single `Candidate` that is related to this `Thread`. */
  candidate?: Maybe<Candidate>;
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Reads a single `Job` that is related to this `Thread`. */
  job?: Maybe<Job>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** The `Thread` that was created by this mutation. */
  thread?: Maybe<Thread>;
  /** An edge for our `Thread`. May be used by Relay 1. */
  threadEdge?: Maybe<ThreadsEdge>;
  /** Reads a single `User` that is related to this `Thread`. */
  user?: Maybe<User>;
};


/** The output of our create `Thread` mutation. */
export type CreateThreadPayloadThreadEdgeArgs = {
  orderBy?: InputMaybe<Array<ThreadsOrderBy>>;
};

/** All input for the create `ThreadUser` mutation. */
export type CreateThreadUserInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The `ThreadUser` to be created by this mutation. */
  threadUser: ThreadUserInput;
};

/** The output of our create `ThreadUser` mutation. */
export type CreateThreadUserPayload = {
  __typename?: 'CreateThreadUserPayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `Thread` that is related to this `ThreadUser`. */
  thread?: Maybe<Thread>;
  /** The `ThreadUser` that was created by this mutation. */
  threadUser?: Maybe<ThreadUser>;
  /** An edge for our `ThreadUser`. May be used by Relay 1. */
  threadUserEdge?: Maybe<ThreadUsersEdge>;
  /** Reads a single `User` that is related to this `ThreadUser`. */
  user?: Maybe<User>;
};


/** The output of our create `ThreadUser` mutation. */
export type CreateThreadUserPayloadThreadUserEdgeArgs = {
  orderBy?: InputMaybe<Array<ThreadUsersOrderBy>>;
};

/** All input for the create `UserInvitation` mutation. */
export type CreateUserInvitationInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The `UserInvitation` to be created by this mutation. */
  userInvitation: UserInvitationInput;
};

/** The output of our create `UserInvitation` mutation. */
export type CreateUserInvitationPayload = {
  __typename?: 'CreateUserInvitationPayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `Role` that is related to this `UserInvitation`. */
  role?: Maybe<Role>;
  /** The `UserInvitation` that was created by this mutation. */
  userInvitation?: Maybe<UserInvitation>;
  /** An edge for our `UserInvitation`. May be used by Relay 1. */
  userInvitationEdge?: Maybe<UserInvitationsEdge>;
};


/** The output of our create `UserInvitation` mutation. */
export type CreateUserInvitationPayloadUserInvitationEdgeArgs = {
  orderBy?: InputMaybe<Array<UserInvitationsOrderBy>>;
};

/** All input for the `createUserToken` mutation. */
export type CreateUserTokenInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  email: Scalars['String']['input'];
  password: Scalars['String']['input'];
};

/** The output of our `createUserToken` mutation. */
export type CreateUserTokenPayload = {
  __typename?: 'CreateUserTokenPayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  userToken?: Maybe<UserToken>;
};

/** All input for the create `UserTranslation` mutation. */
export type CreateUserTranslationInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The `UserTranslation` to be created by this mutation. */
  userTranslation: UserTranslationInput;
};

/** The output of our create `UserTranslation` mutation. */
export type CreateUserTranslationPayload = {
  __typename?: 'CreateUserTranslationPayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `User` that is related to this `UserTranslation`. */
  user?: Maybe<User>;
  /** The `UserTranslation` that was created by this mutation. */
  userTranslation?: Maybe<UserTranslation>;
  /** An edge for our `UserTranslation`. May be used by Relay 1. */
  userTranslationEdge?: Maybe<UserTranslationsEdge>;
};


/** The output of our create `UserTranslation` mutation. */
export type CreateUserTranslationPayloadUserTranslationEdgeArgs = {
  orderBy?: InputMaybe<Array<UserTranslationsOrderBy>>;
};

/** All input for the create `WebsiteFile` mutation. */
export type CreateWebsiteFileInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The `WebsiteFile` to be created by this mutation. */
  websiteFile: WebsiteFileInput;
};

/** The output of our create `WebsiteFile` mutation. */
export type CreateWebsiteFilePayload = {
  __typename?: 'CreateWebsiteFilePayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `Website` that is related to this `WebsiteFile`. */
  website?: Maybe<Website>;
  /** The `WebsiteFile` that was created by this mutation. */
  websiteFile?: Maybe<WebsiteFile>;
  /** An edge for our `WebsiteFile`. May be used by Relay 1. */
  websiteFileEdge?: Maybe<WebsiteFilesEdge>;
};


/** The output of our create `WebsiteFile` mutation. */
export type CreateWebsiteFilePayloadWebsiteFileEdgeArgs = {
  orderBy?: InputMaybe<Array<WebsiteFilesOrderBy>>;
};

export type CustomCompaniesConnection = {
  __typename?: 'CustomCompaniesConnection';
  nodes?: Maybe<Array<CustomCompany_>>;
};

export type CustomCompany = {
  __typename?: 'CustomCompany';
  coverUrl?: Maybe<Scalars['String']['output']>;
  id: Scalars['Int']['output'];
  logoUrl?: Maybe<Scalars['String']['output']>;
  name?: Maybe<Scalars['String']['output']>;
  websiteUrl: Scalars['String']['output'];
};

export type CustomCompany_ = {
  __typename?: 'CustomCompany_';
  companyId: Scalars['Int']['output'];
  jobIds?: Maybe<Array<Scalars['Int']['output']>>;
};

export type CustomJob = {
  __typename?: 'CustomJob';
  description?: Maybe<Scalars['Html']['output']>;
  genders?: Maybe<Array<Maybe<Gender>>>;
  id: Scalars['Int']['output'];
  tags?: Maybe<Array<Maybe<Scalars['String']['output']>>>;
  title: Scalars['String']['output'];
  url: Scalars['String']['output'];
};

export type CustomJobsConnection = {
  __typename?: 'CustomJobsConnection';
  nodes?: Maybe<Array<CustomJob>>;
};

export type CustomTag = {
  __typename?: 'CustomTag';
  id: Scalars['Int']['output'];
  title: Scalars['String']['output'];
};

export type CustomTagsConnection = {
  __typename?: 'CustomTagsConnection';
  nodes?: Maybe<Array<CustomTag>>;
};

/** A filter to be used against Datetime fields. All fields are combined with a logical ‘and.’ */
export type DatetimeFilter = {
  /** Not equal to the specified value, treating null like an ordinary value. */
  distinctFrom?: InputMaybe<Scalars['Datetime']['input']>;
  /** Equal to the specified value. */
  equalTo?: InputMaybe<Scalars['Datetime']['input']>;
  /** Greater than the specified value. */
  greaterThan?: InputMaybe<Scalars['Datetime']['input']>;
  /** Greater than or equal to the specified value. */
  greaterThanOrEqualTo?: InputMaybe<Scalars['Datetime']['input']>;
  /** Included in the specified list. */
  in?: InputMaybe<Array<Scalars['Datetime']['input']>>;
  /** Is null (if `true` is specified) or is not null (if `false` is specified). */
  isNull?: InputMaybe<Scalars['Boolean']['input']>;
  /** Less than the specified value. */
  lessThan?: InputMaybe<Scalars['Datetime']['input']>;
  /** Less than or equal to the specified value. */
  lessThanOrEqualTo?: InputMaybe<Scalars['Datetime']['input']>;
  /** Equal to the specified value, treating null like an ordinary value. */
  notDistinctFrom?: InputMaybe<Scalars['Datetime']['input']>;
  /** Not equal to the specified value. */
  notEqualTo?: InputMaybe<Scalars['Datetime']['input']>;
  /** Not included in the specified list. */
  notIn?: InputMaybe<Array<Scalars['Datetime']['input']>>;
};

/** All input for the `deleteCandidateFileByNodeId` mutation. */
export type DeleteCandidateFileByNodeIdInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `CandidateFile` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** All input for the `deleteCandidateFile` mutation. */
export type DeleteCandidateFileInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  externalId: Scalars['UUID']['input'];
};

/** The output of our delete `CandidateFile` mutation. */
export type DeleteCandidateFilePayload = {
  __typename?: 'DeleteCandidateFilePayload';
  /** Reads a single `Candidate` that is related to this `CandidateFile`. */
  candidate?: Maybe<Candidate>;
  /** The `CandidateFile` that was deleted by this mutation. */
  candidateFile?: Maybe<CandidateFile>;
  /** An edge for our `CandidateFile`. May be used by Relay 1. */
  candidateFileEdge?: Maybe<CandidateFilesEdge>;
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  deletedCandidateFileNodeId?: Maybe<Scalars['ID']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our delete `CandidateFile` mutation. */
export type DeleteCandidateFilePayloadCandidateFileEdgeArgs = {
  orderBy?: InputMaybe<Array<CandidateFilesOrderBy>>;
};

/** All input for the `deleteCandidateTagByNodeId` mutation. */
export type DeleteCandidateTagByNodeIdInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `CandidateTag` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** All input for the `deleteCandidateTag` mutation. */
export type DeleteCandidateTagInput = {
  candidateId: Scalars['Int']['input'];
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  tagId: Scalars['Int']['input'];
  type: CandidateTagType;
};

/** The output of our delete `CandidateTag` mutation. */
export type DeleteCandidateTagPayload = {
  __typename?: 'DeleteCandidateTagPayload';
  /** Reads a single `Candidate` that is related to this `CandidateTag`. */
  candidate?: Maybe<Candidate>;
  /** The `CandidateTag` that was deleted by this mutation. */
  candidateTag?: Maybe<CandidateTag>;
  /** An edge for our `CandidateTag`. May be used by Relay 1. */
  candidateTagEdge?: Maybe<CandidateTagsEdge>;
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  deletedCandidateTagNodeId?: Maybe<Scalars['ID']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `Tag` that is related to this `CandidateTag`. */
  tag?: Maybe<Tag>;
};


/** The output of our delete `CandidateTag` mutation. */
export type DeleteCandidateTagPayloadCandidateTagEdgeArgs = {
  orderBy?: InputMaybe<Array<CandidateTagsOrderBy>>;
};

/** All input for the `deleteCandidateTranslationByNodeId` mutation. */
export type DeleteCandidateTranslationByNodeIdInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `CandidateTranslation` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** All input for the `deleteCandidateTranslation` mutation. */
export type DeleteCandidateTranslationInput = {
  candidateId: Scalars['Int']['input'];
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  lang: Language;
};

/** The output of our delete `CandidateTranslation` mutation. */
export type DeleteCandidateTranslationPayload = {
  __typename?: 'DeleteCandidateTranslationPayload';
  /** Reads a single `Candidate` that is related to this `CandidateTranslation`. */
  candidate?: Maybe<Candidate>;
  /** The `CandidateTranslation` that was deleted by this mutation. */
  candidateTranslation?: Maybe<CandidateTranslation>;
  /** An edge for our `CandidateTranslation`. May be used by Relay 1. */
  candidateTranslationEdge?: Maybe<CandidateTranslationsEdge>;
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  deletedCandidateTranslationNodeId?: Maybe<Scalars['ID']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our delete `CandidateTranslation` mutation. */
export type DeleteCandidateTranslationPayloadCandidateTranslationEdgeArgs = {
  orderBy?: InputMaybe<Array<CandidateTranslationsOrderBy>>;
};

/** All input for the `deleteCompanyUserByNodeId` mutation. */
export type DeleteCompanyUserByNodeIdInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `CompanyUser` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** The output of our delete `CompanyUser` mutation. */
export type DeleteCompanyUserPayload = {
  __typename?: 'DeleteCompanyUserPayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The `CompanyUser` that was deleted by this mutation. */
  companyUser?: Maybe<CompanyUser>;
  /** An edge for our `CompanyUser`. May be used by Relay 1. */
  companyUserEdge?: Maybe<CompanyUsersEdge>;
  deletedCompanyUserNodeId?: Maybe<Scalars['ID']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `Role` that is related to this `CompanyUser`. */
  role?: Maybe<Role>;
  /** Reads a single `User` that is related to this `CompanyUser`. */
  user?: Maybe<User>;
};


/** The output of our delete `CompanyUser` mutation. */
export type DeleteCompanyUserPayloadCompanyUserEdgeArgs = {
  orderBy?: InputMaybe<Array<CompanyUsersOrderBy>>;
};

export type DeleteCompanyUserTokenInput = {
  token: Scalars['String']['input'];
};

export type DeleteCompanyUserTokenPayload = {
  __typename?: 'DeleteCompanyUserTokenPayload';
  success?: Maybe<Scalars['Boolean']['output']>;
};

/** All input for the `deleteDepartmentTranslationByNodeId` mutation. */
export type DeleteDepartmentTranslationByNodeIdInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `DepartmentTranslation` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** All input for the `deleteDepartmentTranslation` mutation. */
export type DeleteDepartmentTranslationInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  departmentId: Scalars['Int']['input'];
  lang: Language;
};

/** The output of our delete `DepartmentTranslation` mutation. */
export type DeleteDepartmentTranslationPayload = {
  __typename?: 'DeleteDepartmentTranslationPayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  deletedDepartmentTranslationNodeId?: Maybe<Scalars['ID']['output']>;
  /** Reads a single `Department` that is related to this `DepartmentTranslation`. */
  department?: Maybe<Department>;
  /** The `DepartmentTranslation` that was deleted by this mutation. */
  departmentTranslation?: Maybe<DepartmentTranslation>;
  /** An edge for our `DepartmentTranslation`. May be used by Relay 1. */
  departmentTranslationEdge?: Maybe<DepartmentTranslationsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our delete `DepartmentTranslation` mutation. */
export type DeleteDepartmentTranslationPayloadDepartmentTranslationEdgeArgs = {
  orderBy?: InputMaybe<Array<DepartmentTranslationsOrderBy>>;
};

/** All input for the `deleteDisqualifyReasonTranslationByNodeId` mutation. */
export type DeleteDisqualifyReasonTranslationByNodeIdInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `DisqualifyReasonTranslation` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** All input for the `deleteDisqualifyReasonTranslation` mutation. */
export type DeleteDisqualifyReasonTranslationInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  disqualifyReasonId: Scalars['Int']['input'];
  lang: Language;
};

/** The output of our delete `DisqualifyReasonTranslation` mutation. */
export type DeleteDisqualifyReasonTranslationPayload = {
  __typename?: 'DeleteDisqualifyReasonTranslationPayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  deletedDisqualifyReasonTranslationNodeId?: Maybe<Scalars['ID']['output']>;
  /** Reads a single `DisqualifyReason` that is related to this `DisqualifyReasonTranslation`. */
  disqualifyReason?: Maybe<DisqualifyReason>;
  /** The `DisqualifyReasonTranslation` that was deleted by this mutation. */
  disqualifyReasonTranslation?: Maybe<DisqualifyReasonTranslation>;
  /** An edge for our `DisqualifyReasonTranslation`. May be used by Relay 1. */
  disqualifyReasonTranslationEdge?: Maybe<DisqualifyReasonTranslationsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our delete `DisqualifyReasonTranslation` mutation. */
export type DeleteDisqualifyReasonTranslationPayloadDisqualifyReasonTranslationEdgeArgs = {
  orderBy?: InputMaybe<Array<DisqualifyReasonTranslationsOrderBy>>;
};

/** All input for the `deleteEventCandidateByNodeId` mutation. */
export type DeleteEventCandidateByNodeIdInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `EventCandidate` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** The output of our delete `EventCandidate` mutation. */
export type DeleteEventCandidatePayload = {
  __typename?: 'DeleteEventCandidatePayload';
  /** Reads a single `Candidate` that is related to this `EventCandidate`. */
  candidate?: Maybe<Candidate>;
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  deletedEventCandidateNodeId?: Maybe<Scalars['ID']['output']>;
  /** Reads a single `Event` that is related to this `EventCandidate`. */
  event?: Maybe<Event>;
  /** The `EventCandidate` that was deleted by this mutation. */
  eventCandidate?: Maybe<EventCandidate>;
  /** An edge for our `EventCandidate`. May be used by Relay 1. */
  eventCandidateEdge?: Maybe<EventCandidatesEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our delete `EventCandidate` mutation. */
export type DeleteEventCandidatePayloadEventCandidateEdgeArgs = {
  orderBy?: InputMaybe<Array<EventCandidatesOrderBy>>;
};

/** All input for the `deleteEventScorecardByNodeId` mutation. */
export type DeleteEventScorecardByNodeIdInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `EventScorecard` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** The output of our delete `EventScorecard` mutation. */
export type DeleteEventScorecardPayload = {
  __typename?: 'DeleteEventScorecardPayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  deletedEventScorecardNodeId?: Maybe<Scalars['ID']['output']>;
  /** Reads a single `Event` that is related to this `EventScorecard`. */
  event?: Maybe<Event>;
  /** The `EventScorecard` that was deleted by this mutation. */
  eventScorecard?: Maybe<EventScorecard>;
  /** An edge for our `EventScorecard`. May be used by Relay 1. */
  eventScorecardEdge?: Maybe<EventScorecardsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `Scorecard` that is related to this `EventScorecard`. */
  scorecard?: Maybe<Scorecard>;
};


/** The output of our delete `EventScorecard` mutation. */
export type DeleteEventScorecardPayloadEventScorecardEdgeArgs = {
  orderBy?: InputMaybe<Array<EventScorecardsOrderBy>>;
};

/** All input for the `deleteEventUserByNodeId` mutation. */
export type DeleteEventUserByNodeIdInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `EventUser` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** The output of our delete `EventUser` mutation. */
export type DeleteEventUserPayload = {
  __typename?: 'DeleteEventUserPayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  deletedEventUserNodeId?: Maybe<Scalars['ID']['output']>;
  /** Reads a single `Event` that is related to this `EventUser`. */
  event?: Maybe<Event>;
  /** The `EventUser` that was deleted by this mutation. */
  eventUser?: Maybe<EventUser>;
  /** An edge for our `EventUser`. May be used by Relay 1. */
  eventUserEdge?: Maybe<EventUsersEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `User` that is related to this `EventUser`. */
  user?: Maybe<User>;
};


/** The output of our delete `EventUser` mutation. */
export type DeleteEventUserPayloadEventUserEdgeArgs = {
  orderBy?: InputMaybe<Array<EventUsersOrderBy>>;
};

/** All input for the `deleteFieldByNodeId` mutation. */
export type DeleteFieldByNodeIdInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `Field` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** All input for the `deleteField` mutation. */
export type DeleteFieldInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
};

/** The output of our delete `Field` mutation. */
export type DeleteFieldPayload = {
  __typename?: 'DeleteFieldPayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  deletedJobFieldNodeId?: Maybe<Scalars['ID']['output']>;
  /** The `Field` that was deleted by this mutation. */
  field?: Maybe<Field>;
  /** An edge for our `Field`. May be used by Relay 1. */
  fieldEdge?: Maybe<FieldsEdge>;
  /** Reads a single `Job` that is related to this `Field`. */
  job?: Maybe<Job>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our delete `Field` mutation. */
export type DeleteFieldPayloadFieldEdgeArgs = {
  orderBy?: InputMaybe<Array<FieldsOrderBy>>;
};

/** All input for the `deleteJobCompetencyByNodeId` mutation. */
export type DeleteJobCompetencyByNodeIdInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `JobCompetency` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** All input for the `deleteJobCompetency` mutation. */
export type DeleteJobCompetencyInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  competenceId: Scalars['Int']['input'];
  jobId: Scalars['Int']['input'];
};

/** The output of our delete `JobCompetency` mutation. */
export type DeleteJobCompetencyPayload = {
  __typename?: 'DeleteJobCompetencyPayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Reads a single `Competency` that is related to this `JobCompetency`. */
  competence?: Maybe<Competency>;
  deletedJobCompetencyNodeId?: Maybe<Scalars['ID']['output']>;
  /** Reads a single `Job` that is related to this `JobCompetency`. */
  job?: Maybe<Job>;
  /** The `JobCompetency` that was deleted by this mutation. */
  jobCompetency?: Maybe<JobCompetency>;
  /** An edge for our `JobCompetency`. May be used by Relay 1. */
  jobCompetencyEdge?: Maybe<JobCompetenciesEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our delete `JobCompetency` mutation. */
export type DeleteJobCompetencyPayloadJobCompetencyEdgeArgs = {
  orderBy?: InputMaybe<Array<JobCompetenciesOrderBy>>;
};

/** All input for the `deleteJobKnowledgeByNodeId` mutation. */
export type DeleteJobKnowledgeByNodeIdInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `JobKnowledge` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** All input for the `deleteJobKnowledge` mutation. */
export type DeleteJobKnowledgeInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  jobId: Scalars['Int']['input'];
  knowledgeId: Scalars['Int']['input'];
};

/** The output of our delete `JobKnowledge` mutation. */
export type DeleteJobKnowledgePayload = {
  __typename?: 'DeleteJobKnowledgePayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  deletedJobKnowledgeNodeId?: Maybe<Scalars['ID']['output']>;
  /** Reads a single `Job` that is related to this `JobKnowledge`. */
  job?: Maybe<Job>;
  /** The `JobKnowledge` that was deleted by this mutation. */
  jobKnowledge?: Maybe<JobKnowledge>;
  /** An edge for our `JobKnowledge`. May be used by Relay 1. */
  jobKnowledgeEdge?: Maybe<JobKnowledgesEdge>;
  /** Reads a single `Knowledge` that is related to this `JobKnowledge`. */
  knowledge?: Maybe<Knowledge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our delete `JobKnowledge` mutation. */
export type DeleteJobKnowledgePayloadJobKnowledgeEdgeArgs = {
  orderBy?: InputMaybe<Array<JobKnowledgesOrderBy>>;
};

/** All input for the `deleteJobOwnerByNodeId` mutation. */
export type DeleteJobOwnerByNodeIdInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `JobOwner` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** All input for the `deleteJobOwner` mutation. */
export type DeleteJobOwnerInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  jobId: Scalars['Int']['input'];
  userId: Scalars['Int']['input'];
};

/** The output of our delete `JobOwner` mutation. */
export type DeleteJobOwnerPayload = {
  __typename?: 'DeleteJobOwnerPayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  deletedJobOwnerNodeId?: Maybe<Scalars['ID']['output']>;
  /** Reads a single `Job` that is related to this `JobOwner`. */
  job?: Maybe<Job>;
  /** The `JobOwner` that was deleted by this mutation. */
  jobOwner?: Maybe<JobOwner>;
  /** An edge for our `JobOwner`. May be used by Relay 1. */
  jobOwnerEdge?: Maybe<JobOwnersEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `User` that is related to this `JobOwner`. */
  user?: Maybe<User>;
};


/** The output of our delete `JobOwner` mutation. */
export type DeleteJobOwnerPayloadJobOwnerEdgeArgs = {
  orderBy?: InputMaybe<Array<JobOwnersOrderBy>>;
};

/** All input for the `deleteJobSkillByNodeId` mutation. */
export type DeleteJobSkillByNodeIdInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `JobSkill` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** All input for the `deleteJobSkill` mutation. */
export type DeleteJobSkillInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  jobId: Scalars['Int']['input'];
  skillId: Scalars['Int']['input'];
};

/** The output of our delete `JobSkill` mutation. */
export type DeleteJobSkillPayload = {
  __typename?: 'DeleteJobSkillPayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  deletedJobSkillNodeId?: Maybe<Scalars['ID']['output']>;
  /** Reads a single `Job` that is related to this `JobSkill`. */
  job?: Maybe<Job>;
  /** The `JobSkill` that was deleted by this mutation. */
  jobSkill?: Maybe<JobSkill>;
  /** An edge for our `JobSkill`. May be used by Relay 1. */
  jobSkillEdge?: Maybe<JobSkillsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `Skill` that is related to this `JobSkill`. */
  skill?: Maybe<Skill>;
};


/** The output of our delete `JobSkill` mutation. */
export type DeleteJobSkillPayloadJobSkillEdgeArgs = {
  orderBy?: InputMaybe<Array<JobSkillsOrderBy>>;
};

/** All input for the `deleteJobTagByNodeId` mutation. */
export type DeleteJobTagByNodeIdInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `JobTag` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** All input for the `deleteJobTag` mutation. */
export type DeleteJobTagInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  jobId: Scalars['Int']['input'];
  tagId: Scalars['Int']['input'];
};

/** The output of our delete `JobTag` mutation. */
export type DeleteJobTagPayload = {
  __typename?: 'DeleteJobTagPayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  deletedJobTagNodeId?: Maybe<Scalars['ID']['output']>;
  /** Reads a single `Job` that is related to this `JobTag`. */
  job?: Maybe<Job>;
  /** The `JobTag` that was deleted by this mutation. */
  jobTag?: Maybe<JobTag>;
  /** An edge for our `JobTag`. May be used by Relay 1. */
  jobTagEdge?: Maybe<JobTagsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `Tag` that is related to this `JobTag`. */
  tag?: Maybe<Tag>;
};


/** The output of our delete `JobTag` mutation. */
export type DeleteJobTagPayloadJobTagEdgeArgs = {
  orderBy?: InputMaybe<Array<JobTagsOrderBy>>;
};

/** All input for the `deleteJobTranslationByNodeId` mutation. */
export type DeleteJobTranslationByNodeIdInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `JobTranslation` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** All input for the `deleteJobTranslation` mutation. */
export type DeleteJobTranslationInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  jobId: Scalars['Int']['input'];
  lang: Language;
};

/** The output of our delete `JobTranslation` mutation. */
export type DeleteJobTranslationPayload = {
  __typename?: 'DeleteJobTranslationPayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  deletedJobTranslationNodeId?: Maybe<Scalars['ID']['output']>;
  /** Reads a single `Job` that is related to this `JobTranslation`. */
  job?: Maybe<Job>;
  /** The `JobTranslation` that was deleted by this mutation. */
  jobTranslation?: Maybe<JobTranslation>;
  /** An edge for our `JobTranslation`. May be used by Relay 1. */
  jobTranslationEdge?: Maybe<JobTranslationsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our delete `JobTranslation` mutation. */
export type DeleteJobTranslationPayloadJobTranslationEdgeArgs = {
  orderBy?: InputMaybe<Array<JobTranslationsOrderBy>>;
};

/** All input for the `deletePipelineStageByNodeId` mutation. */
export type DeletePipelineStageByNodeIdInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `PipelineStage` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** All input for the `deletePipelineStage` mutation. */
export type DeletePipelineStageInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
};

/** The output of our delete `PipelineStage` mutation. */
export type DeletePipelineStagePayload = {
  __typename?: 'DeletePipelineStagePayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  deletedPipelineStageNodeId?: Maybe<Scalars['ID']['output']>;
  /** Reads a single `Pipeline` that is related to this `PipelineStage`. */
  pipeline?: Maybe<Pipeline>;
  /** The `PipelineStage` that was deleted by this mutation. */
  pipelineStage?: Maybe<PipelineStage>;
  /** An edge for our `PipelineStage`. May be used by Relay 1. */
  pipelineStageEdge?: Maybe<PipelineStagesEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our delete `PipelineStage` mutation. */
export type DeletePipelineStagePayloadPipelineStageEdgeArgs = {
  orderBy?: InputMaybe<Array<PipelineStagesOrderBy>>;
};

/** All input for the `deletePipelineStageScorecardByNodeId` mutation. */
export type DeletePipelineStageScorecardByNodeIdInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `PipelineStageScorecard` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** All input for the `deletePipelineStageScorecard` mutation. */
export type DeletePipelineStageScorecardInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  pipelineStageId: Scalars['Int']['input'];
  scorecardId: Scalars['Int']['input'];
};

/** The output of our delete `PipelineStageScorecard` mutation. */
export type DeletePipelineStageScorecardPayload = {
  __typename?: 'DeletePipelineStageScorecardPayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  deletedPipelineStageScorecardNodeId?: Maybe<Scalars['ID']['output']>;
  /** Reads a single `PipelineStage` that is related to this `PipelineStageScorecard`. */
  pipelineStage?: Maybe<PipelineStage>;
  /** The `PipelineStageScorecard` that was deleted by this mutation. */
  pipelineStageScorecard?: Maybe<PipelineStageScorecard>;
  /** An edge for our `PipelineStageScorecard`. May be used by Relay 1. */
  pipelineStageScorecardEdge?: Maybe<PipelineStageScorecardsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `Scorecard` that is related to this `PipelineStageScorecard`. */
  scorecard?: Maybe<Scorecard>;
};


/** The output of our delete `PipelineStageScorecard` mutation. */
export type DeletePipelineStageScorecardPayloadPipelineStageScorecardEdgeArgs = {
  orderBy?: InputMaybe<Array<PipelineStageScorecardsOrderBy>>;
};

/** All input for the `deletePipelineStageTranslationByNodeId` mutation. */
export type DeletePipelineStageTranslationByNodeIdInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `PipelineStageTranslation` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** All input for the `deletePipelineStageTranslation` mutation. */
export type DeletePipelineStageTranslationInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  lang: Language;
  pipelineStageId: Scalars['Int']['input'];
};

/** The output of our delete `PipelineStageTranslation` mutation. */
export type DeletePipelineStageTranslationPayload = {
  __typename?: 'DeletePipelineStageTranslationPayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  deletedPipelineStageTranslationNodeId?: Maybe<Scalars['ID']['output']>;
  /** Reads a single `PipelineStage` that is related to this `PipelineStageTranslation`. */
  pipelineStage?: Maybe<PipelineStage>;
  /** The `PipelineStageTranslation` that was deleted by this mutation. */
  pipelineStageTranslation?: Maybe<PipelineStageTranslation>;
  /** An edge for our `PipelineStageTranslation`. May be used by Relay 1. */
  pipelineStageTranslationEdge?: Maybe<PipelineStageTranslationsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our delete `PipelineStageTranslation` mutation. */
export type DeletePipelineStageTranslationPayloadPipelineStageTranslationEdgeArgs = {
  orderBy?: InputMaybe<Array<PipelineStageTranslationsOrderBy>>;
};

/** All input for the `deletePipelineStageUserByNodeId` mutation. */
export type DeletePipelineStageUserByNodeIdInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `PipelineStageUser` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** All input for the `deletePipelineStageUser` mutation. */
export type DeletePipelineStageUserInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  pipelineStageId: Scalars['Int']['input'];
  userId: Scalars['Int']['input'];
};

/** The output of our delete `PipelineStageUser` mutation. */
export type DeletePipelineStageUserPayload = {
  __typename?: 'DeletePipelineStageUserPayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  deletedPipelineStageUserNodeId?: Maybe<Scalars['ID']['output']>;
  /** Reads a single `PipelineStage` that is related to this `PipelineStageUser`. */
  pipelineStage?: Maybe<PipelineStage>;
  /** The `PipelineStageUser` that was deleted by this mutation. */
  pipelineStageUser?: Maybe<PipelineStageUser>;
  /** An edge for our `PipelineStageUser`. May be used by Relay 1. */
  pipelineStageUserEdge?: Maybe<PipelineStageUsersEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `User` that is related to this `PipelineStageUser`. */
  user?: Maybe<User>;
};


/** The output of our delete `PipelineStageUser` mutation. */
export type DeletePipelineStageUserPayloadPipelineStageUserEdgeArgs = {
  orderBy?: InputMaybe<Array<PipelineStageUsersOrderBy>>;
};

/** All input for the `deletePipelineTranslationByNodeId` mutation. */
export type DeletePipelineTranslationByNodeIdInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `PipelineTranslation` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** All input for the `deletePipelineTranslation` mutation. */
export type DeletePipelineTranslationInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  lang: Language;
  pipelineId: Scalars['Int']['input'];
};

/** The output of our delete `PipelineTranslation` mutation. */
export type DeletePipelineTranslationPayload = {
  __typename?: 'DeletePipelineTranslationPayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  deletedPipelineTranslationNodeId?: Maybe<Scalars['ID']['output']>;
  /** Reads a single `Pipeline` that is related to this `PipelineTranslation`. */
  pipeline?: Maybe<Pipeline>;
  /** The `PipelineTranslation` that was deleted by this mutation. */
  pipelineTranslation?: Maybe<PipelineTranslation>;
  /** An edge for our `PipelineTranslation`. May be used by Relay 1. */
  pipelineTranslationEdge?: Maybe<PipelineTranslationsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our delete `PipelineTranslation` mutation. */
export type DeletePipelineTranslationPayloadPipelineTranslationEdgeArgs = {
  orderBy?: InputMaybe<Array<PipelineTranslationsOrderBy>>;
};

/** All input for the `deleteQuestionOptionByNodeId` mutation. */
export type DeleteQuestionOptionByNodeIdInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `QuestionOption` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** All input for the `deleteQuestionOption` mutation. */
export type DeleteQuestionOptionInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
};

/** The output of our delete `QuestionOption` mutation. */
export type DeleteQuestionOptionPayload = {
  __typename?: 'DeleteQuestionOptionPayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  deletedQuestionOptionNodeId?: Maybe<Scalars['ID']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `Question` that is related to this `QuestionOption`. */
  question?: Maybe<Question>;
  /** The `QuestionOption` that was deleted by this mutation. */
  questionOption?: Maybe<QuestionOption>;
  /** An edge for our `QuestionOption`. May be used by Relay 1. */
  questionOptionEdge?: Maybe<QuestionOptionsEdge>;
};


/** The output of our delete `QuestionOption` mutation. */
export type DeleteQuestionOptionPayloadQuestionOptionEdgeArgs = {
  orderBy?: InputMaybe<Array<QuestionOptionsOrderBy>>;
};

/** All input for the `deleteQuestionOptionTranslationByNodeId` mutation. */
export type DeleteQuestionOptionTranslationByNodeIdInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `QuestionOptionTranslation` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** All input for the `deleteQuestionOptionTranslation` mutation. */
export type DeleteQuestionOptionTranslationInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  lang: Language;
  questionOptionId: Scalars['Int']['input'];
};

/** The output of our delete `QuestionOptionTranslation` mutation. */
export type DeleteQuestionOptionTranslationPayload = {
  __typename?: 'DeleteQuestionOptionTranslationPayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  deletedQuestionOptionTranslationNodeId?: Maybe<Scalars['ID']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `QuestionOption` that is related to this `QuestionOptionTranslation`. */
  questionOption?: Maybe<QuestionOption>;
  /** The `QuestionOptionTranslation` that was deleted by this mutation. */
  questionOptionTranslation?: Maybe<QuestionOptionTranslation>;
  /** An edge for our `QuestionOptionTranslation`. May be used by Relay 1. */
  questionOptionTranslationEdge?: Maybe<QuestionOptionTranslationsEdge>;
};


/** The output of our delete `QuestionOptionTranslation` mutation. */
export type DeleteQuestionOptionTranslationPayloadQuestionOptionTranslationEdgeArgs = {
  orderBy?: InputMaybe<Array<QuestionOptionTranslationsOrderBy>>;
};

/** All input for the `deleteQuestionTranslationByNodeId` mutation. */
export type DeleteQuestionTranslationByNodeIdInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `QuestionTranslation` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** All input for the `deleteQuestionTranslation` mutation. */
export type DeleteQuestionTranslationInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  lang: Language;
  questionId: Scalars['Int']['input'];
};

/** The output of our delete `QuestionTranslation` mutation. */
export type DeleteQuestionTranslationPayload = {
  __typename?: 'DeleteQuestionTranslationPayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  deletedQuestionTranslationNodeId?: Maybe<Scalars['ID']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `Question` that is related to this `QuestionTranslation`. */
  question?: Maybe<Question>;
  /** The `QuestionTranslation` that was deleted by this mutation. */
  questionTranslation?: Maybe<QuestionTranslation>;
  /** An edge for our `QuestionTranslation`. May be used by Relay 1. */
  questionTranslationEdge?: Maybe<QuestionTranslationsEdge>;
};


/** The output of our delete `QuestionTranslation` mutation. */
export type DeleteQuestionTranslationPayloadQuestionTranslationEdgeArgs = {
  orderBy?: InputMaybe<Array<QuestionTranslationsOrderBy>>;
};

/** All input for the `deleteQuestionnaireQuestionByNodeId` mutation. */
export type DeleteQuestionnaireQuestionByNodeIdInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `QuestionnaireQuestion` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** All input for the `deleteQuestionnaireQuestion` mutation. */
export type DeleteQuestionnaireQuestionInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  questionId: Scalars['Int']['input'];
  questionnaireId: Scalars['Int']['input'];
};

/** The output of our delete `QuestionnaireQuestion` mutation. */
export type DeleteQuestionnaireQuestionPayload = {
  __typename?: 'DeleteQuestionnaireQuestionPayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  deletedQuestionnaireQuestionNodeId?: Maybe<Scalars['ID']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `Question` that is related to this `QuestionnaireQuestion`. */
  question?: Maybe<Question>;
  /** Reads a single `Questionnaire` that is related to this `QuestionnaireQuestion`. */
  questionnaire?: Maybe<Questionnaire>;
  /** The `QuestionnaireQuestion` that was deleted by this mutation. */
  questionnaireQuestion?: Maybe<QuestionnaireQuestion>;
  /** An edge for our `QuestionnaireQuestion`. May be used by Relay 1. */
  questionnaireQuestionEdge?: Maybe<QuestionnaireQuestionsEdge>;
};


/** The output of our delete `QuestionnaireQuestion` mutation. */
export type DeleteQuestionnaireQuestionPayloadQuestionnaireQuestionEdgeArgs = {
  orderBy?: InputMaybe<Array<QuestionnaireQuestionsOrderBy>>;
};

/** All input for the `deleteQuestionnaireTranslationByNodeId` mutation. */
export type DeleteQuestionnaireTranslationByNodeIdInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `QuestionnaireTranslation` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** All input for the `deleteQuestionnaireTranslation` mutation. */
export type DeleteQuestionnaireTranslationInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  lang: Language;
  questionnaireId: Scalars['Int']['input'];
};

/** The output of our delete `QuestionnaireTranslation` mutation. */
export type DeleteQuestionnaireTranslationPayload = {
  __typename?: 'DeleteQuestionnaireTranslationPayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  deletedQuestionnaireTranslationNodeId?: Maybe<Scalars['ID']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `Questionnaire` that is related to this `QuestionnaireTranslation`. */
  questionnaire?: Maybe<Questionnaire>;
  /** The `QuestionnaireTranslation` that was deleted by this mutation. */
  questionnaireTranslation?: Maybe<QuestionnaireTranslation>;
  /** An edge for our `QuestionnaireTranslation`. May be used by Relay 1. */
  questionnaireTranslationEdge?: Maybe<QuestionnaireTranslationsEdge>;
};


/** The output of our delete `QuestionnaireTranslation` mutation. */
export type DeleteQuestionnaireTranslationPayloadQuestionnaireTranslationEdgeArgs = {
  orderBy?: InputMaybe<Array<QuestionnaireTranslationsOrderBy>>;
};

/** All input for the `deleteRoleTranslationByNodeId` mutation. */
export type DeleteRoleTranslationByNodeIdInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `RoleTranslation` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** All input for the `deleteRoleTranslation` mutation. */
export type DeleteRoleTranslationInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  lang: Language;
  roleId: Scalars['Int']['input'];
};

/** The output of our delete `RoleTranslation` mutation. */
export type DeleteRoleTranslationPayload = {
  __typename?: 'DeleteRoleTranslationPayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  deletedRoleTranslationNodeId?: Maybe<Scalars['ID']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `Role` that is related to this `RoleTranslation`. */
  role?: Maybe<Role>;
  /** The `RoleTranslation` that was deleted by this mutation. */
  roleTranslation?: Maybe<RoleTranslation>;
  /** An edge for our `RoleTranslation`. May be used by Relay 1. */
  roleTranslationEdge?: Maybe<RoleTranslationsEdge>;
};


/** The output of our delete `RoleTranslation` mutation. */
export type DeleteRoleTranslationPayloadRoleTranslationEdgeArgs = {
  orderBy?: InputMaybe<Array<RoleTranslationsOrderBy>>;
};

/** All input for the `deleteScorecardCriteriaTranslationByNodeId` mutation. */
export type DeleteScorecardCriteriaTranslationByNodeIdInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `ScorecardCriteriaTranslation` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** All input for the `deleteScorecardCriteriaTranslation` mutation. */
export type DeleteScorecardCriteriaTranslationInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  lang: Language;
  scorecardCriteriaId: Scalars['Int']['input'];
};

/** The output of our delete `ScorecardCriteriaTranslation` mutation. */
export type DeleteScorecardCriteriaTranslationPayload = {
  __typename?: 'DeleteScorecardCriteriaTranslationPayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  deletedScorecardCriteriaTranslationNodeId?: Maybe<Scalars['ID']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `ScorecardCriteria` that is related to this `ScorecardCriteriaTranslation`. */
  scorecardCriteria?: Maybe<ScorecardCriteria>;
  /** The `ScorecardCriteriaTranslation` that was deleted by this mutation. */
  scorecardCriteriaTranslation?: Maybe<ScorecardCriteriaTranslation>;
  /** An edge for our `ScorecardCriteriaTranslation`. May be used by Relay 1. */
  scorecardCriteriaTranslationEdge?: Maybe<ScorecardCriteriaTranslationsEdge>;
};


/** The output of our delete `ScorecardCriteriaTranslation` mutation. */
export type DeleteScorecardCriteriaTranslationPayloadScorecardCriteriaTranslationEdgeArgs = {
  orderBy?: InputMaybe<Array<ScorecardCriteriaTranslationsOrderBy>>;
};

/** All input for the `deleteScorecardTranslationByNodeId` mutation. */
export type DeleteScorecardTranslationByNodeIdInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `ScorecardTranslation` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** All input for the `deleteScorecardTranslation` mutation. */
export type DeleteScorecardTranslationInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  lang: Language;
  scorecardId: Scalars['Int']['input'];
};

/** The output of our delete `ScorecardTranslation` mutation. */
export type DeleteScorecardTranslationPayload = {
  __typename?: 'DeleteScorecardTranslationPayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  deletedScorecardTranslationNodeId?: Maybe<Scalars['ID']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `Scorecard` that is related to this `ScorecardTranslation`. */
  scorecard?: Maybe<Scorecard>;
  /** The `ScorecardTranslation` that was deleted by this mutation. */
  scorecardTranslation?: Maybe<ScorecardTranslation>;
  /** An edge for our `ScorecardTranslation`. May be used by Relay 1. */
  scorecardTranslationEdge?: Maybe<ScorecardTranslationsEdge>;
};


/** The output of our delete `ScorecardTranslation` mutation. */
export type DeleteScorecardTranslationPayloadScorecardTranslationEdgeArgs = {
  orderBy?: InputMaybe<Array<ScorecardTranslationsOrderBy>>;
};

/** All input for the `deleteUserTranslationByNodeId` mutation. */
export type DeleteUserTranslationByNodeIdInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `UserTranslation` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** All input for the `deleteUserTranslation` mutation. */
export type DeleteUserTranslationInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  lang: Language;
  userId: Scalars['Int']['input'];
};

/** The output of our delete `UserTranslation` mutation. */
export type DeleteUserTranslationPayload = {
  __typename?: 'DeleteUserTranslationPayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  deletedUserTranslationNodeId?: Maybe<Scalars['ID']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `User` that is related to this `UserTranslation`. */
  user?: Maybe<User>;
  /** The `UserTranslation` that was deleted by this mutation. */
  userTranslation?: Maybe<UserTranslation>;
  /** An edge for our `UserTranslation`. May be used by Relay 1. */
  userTranslationEdge?: Maybe<UserTranslationsEdge>;
};


/** The output of our delete `UserTranslation` mutation. */
export type DeleteUserTranslationPayloadUserTranslationEdgeArgs = {
  orderBy?: InputMaybe<Array<UserTranslationsOrderBy>>;
};

/** All input for the `deleteWebsiteFileByNodeId` mutation. */
export type DeleteWebsiteFileByNodeIdInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `WebsiteFile` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** All input for the `deleteWebsiteFile` mutation. */
export type DeleteWebsiteFileInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  externalId: Scalars['UUID']['input'];
};

/** The output of our delete `WebsiteFile` mutation. */
export type DeleteWebsiteFilePayload = {
  __typename?: 'DeleteWebsiteFilePayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  deletedWebsiteFileNodeId?: Maybe<Scalars['ID']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `Website` that is related to this `WebsiteFile`. */
  website?: Maybe<Website>;
  /** The `WebsiteFile` that was deleted by this mutation. */
  websiteFile?: Maybe<WebsiteFile>;
  /** An edge for our `WebsiteFile`. May be used by Relay 1. */
  websiteFileEdge?: Maybe<WebsiteFilesEdge>;
};


/** The output of our delete `WebsiteFile` mutation. */
export type DeleteWebsiteFilePayloadWebsiteFileEdgeArgs = {
  orderBy?: InputMaybe<Array<WebsiteFilesOrderBy>>;
};

export type Department = Node & {
  __typename?: 'Department';
  createdAt: Scalars['Datetime']['output'];
  id: Scalars['Int']['output'];
  /** Reads and enables pagination through a set of `Job`. */
  jobs: JobsConnection;
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  /** Reads and enables pagination through a set of `Pipeline`. */
  pipelines: DepartmentPipelinesByJobDepartmentIdAndPipelineIdManyToManyConnection;
  /** Reads and enables pagination through a set of `DepartmentTranslation`. */
  translations: DepartmentTranslationsConnection;
  updatedAt: Scalars['Datetime']['output'];
};


export type DepartmentJobsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<JobCondition>;
  filter?: InputMaybe<JobFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<JobsOrderBy>>;
};


export type DepartmentPipelinesArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<PipelineCondition>;
  filter?: InputMaybe<PipelineFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<PipelinesOrderBy>>;
};


export type DepartmentTranslationsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<DepartmentTranslationCondition>;
  filter?: InputMaybe<DepartmentTranslationFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<DepartmentTranslationsOrderBy>>;
};

/** A condition to be used against `Department` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type DepartmentCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['Int']['input']>;
};

/** The fields on `department` to look up the row to connect. */
export type DepartmentDepartmentsPkeyConnect = {
  id: Scalars['Int']['input'];
};

/** A filter to be used against `Department` object types. All fields are combined with a logical ‘and.’ */
export type DepartmentFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<DepartmentFilter>>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<IntFilter>;
  /** Filter by the object’s `jobs` relation. */
  jobs?: InputMaybe<DepartmentToManyJobFilter>;
  /** Some related `jobs` exist. */
  jobsExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Negates the expression. */
  not?: InputMaybe<DepartmentFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<DepartmentFilter>>;
  /** Filter by the object’s `translations` relation. */
  translations?: InputMaybe<DepartmentToManyDepartmentTranslationFilter>;
  /** Some related `translations` exist. */
  translationsExist?: InputMaybe<Scalars['Boolean']['input']>;
};

/** An input for mutations affecting `Department` */
export type DepartmentInput = {
  jobs?: InputMaybe<JobsDepartmentIdFkeyInverseInput>;
  translations?: InputMaybe<DepartmentTranslationsDepartmentIdFkeyInverseInput>;
};

/** The globally unique `ID` look up for the row to connect. */
export type DepartmentNodeIdConnect = {
  /** The globally unique `ID` which identifies a single `department` to be connected. */
  nodeId: Scalars['ID']['input'];
};

/** The globally unique `ID` look up for the row to update. */
export type DepartmentOnDepartmentTranslationForDepartmentTranslationsDepartmentIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `departmentTranslation` to be connected. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `departmentTranslation` being updated. */
  patch: DepartmentTranslationPatch;
};

/** The fields on `department` to look up the row to update. */
export type DepartmentOnDepartmentTranslationForDepartmentTranslationsDepartmentIdFkeyUsingDepartmentsPkeyUpdate = {
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `department` being updated. */
  patch: UpdateDepartmentOnDepartmentTranslationForDepartmentTranslationsDepartmentIdFkeyPatch;
};

/** The globally unique `ID` look up for the row to update. */
export type DepartmentOnJobForJobsDepartmentIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `job` to be connected. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `job` being updated. */
  patch: JobPatch;
};

/** The fields on `department` to look up the row to update. */
export type DepartmentOnJobForJobsDepartmentIdFkeyUsingDepartmentsPkeyUpdate = {
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `department` being updated. */
  patch: UpdateDepartmentOnJobForJobsDepartmentIdFkeyPatch;
};

/** Represents an update to a `Department`. Fields that are set will be updated. */
export type DepartmentPatch = {
  jobs?: InputMaybe<JobsDepartmentIdFkeyInverseInput>;
  translations?: InputMaybe<DepartmentTranslationsDepartmentIdFkeyInverseInput>;
};

export type DepartmentPatch__ = {
  translations: Array<DepartmentTranlationsInput__>;
};

/** A connection to a list of `Pipeline` values, with data from `Job`. */
export type DepartmentPipelinesByJobDepartmentIdAndPipelineIdManyToManyConnection = {
  __typename?: 'DepartmentPipelinesByJobDepartmentIdAndPipelineIdManyToManyConnection';
  /** A list of edges which contains the `Pipeline`, info from the `Job`, and the cursor to aid in pagination. */
  edges: Array<DepartmentPipelinesByJobDepartmentIdAndPipelineIdManyToManyEdge>;
  /** A list of `Pipeline` objects. */
  nodes: Array<Pipeline>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Pipeline` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `Pipeline` edge in the connection, with data from `Job`. */
export type DepartmentPipelinesByJobDepartmentIdAndPipelineIdManyToManyEdge = {
  __typename?: 'DepartmentPipelinesByJobDepartmentIdAndPipelineIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** Reads and enables pagination through a set of `Job`. */
  jobs: JobsConnection;
  /** The `Pipeline` at the end of the edge. */
  node: Pipeline;
};


/** A `Pipeline` edge in the connection, with data from `Job`. */
export type DepartmentPipelinesByJobDepartmentIdAndPipelineIdManyToManyEdgeJobsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<JobCondition>;
  filter?: InputMaybe<JobFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<JobsOrderBy>>;
};

/** A filter to be used against many `DepartmentTranslation` object types. All fields are combined with a logical ‘and.’ */
export type DepartmentToManyDepartmentTranslationFilter = {
  /** Every related `DepartmentTranslation` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<DepartmentTranslationFilter>;
  /** No related `DepartmentTranslation` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<DepartmentTranslationFilter>;
  /** Some related `DepartmentTranslation` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<DepartmentTranslationFilter>;
};

/** A filter to be used against many `Job` object types. All fields are combined with a logical ‘and.’ */
export type DepartmentToManyJobFilter = {
  /** Every related `Job` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<JobFilter>;
  /** No related `Job` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<JobFilter>;
  /** Some related `Job` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<JobFilter>;
};

export type DepartmentTranlationsInput__ = {
  lang: Language;
  title: Scalars['String']['input'];
};

export type DepartmentTranslation = Node & {
  __typename?: 'DepartmentTranslation';
  /** Reads a single `Department` that is related to this `DepartmentTranslation`. */
  department?: Maybe<Department>;
  departmentId: Scalars['Int']['output'];
  lang: Language;
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  title: Scalars['String']['output'];
};

/** A condition to be used against `DepartmentTranslation` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type DepartmentTranslationCondition = {
  /** Checks for equality with the object’s `departmentId` field. */
  departmentId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `title` field. */
  title?: InputMaybe<Scalars['String']['input']>;
};

/** The fields on `departmentTranslation` to look up the row to connect. */
export type DepartmentTranslationDepartmentTranslationsPkeyConnect = {
  departmentId: Scalars['Int']['input'];
  lang: Language;
};

/** The fields on `departmentTranslation` to look up the row to delete. */
export type DepartmentTranslationDepartmentTranslationsPkeyDelete = {
  departmentId: Scalars['Int']['input'];
  lang: Language;
};

/** A filter to be used against `DepartmentTranslation` object types. All fields are combined with a logical ‘and.’ */
export type DepartmentTranslationFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<DepartmentTranslationFilter>>;
  /** Filter by the object’s `department` relation. */
  department?: InputMaybe<DepartmentFilter>;
  /** Filter by the object’s `departmentId` field. */
  departmentId?: InputMaybe<IntFilter>;
  /** Negates the expression. */
  not?: InputMaybe<DepartmentTranslationFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<DepartmentTranslationFilter>>;
  /** Filter by the object’s `title` field. */
  title?: InputMaybe<StringFilter>;
};

/** An input for mutations affecting `DepartmentTranslation` */
export type DepartmentTranslationInput = {
  department?: InputMaybe<DepartmentTranslationsDepartmentIdFkeyInput>;
  departmentId?: InputMaybe<Scalars['Int']['input']>;
  lang: Language;
  title: Scalars['String']['input'];
};

/** The globally unique `ID` look up for the row to connect. */
export type DepartmentTranslationNodeIdConnect = {
  /** The globally unique `ID` which identifies a single `departmentTranslation` to be connected. */
  nodeId: Scalars['ID']['input'];
};

/** The globally unique `ID` look up for the row to delete. */
export type DepartmentTranslationNodeIdDelete = {
  /** The globally unique `ID` which identifies a single `departmentTranslation` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** The globally unique `ID` look up for the row to update. */
export type DepartmentTranslationOnDepartmentTranslationForDepartmentTranslationsDepartmentIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `department` to be connected. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `department` being updated. */
  patch: DepartmentPatch;
};

/** The fields on `departmentTranslation` to look up the row to update. */
export type DepartmentTranslationOnDepartmentTranslationForDepartmentTranslationsDepartmentIdFkeyUsingDepartmentTranslationsPkeyUpdate = {
  departmentId: Scalars['Int']['input'];
  lang: Language;
  /** An object where the defined keys will be set on the `departmentTranslation` being updated. */
  patch: UpdateDepartmentTranslationOnDepartmentTranslationForDepartmentTranslationsDepartmentIdFkeyPatch;
};

/** Represents an update to a `DepartmentTranslation`. Fields that are set will be updated. */
export type DepartmentTranslationPatch = {
  department?: InputMaybe<DepartmentTranslationsDepartmentIdFkeyInput>;
  departmentId?: InputMaybe<Scalars['Int']['input']>;
  title?: InputMaybe<Scalars['String']['input']>;
};

/** A connection to a list of `DepartmentTranslation` values. */
export type DepartmentTranslationsConnection = {
  __typename?: 'DepartmentTranslationsConnection';
  /** A list of edges which contains the `DepartmentTranslation` and cursor to aid in pagination. */
  edges: Array<DepartmentTranslationsEdge>;
  /** A list of `DepartmentTranslation` objects. */
  nodes: Array<DepartmentTranslation>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `DepartmentTranslation` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** The `departmentTranslation` to be created by this mutation. */
export type DepartmentTranslationsDepartmentIdFkeyDepartmentTranslationsCreateInput = {
  department?: InputMaybe<DepartmentTranslationsDepartmentIdFkeyInput>;
  lang: Language;
  title: Scalars['String']['input'];
};

/** The `department` to be created by this mutation. */
export type DepartmentTranslationsDepartmentIdFkeyDepartmentsCreateInput = {
  jobs?: InputMaybe<JobsDepartmentIdFkeyInverseInput>;
  translations?: InputMaybe<DepartmentTranslationsDepartmentIdFkeyInverseInput>;
};

/** Input for the nested mutation of `department` in the `DepartmentTranslationInput` mutation. */
export type DepartmentTranslationsDepartmentIdFkeyInput = {
  /** The primary key(s) for `department` for the far side of the relationship. */
  connectById?: InputMaybe<DepartmentDepartmentsPkeyConnect>;
  /** The primary key(s) for `department` for the far side of the relationship. */
  connectByNodeId?: InputMaybe<DepartmentNodeIdConnect>;
  /** A `DepartmentInput` object that will be created and connected to this object. */
  create?: InputMaybe<DepartmentTranslationsDepartmentIdFkeyDepartmentsCreateInput>;
  /** The primary key(s) and patch data for `department` for the far side of the relationship. */
  updateById?: InputMaybe<DepartmentOnDepartmentTranslationForDepartmentTranslationsDepartmentIdFkeyUsingDepartmentsPkeyUpdate>;
  /** The primary key(s) and patch data for `department` for the far side of the relationship. */
  updateByNodeId?: InputMaybe<DepartmentTranslationOnDepartmentTranslationForDepartmentTranslationsDepartmentIdFkeyNodeIdUpdate>;
};

/** Input for the nested mutation of `departmentTranslation` in the `DepartmentInput` mutation. */
export type DepartmentTranslationsDepartmentIdFkeyInverseInput = {
  /** The primary key(s) for `departmentTranslation` for the far side of the relationship. */
  connectByDepartmentIdAndLang?: InputMaybe<Array<DepartmentTranslationDepartmentTranslationsPkeyConnect>>;
  /** The primary key(s) for `departmentTranslation` for the far side of the relationship. */
  connectByNodeId?: InputMaybe<Array<DepartmentTranslationNodeIdConnect>>;
  /** A `DepartmentTranslationInput` object that will be created and connected to this object. */
  create?: InputMaybe<Array<DepartmentTranslationsDepartmentIdFkeyDepartmentTranslationsCreateInput>>;
  /** The primary key(s) for `departmentTranslation` for the far side of the relationship. */
  deleteByDepartmentIdAndLang?: InputMaybe<Array<DepartmentTranslationDepartmentTranslationsPkeyDelete>>;
  /** The primary key(s) for `departmentTranslation` for the far side of the relationship. */
  deleteByNodeId?: InputMaybe<Array<DepartmentTranslationNodeIdDelete>>;
  /** Flag indicating whether all other `departmentTranslation` records that match this relationship should be removed. */
  deleteOthers?: InputMaybe<Scalars['Boolean']['input']>;
  /** The primary key(s) and patch data for `departmentTranslation` for the far side of the relationship. */
  updateByDepartmentIdAndLang?: InputMaybe<Array<DepartmentTranslationOnDepartmentTranslationForDepartmentTranslationsDepartmentIdFkeyUsingDepartmentTranslationsPkeyUpdate>>;
  /** The primary key(s) and patch data for `departmentTranslation` for the far side of the relationship. */
  updateByNodeId?: InputMaybe<Array<DepartmentOnDepartmentTranslationForDepartmentTranslationsDepartmentIdFkeyNodeIdUpdate>>;
};

/** A `DepartmentTranslation` edge in the connection. */
export type DepartmentTranslationsEdge = {
  __typename?: 'DepartmentTranslationsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `DepartmentTranslation` at the end of the edge. */
  node: DepartmentTranslation;
};

/** Methods to use when ordering `DepartmentTranslation`. */
export enum DepartmentTranslationsOrderBy {
  DepartmentIdAsc = 'DEPARTMENT_ID_ASC',
  DepartmentIdDesc = 'DEPARTMENT_ID_DESC',
  Natural = 'NATURAL',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  TitleAsc = 'TITLE_ASC',
  TitleDesc = 'TITLE_DESC'
}

/** A connection to a list of `Department` values. */
export type DepartmentsConnection = {
  __typename?: 'DepartmentsConnection';
  /** A list of edges which contains the `Department` and cursor to aid in pagination. */
  edges: Array<DepartmentsEdge>;
  /** A list of `Department` objects. */
  nodes: Array<Department>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Department` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `Department` edge in the connection. */
export type DepartmentsEdge = {
  __typename?: 'DepartmentsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Department` at the end of the edge. */
  node: Department;
};

/** Methods to use when ordering `Department`. */
export enum DepartmentsOrderBy {
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  Natural = 'NATURAL',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC'
}

/** All input for the `disableUserFromCompany` mutation. */
export type DisableUserFromCompanyInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
};

/** The output of our `disableUserFromCompany` mutation. */
export type DisableUserFromCompanyPayload = {
  __typename?: 'DisableUserFromCompanyPayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  companyUser?: Maybe<CompanyUser>;
  /** An edge for our `CompanyUser`. May be used by Relay 1. */
  companyUserEdge?: Maybe<CompanyUsersEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `Role` that is related to this `CompanyUser`. */
  role?: Maybe<Role>;
  /** Reads a single `User` that is related to this `CompanyUser`. */
  user?: Maybe<User>;
};


/** The output of our `disableUserFromCompany` mutation. */
export type DisableUserFromCompanyPayloadCompanyUserEdgeArgs = {
  orderBy?: InputMaybe<Array<CompanyUsersOrderBy>>;
};

export type DisqualifyReason = Node & {
  __typename?: 'DisqualifyReason';
  /** Reads and enables pagination through a set of `Candidate`. */
  candidates: DisqualifyReasonCandidatesByJobsApplicationDisqualifyReasonIdAndCandidateIdManyToManyConnection;
  createdAt: Scalars['Datetime']['output'];
  id: Scalars['Int']['output'];
  /** Reads and enables pagination through a set of `Job`. */
  jobs: DisqualifyReasonJobsByJobsApplicationDisqualifyReasonIdAndJobIdManyToManyConnection;
  /** Reads and enables pagination through a set of `JobsApplication`. */
  jobsApplications: JobsApplicationsConnection;
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  /** Reads and enables pagination through a set of `PipelineStage`. */
  pipelineStages: DisqualifyReasonPipelineStagesByJobsApplicationDisqualifyReasonIdAndPipelineStageIdManyToManyConnection;
  position: Scalars['Int']['output'];
  /** Reads and enables pagination through a set of `DisqualifyReasonTranslation`. */
  translations: DisqualifyReasonTranslationsConnection;
  updatedAt: Scalars['Datetime']['output'];
};


export type DisqualifyReasonCandidatesArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<CandidateCondition>;
  filter?: InputMaybe<CandidateFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<CandidatesOrderBy>>;
};


export type DisqualifyReasonJobsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<JobCondition>;
  filter?: InputMaybe<JobFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<JobsOrderBy>>;
};


export type DisqualifyReasonJobsApplicationsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<JobsApplicationCondition>;
  filter?: InputMaybe<JobsApplicationFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<JobsApplicationsOrderBy>>;
};


export type DisqualifyReasonPipelineStagesArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<PipelineStageCondition>;
  filter?: InputMaybe<PipelineStageFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<PipelineStagesOrderBy>>;
};


export type DisqualifyReasonTranslationsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<DisqualifyReasonTranslationCondition>;
  filter?: InputMaybe<DisqualifyReasonTranslationFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<DisqualifyReasonTranslationsOrderBy>>;
};

/** A connection to a list of `Candidate` values, with data from `JobsApplication`. */
export type DisqualifyReasonCandidatesByJobsApplicationDisqualifyReasonIdAndCandidateIdManyToManyConnection = {
  __typename?: 'DisqualifyReasonCandidatesByJobsApplicationDisqualifyReasonIdAndCandidateIdManyToManyConnection';
  /** A list of edges which contains the `Candidate`, info from the `JobsApplication`, and the cursor to aid in pagination. */
  edges: Array<DisqualifyReasonCandidatesByJobsApplicationDisqualifyReasonIdAndCandidateIdManyToManyEdge>;
  /** A list of `Candidate` objects. */
  nodes: Array<Candidate>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Candidate` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `Candidate` edge in the connection, with data from `JobsApplication`. */
export type DisqualifyReasonCandidatesByJobsApplicationDisqualifyReasonIdAndCandidateIdManyToManyEdge = {
  __typename?: 'DisqualifyReasonCandidatesByJobsApplicationDisqualifyReasonIdAndCandidateIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** Reads and enables pagination through a set of `JobsApplication`. */
  jobsApplications: JobsApplicationsConnection;
  /** The `Candidate` at the end of the edge. */
  node: Candidate;
};


/** A `Candidate` edge in the connection, with data from `JobsApplication`. */
export type DisqualifyReasonCandidatesByJobsApplicationDisqualifyReasonIdAndCandidateIdManyToManyEdgeJobsApplicationsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<JobsApplicationCondition>;
  filter?: InputMaybe<JobsApplicationFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<JobsApplicationsOrderBy>>;
};

/** A condition to be used against `DisqualifyReason` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type DisqualifyReasonCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['Int']['input']>;
};

/** The fields on `disqualifyReason` to look up the row to connect. */
export type DisqualifyReasonDisqualifyReasonsPkeyConnect = {
  id: Scalars['Int']['input'];
};

/** A filter to be used against `DisqualifyReason` object types. All fields are combined with a logical ‘and.’ */
export type DisqualifyReasonFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<DisqualifyReasonFilter>>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<IntFilter>;
  /** Filter by the object’s `jobsApplications` relation. */
  jobsApplications?: InputMaybe<DisqualifyReasonToManyJobsApplicationFilter>;
  /** Some related `jobsApplications` exist. */
  jobsApplicationsExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Negates the expression. */
  not?: InputMaybe<DisqualifyReasonFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<DisqualifyReasonFilter>>;
  /** Filter by the object’s `translations` relation. */
  translations?: InputMaybe<DisqualifyReasonToManyDisqualifyReasonTranslationFilter>;
  /** Some related `translations` exist. */
  translationsExist?: InputMaybe<Scalars['Boolean']['input']>;
};

/** An input for mutations affecting `DisqualifyReason` */
export type DisqualifyReasonInput = {
  jobsApplications?: InputMaybe<JobsApplicationsDisqualifyReasonIdFkeyInverseInput>;
  position?: InputMaybe<Scalars['Int']['input']>;
  translations?: InputMaybe<DisqualifyReasonTranslationsDisqualifyReasonIdFkeyInverseInput>;
};

/** A connection to a list of `Job` values, with data from `JobsApplication`. */
export type DisqualifyReasonJobsByJobsApplicationDisqualifyReasonIdAndJobIdManyToManyConnection = {
  __typename?: 'DisqualifyReasonJobsByJobsApplicationDisqualifyReasonIdAndJobIdManyToManyConnection';
  /** A list of edges which contains the `Job`, info from the `JobsApplication`, and the cursor to aid in pagination. */
  edges: Array<DisqualifyReasonJobsByJobsApplicationDisqualifyReasonIdAndJobIdManyToManyEdge>;
  /** A list of `Job` objects. */
  nodes: Array<Job>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Job` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `Job` edge in the connection, with data from `JobsApplication`. */
export type DisqualifyReasonJobsByJobsApplicationDisqualifyReasonIdAndJobIdManyToManyEdge = {
  __typename?: 'DisqualifyReasonJobsByJobsApplicationDisqualifyReasonIdAndJobIdManyToManyEdge';
  /** Reads and enables pagination through a set of `JobsApplication`. */
  applications: JobsApplicationsConnection;
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Job` at the end of the edge. */
  node: Job;
};


/** A `Job` edge in the connection, with data from `JobsApplication`. */
export type DisqualifyReasonJobsByJobsApplicationDisqualifyReasonIdAndJobIdManyToManyEdgeApplicationsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<JobsApplicationCondition>;
  filter?: InputMaybe<JobsApplicationFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<JobsApplicationsOrderBy>>;
};

/** The globally unique `ID` look up for the row to connect. */
export type DisqualifyReasonNodeIdConnect = {
  /** The globally unique `ID` which identifies a single `disqualifyReason` to be connected. */
  nodeId: Scalars['ID']['input'];
};

/** The globally unique `ID` look up for the row to update. */
export type DisqualifyReasonOnDisqualifyReasonTranslationForDisqualifyReasonTranslationsDisqualifyReasonIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `disqualifyReasonTranslation` to be connected. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `disqualifyReasonTranslation` being updated. */
  patch: DisqualifyReasonTranslationPatch;
};

/** The fields on `disqualifyReason` to look up the row to update. */
export type DisqualifyReasonOnDisqualifyReasonTranslationForDisqualifyReasonTranslationsDisqualifyReasonIdFkeyUsingDisqualifyReasonsPkeyUpdate = {
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `disqualifyReason` being updated. */
  patch: UpdateDisqualifyReasonOnDisqualifyReasonTranslationForDisqualifyReasonTranslationsDisqualifyReasonIdFkeyPatch;
};

/** The globally unique `ID` look up for the row to update. */
export type DisqualifyReasonOnJobsApplicationForJobsApplicationsDisqualifyReasonIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `jobsApplication` to be connected. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `jobsApplication` being updated. */
  patch: JobsApplicationPatch;
};

/** The fields on `disqualifyReason` to look up the row to update. */
export type DisqualifyReasonOnJobsApplicationForJobsApplicationsDisqualifyReasonIdFkeyUsingDisqualifyReasonsPkeyUpdate = {
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `disqualifyReason` being updated. */
  patch: UpdateDisqualifyReasonOnJobsApplicationForJobsApplicationsDisqualifyReasonIdFkeyPatch;
};

/** Represents an update to a `DisqualifyReason`. Fields that are set will be updated. */
export type DisqualifyReasonPatch = {
  jobsApplications?: InputMaybe<JobsApplicationsDisqualifyReasonIdFkeyInverseInput>;
  position?: InputMaybe<Scalars['Int']['input']>;
  translations?: InputMaybe<DisqualifyReasonTranslationsDisqualifyReasonIdFkeyInverseInput>;
};

/** A connection to a list of `PipelineStage` values, with data from `JobsApplication`. */
export type DisqualifyReasonPipelineStagesByJobsApplicationDisqualifyReasonIdAndPipelineStageIdManyToManyConnection = {
  __typename?: 'DisqualifyReasonPipelineStagesByJobsApplicationDisqualifyReasonIdAndPipelineStageIdManyToManyConnection';
  /** A list of edges which contains the `PipelineStage`, info from the `JobsApplication`, and the cursor to aid in pagination. */
  edges: Array<DisqualifyReasonPipelineStagesByJobsApplicationDisqualifyReasonIdAndPipelineStageIdManyToManyEdge>;
  /** A list of `PipelineStage` objects. */
  nodes: Array<PipelineStage>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `PipelineStage` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `PipelineStage` edge in the connection, with data from `JobsApplication`. */
export type DisqualifyReasonPipelineStagesByJobsApplicationDisqualifyReasonIdAndPipelineStageIdManyToManyEdge = {
  __typename?: 'DisqualifyReasonPipelineStagesByJobsApplicationDisqualifyReasonIdAndPipelineStageIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** Reads and enables pagination through a set of `JobsApplication`. */
  jobsApplications: JobsApplicationsConnection;
  /** The `PipelineStage` at the end of the edge. */
  node: PipelineStage;
};


/** A `PipelineStage` edge in the connection, with data from `JobsApplication`. */
export type DisqualifyReasonPipelineStagesByJobsApplicationDisqualifyReasonIdAndPipelineStageIdManyToManyEdgeJobsApplicationsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<JobsApplicationCondition>;
  filter?: InputMaybe<JobsApplicationFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<JobsApplicationsOrderBy>>;
};

/** A filter to be used against many `DisqualifyReasonTranslation` object types. All fields are combined with a logical ‘and.’ */
export type DisqualifyReasonToManyDisqualifyReasonTranslationFilter = {
  /** Every related `DisqualifyReasonTranslation` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<DisqualifyReasonTranslationFilter>;
  /** No related `DisqualifyReasonTranslation` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<DisqualifyReasonTranslationFilter>;
  /** Some related `DisqualifyReasonTranslation` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<DisqualifyReasonTranslationFilter>;
};

/** A filter to be used against many `JobsApplication` object types. All fields are combined with a logical ‘and.’ */
export type DisqualifyReasonToManyJobsApplicationFilter = {
  /** Every related `JobsApplication` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<JobsApplicationFilter>;
  /** No related `JobsApplication` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<JobsApplicationFilter>;
  /** Some related `JobsApplication` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<JobsApplicationFilter>;
};

export type DisqualifyReasonTranslation = Node & {
  __typename?: 'DisqualifyReasonTranslation';
  /** Reads a single `DisqualifyReason` that is related to this `DisqualifyReasonTranslation`. */
  disqualifyReason?: Maybe<DisqualifyReason>;
  disqualifyReasonId: Scalars['Int']['output'];
  lang: Language;
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  title: Scalars['String']['output'];
};

/** A condition to be used against `DisqualifyReasonTranslation` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type DisqualifyReasonTranslationCondition = {
  /** Checks for equality with the object’s `disqualifyReasonId` field. */
  disqualifyReasonId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `title` field. */
  title?: InputMaybe<Scalars['String']['input']>;
};

/** The fields on `disqualifyReasonTranslation` to look up the row to connect. */
export type DisqualifyReasonTranslationDisqualifyReasonTranslationsPkeyConnect = {
  disqualifyReasonId: Scalars['Int']['input'];
  lang: Language;
};

/** The fields on `disqualifyReasonTranslation` to look up the row to delete. */
export type DisqualifyReasonTranslationDisqualifyReasonTranslationsPkeyDelete = {
  disqualifyReasonId: Scalars['Int']['input'];
  lang: Language;
};

/** A filter to be used against `DisqualifyReasonTranslation` object types. All fields are combined with a logical ‘and.’ */
export type DisqualifyReasonTranslationFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<DisqualifyReasonTranslationFilter>>;
  /** Filter by the object’s `disqualifyReason` relation. */
  disqualifyReason?: InputMaybe<DisqualifyReasonFilter>;
  /** Filter by the object’s `disqualifyReasonId` field. */
  disqualifyReasonId?: InputMaybe<IntFilter>;
  /** Negates the expression. */
  not?: InputMaybe<DisqualifyReasonTranslationFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<DisqualifyReasonTranslationFilter>>;
  /** Filter by the object’s `title` field. */
  title?: InputMaybe<StringFilter>;
};

/** An input for mutations affecting `DisqualifyReasonTranslation` */
export type DisqualifyReasonTranslationInput = {
  disqualifyReason?: InputMaybe<DisqualifyReasonTranslationsDisqualifyReasonIdFkeyInput>;
  disqualifyReasonId?: InputMaybe<Scalars['Int']['input']>;
  lang: Language;
  title: Scalars['String']['input'];
};

/** The globally unique `ID` look up for the row to connect. */
export type DisqualifyReasonTranslationNodeIdConnect = {
  /** The globally unique `ID` which identifies a single `disqualifyReasonTranslation` to be connected. */
  nodeId: Scalars['ID']['input'];
};

/** The globally unique `ID` look up for the row to delete. */
export type DisqualifyReasonTranslationNodeIdDelete = {
  /** The globally unique `ID` which identifies a single `disqualifyReasonTranslation` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** The globally unique `ID` look up for the row to update. */
export type DisqualifyReasonTranslationOnDisqualifyReasonTranslationForDisqualifyReasonTranslationsDisqualifyReasonIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `disqualifyReason` to be connected. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `disqualifyReason` being updated. */
  patch: DisqualifyReasonPatch;
};

/** The fields on `disqualifyReasonTranslation` to look up the row to update. */
export type DisqualifyReasonTranslationOnDisqualifyReasonTranslationForDisqualifyReasonTranslationsDisqualifyReasonIdFkeyUsingDisqualifyReasonTranslationsPkeyUpdate = {
  disqualifyReasonId: Scalars['Int']['input'];
  lang: Language;
  /** An object where the defined keys will be set on the `disqualifyReasonTranslation` being updated. */
  patch: UpdateDisqualifyReasonTranslationOnDisqualifyReasonTranslationForDisqualifyReasonTranslationsDisqualifyReasonIdFkeyPatch;
};

/** Represents an update to a `DisqualifyReasonTranslation`. Fields that are set will be updated. */
export type DisqualifyReasonTranslationPatch = {
  disqualifyReason?: InputMaybe<DisqualifyReasonTranslationsDisqualifyReasonIdFkeyInput>;
  disqualifyReasonId?: InputMaybe<Scalars['Int']['input']>;
  title?: InputMaybe<Scalars['String']['input']>;
};

/** A connection to a list of `DisqualifyReasonTranslation` values. */
export type DisqualifyReasonTranslationsConnection = {
  __typename?: 'DisqualifyReasonTranslationsConnection';
  /** A list of edges which contains the `DisqualifyReasonTranslation` and cursor to aid in pagination. */
  edges: Array<DisqualifyReasonTranslationsEdge>;
  /** A list of `DisqualifyReasonTranslation` objects. */
  nodes: Array<DisqualifyReasonTranslation>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `DisqualifyReasonTranslation` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** The `disqualifyReasonTranslation` to be created by this mutation. */
export type DisqualifyReasonTranslationsDisqualifyReasonIdFkeyDisqualifyReasonTranslationsCreateInput = {
  disqualifyReason?: InputMaybe<DisqualifyReasonTranslationsDisqualifyReasonIdFkeyInput>;
  lang: Language;
  title: Scalars['String']['input'];
};

/** The `disqualifyReason` to be created by this mutation. */
export type DisqualifyReasonTranslationsDisqualifyReasonIdFkeyDisqualifyReasonsCreateInput = {
  jobsApplications?: InputMaybe<JobsApplicationsDisqualifyReasonIdFkeyInverseInput>;
  position?: InputMaybe<Scalars['Int']['input']>;
  translations?: InputMaybe<DisqualifyReasonTranslationsDisqualifyReasonIdFkeyInverseInput>;
};

/** Input for the nested mutation of `disqualifyReason` in the `DisqualifyReasonTranslationInput` mutation. */
export type DisqualifyReasonTranslationsDisqualifyReasonIdFkeyInput = {
  /** The primary key(s) for `disqualifyReason` for the far side of the relationship. */
  connectById?: InputMaybe<DisqualifyReasonDisqualifyReasonsPkeyConnect>;
  /** The primary key(s) for `disqualifyReason` for the far side of the relationship. */
  connectByNodeId?: InputMaybe<DisqualifyReasonNodeIdConnect>;
  /** A `DisqualifyReasonInput` object that will be created and connected to this object. */
  create?: InputMaybe<DisqualifyReasonTranslationsDisqualifyReasonIdFkeyDisqualifyReasonsCreateInput>;
  /** The primary key(s) and patch data for `disqualifyReason` for the far side of the relationship. */
  updateById?: InputMaybe<DisqualifyReasonOnDisqualifyReasonTranslationForDisqualifyReasonTranslationsDisqualifyReasonIdFkeyUsingDisqualifyReasonsPkeyUpdate>;
  /** The primary key(s) and patch data for `disqualifyReason` for the far side of the relationship. */
  updateByNodeId?: InputMaybe<DisqualifyReasonTranslationOnDisqualifyReasonTranslationForDisqualifyReasonTranslationsDisqualifyReasonIdFkeyNodeIdUpdate>;
};

/** Input for the nested mutation of `disqualifyReasonTranslation` in the `DisqualifyReasonInput` mutation. */
export type DisqualifyReasonTranslationsDisqualifyReasonIdFkeyInverseInput = {
  /** The primary key(s) for `disqualifyReasonTranslation` for the far side of the relationship. */
  connectByDisqualifyReasonIdAndLang?: InputMaybe<Array<DisqualifyReasonTranslationDisqualifyReasonTranslationsPkeyConnect>>;
  /** The primary key(s) for `disqualifyReasonTranslation` for the far side of the relationship. */
  connectByNodeId?: InputMaybe<Array<DisqualifyReasonTranslationNodeIdConnect>>;
  /** A `DisqualifyReasonTranslationInput` object that will be created and connected to this object. */
  create?: InputMaybe<Array<DisqualifyReasonTranslationsDisqualifyReasonIdFkeyDisqualifyReasonTranslationsCreateInput>>;
  /** The primary key(s) for `disqualifyReasonTranslation` for the far side of the relationship. */
  deleteByDisqualifyReasonIdAndLang?: InputMaybe<Array<DisqualifyReasonTranslationDisqualifyReasonTranslationsPkeyDelete>>;
  /** The primary key(s) for `disqualifyReasonTranslation` for the far side of the relationship. */
  deleteByNodeId?: InputMaybe<Array<DisqualifyReasonTranslationNodeIdDelete>>;
  /** Flag indicating whether all other `disqualifyReasonTranslation` records that match this relationship should be removed. */
  deleteOthers?: InputMaybe<Scalars['Boolean']['input']>;
  /** The primary key(s) and patch data for `disqualifyReasonTranslation` for the far side of the relationship. */
  updateByDisqualifyReasonIdAndLang?: InputMaybe<Array<DisqualifyReasonTranslationOnDisqualifyReasonTranslationForDisqualifyReasonTranslationsDisqualifyReasonIdFkeyUsingDisqualifyReasonTranslationsPkeyUpdate>>;
  /** The primary key(s) and patch data for `disqualifyReasonTranslation` for the far side of the relationship. */
  updateByNodeId?: InputMaybe<Array<DisqualifyReasonOnDisqualifyReasonTranslationForDisqualifyReasonTranslationsDisqualifyReasonIdFkeyNodeIdUpdate>>;
};

/** A `DisqualifyReasonTranslation` edge in the connection. */
export type DisqualifyReasonTranslationsEdge = {
  __typename?: 'DisqualifyReasonTranslationsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `DisqualifyReasonTranslation` at the end of the edge. */
  node: DisqualifyReasonTranslation;
};

/** Methods to use when ordering `DisqualifyReasonTranslation`. */
export enum DisqualifyReasonTranslationsOrderBy {
  DisqualifyReasonIdAsc = 'DISQUALIFY_REASON_ID_ASC',
  DisqualifyReasonIdDesc = 'DISQUALIFY_REASON_ID_DESC',
  Natural = 'NATURAL',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  TitleAsc = 'TITLE_ASC',
  TitleDesc = 'TITLE_DESC'
}

/** A connection to a list of `DisqualifyReason` values. */
export type DisqualifyReasonsConnection = {
  __typename?: 'DisqualifyReasonsConnection';
  /** A list of edges which contains the `DisqualifyReason` and cursor to aid in pagination. */
  edges: Array<DisqualifyReasonsEdge>;
  /** A list of `DisqualifyReason` objects. */
  nodes: Array<DisqualifyReason>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `DisqualifyReason` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `DisqualifyReason` edge in the connection. */
export type DisqualifyReasonsEdge = {
  __typename?: 'DisqualifyReasonsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `DisqualifyReason` at the end of the edge. */
  node: DisqualifyReason;
};

/** Methods to use when ordering `DisqualifyReason`. */
export enum DisqualifyReasonsOrderBy {
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  Natural = 'NATURAL',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC'
}

export type DraftEvaluation = Node & {
  __typename?: 'DraftEvaluation';
  /** Reads a single `Candidate` that is related to this `DraftEvaluation`. */
  candidate?: Maybe<Candidate>;
  candidateId: Scalars['Int']['output'];
  /** Reads and enables pagination through a set of `Candidate`. */
  candidates: DraftEvaluationCandidatesByEvaluationDraftEvaluationIdAndCandidateIdManyToManyConnection;
  /** Reads a single `Company` that is related to this `DraftEvaluation`. */
  company?: Maybe<Company>;
  companyId: Scalars['Int']['output'];
  createdAt: Scalars['Datetime']['output'];
  deletedAt?: Maybe<Scalars['Datetime']['output']>;
  /** Reads and enables pagination through a set of `Evaluation`. */
  evaluations: EvaluationsConnection;
  /** Reads and enables pagination through a set of `EventDraftEvaluation`. */
  eventDraftEvaluations: DraftEvaluationEventDraftEvaluationsByEvaluationDraftEvaluationIdAndEventDraftEvaluationIdManyToManyConnection;
  id: Scalars['Int']['output'];
  /** Reads a single `Job` that is related to this `DraftEvaluation`. */
  job?: Maybe<Job>;
  jobId: Scalars['Int']['output'];
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  /** Reads a single `PipelineStage` that is related to this `DraftEvaluation`. */
  pipelineStage?: Maybe<PipelineStage>;
  pipelineStageId: Scalars['Int']['output'];
  scorecardIds: Array<Maybe<Scalars['Int']['output']>>;
  /** Reads and enables pagination through a set of `Scorecard`. */
  scorecards: ScorecardsConnection;
  userIds: Array<Maybe<Scalars['Int']['output']>>;
};


export type DraftEvaluationCandidatesArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<CandidateCondition>;
  filter?: InputMaybe<CandidateFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<CandidatesOrderBy>>;
};


export type DraftEvaluationEvaluationsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<EvaluationCondition>;
  filter?: InputMaybe<EvaluationFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<EvaluationsOrderBy>>;
};


export type DraftEvaluationEventDraftEvaluationsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<EventDraftEvaluationCondition>;
  filter?: InputMaybe<EventDraftEvaluationFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<EventDraftEvaluationsOrderBy>>;
};


export type DraftEvaluationScorecardsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<ScorecardFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
};

/** A connection to a list of `Candidate` values, with data from `Evaluation`. */
export type DraftEvaluationCandidatesByEvaluationDraftEvaluationIdAndCandidateIdManyToManyConnection = {
  __typename?: 'DraftEvaluationCandidatesByEvaluationDraftEvaluationIdAndCandidateIdManyToManyConnection';
  /** A list of edges which contains the `Candidate`, info from the `Evaluation`, and the cursor to aid in pagination. */
  edges: Array<DraftEvaluationCandidatesByEvaluationDraftEvaluationIdAndCandidateIdManyToManyEdge>;
  /** A list of `Candidate` objects. */
  nodes: Array<Candidate>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Candidate` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `Candidate` edge in the connection, with data from `Evaluation`. */
export type DraftEvaluationCandidatesByEvaluationDraftEvaluationIdAndCandidateIdManyToManyEdge = {
  __typename?: 'DraftEvaluationCandidatesByEvaluationDraftEvaluationIdAndCandidateIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** Reads and enables pagination through a set of `Evaluation`. */
  evaluations: EvaluationsConnection;
  /** The `Candidate` at the end of the edge. */
  node: Candidate;
};


/** A `Candidate` edge in the connection, with data from `Evaluation`. */
export type DraftEvaluationCandidatesByEvaluationDraftEvaluationIdAndCandidateIdManyToManyEdgeEvaluationsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<EvaluationCondition>;
  filter?: InputMaybe<EvaluationFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<EvaluationsOrderBy>>;
};

/** A condition to be used against `DraftEvaluation` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type DraftEvaluationCondition = {
  /** Checks for equality with the object’s `candidateId` field. */
  candidateId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `companyId` field. */
  companyId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `createdAt` field. */
  createdAt?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `deletedAt` field. */
  deletedAt?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `jobId` field. */
  jobId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `pipelineStageId` field. */
  pipelineStageId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `scorecardIds` field. */
  scorecardIds?: InputMaybe<Array<InputMaybe<Scalars['Int']['input']>>>;
  /** Checks for equality with the object’s `userIds` field. */
  userIds?: InputMaybe<Array<InputMaybe<Scalars['Int']['input']>>>;
};

/** The fields on `draftEvaluation` to look up the row to connect. */
export type DraftEvaluationDraftEvaluationsPipelineStageIdJobIdCandidateIdKeyConnect = {
  candidateId: Scalars['Int']['input'];
  jobId: Scalars['Int']['input'];
  pipelineStageId: Scalars['Int']['input'];
};

/** The fields on `draftEvaluation` to look up the row to connect. */
export type DraftEvaluationDraftEvaluationsPkeyConnect = {
  id: Scalars['Int']['input'];
};

/** A connection to a list of `EventDraftEvaluation` values, with data from `Evaluation`. */
export type DraftEvaluationEventDraftEvaluationsByEvaluationDraftEvaluationIdAndEventDraftEvaluationIdManyToManyConnection = {
  __typename?: 'DraftEvaluationEventDraftEvaluationsByEvaluationDraftEvaluationIdAndEventDraftEvaluationIdManyToManyConnection';
  /** A list of edges which contains the `EventDraftEvaluation`, info from the `Evaluation`, and the cursor to aid in pagination. */
  edges: Array<DraftEvaluationEventDraftEvaluationsByEvaluationDraftEvaluationIdAndEventDraftEvaluationIdManyToManyEdge>;
  /** A list of `EventDraftEvaluation` objects. */
  nodes: Array<EventDraftEvaluation>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `EventDraftEvaluation` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `EventDraftEvaluation` edge in the connection, with data from `Evaluation`. */
export type DraftEvaluationEventDraftEvaluationsByEvaluationDraftEvaluationIdAndEventDraftEvaluationIdManyToManyEdge = {
  __typename?: 'DraftEvaluationEventDraftEvaluationsByEvaluationDraftEvaluationIdAndEventDraftEvaluationIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** Reads and enables pagination through a set of `Evaluation`. */
  evaluations: EvaluationsConnection;
  /** The `EventDraftEvaluation` at the end of the edge. */
  node: EventDraftEvaluation;
};


/** A `EventDraftEvaluation` edge in the connection, with data from `Evaluation`. */
export type DraftEvaluationEventDraftEvaluationsByEvaluationDraftEvaluationIdAndEventDraftEvaluationIdManyToManyEdgeEvaluationsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<EvaluationCondition>;
  filter?: InputMaybe<EvaluationFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<EvaluationsOrderBy>>;
};

/** A filter to be used against `DraftEvaluation` object types. All fields are combined with a logical ‘and.’ */
export type DraftEvaluationFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<DraftEvaluationFilter>>;
  /** Filter by the object’s `candidate` relation. */
  candidate?: InputMaybe<CandidateFilter>;
  /** Filter by the object’s `candidateId` field. */
  candidateId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `company` relation. */
  company?: InputMaybe<CompanyFilter>;
  /** Filter by the object’s `companyId` field. */
  companyId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `createdAt` field. */
  createdAt?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `deletedAt` field. */
  deletedAt?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `evaluations` relation. */
  evaluations?: InputMaybe<DraftEvaluationToManyEvaluationFilter>;
  /** Some related `evaluations` exist. */
  evaluationsExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<IntFilter>;
  /** Filter by the object’s `job` relation. */
  job?: InputMaybe<JobFilter>;
  /** Filter by the object’s `jobId` field. */
  jobId?: InputMaybe<IntFilter>;
  /** Negates the expression. */
  not?: InputMaybe<DraftEvaluationFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<DraftEvaluationFilter>>;
  /** Filter by the object’s `pipelineStage` relation. */
  pipelineStage?: InputMaybe<PipelineStageFilter>;
  /** Filter by the object’s `pipelineStageId` field. */
  pipelineStageId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `scorecardIds` field. */
  scorecardIds?: InputMaybe<IntListFilter>;
  /** Filter by the object’s `userIds` field. */
  userIds?: InputMaybe<IntListFilter>;
};

/** The globally unique `ID` look up for the row to connect. */
export type DraftEvaluationNodeIdConnect = {
  /** The globally unique `ID` which identifies a single `draftEvaluation` to be connected. */
  nodeId: Scalars['ID']['input'];
};

/** The globally unique `ID` look up for the row to update. */
export type DraftEvaluationOnDraftEvaluationForDraftEvaluationsCandidateIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `candidate` to be connected. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `candidate` being updated. */
  patch: CandidatePatch;
};

/** The fields on `draftEvaluation` to look up the row to update. */
export type DraftEvaluationOnDraftEvaluationForDraftEvaluationsCandidateIdFkeyUsingDraftEvaluationsPipelineStageIdJobIdCandidateIdKeyUpdate = {
  candidateId: Scalars['Int']['input'];
  jobId: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `draftEvaluation` being updated. */
  patch: UpdateDraftEvaluationOnDraftEvaluationForDraftEvaluationsCandidateIdFkeyPatch;
  pipelineStageId: Scalars['Int']['input'];
};

/** The fields on `draftEvaluation` to look up the row to update. */
export type DraftEvaluationOnDraftEvaluationForDraftEvaluationsCandidateIdFkeyUsingDraftEvaluationsPkeyUpdate = {
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `draftEvaluation` being updated. */
  patch: UpdateDraftEvaluationOnDraftEvaluationForDraftEvaluationsCandidateIdFkeyPatch;
};

/** The globally unique `ID` look up for the row to update. */
export type DraftEvaluationOnDraftEvaluationForDraftEvaluationsCompanyIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `company` to be connected. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `company` being updated. */
  patch: CompanyPatch;
};

/** The fields on `draftEvaluation` to look up the row to update. */
export type DraftEvaluationOnDraftEvaluationForDraftEvaluationsCompanyIdFkeyUsingDraftEvaluationsPipelineStageIdJobIdCandidateIdKeyUpdate = {
  candidateId: Scalars['Int']['input'];
  jobId: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `draftEvaluation` being updated. */
  patch: UpdateDraftEvaluationOnDraftEvaluationForDraftEvaluationsCompanyIdFkeyPatch;
  pipelineStageId: Scalars['Int']['input'];
};

/** The fields on `draftEvaluation` to look up the row to update. */
export type DraftEvaluationOnDraftEvaluationForDraftEvaluationsCompanyIdFkeyUsingDraftEvaluationsPkeyUpdate = {
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `draftEvaluation` being updated. */
  patch: UpdateDraftEvaluationOnDraftEvaluationForDraftEvaluationsCompanyIdFkeyPatch;
};

/** The globally unique `ID` look up for the row to update. */
export type DraftEvaluationOnDraftEvaluationForDraftEvaluationsJobIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `job` to be connected. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `job` being updated. */
  patch: JobPatch;
};

/** The fields on `draftEvaluation` to look up the row to update. */
export type DraftEvaluationOnDraftEvaluationForDraftEvaluationsJobIdFkeyUsingDraftEvaluationsPipelineStageIdJobIdCandidateIdKeyUpdate = {
  candidateId: Scalars['Int']['input'];
  jobId: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `draftEvaluation` being updated. */
  patch: UpdateDraftEvaluationOnDraftEvaluationForDraftEvaluationsJobIdFkeyPatch;
  pipelineStageId: Scalars['Int']['input'];
};

/** The fields on `draftEvaluation` to look up the row to update. */
export type DraftEvaluationOnDraftEvaluationForDraftEvaluationsJobIdFkeyUsingDraftEvaluationsPkeyUpdate = {
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `draftEvaluation` being updated. */
  patch: UpdateDraftEvaluationOnDraftEvaluationForDraftEvaluationsJobIdFkeyPatch;
};

/** The globally unique `ID` look up for the row to update. */
export type DraftEvaluationOnDraftEvaluationForDraftEvaluationsPipelineStageIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `pipelineStage` to be connected. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `pipelineStage` being updated. */
  patch: PipelineStagePatch;
};

/** The fields on `draftEvaluation` to look up the row to update. */
export type DraftEvaluationOnDraftEvaluationForDraftEvaluationsPipelineStageIdFkeyUsingDraftEvaluationsPipelineStageIdJobIdCandidateIdKeyUpdate = {
  candidateId: Scalars['Int']['input'];
  jobId: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `draftEvaluation` being updated. */
  patch: UpdateDraftEvaluationOnDraftEvaluationForDraftEvaluationsPipelineStageIdFkeyPatch;
  pipelineStageId: Scalars['Int']['input'];
};

/** The fields on `draftEvaluation` to look up the row to update. */
export type DraftEvaluationOnDraftEvaluationForDraftEvaluationsPipelineStageIdFkeyUsingDraftEvaluationsPkeyUpdate = {
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `draftEvaluation` being updated. */
  patch: UpdateDraftEvaluationOnDraftEvaluationForDraftEvaluationsPipelineStageIdFkeyPatch;
};

/** The globally unique `ID` look up for the row to update. */
export type DraftEvaluationOnEvaluationForEvaluationsDraftEvaluationIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `evaluation` to be connected. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `evaluation` being updated. */
  patch: EvaluationPatch;
};

/** The fields on `draftEvaluation` to look up the row to update. */
export type DraftEvaluationOnEvaluationForEvaluationsDraftEvaluationIdFkeyUsingDraftEvaluationsPipelineStageIdJobIdCandidateIdKeyUpdate = {
  candidateId: Scalars['Int']['input'];
  jobId: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `draftEvaluation` being updated. */
  patch: UpdateDraftEvaluationOnEvaluationForEvaluationsDraftEvaluationIdFkeyPatch;
  pipelineStageId: Scalars['Int']['input'];
};

/** The fields on `draftEvaluation` to look up the row to update. */
export type DraftEvaluationOnEvaluationForEvaluationsDraftEvaluationIdFkeyUsingDraftEvaluationsPkeyUpdate = {
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `draftEvaluation` being updated. */
  patch: UpdateDraftEvaluationOnEvaluationForEvaluationsDraftEvaluationIdFkeyPatch;
};

/** Represents an update to a `DraftEvaluation`. Fields that are set will be updated. */
export type DraftEvaluationPatch = {
  candidate?: InputMaybe<DraftEvaluationsCandidateIdFkeyInput>;
  candidateId?: InputMaybe<Scalars['Int']['input']>;
  company?: InputMaybe<DraftEvaluationsCompanyIdFkeyInput>;
  companyId?: InputMaybe<Scalars['Int']['input']>;
  createdAt?: InputMaybe<Scalars['Datetime']['input']>;
  deletedAt?: InputMaybe<Scalars['Datetime']['input']>;
  evaluations?: InputMaybe<EvaluationsDraftEvaluationIdFkeyInverseInput>;
  id?: InputMaybe<Scalars['Int']['input']>;
  job?: InputMaybe<DraftEvaluationsJobIdFkeyInput>;
  jobId?: InputMaybe<Scalars['Int']['input']>;
  pipelineStage?: InputMaybe<DraftEvaluationsPipelineStageIdFkeyInput>;
  pipelineStageId?: InputMaybe<Scalars['Int']['input']>;
  scorecardIds?: InputMaybe<Array<InputMaybe<Scalars['Int']['input']>>>;
  userIds?: InputMaybe<Array<InputMaybe<Scalars['Int']['input']>>>;
};

/** A filter to be used against many `Evaluation` object types. All fields are combined with a logical ‘and.’ */
export type DraftEvaluationToManyEvaluationFilter = {
  /** Every related `Evaluation` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<EvaluationFilter>;
  /** No related `Evaluation` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<EvaluationFilter>;
  /** Some related `Evaluation` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<EvaluationFilter>;
};

/** The `candidate` to be created by this mutation. */
export type DraftEvaluationsCandidateIdFkeyCandidatesCreateInput = {
  birthday?: InputMaybe<Scalars['Date']['input']>;
  candidateDraftEvaluations?: InputMaybe<DraftEvaluationsCandidateIdFkeyInverseInput>;
  candidateEventDraftEvaluations?: InputMaybe<EventDraftEvaluationsCandidateIdFkeyInverseInput>;
  candidateImportCandidate?: InputMaybe<CandidateImportCandidatesCandidateIdFkeyInverseInput>;
  candidateQuestionnaires?: InputMaybe<CandidateQuestionnairesCandidateIdFkeyInverseInput>;
  candidateQuestions?: InputMaybe<CandidateQuestionsCandidateIdFkeyInverseInput>;
  candidateTags?: InputMaybe<CandidateTagsCandidateIdFkeyInverseInput>;
  cvText?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  emails?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  evaluations?: InputMaybe<EvaluationsCandidateIdFkeyInverseInput>;
  eventCandidates?: InputMaybe<EventCandidatesCandidateIdFkeyInverseInput>;
  files?: InputMaybe<CandidateFilesCandidateIdFkeyInverseInput>;
  gender?: InputMaybe<Gender>;
  jobsApplications?: InputMaybe<JobsApplicationsCandidateIdFkeyInverseInput>;
  language: Language;
  links?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  militaryStatus?: InputMaybe<MilitaryStatus>;
  phones?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  photoExternalId?: InputMaybe<Scalars['UUID']['input']>;
  resumeExternalId?: InputMaybe<Scalars['UUID']['input']>;
  socialLinks?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  sources?: InputMaybe<Array<Scalars['String']['input']>>;
  tags?: InputMaybe<Array<Scalars['String']['input']>>;
  threads?: InputMaybe<ThreadsCandidateIdFkeyInverseInput>;
  translations?: InputMaybe<CandidateTranslationsCandidateIdFkeyInverseInput>;
};

/** Input for the nested mutation of `candidate` in the `DraftEvaluationInput` mutation. */
export type DraftEvaluationsCandidateIdFkeyInput = {
  /** The primary key(s) for `candidate` for the far side of the relationship. */
  connectById?: InputMaybe<CandidateCandidatesPkeyConnect>;
  /** The primary key(s) for `candidate` for the far side of the relationship. */
  connectByNodeId?: InputMaybe<CandidateNodeIdConnect>;
  /** A `CandidateInput` object that will be created and connected to this object. */
  create?: InputMaybe<DraftEvaluationsCandidateIdFkeyCandidatesCreateInput>;
  /** The primary key(s) and patch data for `candidate` for the far side of the relationship. */
  updateById?: InputMaybe<CandidateOnDraftEvaluationForDraftEvaluationsCandidateIdFkeyUsingCandidatesPkeyUpdate>;
  /** The primary key(s) and patch data for `candidate` for the far side of the relationship. */
  updateByNodeId?: InputMaybe<DraftEvaluationOnDraftEvaluationForDraftEvaluationsCandidateIdFkeyNodeIdUpdate>;
};

/** Input for the nested mutation of `draftEvaluation` in the `CandidateInput` mutation. */
export type DraftEvaluationsCandidateIdFkeyInverseInput = {
  /** The primary key(s) for `draftEvaluation` for the far side of the relationship. */
  connectById?: InputMaybe<Array<DraftEvaluationDraftEvaluationsPkeyConnect>>;
  /** The primary key(s) for `draftEvaluation` for the far side of the relationship. */
  connectByNodeId?: InputMaybe<Array<DraftEvaluationNodeIdConnect>>;
  /** The primary key(s) for `draftEvaluation` for the far side of the relationship. */
  connectByPipelineStageIdAndJobIdAndCandidateId?: InputMaybe<Array<DraftEvaluationDraftEvaluationsPipelineStageIdJobIdCandidateIdKeyConnect>>;
  /** The primary key(s) and patch data for `draftEvaluation` for the far side of the relationship. */
  updateById?: InputMaybe<Array<DraftEvaluationOnDraftEvaluationForDraftEvaluationsCandidateIdFkeyUsingDraftEvaluationsPkeyUpdate>>;
  /** The primary key(s) and patch data for `draftEvaluation` for the far side of the relationship. */
  updateByNodeId?: InputMaybe<Array<CandidateOnDraftEvaluationForDraftEvaluationsCandidateIdFkeyNodeIdUpdate>>;
  /** The primary key(s) and patch data for `draftEvaluation` for the far side of the relationship. */
  updateByPipelineStageIdAndJobIdAndCandidateId?: InputMaybe<Array<DraftEvaluationOnDraftEvaluationForDraftEvaluationsCandidateIdFkeyUsingDraftEvaluationsPipelineStageIdJobIdCandidateIdKeyUpdate>>;
};

/** Input for the nested mutation of `company` in the `DraftEvaluationInput` mutation. */
export type DraftEvaluationsCompanyIdFkeyInput = {
  /** The primary key(s) for `company` for the far side of the relationship. */
  connectById?: InputMaybe<CompanyCompaniesPkeyConnect>;
  /** The primary key(s) for `company` for the far side of the relationship. */
  connectByNodeId?: InputMaybe<CompanyNodeIdConnect>;
  /** The primary key(s) for `company` for the far side of the relationship. */
  connectBySlug?: InputMaybe<CompanyCompaniesSlugKeyConnect>;
  /** The primary key(s) and patch data for `company` for the far side of the relationship. */
  updateById?: InputMaybe<CompanyOnDraftEvaluationForDraftEvaluationsCompanyIdFkeyUsingCompaniesPkeyUpdate>;
  /** The primary key(s) and patch data for `company` for the far side of the relationship. */
  updateByNodeId?: InputMaybe<DraftEvaluationOnDraftEvaluationForDraftEvaluationsCompanyIdFkeyNodeIdUpdate>;
  /** The primary key(s) and patch data for `company` for the far side of the relationship. */
  updateBySlug?: InputMaybe<CompanyOnDraftEvaluationForDraftEvaluationsCompanyIdFkeyUsingCompaniesSlugKeyUpdate>;
};

/** Input for the nested mutation of `draftEvaluation` in the `CompanyInput` mutation. */
export type DraftEvaluationsCompanyIdFkeyInverseInput = {
  /** The primary key(s) for `draftEvaluation` for the far side of the relationship. */
  connectById?: InputMaybe<Array<DraftEvaluationDraftEvaluationsPkeyConnect>>;
  /** The primary key(s) for `draftEvaluation` for the far side of the relationship. */
  connectByNodeId?: InputMaybe<Array<DraftEvaluationNodeIdConnect>>;
  /** The primary key(s) for `draftEvaluation` for the far side of the relationship. */
  connectByPipelineStageIdAndJobIdAndCandidateId?: InputMaybe<Array<DraftEvaluationDraftEvaluationsPipelineStageIdJobIdCandidateIdKeyConnect>>;
  /** The primary key(s) and patch data for `draftEvaluation` for the far side of the relationship. */
  updateById?: InputMaybe<Array<DraftEvaluationOnDraftEvaluationForDraftEvaluationsCompanyIdFkeyUsingDraftEvaluationsPkeyUpdate>>;
  /** The primary key(s) and patch data for `draftEvaluation` for the far side of the relationship. */
  updateByNodeId?: InputMaybe<Array<CompanyOnDraftEvaluationForDraftEvaluationsCompanyIdFkeyNodeIdUpdate>>;
  /** The primary key(s) and patch data for `draftEvaluation` for the far side of the relationship. */
  updateByPipelineStageIdAndJobIdAndCandidateId?: InputMaybe<Array<DraftEvaluationOnDraftEvaluationForDraftEvaluationsCompanyIdFkeyUsingDraftEvaluationsPipelineStageIdJobIdCandidateIdKeyUpdate>>;
};

/** A connection to a list of `DraftEvaluation` values. */
export type DraftEvaluationsConnection = {
  __typename?: 'DraftEvaluationsConnection';
  /** A list of edges which contains the `DraftEvaluation` and cursor to aid in pagination. */
  edges: Array<DraftEvaluationsEdge>;
  /** A list of `DraftEvaluation` objects. */
  nodes: Array<DraftEvaluation>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `DraftEvaluation` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `DraftEvaluation` edge in the connection. */
export type DraftEvaluationsEdge = {
  __typename?: 'DraftEvaluationsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `DraftEvaluation` at the end of the edge. */
  node: DraftEvaluation;
};

/** Input for the nested mutation of `job` in the `DraftEvaluationInput` mutation. */
export type DraftEvaluationsJobIdFkeyInput = {
  /** The primary key(s) for `job` for the far side of the relationship. */
  connectById?: InputMaybe<JobJobsPkeyConnect>;
  /** The primary key(s) for `job` for the far side of the relationship. */
  connectByNodeId?: InputMaybe<JobNodeIdConnect>;
  /** A `JobInput` object that will be created and connected to this object. */
  create?: InputMaybe<DraftEvaluationsJobIdFkeyJobsCreateInput>;
  /** The primary key(s) and patch data for `job` for the far side of the relationship. */
  updateById?: InputMaybe<JobOnDraftEvaluationForDraftEvaluationsJobIdFkeyUsingJobsPkeyUpdate>;
  /** The primary key(s) and patch data for `job` for the far side of the relationship. */
  updateByNodeId?: InputMaybe<DraftEvaluationOnDraftEvaluationForDraftEvaluationsJobIdFkeyNodeIdUpdate>;
};

/** Input for the nested mutation of `draftEvaluation` in the `JobInput` mutation. */
export type DraftEvaluationsJobIdFkeyInverseInput = {
  /** The primary key(s) for `draftEvaluation` for the far side of the relationship. */
  connectById?: InputMaybe<Array<DraftEvaluationDraftEvaluationsPkeyConnect>>;
  /** The primary key(s) for `draftEvaluation` for the far side of the relationship. */
  connectByNodeId?: InputMaybe<Array<DraftEvaluationNodeIdConnect>>;
  /** The primary key(s) for `draftEvaluation` for the far side of the relationship. */
  connectByPipelineStageIdAndJobIdAndCandidateId?: InputMaybe<Array<DraftEvaluationDraftEvaluationsPipelineStageIdJobIdCandidateIdKeyConnect>>;
  /** The primary key(s) and patch data for `draftEvaluation` for the far side of the relationship. */
  updateById?: InputMaybe<Array<DraftEvaluationOnDraftEvaluationForDraftEvaluationsJobIdFkeyUsingDraftEvaluationsPkeyUpdate>>;
  /** The primary key(s) and patch data for `draftEvaluation` for the far side of the relationship. */
  updateByNodeId?: InputMaybe<Array<JobOnDraftEvaluationForDraftEvaluationsJobIdFkeyNodeIdUpdate>>;
  /** The primary key(s) and patch data for `draftEvaluation` for the far side of the relationship. */
  updateByPipelineStageIdAndJobIdAndCandidateId?: InputMaybe<Array<DraftEvaluationOnDraftEvaluationForDraftEvaluationsJobIdFkeyUsingDraftEvaluationsPipelineStageIdJobIdCandidateIdKeyUpdate>>;
};

/** The `job` to be created by this mutation. */
export type DraftEvaluationsJobIdFkeyJobsCreateInput = {
  address?: InputMaybe<Scalars['String']['input']>;
  applications?: InputMaybe<JobsApplicationsJobIdFkeyInverseInput>;
  city?: InputMaybe<Scalars['String']['input']>;
  competencies?: InputMaybe<Array<Scalars['String']['input']>>;
  country?: InputMaybe<Scalars['Int']['input']>;
  department?: InputMaybe<JobsDepartmentIdFkeyInput>;
  departmentId?: InputMaybe<Scalars['Int']['input']>;
  draftEvaluations?: InputMaybe<DraftEvaluationsJobIdFkeyInverseInput>;
  education?: InputMaybe<JobEducation>;
  evaluations?: InputMaybe<EvaluationsJobIdFkeyInverseInput>;
  fields?: InputMaybe<JobFieldsJobIdFkeyInverseInput>;
  genders?: InputMaybe<Array<InputMaybe<Gender>>>;
  gradeConditions?: InputMaybe<Array<InputMaybe<GradeCondition>>>;
  hoursPerWeek?: InputMaybe<IntRangeInput>;
  isRemote?: InputMaybe<Scalars['Boolean']['input']>;
  jobCompetencies?: InputMaybe<JobCompetenciesJobIdFkeyInverseInput>;
  jobKnowledges?: InputMaybe<JobKnowledgesJobIdFkeyInverseInput>;
  jobQuestionnaires?: InputMaybe<JobQuestionnairesJobIdFkeyInverseInput>;
  jobSkills?: InputMaybe<JobSkillsJobIdFkeyInverseInput>;
  jobTags?: InputMaybe<JobTagsJobIdFkeyInverseInput>;
  knowledges?: InputMaybe<Array<Scalars['String']['input']>>;
  languages: Array<InputMaybe<Language>>;
  maxAgeCondition?: InputMaybe<Scalars['Int']['input']>;
  militaryStatus?: InputMaybe<Array<InputMaybe<MilitaryStatus>>>;
  minAgeCondition?: InputMaybe<Scalars['Int']['input']>;
  owners?: InputMaybe<JobOwnersJobIdFkeyInverseInput>;
  pipeline?: InputMaybe<JobsPipelineIdFkeyInput>;
  pipelineId?: InputMaybe<Scalars['Int']['input']>;
  position: Scalars['Int']['input'];
  publishedAt?: InputMaybe<Scalars['Datetime']['input']>;
  skills?: InputMaybe<Array<Scalars['String']['input']>>;
  state?: InputMaybe<Scalars['Int']['input']>;
  status: JobStatus;
  tags?: InputMaybe<Array<Scalars['String']['input']>>;
  threads?: InputMaybe<ThreadsJobIdFkeyInverseInput>;
  translations?: InputMaybe<JobTranslationsJobIdFkeyInverseInput>;
  workExperienceCondition?: InputMaybe<Scalars['Int']['input']>;
};

/** Methods to use when ordering `DraftEvaluation`. */
export enum DraftEvaluationsOrderBy {
  CandidateIdAsc = 'CANDIDATE_ID_ASC',
  CandidateIdDesc = 'CANDIDATE_ID_DESC',
  CompanyIdAsc = 'COMPANY_ID_ASC',
  CompanyIdDesc = 'COMPANY_ID_DESC',
  CreatedAtAsc = 'CREATED_AT_ASC',
  CreatedAtDesc = 'CREATED_AT_DESC',
  DeletedAtAsc = 'DELETED_AT_ASC',
  DeletedAtDesc = 'DELETED_AT_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  JobIdAsc = 'JOB_ID_ASC',
  JobIdDesc = 'JOB_ID_DESC',
  Natural = 'NATURAL',
  PipelineStageIdAsc = 'PIPELINE_STAGE_ID_ASC',
  PipelineStageIdDesc = 'PIPELINE_STAGE_ID_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  ScorecardIdsAsc = 'SCORECARD_IDS_ASC',
  ScorecardIdsDesc = 'SCORECARD_IDS_DESC',
  UserIdsAsc = 'USER_IDS_ASC',
  UserIdsDesc = 'USER_IDS_DESC'
}

/** Input for the nested mutation of `pipelineStage` in the `DraftEvaluationInput` mutation. */
export type DraftEvaluationsPipelineStageIdFkeyInput = {
  /** The primary key(s) for `pipelineStage` for the far side of the relationship. */
  connectById?: InputMaybe<PipelineStagePipelineStagesPkeyConnect>;
  /** The primary key(s) for `pipelineStage` for the far side of the relationship. */
  connectByNodeId?: InputMaybe<PipelineStageNodeIdConnect>;
  /** A `PipelineStageInput` object that will be created and connected to this object. */
  create?: InputMaybe<DraftEvaluationsPipelineStageIdFkeyPipelineStagesCreateInput>;
  /** The primary key(s) for `pipelineStage` for the far side of the relationship. */
  deleteById?: InputMaybe<PipelineStagePipelineStagesPkeyDelete>;
  /** The primary key(s) for `pipelineStage` for the far side of the relationship. */
  deleteByNodeId?: InputMaybe<PipelineStageNodeIdDelete>;
  /** The primary key(s) and patch data for `pipelineStage` for the far side of the relationship. */
  updateById?: InputMaybe<PipelineStageOnDraftEvaluationForDraftEvaluationsPipelineStageIdFkeyUsingPipelineStagesPkeyUpdate>;
  /** The primary key(s) and patch data for `pipelineStage` for the far side of the relationship. */
  updateByNodeId?: InputMaybe<DraftEvaluationOnDraftEvaluationForDraftEvaluationsPipelineStageIdFkeyNodeIdUpdate>;
};

/** Input for the nested mutation of `draftEvaluation` in the `PipelineStageInput` mutation. */
export type DraftEvaluationsPipelineStageIdFkeyInverseInput = {
  /** The primary key(s) for `draftEvaluation` for the far side of the relationship. */
  connectById?: InputMaybe<Array<DraftEvaluationDraftEvaluationsPkeyConnect>>;
  /** The primary key(s) for `draftEvaluation` for the far side of the relationship. */
  connectByNodeId?: InputMaybe<Array<DraftEvaluationNodeIdConnect>>;
  /** The primary key(s) for `draftEvaluation` for the far side of the relationship. */
  connectByPipelineStageIdAndJobIdAndCandidateId?: InputMaybe<Array<DraftEvaluationDraftEvaluationsPipelineStageIdJobIdCandidateIdKeyConnect>>;
  /** The primary key(s) and patch data for `draftEvaluation` for the far side of the relationship. */
  updateById?: InputMaybe<Array<DraftEvaluationOnDraftEvaluationForDraftEvaluationsPipelineStageIdFkeyUsingDraftEvaluationsPkeyUpdate>>;
  /** The primary key(s) and patch data for `draftEvaluation` for the far side of the relationship. */
  updateByNodeId?: InputMaybe<Array<PipelineStageOnDraftEvaluationForDraftEvaluationsPipelineStageIdFkeyNodeIdUpdate>>;
  /** The primary key(s) and patch data for `draftEvaluation` for the far side of the relationship. */
  updateByPipelineStageIdAndJobIdAndCandidateId?: InputMaybe<Array<DraftEvaluationOnDraftEvaluationForDraftEvaluationsPipelineStageIdFkeyUsingDraftEvaluationsPipelineStageIdJobIdCandidateIdKeyUpdate>>;
};

/** The `pipelineStage` to be created by this mutation. */
export type DraftEvaluationsPipelineStageIdFkeyPipelineStagesCreateInput = {
  draftEvaluations?: InputMaybe<DraftEvaluationsPipelineStageIdFkeyInverseInput>;
  jobsApplications?: InputMaybe<JobsApplicationsPipelineStageIdFkeyInverseInput>;
  pipeline?: InputMaybe<PipelineStagesPipelineIdFkeyInput>;
  pipelineId?: InputMaybe<Scalars['Int']['input']>;
  position: Scalars['Int']['input'];
  stageScorecards?: InputMaybe<PipelineStageScorecardsPipelineStageIdFkeyInverseInput>;
  stageUsers?: InputMaybe<PipelineStageUsersPipelineStageIdFkeyInverseInput>;
  translations?: InputMaybe<PipelineStageTranslationsPipelineStageIdFkeyInverseInput>;
  type: PipelineStageType;
};

export enum DurationType {
  Monthly = 'MONTHLY',
  Seasonal = 'SEASONAL',
  Unlimited = 'UNLIMITED',
  Yearly = 'YEARLY'
}

/** A filter to be used against DurationType fields. All fields are combined with a logical ‘and.’ */
export type DurationTypeFilter = {
  /** Not equal to the specified value, treating null like an ordinary value. */
  distinctFrom?: InputMaybe<DurationType>;
  /** Equal to the specified value. */
  equalTo?: InputMaybe<DurationType>;
  /** Greater than the specified value. */
  greaterThan?: InputMaybe<DurationType>;
  /** Greater than or equal to the specified value. */
  greaterThanOrEqualTo?: InputMaybe<DurationType>;
  /** Included in the specified list. */
  in?: InputMaybe<Array<DurationType>>;
  /** Is null (if `true` is specified) or is not null (if `false` is specified). */
  isNull?: InputMaybe<Scalars['Boolean']['input']>;
  /** Less than the specified value. */
  lessThan?: InputMaybe<DurationType>;
  /** Less than or equal to the specified value. */
  lessThanOrEqualTo?: InputMaybe<DurationType>;
  /** Equal to the specified value, treating null like an ordinary value. */
  notDistinctFrom?: InputMaybe<DurationType>;
  /** Not equal to the specified value. */
  notEqualTo?: InputMaybe<DurationType>;
  /** Not included in the specified list. */
  notIn?: InputMaybe<Array<DurationType>>;
};

export type Evaluation = Node & {
  __typename?: 'Evaluation';
  /** Reads a single `Candidate` that is related to this `Evaluation`. */
  candidate?: Maybe<Candidate>;
  candidateId: Scalars['Int']['output'];
  /** Reads and enables pagination through a set of `CandidateQuestionnaire`. */
  candidateQuestionnaires: CandidateQuestionnairesConnection;
  /** Reads and enables pagination through a set of `CandidateQuestion`. */
  candidateQuestions: CandidateQuestionsConnection;
  comment?: Maybe<Scalars['String']['output']>;
  createdAt: Scalars['Datetime']['output'];
  /** Reads a single `DraftEvaluation` that is related to this `Evaluation`. */
  draftEvaluation?: Maybe<DraftEvaluation>;
  draftEvaluationId?: Maybe<Scalars['Int']['output']>;
  /** Reads and enables pagination through a set of `EvaluationScorecard`. */
  evaluationScorecards: EvaluationScorecardsConnection;
  /** Reads a single `EventDraftEvaluation` that is related to this `Evaluation`. */
  eventDraftEvaluation?: Maybe<EventDraftEvaluation>;
  eventDraftEvaluationId?: Maybe<Scalars['Int']['output']>;
  id: Scalars['Int']['output'];
  /** Reads a single `Job` that is related to this `Evaluation`. */
  job?: Maybe<Job>;
  jobId?: Maybe<Scalars['Int']['output']>;
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  point: Scalars['Int']['output'];
  /** Reads and enables pagination through a set of `Scorecard`. */
  scorecards: EvaluationScorecardsByEvaluationScorecardEvaluationIdAndScorecardIdManyToManyConnection;
  /** Reads a single `User` that is related to this `Evaluation`. */
  user?: Maybe<User>;
  userId: Scalars['Int']['output'];
};


export type EvaluationCandidateQuestionnairesArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<CandidateQuestionnaireCondition>;
  filter?: InputMaybe<CandidateQuestionnaireFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<CandidateQuestionnairesOrderBy>>;
};


export type EvaluationCandidateQuestionsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<CandidateQuestionCondition>;
  filter?: InputMaybe<CandidateQuestionFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<CandidateQuestionsOrderBy>>;
};


export type EvaluationEvaluationScorecardsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<EvaluationScorecardCondition>;
  filter?: InputMaybe<EvaluationScorecardFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<EvaluationScorecardsOrderBy>>;
};


export type EvaluationScorecardsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<ScorecardCondition>;
  filter?: InputMaybe<ScorecardFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<ScorecardsOrderBy>>;
};

/** A condition to be used against `Evaluation` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type EvaluationCondition = {
  /** Checks for equality with the object’s `candidateId` field. */
  candidateId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `createdAt` field. */
  createdAt?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `draftEvaluationId` field. */
  draftEvaluationId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `eventDraftEvaluationId` field. */
  eventDraftEvaluationId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `jobId` field. */
  jobId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `point` field. */
  point?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `userId` field. */
  userId?: InputMaybe<Scalars['Int']['input']>;
};

/** The fields on `evaluation` to look up the row to connect. */
export type EvaluationEvaluationsPkeyConnect = {
  id: Scalars['Int']['input'];
};

/** A filter to be used against `Evaluation` object types. All fields are combined with a logical ‘and.’ */
export type EvaluationFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<EvaluationFilter>>;
  /** Filter by the object’s `candidate` relation. */
  candidate?: InputMaybe<CandidateFilter>;
  /** Filter by the object’s `candidateId` field. */
  candidateId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `candidateQuestionnaires` relation. */
  candidateQuestionnaires?: InputMaybe<EvaluationToManyCandidateQuestionnaireFilter>;
  /** Some related `candidateQuestionnaires` exist. */
  candidateQuestionnairesExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `candidateQuestions` relation. */
  candidateQuestions?: InputMaybe<EvaluationToManyCandidateQuestionFilter>;
  /** Some related `candidateQuestions` exist. */
  candidateQuestionsExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `createdAt` field. */
  createdAt?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `draftEvaluation` relation. */
  draftEvaluation?: InputMaybe<DraftEvaluationFilter>;
  /** A related `draftEvaluation` exists. */
  draftEvaluationExists?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `draftEvaluationId` field. */
  draftEvaluationId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `evaluationScorecards` relation. */
  evaluationScorecards?: InputMaybe<EvaluationToManyEvaluationScorecardFilter>;
  /** Some related `evaluationScorecards` exist. */
  evaluationScorecardsExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `eventDraftEvaluation` relation. */
  eventDraftEvaluation?: InputMaybe<EventDraftEvaluationFilter>;
  /** A related `eventDraftEvaluation` exists. */
  eventDraftEvaluationExists?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `eventDraftEvaluationId` field. */
  eventDraftEvaluationId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<IntFilter>;
  /** Filter by the object’s `job` relation. */
  job?: InputMaybe<JobFilter>;
  /** A related `job` exists. */
  jobExists?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `jobId` field. */
  jobId?: InputMaybe<IntFilter>;
  /** Negates the expression. */
  not?: InputMaybe<EvaluationFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<EvaluationFilter>>;
  /** Filter by the object’s `point` field. */
  point?: InputMaybe<IntFilter>;
  /** Filter by the object’s `user` relation. */
  user?: InputMaybe<UserFilter>;
  /** Filter by the object’s `userId` field. */
  userId?: InputMaybe<IntFilter>;
};

/** An input for mutations affecting `Evaluation` */
export type EvaluationInput = {
  candidate?: InputMaybe<EvaluationsCandidateIdFkeyInput>;
  candidateId?: InputMaybe<Scalars['Int']['input']>;
  candidateQuestionnaires?: InputMaybe<CandidateQuestionnairesEvaluationIdFkeyInverseInput>;
  candidateQuestions?: InputMaybe<CandidateQuestionsEvaluationIdFkeyInverseInput>;
  comment?: InputMaybe<Scalars['String']['input']>;
  draftEvaluation?: InputMaybe<EvaluationsDraftEvaluationIdFkeyInput>;
  draftEvaluationId?: InputMaybe<Scalars['Int']['input']>;
  evaluationScorecards?: InputMaybe<EvaluationScorecardsEvaluationIdFkeyInverseInput>;
  eventDraftEvaluation?: InputMaybe<EvaluationsEventDraftEvaluationIdFkeyInput>;
  eventDraftEvaluationId?: InputMaybe<Scalars['Int']['input']>;
  job?: InputMaybe<EvaluationsJobIdFkeyInput>;
  jobId?: InputMaybe<Scalars['Int']['input']>;
  point: Scalars['Int']['input'];
  user?: InputMaybe<EvaluationsUserIdFkeyInput>;
  userId?: InputMaybe<Scalars['Int']['input']>;
};

/** The globally unique `ID` look up for the row to connect. */
export type EvaluationNodeIdConnect = {
  /** The globally unique `ID` which identifies a single `evaluation` to be connected. */
  nodeId: Scalars['ID']['input'];
};

/** The globally unique `ID` look up for the row to update. */
export type EvaluationOnCandidateQuestionForCandidateQuestionsEvaluationIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `candidateQuestion` to be connected. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `candidateQuestion` being updated. */
  patch: CandidateQuestionPatch;
};

/** The fields on `evaluation` to look up the row to update. */
export type EvaluationOnCandidateQuestionForCandidateQuestionsEvaluationIdFkeyUsingEvaluationsPkeyUpdate = {
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `evaluation` being updated. */
  patch: UpdateEvaluationOnCandidateQuestionForCandidateQuestionsEvaluationIdFkeyPatch;
};

/** The globally unique `ID` look up for the row to update. */
export type EvaluationOnCandidateQuestionnaireForCandidateQuestionnairesEvaluationIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `candidateQuestionnaire` to be connected. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `candidateQuestionnaire` being updated. */
  patch: CandidateQuestionnairePatch;
};

/** The fields on `evaluation` to look up the row to update. */
export type EvaluationOnCandidateQuestionnaireForCandidateQuestionnairesEvaluationIdFkeyUsingEvaluationsPkeyUpdate = {
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `evaluation` being updated. */
  patch: UpdateEvaluationOnCandidateQuestionnaireForCandidateQuestionnairesEvaluationIdFkeyPatch;
};

/** The globally unique `ID` look up for the row to update. */
export type EvaluationOnEvaluationForEvaluationsCandidateIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `candidate` to be connected. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `candidate` being updated. */
  patch: CandidatePatch;
};

/** The fields on `evaluation` to look up the row to update. */
export type EvaluationOnEvaluationForEvaluationsCandidateIdFkeyUsingEvaluationsPkeyUpdate = {
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `evaluation` being updated. */
  patch: UpdateEvaluationOnEvaluationForEvaluationsCandidateIdFkeyPatch;
};

/** The globally unique `ID` look up for the row to update. */
export type EvaluationOnEvaluationForEvaluationsDraftEvaluationIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `draftEvaluation` to be connected. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `draftEvaluation` being updated. */
  patch: DraftEvaluationPatch;
};

/** The fields on `evaluation` to look up the row to update. */
export type EvaluationOnEvaluationForEvaluationsDraftEvaluationIdFkeyUsingEvaluationsPkeyUpdate = {
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `evaluation` being updated. */
  patch: UpdateEvaluationOnEvaluationForEvaluationsDraftEvaluationIdFkeyPatch;
};

/** The globally unique `ID` look up for the row to update. */
export type EvaluationOnEvaluationForEvaluationsEventDraftEvaluationIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `eventDraftEvaluation` to be connected. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `eventDraftEvaluation` being updated. */
  patch: EventDraftEvaluationPatch;
};

/** The fields on `evaluation` to look up the row to update. */
export type EvaluationOnEvaluationForEvaluationsEventDraftEvaluationIdFkeyUsingEvaluationsPkeyUpdate = {
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `evaluation` being updated. */
  patch: UpdateEvaluationOnEvaluationForEvaluationsEventDraftEvaluationIdFkeyPatch;
};

/** The globally unique `ID` look up for the row to update. */
export type EvaluationOnEvaluationForEvaluationsJobIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `job` to be connected. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `job` being updated. */
  patch: JobPatch;
};

/** The fields on `evaluation` to look up the row to update. */
export type EvaluationOnEvaluationForEvaluationsJobIdFkeyUsingEvaluationsPkeyUpdate = {
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `evaluation` being updated. */
  patch: UpdateEvaluationOnEvaluationForEvaluationsJobIdFkeyPatch;
};

/** The globally unique `ID` look up for the row to update. */
export type EvaluationOnEvaluationForEvaluationsUserIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `user` to be connected. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `user` being updated. */
  patch: UserPatch;
};

/** The fields on `evaluation` to look up the row to update. */
export type EvaluationOnEvaluationForEvaluationsUserIdFkeyUsingEvaluationsPkeyUpdate = {
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `evaluation` being updated. */
  patch: UpdateEvaluationOnEvaluationForEvaluationsUserIdFkeyPatch;
};

/** The globally unique `ID` look up for the row to update. */
export type EvaluationOnEvaluationScorecardForEvaluationScorecardsEvaluationIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `evaluationScorecard` to be connected. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `evaluationScorecard` being updated. */
  patch: EvaluationScorecardPatch;
};

/** The fields on `evaluation` to look up the row to update. */
export type EvaluationOnEvaluationScorecardForEvaluationScorecardsEvaluationIdFkeyUsingEvaluationsPkeyUpdate = {
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `evaluation` being updated. */
  patch: UpdateEvaluationOnEvaluationScorecardForEvaluationScorecardsEvaluationIdFkeyPatch;
};

/** Represents an update to a `Evaluation`. Fields that are set will be updated. */
export type EvaluationPatch = {
  candidate?: InputMaybe<EvaluationsCandidateIdFkeyInput>;
  candidateId?: InputMaybe<Scalars['Int']['input']>;
  candidateQuestionnaires?: InputMaybe<CandidateQuestionnairesEvaluationIdFkeyInverseInput>;
  candidateQuestions?: InputMaybe<CandidateQuestionsEvaluationIdFkeyInverseInput>;
  draftEvaluation?: InputMaybe<EvaluationsDraftEvaluationIdFkeyInput>;
  draftEvaluationId?: InputMaybe<Scalars['Int']['input']>;
  evaluationScorecards?: InputMaybe<EvaluationScorecardsEvaluationIdFkeyInverseInput>;
  eventDraftEvaluation?: InputMaybe<EvaluationsEventDraftEvaluationIdFkeyInput>;
  eventDraftEvaluationId?: InputMaybe<Scalars['Int']['input']>;
  job?: InputMaybe<EvaluationsJobIdFkeyInput>;
  jobId?: InputMaybe<Scalars['Int']['input']>;
  user?: InputMaybe<EvaluationsUserIdFkeyInput>;
  userId?: InputMaybe<Scalars['Int']['input']>;
};

export type EvaluationScorecard = Node & {
  __typename?: 'EvaluationScorecard';
  createdAt: Scalars['Datetime']['output'];
  /** Reads a single `Evaluation` that is related to this `EvaluationScorecard`. */
  evaluation?: Maybe<Evaluation>;
  evaluationId: Scalars['Int']['output'];
  id: Scalars['Int']['output'];
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  /** Reads a single `Scorecard` that is related to this `EvaluationScorecard`. */
  scorecard?: Maybe<Scorecard>;
  /** Reads and enables pagination through a set of `ScorecardCriteria`. */
  scorecardCriteria: EvaluationScorecardScorecardCriteriaByEvaluationScorecardCriteriaEvaluationScorecardIdAndCriteriaIdManyToManyConnection;
  /** Reads and enables pagination through a set of `EvaluationScorecardCriteria`. */
  scorecardCriterias: EvaluationScorecardCriteriaConnection;
  scorecardId: Scalars['Int']['output'];
};


export type EvaluationScorecardScorecardCriteriaArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<ScorecardCriteriaCondition>;
  filter?: InputMaybe<ScorecardCriteriaFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<ScorecardCriteriaOrderBy>>;
};


export type EvaluationScorecardScorecardCriteriasArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<EvaluationScorecardCriteriaCondition>;
  filter?: InputMaybe<EvaluationScorecardCriteriaFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<EvaluationScorecardCriteriaOrderBy>>;
};

/** A condition to be used against `EvaluationScorecard` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type EvaluationScorecardCondition = {
  /** Checks for equality with the object’s `evaluationId` field. */
  evaluationId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `scorecardId` field. */
  scorecardId?: InputMaybe<Scalars['Int']['input']>;
};

export type EvaluationScorecardCriteria = Node & {
  __typename?: 'EvaluationScorecardCriteria';
  comment?: Maybe<Scalars['String']['output']>;
  createdAt: Scalars['Datetime']['output'];
  /** Reads a single `ScorecardCriteria` that is related to this `EvaluationScorecardCriteria`. */
  criteria?: Maybe<ScorecardCriteria>;
  criteriaId: Scalars['Int']['output'];
  /** Reads a single `EvaluationScorecard` that is related to this `EvaluationScorecardCriteria`. */
  evaluationScorecard?: Maybe<EvaluationScorecard>;
  evaluationScorecardId: Scalars['Int']['output'];
  id: Scalars['Int']['output'];
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  point?: Maybe<Scalars['Int']['output']>;
};

/** A condition to be used against `EvaluationScorecardCriteria` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type EvaluationScorecardCriteriaCondition = {
  /** Checks for equality with the object’s `criteriaId` field. */
  criteriaId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `evaluationScorecardId` field. */
  evaluationScorecardId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['Int']['input']>;
};

/** A connection to a list of `EvaluationScorecardCriteria` values. */
export type EvaluationScorecardCriteriaConnection = {
  __typename?: 'EvaluationScorecardCriteriaConnection';
  /** A list of edges which contains the `EvaluationScorecardCriteria` and cursor to aid in pagination. */
  edges: Array<EvaluationScorecardCriteriaEdge>;
  /** A list of `EvaluationScorecardCriteria` objects. */
  nodes: Array<EvaluationScorecardCriteria>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `EvaluationScorecardCriteria` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `EvaluationScorecardCriteria` edge in the connection. */
export type EvaluationScorecardCriteriaEdge = {
  __typename?: 'EvaluationScorecardCriteriaEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `EvaluationScorecardCriteria` at the end of the edge. */
  node: EvaluationScorecardCriteria;
};

/** The fields on `evaluationScorecardCriteria` to look up the row to connect. */
export type EvaluationScorecardCriteriaEvaluationScorecardCriteriasPkeyConnect = {
  id: Scalars['Int']['input'];
};

/** A filter to be used against `EvaluationScorecardCriteria` object types. All fields are combined with a logical ‘and.’ */
export type EvaluationScorecardCriteriaFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<EvaluationScorecardCriteriaFilter>>;
  /** Filter by the object’s `criteria` relation. */
  criteria?: InputMaybe<ScorecardCriteriaFilter>;
  /** Filter by the object’s `criteriaId` field. */
  criteriaId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `evaluationScorecard` relation. */
  evaluationScorecard?: InputMaybe<EvaluationScorecardFilter>;
  /** Filter by the object’s `evaluationScorecardId` field. */
  evaluationScorecardId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<IntFilter>;
  /** Negates the expression. */
  not?: InputMaybe<EvaluationScorecardCriteriaFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<EvaluationScorecardCriteriaFilter>>;
};

/** An input for mutations affecting `EvaluationScorecardCriteria` */
export type EvaluationScorecardCriteriaInput = {
  comment?: InputMaybe<Scalars['String']['input']>;
  criteriaId?: InputMaybe<Scalars['Int']['input']>;
  evaluationScorecard?: InputMaybe<EvaluationScorecardCriteriasEvaluationScorecardIdFkeyInput>;
  evaluationScorecardId?: InputMaybe<Scalars['Int']['input']>;
  point?: InputMaybe<Scalars['Int']['input']>;
  scorecardCriteria?: InputMaybe<EvaluationScorecardCriteriasCriteriaIdFkeyInput>;
};

/** The globally unique `ID` look up for the row to connect. */
export type EvaluationScorecardCriteriaNodeIdConnect = {
  /** The globally unique `ID` which identifies a single `evaluationScorecardCriteria` to be connected. */
  nodeId: Scalars['ID']['input'];
};

/** The globally unique `ID` look up for the row to update. */
export type EvaluationScorecardCriteriaOnEvaluationScorecardCriteriaForEvaluationScorecardCriteriasCriteriaIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `scorecardCriteria` to be connected. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `scorecardCriteria` being updated. */
  patch: ScorecardCriteriaPatch;
};

/** The fields on `evaluationScorecardCriteria` to look up the row to update. */
export type EvaluationScorecardCriteriaOnEvaluationScorecardCriteriaForEvaluationScorecardCriteriasCriteriaIdFkeyUsingEvaluationScorecardCriteriasPkeyUpdate = {
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `evaluationScorecardCriteria` being updated. */
  patch: UpdateEvaluationScorecardCriteriaOnEvaluationScorecardCriteriaForEvaluationScorecardCriteriasCriteriaIdFkeyPatch;
};

/** The globally unique `ID` look up for the row to update. */
export type EvaluationScorecardCriteriaOnEvaluationScorecardCriteriaForEvaluationScorecardCriteriasEvaluationScorecardIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `evaluationScorecard` to be connected. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `evaluationScorecard` being updated. */
  patch: EvaluationScorecardPatch;
};

/** The fields on `evaluationScorecardCriteria` to look up the row to update. */
export type EvaluationScorecardCriteriaOnEvaluationScorecardCriteriaForEvaluationScorecardCriteriasEvaluationScorecardIdFkeyUsingEvaluationScorecardCriteriasPkeyUpdate = {
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `evaluationScorecardCriteria` being updated. */
  patch: UpdateEvaluationScorecardCriteriaOnEvaluationScorecardCriteriaForEvaluationScorecardCriteriasEvaluationScorecardIdFkeyPatch;
};

/** Methods to use when ordering `EvaluationScorecardCriteria`. */
export enum EvaluationScorecardCriteriaOrderBy {
  CriteriaIdAsc = 'CRITERIA_ID_ASC',
  CriteriaIdDesc = 'CRITERIA_ID_DESC',
  EvaluationScorecardIdAsc = 'EVALUATION_SCORECARD_ID_ASC',
  EvaluationScorecardIdDesc = 'EVALUATION_SCORECARD_ID_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  Natural = 'NATURAL',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC'
}

/** Represents an update to a `EvaluationScorecardCriteria`. Fields that are set will be updated. */
export type EvaluationScorecardCriteriaPatch = {
  comment?: InputMaybe<Scalars['String']['input']>;
  criteriaId?: InputMaybe<Scalars['Int']['input']>;
  evaluationScorecard?: InputMaybe<EvaluationScorecardCriteriasEvaluationScorecardIdFkeyInput>;
  evaluationScorecardId?: InputMaybe<Scalars['Int']['input']>;
  scorecardCriteria?: InputMaybe<EvaluationScorecardCriteriasCriteriaIdFkeyInput>;
};

/** The `evaluationScorecardCriteria` to be created by this mutation. */
export type EvaluationScorecardCriteriasCriteriaIdFkeyEvaluationScorecardCriteriasCreateInput = {
  comment?: InputMaybe<Scalars['String']['input']>;
  evaluationScorecard?: InputMaybe<EvaluationScorecardCriteriasEvaluationScorecardIdFkeyInput>;
  evaluationScorecardId?: InputMaybe<Scalars['Int']['input']>;
  point?: InputMaybe<Scalars['Int']['input']>;
  scorecardCriteria?: InputMaybe<EvaluationScorecardCriteriasCriteriaIdFkeyInput>;
};

/** Input for the nested mutation of `scorecardCriteria` in the `EvaluationScorecardCriteriaInput` mutation. */
export type EvaluationScorecardCriteriasCriteriaIdFkeyInput = {
  /** The primary key(s) for `scorecardCriteria` for the far side of the relationship. */
  connectById?: InputMaybe<ScorecardCriteriaScorecardCriteriasPkeyConnect>;
  /** The primary key(s) for `scorecardCriteria` for the far side of the relationship. */
  connectByNodeId?: InputMaybe<ScorecardCriteriaNodeIdConnect>;
  /** A `ScorecardCriteriaInput` object that will be created and connected to this object. */
  create?: InputMaybe<EvaluationScorecardCriteriasCriteriaIdFkeyScorecardCriteriasCreateInput>;
  /** The primary key(s) and patch data for `scorecardCriteria` for the far side of the relationship. */
  updateById?: InputMaybe<ScorecardCriteriaOnEvaluationScorecardCriteriaForEvaluationScorecardCriteriasCriteriaIdFkeyUsingScorecardCriteriasPkeyUpdate>;
  /** The primary key(s) and patch data for `scorecardCriteria` for the far side of the relationship. */
  updateByNodeId?: InputMaybe<EvaluationScorecardCriteriaOnEvaluationScorecardCriteriaForEvaluationScorecardCriteriasCriteriaIdFkeyNodeIdUpdate>;
};

/** Input for the nested mutation of `evaluationScorecardCriteria` in the `ScorecardCriteriaInput` mutation. */
export type EvaluationScorecardCriteriasCriteriaIdFkeyInverseInput = {
  /** The primary key(s) for `evaluationScorecardCriteria` for the far side of the relationship. */
  connectById?: InputMaybe<Array<EvaluationScorecardCriteriaEvaluationScorecardCriteriasPkeyConnect>>;
  /** The primary key(s) for `evaluationScorecardCriteria` for the far side of the relationship. */
  connectByNodeId?: InputMaybe<Array<EvaluationScorecardCriteriaNodeIdConnect>>;
  /** A `EvaluationScorecardCriteriaInput` object that will be created and connected to this object. */
  create?: InputMaybe<Array<EvaluationScorecardCriteriasCriteriaIdFkeyEvaluationScorecardCriteriasCreateInput>>;
  /** The primary key(s) and patch data for `evaluationScorecardCriteria` for the far side of the relationship. */
  updateById?: InputMaybe<Array<EvaluationScorecardCriteriaOnEvaluationScorecardCriteriaForEvaluationScorecardCriteriasCriteriaIdFkeyUsingEvaluationScorecardCriteriasPkeyUpdate>>;
  /** The primary key(s) and patch data for `evaluationScorecardCriteria` for the far side of the relationship. */
  updateByNodeId?: InputMaybe<Array<ScorecardCriteriaOnEvaluationScorecardCriteriaForEvaluationScorecardCriteriasCriteriaIdFkeyNodeIdUpdate>>;
};

/** The `scorecardCriteria` to be created by this mutation. */
export type EvaluationScorecardCriteriasCriteriaIdFkeyScorecardCriteriasCreateInput = {
  commentable: Scalars['Boolean']['input'];
  evaluationScorecardCriteria?: InputMaybe<EvaluationScorecardCriteriasCriteriaIdFkeyInverseInput>;
  required: Scalars['Boolean']['input'];
  scorecard?: InputMaybe<ScorecardCriteriasScorecardIdFkeyInput>;
  scorecardId?: InputMaybe<Scalars['Int']['input']>;
  translations?: InputMaybe<ScorecardCriteriaTranslationsScorecardCriteriaIdFkeyInverseInput>;
};

/** The `evaluationScorecardCriteria` to be created by this mutation. */
export type EvaluationScorecardCriteriasEvaluationScorecardIdFkeyEvaluationScorecardCriteriasCreateInput = {
  comment?: InputMaybe<Scalars['String']['input']>;
  criteriaId?: InputMaybe<Scalars['Int']['input']>;
  evaluationScorecard?: InputMaybe<EvaluationScorecardCriteriasEvaluationScorecardIdFkeyInput>;
  point?: InputMaybe<Scalars['Int']['input']>;
  scorecardCriteria?: InputMaybe<EvaluationScorecardCriteriasCriteriaIdFkeyInput>;
};

/** The `evaluationScorecard` to be created by this mutation. */
export type EvaluationScorecardCriteriasEvaluationScorecardIdFkeyEvaluationScorecardsCreateInput = {
  evaluation?: InputMaybe<EvaluationScorecardsEvaluationIdFkeyInput>;
  evaluationId?: InputMaybe<Scalars['Int']['input']>;
  scorecard?: InputMaybe<EvaluationScorecardsScorecardIdFkeyInput>;
  scorecardCriterias?: InputMaybe<EvaluationScorecardCriteriasEvaluationScorecardIdFkeyInverseInput>;
  scorecardId?: InputMaybe<Scalars['Int']['input']>;
};

/** Input for the nested mutation of `evaluationScorecard` in the `EvaluationScorecardCriteriaInput` mutation. */
export type EvaluationScorecardCriteriasEvaluationScorecardIdFkeyInput = {
  /** The primary key(s) for `evaluationScorecard` for the far side of the relationship. */
  connectById?: InputMaybe<EvaluationScorecardEvaluationScorecardsPkeyConnect>;
  /** The primary key(s) for `evaluationScorecard` for the far side of the relationship. */
  connectByNodeId?: InputMaybe<EvaluationScorecardNodeIdConnect>;
  /** A `EvaluationScorecardInput` object that will be created and connected to this object. */
  create?: InputMaybe<EvaluationScorecardCriteriasEvaluationScorecardIdFkeyEvaluationScorecardsCreateInput>;
  /** The primary key(s) and patch data for `evaluationScorecard` for the far side of the relationship. */
  updateById?: InputMaybe<EvaluationScorecardOnEvaluationScorecardCriteriaForEvaluationScorecardCriteriasEvaluationScorecardIdFkeyUsingEvaluationScorecardsPkeyUpdate>;
  /** The primary key(s) and patch data for `evaluationScorecard` for the far side of the relationship. */
  updateByNodeId?: InputMaybe<EvaluationScorecardCriteriaOnEvaluationScorecardCriteriaForEvaluationScorecardCriteriasEvaluationScorecardIdFkeyNodeIdUpdate>;
};

/** Input for the nested mutation of `evaluationScorecardCriteria` in the `EvaluationScorecardInput` mutation. */
export type EvaluationScorecardCriteriasEvaluationScorecardIdFkeyInverseInput = {
  /** The primary key(s) for `evaluationScorecardCriteria` for the far side of the relationship. */
  connectById?: InputMaybe<Array<EvaluationScorecardCriteriaEvaluationScorecardCriteriasPkeyConnect>>;
  /** The primary key(s) for `evaluationScorecardCriteria` for the far side of the relationship. */
  connectByNodeId?: InputMaybe<Array<EvaluationScorecardCriteriaNodeIdConnect>>;
  /** A `EvaluationScorecardCriteriaInput` object that will be created and connected to this object. */
  create?: InputMaybe<Array<EvaluationScorecardCriteriasEvaluationScorecardIdFkeyEvaluationScorecardCriteriasCreateInput>>;
  /** The primary key(s) and patch data for `evaluationScorecardCriteria` for the far side of the relationship. */
  updateById?: InputMaybe<Array<EvaluationScorecardCriteriaOnEvaluationScorecardCriteriaForEvaluationScorecardCriteriasEvaluationScorecardIdFkeyUsingEvaluationScorecardCriteriasPkeyUpdate>>;
  /** The primary key(s) and patch data for `evaluationScorecardCriteria` for the far side of the relationship. */
  updateByNodeId?: InputMaybe<Array<EvaluationScorecardOnEvaluationScorecardCriteriaForEvaluationScorecardCriteriasEvaluationScorecardIdFkeyNodeIdUpdate>>;
};

/** The fields on `evaluationScorecard` to look up the row to connect. */
export type EvaluationScorecardEvaluationScorecardsPkeyConnect = {
  id: Scalars['Int']['input'];
};

/** A filter to be used against `EvaluationScorecard` object types. All fields are combined with a logical ‘and.’ */
export type EvaluationScorecardFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<EvaluationScorecardFilter>>;
  /** Filter by the object’s `evaluation` relation. */
  evaluation?: InputMaybe<EvaluationFilter>;
  /** Filter by the object’s `evaluationId` field. */
  evaluationId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<IntFilter>;
  /** Negates the expression. */
  not?: InputMaybe<EvaluationScorecardFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<EvaluationScorecardFilter>>;
  /** Filter by the object’s `scorecard` relation. */
  scorecard?: InputMaybe<ScorecardFilter>;
  /** Filter by the object’s `scorecardCriterias` relation. */
  scorecardCriterias?: InputMaybe<EvaluationScorecardToManyEvaluationScorecardCriteriaFilter>;
  /** Some related `scorecardCriterias` exist. */
  scorecardCriteriasExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `scorecardId` field. */
  scorecardId?: InputMaybe<IntFilter>;
};

/** An input for mutations affecting `EvaluationScorecard` */
export type EvaluationScorecardInput = {
  evaluation?: InputMaybe<EvaluationScorecardsEvaluationIdFkeyInput>;
  evaluationId?: InputMaybe<Scalars['Int']['input']>;
  scorecard?: InputMaybe<EvaluationScorecardsScorecardIdFkeyInput>;
  scorecardCriterias?: InputMaybe<EvaluationScorecardCriteriasEvaluationScorecardIdFkeyInverseInput>;
  scorecardId?: InputMaybe<Scalars['Int']['input']>;
};

/** The globally unique `ID` look up for the row to connect. */
export type EvaluationScorecardNodeIdConnect = {
  /** The globally unique `ID` which identifies a single `evaluationScorecard` to be connected. */
  nodeId: Scalars['ID']['input'];
};

/** The globally unique `ID` look up for the row to update. */
export type EvaluationScorecardOnEvaluationScorecardCriteriaForEvaluationScorecardCriteriasEvaluationScorecardIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `evaluationScorecardCriteria` to be connected. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `evaluationScorecardCriteria` being updated. */
  patch: EvaluationScorecardCriteriaPatch;
};

/** The fields on `evaluationScorecard` to look up the row to update. */
export type EvaluationScorecardOnEvaluationScorecardCriteriaForEvaluationScorecardCriteriasEvaluationScorecardIdFkeyUsingEvaluationScorecardsPkeyUpdate = {
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `evaluationScorecard` being updated. */
  patch: UpdateEvaluationScorecardOnEvaluationScorecardCriteriaForEvaluationScorecardCriteriasEvaluationScorecardIdFkeyPatch;
};

/** The globally unique `ID` look up for the row to update. */
export type EvaluationScorecardOnEvaluationScorecardForEvaluationScorecardsEvaluationIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `evaluation` to be connected. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `evaluation` being updated. */
  patch: EvaluationPatch;
};

/** The fields on `evaluationScorecard` to look up the row to update. */
export type EvaluationScorecardOnEvaluationScorecardForEvaluationScorecardsEvaluationIdFkeyUsingEvaluationScorecardsPkeyUpdate = {
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `evaluationScorecard` being updated. */
  patch: UpdateEvaluationScorecardOnEvaluationScorecardForEvaluationScorecardsEvaluationIdFkeyPatch;
};

/** The globally unique `ID` look up for the row to update. */
export type EvaluationScorecardOnEvaluationScorecardForEvaluationScorecardsScorecardIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `scorecard` to be connected. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `scorecard` being updated. */
  patch: ScorecardPatch;
};

/** The fields on `evaluationScorecard` to look up the row to update. */
export type EvaluationScorecardOnEvaluationScorecardForEvaluationScorecardsScorecardIdFkeyUsingEvaluationScorecardsPkeyUpdate = {
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `evaluationScorecard` being updated. */
  patch: UpdateEvaluationScorecardOnEvaluationScorecardForEvaluationScorecardsScorecardIdFkeyPatch;
};

/** Represents an update to a `EvaluationScorecard`. Fields that are set will be updated. */
export type EvaluationScorecardPatch = {
  evaluation?: InputMaybe<EvaluationScorecardsEvaluationIdFkeyInput>;
  evaluationId?: InputMaybe<Scalars['Int']['input']>;
  scorecard?: InputMaybe<EvaluationScorecardsScorecardIdFkeyInput>;
  scorecardCriterias?: InputMaybe<EvaluationScorecardCriteriasEvaluationScorecardIdFkeyInverseInput>;
  scorecardId?: InputMaybe<Scalars['Int']['input']>;
};

/** A connection to a list of `ScorecardCriteria` values, with data from `EvaluationScorecardCriteria`. */
export type EvaluationScorecardScorecardCriteriaByEvaluationScorecardCriteriaEvaluationScorecardIdAndCriteriaIdManyToManyConnection = {
  __typename?: 'EvaluationScorecardScorecardCriteriaByEvaluationScorecardCriteriaEvaluationScorecardIdAndCriteriaIdManyToManyConnection';
  /** A list of edges which contains the `ScorecardCriteria`, info from the `EvaluationScorecardCriteria`, and the cursor to aid in pagination. */
  edges: Array<EvaluationScorecardScorecardCriteriaByEvaluationScorecardCriteriaEvaluationScorecardIdAndCriteriaIdManyToManyEdge>;
  /** A list of `ScorecardCriteria` objects. */
  nodes: Array<ScorecardCriteria>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `ScorecardCriteria` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `ScorecardCriteria` edge in the connection, with data from `EvaluationScorecardCriteria`. */
export type EvaluationScorecardScorecardCriteriaByEvaluationScorecardCriteriaEvaluationScorecardIdAndCriteriaIdManyToManyEdge = {
  __typename?: 'EvaluationScorecardScorecardCriteriaByEvaluationScorecardCriteriaEvaluationScorecardIdAndCriteriaIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** Reads and enables pagination through a set of `EvaluationScorecardCriteria`. */
  evaluationScorecardCriteriaByCriteriaId: EvaluationScorecardCriteriaConnection;
  /** The `ScorecardCriteria` at the end of the edge. */
  node: ScorecardCriteria;
};


/** A `ScorecardCriteria` edge in the connection, with data from `EvaluationScorecardCriteria`. */
export type EvaluationScorecardScorecardCriteriaByEvaluationScorecardCriteriaEvaluationScorecardIdAndCriteriaIdManyToManyEdgeEvaluationScorecardCriteriaByCriteriaIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<EvaluationScorecardCriteriaCondition>;
  filter?: InputMaybe<EvaluationScorecardCriteriaFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<EvaluationScorecardCriteriaOrderBy>>;
};

/** A filter to be used against many `EvaluationScorecardCriteria` object types. All fields are combined with a logical ‘and.’ */
export type EvaluationScorecardToManyEvaluationScorecardCriteriaFilter = {
  /** Every related `EvaluationScorecardCriteria` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<EvaluationScorecardCriteriaFilter>;
  /** No related `EvaluationScorecardCriteria` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<EvaluationScorecardCriteriaFilter>;
  /** Some related `EvaluationScorecardCriteria` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<EvaluationScorecardCriteriaFilter>;
};

/** A connection to a list of `Scorecard` values, with data from `EvaluationScorecard`. */
export type EvaluationScorecardsByEvaluationScorecardEvaluationIdAndScorecardIdManyToManyConnection = {
  __typename?: 'EvaluationScorecardsByEvaluationScorecardEvaluationIdAndScorecardIdManyToManyConnection';
  /** A list of edges which contains the `Scorecard`, info from the `EvaluationScorecard`, and the cursor to aid in pagination. */
  edges: Array<EvaluationScorecardsByEvaluationScorecardEvaluationIdAndScorecardIdManyToManyEdge>;
  /** A list of `Scorecard` objects. */
  nodes: Array<Scorecard>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Scorecard` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `Scorecard` edge in the connection, with data from `EvaluationScorecard`. */
export type EvaluationScorecardsByEvaluationScorecardEvaluationIdAndScorecardIdManyToManyEdge = {
  __typename?: 'EvaluationScorecardsByEvaluationScorecardEvaluationIdAndScorecardIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** Reads and enables pagination through a set of `EvaluationScorecard`. */
  evaluationScorecards: EvaluationScorecardsConnection;
  /** The `Scorecard` at the end of the edge. */
  node: Scorecard;
};


/** A `Scorecard` edge in the connection, with data from `EvaluationScorecard`. */
export type EvaluationScorecardsByEvaluationScorecardEvaluationIdAndScorecardIdManyToManyEdgeEvaluationScorecardsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<EvaluationScorecardCondition>;
  filter?: InputMaybe<EvaluationScorecardFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<EvaluationScorecardsOrderBy>>;
};

/** A connection to a list of `EvaluationScorecard` values. */
export type EvaluationScorecardsConnection = {
  __typename?: 'EvaluationScorecardsConnection';
  /** A list of edges which contains the `EvaluationScorecard` and cursor to aid in pagination. */
  edges: Array<EvaluationScorecardsEdge>;
  /** A list of `EvaluationScorecard` objects. */
  nodes: Array<EvaluationScorecard>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `EvaluationScorecard` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `EvaluationScorecard` edge in the connection. */
export type EvaluationScorecardsEdge = {
  __typename?: 'EvaluationScorecardsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `EvaluationScorecard` at the end of the edge. */
  node: EvaluationScorecard;
};

/** The `evaluationScorecard` to be created by this mutation. */
export type EvaluationScorecardsEvaluationIdFkeyEvaluationScorecardsCreateInput = {
  evaluation?: InputMaybe<EvaluationScorecardsEvaluationIdFkeyInput>;
  scorecard?: InputMaybe<EvaluationScorecardsScorecardIdFkeyInput>;
  scorecardCriterias?: InputMaybe<EvaluationScorecardCriteriasEvaluationScorecardIdFkeyInverseInput>;
  scorecardId?: InputMaybe<Scalars['Int']['input']>;
};

/** The `evaluation` to be created by this mutation. */
export type EvaluationScorecardsEvaluationIdFkeyEvaluationsCreateInput = {
  candidate?: InputMaybe<EvaluationsCandidateIdFkeyInput>;
  candidateId?: InputMaybe<Scalars['Int']['input']>;
  candidateQuestionnaires?: InputMaybe<CandidateQuestionnairesEvaluationIdFkeyInverseInput>;
  candidateQuestions?: InputMaybe<CandidateQuestionsEvaluationIdFkeyInverseInput>;
  comment?: InputMaybe<Scalars['String']['input']>;
  draftEvaluation?: InputMaybe<EvaluationsDraftEvaluationIdFkeyInput>;
  draftEvaluationId?: InputMaybe<Scalars['Int']['input']>;
  evaluationScorecards?: InputMaybe<EvaluationScorecardsEvaluationIdFkeyInverseInput>;
  eventDraftEvaluation?: InputMaybe<EvaluationsEventDraftEvaluationIdFkeyInput>;
  eventDraftEvaluationId?: InputMaybe<Scalars['Int']['input']>;
  job?: InputMaybe<EvaluationsJobIdFkeyInput>;
  jobId?: InputMaybe<Scalars['Int']['input']>;
  point: Scalars['Int']['input'];
  user?: InputMaybe<EvaluationsUserIdFkeyInput>;
  userId?: InputMaybe<Scalars['Int']['input']>;
};

/** Input for the nested mutation of `evaluation` in the `EvaluationScorecardInput` mutation. */
export type EvaluationScorecardsEvaluationIdFkeyInput = {
  /** The primary key(s) for `evaluation` for the far side of the relationship. */
  connectById?: InputMaybe<EvaluationEvaluationsPkeyConnect>;
  /** The primary key(s) for `evaluation` for the far side of the relationship. */
  connectByNodeId?: InputMaybe<EvaluationNodeIdConnect>;
  /** A `EvaluationInput` object that will be created and connected to this object. */
  create?: InputMaybe<EvaluationScorecardsEvaluationIdFkeyEvaluationsCreateInput>;
  /** The primary key(s) and patch data for `evaluation` for the far side of the relationship. */
  updateById?: InputMaybe<EvaluationOnEvaluationScorecardForEvaluationScorecardsEvaluationIdFkeyUsingEvaluationsPkeyUpdate>;
  /** The primary key(s) and patch data for `evaluation` for the far side of the relationship. */
  updateByNodeId?: InputMaybe<EvaluationScorecardOnEvaluationScorecardForEvaluationScorecardsEvaluationIdFkeyNodeIdUpdate>;
};

/** Input for the nested mutation of `evaluationScorecard` in the `EvaluationInput` mutation. */
export type EvaluationScorecardsEvaluationIdFkeyInverseInput = {
  /** The primary key(s) for `evaluationScorecard` for the far side of the relationship. */
  connectById?: InputMaybe<Array<EvaluationScorecardEvaluationScorecardsPkeyConnect>>;
  /** The primary key(s) for `evaluationScorecard` for the far side of the relationship. */
  connectByNodeId?: InputMaybe<Array<EvaluationScorecardNodeIdConnect>>;
  /** A `EvaluationScorecardInput` object that will be created and connected to this object. */
  create?: InputMaybe<Array<EvaluationScorecardsEvaluationIdFkeyEvaluationScorecardsCreateInput>>;
  /** The primary key(s) and patch data for `evaluationScorecard` for the far side of the relationship. */
  updateById?: InputMaybe<Array<EvaluationScorecardOnEvaluationScorecardForEvaluationScorecardsEvaluationIdFkeyUsingEvaluationScorecardsPkeyUpdate>>;
  /** The primary key(s) and patch data for `evaluationScorecard` for the far side of the relationship. */
  updateByNodeId?: InputMaybe<Array<EvaluationOnEvaluationScorecardForEvaluationScorecardsEvaluationIdFkeyNodeIdUpdate>>;
};

/** Methods to use when ordering `EvaluationScorecard`. */
export enum EvaluationScorecardsOrderBy {
  EvaluationIdAsc = 'EVALUATION_ID_ASC',
  EvaluationIdDesc = 'EVALUATION_ID_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  Natural = 'NATURAL',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  ScorecardIdAsc = 'SCORECARD_ID_ASC',
  ScorecardIdDesc = 'SCORECARD_ID_DESC'
}

/** The `evaluationScorecard` to be created by this mutation. */
export type EvaluationScorecardsScorecardIdFkeyEvaluationScorecardsCreateInput = {
  evaluation?: InputMaybe<EvaluationScorecardsEvaluationIdFkeyInput>;
  evaluationId?: InputMaybe<Scalars['Int']['input']>;
  scorecard?: InputMaybe<EvaluationScorecardsScorecardIdFkeyInput>;
  scorecardCriterias?: InputMaybe<EvaluationScorecardCriteriasEvaluationScorecardIdFkeyInverseInput>;
};

/** Input for the nested mutation of `scorecard` in the `EvaluationScorecardInput` mutation. */
export type EvaluationScorecardsScorecardIdFkeyInput = {
  /** The primary key(s) for `scorecard` for the far side of the relationship. */
  connectById?: InputMaybe<ScorecardScorecardsPkeyConnect>;
  /** The primary key(s) for `scorecard` for the far side of the relationship. */
  connectByNodeId?: InputMaybe<ScorecardNodeIdConnect>;
  /** A `ScorecardInput` object that will be created and connected to this object. */
  create?: InputMaybe<EvaluationScorecardsScorecardIdFkeyScorecardsCreateInput>;
  /** The primary key(s) and patch data for `scorecard` for the far side of the relationship. */
  updateById?: InputMaybe<ScorecardOnEvaluationScorecardForEvaluationScorecardsScorecardIdFkeyUsingScorecardsPkeyUpdate>;
  /** The primary key(s) and patch data for `scorecard` for the far side of the relationship. */
  updateByNodeId?: InputMaybe<EvaluationScorecardOnEvaluationScorecardForEvaluationScorecardsScorecardIdFkeyNodeIdUpdate>;
};

/** Input for the nested mutation of `evaluationScorecard` in the `ScorecardInput` mutation. */
export type EvaluationScorecardsScorecardIdFkeyInverseInput = {
  /** The primary key(s) for `evaluationScorecard` for the far side of the relationship. */
  connectById?: InputMaybe<Array<EvaluationScorecardEvaluationScorecardsPkeyConnect>>;
  /** The primary key(s) for `evaluationScorecard` for the far side of the relationship. */
  connectByNodeId?: InputMaybe<Array<EvaluationScorecardNodeIdConnect>>;
  /** A `EvaluationScorecardInput` object that will be created and connected to this object. */
  create?: InputMaybe<Array<EvaluationScorecardsScorecardIdFkeyEvaluationScorecardsCreateInput>>;
  /** The primary key(s) and patch data for `evaluationScorecard` for the far side of the relationship. */
  updateById?: InputMaybe<Array<EvaluationScorecardOnEvaluationScorecardForEvaluationScorecardsScorecardIdFkeyUsingEvaluationScorecardsPkeyUpdate>>;
  /** The primary key(s) and patch data for `evaluationScorecard` for the far side of the relationship. */
  updateByNodeId?: InputMaybe<Array<ScorecardOnEvaluationScorecardForEvaluationScorecardsScorecardIdFkeyNodeIdUpdate>>;
};

/** The `scorecard` to be created by this mutation. */
export type EvaluationScorecardsScorecardIdFkeyScorecardsCreateInput = {
  criterias?: InputMaybe<ScorecardCriteriasScorecardIdFkeyInverseInput>;
  evaluationScorecards?: InputMaybe<EvaluationScorecardsScorecardIdFkeyInverseInput>;
  eventScorecards?: InputMaybe<EventScorecardsScorecardIdFkeyInverseInput>;
  pipelineStageScorecards?: InputMaybe<PipelineStageScorecardsScorecardIdFkeyInverseInput>;
  translations?: InputMaybe<ScorecardTranslationsScorecardIdFkeyInverseInput>;
};

/** A filter to be used against many `CandidateQuestion` object types. All fields are combined with a logical ‘and.’ */
export type EvaluationToManyCandidateQuestionFilter = {
  /** Every related `CandidateQuestion` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<CandidateQuestionFilter>;
  /** No related `CandidateQuestion` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<CandidateQuestionFilter>;
  /** Some related `CandidateQuestion` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<CandidateQuestionFilter>;
};

/** A filter to be used against many `CandidateQuestionnaire` object types. All fields are combined with a logical ‘and.’ */
export type EvaluationToManyCandidateQuestionnaireFilter = {
  /** Every related `CandidateQuestionnaire` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<CandidateQuestionnaireFilter>;
  /** No related `CandidateQuestionnaire` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<CandidateQuestionnaireFilter>;
  /** Some related `CandidateQuestionnaire` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<CandidateQuestionnaireFilter>;
};

/** A filter to be used against many `EvaluationScorecard` object types. All fields are combined with a logical ‘and.’ */
export type EvaluationToManyEvaluationScorecardFilter = {
  /** Every related `EvaluationScorecard` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<EvaluationScorecardFilter>;
  /** No related `EvaluationScorecard` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<EvaluationScorecardFilter>;
  /** Some related `EvaluationScorecard` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<EvaluationScorecardFilter>;
};

/** The `candidate` to be created by this mutation. */
export type EvaluationsCandidateIdFkeyCandidatesCreateInput = {
  birthday?: InputMaybe<Scalars['Date']['input']>;
  candidateDraftEvaluations?: InputMaybe<DraftEvaluationsCandidateIdFkeyInverseInput>;
  candidateEventDraftEvaluations?: InputMaybe<EventDraftEvaluationsCandidateIdFkeyInverseInput>;
  candidateImportCandidate?: InputMaybe<CandidateImportCandidatesCandidateIdFkeyInverseInput>;
  candidateQuestionnaires?: InputMaybe<CandidateQuestionnairesCandidateIdFkeyInverseInput>;
  candidateQuestions?: InputMaybe<CandidateQuestionsCandidateIdFkeyInverseInput>;
  candidateTags?: InputMaybe<CandidateTagsCandidateIdFkeyInverseInput>;
  cvText?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  emails?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  evaluations?: InputMaybe<EvaluationsCandidateIdFkeyInverseInput>;
  eventCandidates?: InputMaybe<EventCandidatesCandidateIdFkeyInverseInput>;
  files?: InputMaybe<CandidateFilesCandidateIdFkeyInverseInput>;
  gender?: InputMaybe<Gender>;
  jobsApplications?: InputMaybe<JobsApplicationsCandidateIdFkeyInverseInput>;
  language: Language;
  links?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  militaryStatus?: InputMaybe<MilitaryStatus>;
  phones?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  photoExternalId?: InputMaybe<Scalars['UUID']['input']>;
  resumeExternalId?: InputMaybe<Scalars['UUID']['input']>;
  socialLinks?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  sources?: InputMaybe<Array<Scalars['String']['input']>>;
  tags?: InputMaybe<Array<Scalars['String']['input']>>;
  threads?: InputMaybe<ThreadsCandidateIdFkeyInverseInput>;
  translations?: InputMaybe<CandidateTranslationsCandidateIdFkeyInverseInput>;
};

/** The `evaluation` to be created by this mutation. */
export type EvaluationsCandidateIdFkeyEvaluationsCreateInput = {
  candidate?: InputMaybe<EvaluationsCandidateIdFkeyInput>;
  candidateQuestionnaires?: InputMaybe<CandidateQuestionnairesEvaluationIdFkeyInverseInput>;
  candidateQuestions?: InputMaybe<CandidateQuestionsEvaluationIdFkeyInverseInput>;
  comment?: InputMaybe<Scalars['String']['input']>;
  draftEvaluation?: InputMaybe<EvaluationsDraftEvaluationIdFkeyInput>;
  draftEvaluationId?: InputMaybe<Scalars['Int']['input']>;
  evaluationScorecards?: InputMaybe<EvaluationScorecardsEvaluationIdFkeyInverseInput>;
  eventDraftEvaluation?: InputMaybe<EvaluationsEventDraftEvaluationIdFkeyInput>;
  eventDraftEvaluationId?: InputMaybe<Scalars['Int']['input']>;
  job?: InputMaybe<EvaluationsJobIdFkeyInput>;
  jobId?: InputMaybe<Scalars['Int']['input']>;
  point: Scalars['Int']['input'];
  user?: InputMaybe<EvaluationsUserIdFkeyInput>;
  userId?: InputMaybe<Scalars['Int']['input']>;
};

/** Input for the nested mutation of `candidate` in the `EvaluationInput` mutation. */
export type EvaluationsCandidateIdFkeyInput = {
  /** The primary key(s) for `candidate` for the far side of the relationship. */
  connectById?: InputMaybe<CandidateCandidatesPkeyConnect>;
  /** The primary key(s) for `candidate` for the far side of the relationship. */
  connectByNodeId?: InputMaybe<CandidateNodeIdConnect>;
  /** A `CandidateInput` object that will be created and connected to this object. */
  create?: InputMaybe<EvaluationsCandidateIdFkeyCandidatesCreateInput>;
  /** The primary key(s) and patch data for `candidate` for the far side of the relationship. */
  updateById?: InputMaybe<CandidateOnEvaluationForEvaluationsCandidateIdFkeyUsingCandidatesPkeyUpdate>;
  /** The primary key(s) and patch data for `candidate` for the far side of the relationship. */
  updateByNodeId?: InputMaybe<EvaluationOnEvaluationForEvaluationsCandidateIdFkeyNodeIdUpdate>;
};

/** Input for the nested mutation of `evaluation` in the `CandidateInput` mutation. */
export type EvaluationsCandidateIdFkeyInverseInput = {
  /** The primary key(s) for `evaluation` for the far side of the relationship. */
  connectById?: InputMaybe<Array<EvaluationEvaluationsPkeyConnect>>;
  /** The primary key(s) for `evaluation` for the far side of the relationship. */
  connectByNodeId?: InputMaybe<Array<EvaluationNodeIdConnect>>;
  /** A `EvaluationInput` object that will be created and connected to this object. */
  create?: InputMaybe<Array<EvaluationsCandidateIdFkeyEvaluationsCreateInput>>;
  /** The primary key(s) and patch data for `evaluation` for the far side of the relationship. */
  updateById?: InputMaybe<Array<EvaluationOnEvaluationForEvaluationsCandidateIdFkeyUsingEvaluationsPkeyUpdate>>;
  /** The primary key(s) and patch data for `evaluation` for the far side of the relationship. */
  updateByNodeId?: InputMaybe<Array<CandidateOnEvaluationForEvaluationsCandidateIdFkeyNodeIdUpdate>>;
};

/** A connection to a list of `Evaluation` values. */
export type EvaluationsConnection = {
  __typename?: 'EvaluationsConnection';
  /** A list of edges which contains the `Evaluation` and cursor to aid in pagination. */
  edges: Array<EvaluationsEdge>;
  /** A list of `Evaluation` objects. */
  nodes: Array<Evaluation>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Evaluation` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** The `evaluation` to be created by this mutation. */
export type EvaluationsDraftEvaluationIdFkeyEvaluationsCreateInput = {
  candidate?: InputMaybe<EvaluationsCandidateIdFkeyInput>;
  candidateId?: InputMaybe<Scalars['Int']['input']>;
  candidateQuestionnaires?: InputMaybe<CandidateQuestionnairesEvaluationIdFkeyInverseInput>;
  candidateQuestions?: InputMaybe<CandidateQuestionsEvaluationIdFkeyInverseInput>;
  comment?: InputMaybe<Scalars['String']['input']>;
  draftEvaluation?: InputMaybe<EvaluationsDraftEvaluationIdFkeyInput>;
  evaluationScorecards?: InputMaybe<EvaluationScorecardsEvaluationIdFkeyInverseInput>;
  eventDraftEvaluation?: InputMaybe<EvaluationsEventDraftEvaluationIdFkeyInput>;
  eventDraftEvaluationId?: InputMaybe<Scalars['Int']['input']>;
  job?: InputMaybe<EvaluationsJobIdFkeyInput>;
  jobId?: InputMaybe<Scalars['Int']['input']>;
  point: Scalars['Int']['input'];
  user?: InputMaybe<EvaluationsUserIdFkeyInput>;
  userId?: InputMaybe<Scalars['Int']['input']>;
};

/** Input for the nested mutation of `draftEvaluation` in the `EvaluationInput` mutation. */
export type EvaluationsDraftEvaluationIdFkeyInput = {
  /** The primary key(s) for `draftEvaluation` for the far side of the relationship. */
  connectById?: InputMaybe<DraftEvaluationDraftEvaluationsPkeyConnect>;
  /** The primary key(s) for `draftEvaluation` for the far side of the relationship. */
  connectByNodeId?: InputMaybe<DraftEvaluationNodeIdConnect>;
  /** The primary key(s) for `draftEvaluation` for the far side of the relationship. */
  connectByPipelineStageIdAndJobIdAndCandidateId?: InputMaybe<DraftEvaluationDraftEvaluationsPipelineStageIdJobIdCandidateIdKeyConnect>;
  /** The primary key(s) and patch data for `draftEvaluation` for the far side of the relationship. */
  updateById?: InputMaybe<DraftEvaluationOnEvaluationForEvaluationsDraftEvaluationIdFkeyUsingDraftEvaluationsPkeyUpdate>;
  /** The primary key(s) and patch data for `draftEvaluation` for the far side of the relationship. */
  updateByNodeId?: InputMaybe<EvaluationOnEvaluationForEvaluationsDraftEvaluationIdFkeyNodeIdUpdate>;
  /** The primary key(s) and patch data for `draftEvaluation` for the far side of the relationship. */
  updateByPipelineStageIdAndJobIdAndCandidateId?: InputMaybe<DraftEvaluationOnEvaluationForEvaluationsDraftEvaluationIdFkeyUsingDraftEvaluationsPipelineStageIdJobIdCandidateIdKeyUpdate>;
};

/** Input for the nested mutation of `evaluation` in the `DraftEvaluationInput` mutation. */
export type EvaluationsDraftEvaluationIdFkeyInverseInput = {
  /** The primary key(s) for `evaluation` for the far side of the relationship. */
  connectById?: InputMaybe<Array<EvaluationEvaluationsPkeyConnect>>;
  /** The primary key(s) for `evaluation` for the far side of the relationship. */
  connectByNodeId?: InputMaybe<Array<EvaluationNodeIdConnect>>;
  /** A `EvaluationInput` object that will be created and connected to this object. */
  create?: InputMaybe<Array<EvaluationsDraftEvaluationIdFkeyEvaluationsCreateInput>>;
  /** The primary key(s) and patch data for `evaluation` for the far side of the relationship. */
  updateById?: InputMaybe<Array<EvaluationOnEvaluationForEvaluationsDraftEvaluationIdFkeyUsingEvaluationsPkeyUpdate>>;
  /** The primary key(s) and patch data for `evaluation` for the far side of the relationship. */
  updateByNodeId?: InputMaybe<Array<DraftEvaluationOnEvaluationForEvaluationsDraftEvaluationIdFkeyNodeIdUpdate>>;
};

/** A `Evaluation` edge in the connection. */
export type EvaluationsEdge = {
  __typename?: 'EvaluationsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Evaluation` at the end of the edge. */
  node: Evaluation;
};

/** The `evaluation` to be created by this mutation. */
export type EvaluationsEventDraftEvaluationIdFkeyEvaluationsCreateInput = {
  candidate?: InputMaybe<EvaluationsCandidateIdFkeyInput>;
  candidateId?: InputMaybe<Scalars['Int']['input']>;
  candidateQuestionnaires?: InputMaybe<CandidateQuestionnairesEvaluationIdFkeyInverseInput>;
  candidateQuestions?: InputMaybe<CandidateQuestionsEvaluationIdFkeyInverseInput>;
  comment?: InputMaybe<Scalars['String']['input']>;
  draftEvaluation?: InputMaybe<EvaluationsDraftEvaluationIdFkeyInput>;
  draftEvaluationId?: InputMaybe<Scalars['Int']['input']>;
  evaluationScorecards?: InputMaybe<EvaluationScorecardsEvaluationIdFkeyInverseInput>;
  eventDraftEvaluation?: InputMaybe<EvaluationsEventDraftEvaluationIdFkeyInput>;
  job?: InputMaybe<EvaluationsJobIdFkeyInput>;
  jobId?: InputMaybe<Scalars['Int']['input']>;
  point: Scalars['Int']['input'];
  user?: InputMaybe<EvaluationsUserIdFkeyInput>;
  userId?: InputMaybe<Scalars['Int']['input']>;
};

/** Input for the nested mutation of `eventDraftEvaluation` in the `EvaluationInput` mutation. */
export type EvaluationsEventDraftEvaluationIdFkeyInput = {
  /** The primary key(s) for `eventDraftEvaluation` for the far side of the relationship. */
  connectByEventIdAndCandidateId?: InputMaybe<EventDraftEvaluationEventDraftEvaluationsEventIdCandidateIdKeyConnect>;
  /** The primary key(s) for `eventDraftEvaluation` for the far side of the relationship. */
  connectById?: InputMaybe<EventDraftEvaluationEventDraftEvaluationsPkeyConnect>;
  /** The primary key(s) for `eventDraftEvaluation` for the far side of the relationship. */
  connectByNodeId?: InputMaybe<EventDraftEvaluationNodeIdConnect>;
  /** The primary key(s) and patch data for `eventDraftEvaluation` for the far side of the relationship. */
  updateByEventIdAndCandidateId?: InputMaybe<EventDraftEvaluationOnEvaluationForEvaluationsEventDraftEvaluationIdFkeyUsingEventDraftEvaluationsEventIdCandidateIdKeyUpdate>;
  /** The primary key(s) and patch data for `eventDraftEvaluation` for the far side of the relationship. */
  updateById?: InputMaybe<EventDraftEvaluationOnEvaluationForEvaluationsEventDraftEvaluationIdFkeyUsingEventDraftEvaluationsPkeyUpdate>;
  /** The primary key(s) and patch data for `eventDraftEvaluation` for the far side of the relationship. */
  updateByNodeId?: InputMaybe<EvaluationOnEvaluationForEvaluationsEventDraftEvaluationIdFkeyNodeIdUpdate>;
};

/** Input for the nested mutation of `evaluation` in the `EventDraftEvaluationInput` mutation. */
export type EvaluationsEventDraftEvaluationIdFkeyInverseInput = {
  /** The primary key(s) for `evaluation` for the far side of the relationship. */
  connectById?: InputMaybe<Array<EvaluationEvaluationsPkeyConnect>>;
  /** The primary key(s) for `evaluation` for the far side of the relationship. */
  connectByNodeId?: InputMaybe<Array<EvaluationNodeIdConnect>>;
  /** A `EvaluationInput` object that will be created and connected to this object. */
  create?: InputMaybe<Array<EvaluationsEventDraftEvaluationIdFkeyEvaluationsCreateInput>>;
  /** The primary key(s) and patch data for `evaluation` for the far side of the relationship. */
  updateById?: InputMaybe<Array<EvaluationOnEvaluationForEvaluationsEventDraftEvaluationIdFkeyUsingEvaluationsPkeyUpdate>>;
  /** The primary key(s) and patch data for `evaluation` for the far side of the relationship. */
  updateByNodeId?: InputMaybe<Array<EventDraftEvaluationOnEvaluationForEvaluationsEventDraftEvaluationIdFkeyNodeIdUpdate>>;
};

/** The `evaluation` to be created by this mutation. */
export type EvaluationsJobIdFkeyEvaluationsCreateInput = {
  candidate?: InputMaybe<EvaluationsCandidateIdFkeyInput>;
  candidateId?: InputMaybe<Scalars['Int']['input']>;
  candidateQuestionnaires?: InputMaybe<CandidateQuestionnairesEvaluationIdFkeyInverseInput>;
  candidateQuestions?: InputMaybe<CandidateQuestionsEvaluationIdFkeyInverseInput>;
  comment?: InputMaybe<Scalars['String']['input']>;
  draftEvaluation?: InputMaybe<EvaluationsDraftEvaluationIdFkeyInput>;
  draftEvaluationId?: InputMaybe<Scalars['Int']['input']>;
  evaluationScorecards?: InputMaybe<EvaluationScorecardsEvaluationIdFkeyInverseInput>;
  eventDraftEvaluation?: InputMaybe<EvaluationsEventDraftEvaluationIdFkeyInput>;
  eventDraftEvaluationId?: InputMaybe<Scalars['Int']['input']>;
  job?: InputMaybe<EvaluationsJobIdFkeyInput>;
  point: Scalars['Int']['input'];
  user?: InputMaybe<EvaluationsUserIdFkeyInput>;
  userId?: InputMaybe<Scalars['Int']['input']>;
};

/** Input for the nested mutation of `job` in the `EvaluationInput` mutation. */
export type EvaluationsJobIdFkeyInput = {
  /** The primary key(s) for `job` for the far side of the relationship. */
  connectById?: InputMaybe<JobJobsPkeyConnect>;
  /** The primary key(s) for `job` for the far side of the relationship. */
  connectByNodeId?: InputMaybe<JobNodeIdConnect>;
  /** A `JobInput` object that will be created and connected to this object. */
  create?: InputMaybe<EvaluationsJobIdFkeyJobsCreateInput>;
  /** The primary key(s) and patch data for `job` for the far side of the relationship. */
  updateById?: InputMaybe<JobOnEvaluationForEvaluationsJobIdFkeyUsingJobsPkeyUpdate>;
  /** The primary key(s) and patch data for `job` for the far side of the relationship. */
  updateByNodeId?: InputMaybe<EvaluationOnEvaluationForEvaluationsJobIdFkeyNodeIdUpdate>;
};

/** Input for the nested mutation of `evaluation` in the `JobInput` mutation. */
export type EvaluationsJobIdFkeyInverseInput = {
  /** The primary key(s) for `evaluation` for the far side of the relationship. */
  connectById?: InputMaybe<Array<EvaluationEvaluationsPkeyConnect>>;
  /** The primary key(s) for `evaluation` for the far side of the relationship. */
  connectByNodeId?: InputMaybe<Array<EvaluationNodeIdConnect>>;
  /** A `EvaluationInput` object that will be created and connected to this object. */
  create?: InputMaybe<Array<EvaluationsJobIdFkeyEvaluationsCreateInput>>;
  /** The primary key(s) and patch data for `evaluation` for the far side of the relationship. */
  updateById?: InputMaybe<Array<EvaluationOnEvaluationForEvaluationsJobIdFkeyUsingEvaluationsPkeyUpdate>>;
  /** The primary key(s) and patch data for `evaluation` for the far side of the relationship. */
  updateByNodeId?: InputMaybe<Array<JobOnEvaluationForEvaluationsJobIdFkeyNodeIdUpdate>>;
};

/** The `job` to be created by this mutation. */
export type EvaluationsJobIdFkeyJobsCreateInput = {
  address?: InputMaybe<Scalars['String']['input']>;
  applications?: InputMaybe<JobsApplicationsJobIdFkeyInverseInput>;
  city?: InputMaybe<Scalars['String']['input']>;
  competencies?: InputMaybe<Array<Scalars['String']['input']>>;
  country?: InputMaybe<Scalars['Int']['input']>;
  department?: InputMaybe<JobsDepartmentIdFkeyInput>;
  departmentId?: InputMaybe<Scalars['Int']['input']>;
  draftEvaluations?: InputMaybe<DraftEvaluationsJobIdFkeyInverseInput>;
  education?: InputMaybe<JobEducation>;
  evaluations?: InputMaybe<EvaluationsJobIdFkeyInverseInput>;
  fields?: InputMaybe<JobFieldsJobIdFkeyInverseInput>;
  genders?: InputMaybe<Array<InputMaybe<Gender>>>;
  gradeConditions?: InputMaybe<Array<InputMaybe<GradeCondition>>>;
  hoursPerWeek?: InputMaybe<IntRangeInput>;
  isRemote?: InputMaybe<Scalars['Boolean']['input']>;
  jobCompetencies?: InputMaybe<JobCompetenciesJobIdFkeyInverseInput>;
  jobKnowledges?: InputMaybe<JobKnowledgesJobIdFkeyInverseInput>;
  jobQuestionnaires?: InputMaybe<JobQuestionnairesJobIdFkeyInverseInput>;
  jobSkills?: InputMaybe<JobSkillsJobIdFkeyInverseInput>;
  jobTags?: InputMaybe<JobTagsJobIdFkeyInverseInput>;
  knowledges?: InputMaybe<Array<Scalars['String']['input']>>;
  languages: Array<InputMaybe<Language>>;
  maxAgeCondition?: InputMaybe<Scalars['Int']['input']>;
  militaryStatus?: InputMaybe<Array<InputMaybe<MilitaryStatus>>>;
  minAgeCondition?: InputMaybe<Scalars['Int']['input']>;
  owners?: InputMaybe<JobOwnersJobIdFkeyInverseInput>;
  pipeline?: InputMaybe<JobsPipelineIdFkeyInput>;
  pipelineId?: InputMaybe<Scalars['Int']['input']>;
  position: Scalars['Int']['input'];
  publishedAt?: InputMaybe<Scalars['Datetime']['input']>;
  skills?: InputMaybe<Array<Scalars['String']['input']>>;
  state?: InputMaybe<Scalars['Int']['input']>;
  status: JobStatus;
  tags?: InputMaybe<Array<Scalars['String']['input']>>;
  threads?: InputMaybe<ThreadsJobIdFkeyInverseInput>;
  translations?: InputMaybe<JobTranslationsJobIdFkeyInverseInput>;
  workExperienceCondition?: InputMaybe<Scalars['Int']['input']>;
};

/** Methods to use when ordering `Evaluation`. */
export enum EvaluationsOrderBy {
  CandidateIdAsc = 'CANDIDATE_ID_ASC',
  CandidateIdDesc = 'CANDIDATE_ID_DESC',
  CreatedAtAsc = 'CREATED_AT_ASC',
  CreatedAtDesc = 'CREATED_AT_DESC',
  DraftEvaluationIdAsc = 'DRAFT_EVALUATION_ID_ASC',
  DraftEvaluationIdDesc = 'DRAFT_EVALUATION_ID_DESC',
  EventDraftEvaluationIdAsc = 'EVENT_DRAFT_EVALUATION_ID_ASC',
  EventDraftEvaluationIdDesc = 'EVENT_DRAFT_EVALUATION_ID_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  JobIdAsc = 'JOB_ID_ASC',
  JobIdDesc = 'JOB_ID_DESC',
  Natural = 'NATURAL',
  PointAsc = 'POINT_ASC',
  PointDesc = 'POINT_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  UserIdAsc = 'USER_ID_ASC',
  UserIdDesc = 'USER_ID_DESC'
}

/** Input for the nested mutation of `user` in the `EvaluationInput` mutation. */
export type EvaluationsUserIdFkeyInput = {
  /** The primary key(s) for `user` for the far side of the relationship. */
  connectByEmail?: InputMaybe<UserUsersEmailKeyConnect>;
  /** The primary key(s) for `user` for the far side of the relationship. */
  connectById?: InputMaybe<UserUsersPkeyConnect>;
  /** The primary key(s) for `user` for the far side of the relationship. */
  connectByNodeId?: InputMaybe<UserNodeIdConnect>;
  /** The primary key(s) and patch data for `user` for the far side of the relationship. */
  updateByEmail?: InputMaybe<UserOnEvaluationForEvaluationsUserIdFkeyUsingUsersEmailKeyUpdate>;
  /** The primary key(s) and patch data for `user` for the far side of the relationship. */
  updateById?: InputMaybe<UserOnEvaluationForEvaluationsUserIdFkeyUsingUsersPkeyUpdate>;
  /** The primary key(s) and patch data for `user` for the far side of the relationship. */
  updateByNodeId?: InputMaybe<EvaluationOnEvaluationForEvaluationsUserIdFkeyNodeIdUpdate>;
};

/** Input for the nested mutation of `evaluation` in the `UserInput` mutation. */
export type EvaluationsUserIdFkeyInverseInput = {
  /** The primary key(s) for `evaluation` for the far side of the relationship. */
  connectById?: InputMaybe<Array<EvaluationEvaluationsPkeyConnect>>;
  /** The primary key(s) for `evaluation` for the far side of the relationship. */
  connectByNodeId?: InputMaybe<Array<EvaluationNodeIdConnect>>;
  /** The primary key(s) and patch data for `evaluation` for the far side of the relationship. */
  updateById?: InputMaybe<Array<EvaluationOnEvaluationForEvaluationsUserIdFkeyUsingEvaluationsPkeyUpdate>>;
  /** The primary key(s) and patch data for `evaluation` for the far side of the relationship. */
  updateByNodeId?: InputMaybe<Array<UserOnEvaluationForEvaluationsUserIdFkeyNodeIdUpdate>>;
};

export type Event = Node & {
  __typename?: 'Event';
  address?: Maybe<Scalars['String']['output']>;
  /** Reads and enables pagination through a set of `Candidate`. */
  candidates: EventCandidatesByEventCandidateEventIdAndCandidateIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Company`. */
  companies: EventCompaniesByEventDraftEvaluationEventIdAndCompanyIdManyToManyConnection;
  createdAt: Scalars['Datetime']['output'];
  deletedAt?: Maybe<Scalars['Datetime']['output']>;
  description?: Maybe<Scalars['String']['output']>;
  endTime: Scalars['Datetime']['output'];
  /** Reads and enables pagination through a set of `EventCandidate`. */
  eventCandidates: EventCandidatesConnection;
  /** Reads and enables pagination through a set of `EventDraftEvaluation`. */
  eventDraftEvaluations: EventDraftEvaluationsConnection;
  /** Reads and enables pagination through a set of `EventScorecard`. */
  eventScorecards: EventScorecardsConnection;
  /** Reads and enables pagination through a set of `EventUser`. */
  eventUsers: EventUsersConnection;
  id: Scalars['Int']['output'];
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  /** Reads and enables pagination through a set of `Scorecard`. */
  scorecards: EventScorecardsByEventScorecardEventIdAndScorecardIdManyToManyConnection;
  startTime: Scalars['Datetime']['output'];
  title: Scalars['String']['output'];
  type: EventType;
  updatedAt: Scalars['Datetime']['output'];
  url?: Maybe<Scalars['String']['output']>;
  /** Reads and enables pagination through a set of `User`. */
  users: EventUsersByEventUserEventIdAndUserIdManyToManyConnection;
};


export type EventCandidatesArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<CandidateCondition>;
  filter?: InputMaybe<CandidateFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<CandidatesOrderBy>>;
};


export type EventCompaniesArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<CompanyCondition>;
  filter?: InputMaybe<CompanyFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<CompaniesOrderBy>>;
};


export type EventEventCandidatesArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<EventCandidateCondition>;
  filter?: InputMaybe<EventCandidateFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<EventCandidatesOrderBy>>;
};


export type EventEventDraftEvaluationsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<EventDraftEvaluationCondition>;
  filter?: InputMaybe<EventDraftEvaluationFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<EventDraftEvaluationsOrderBy>>;
};


export type EventEventScorecardsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<EventScorecardCondition>;
  filter?: InputMaybe<EventScorecardFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<EventScorecardsOrderBy>>;
};


export type EventEventUsersArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<EventUserCondition>;
  filter?: InputMaybe<EventUserFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<EventUsersOrderBy>>;
};


export type EventScorecardsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<ScorecardCondition>;
  filter?: InputMaybe<ScorecardFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<ScorecardsOrderBy>>;
};


export type EventUsersArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<UserCondition>;
  filter?: InputMaybe<UserFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<UsersOrderBy>>;
};

export type EventCandidate = Node & {
  __typename?: 'EventCandidate';
  /** Reads a single `Candidate` that is related to this `EventCandidate`. */
  candidate?: Maybe<Candidate>;
  candidateId: Scalars['Int']['output'];
  createdAt: Scalars['Datetime']['output'];
  /** Reads a single `Event` that is related to this `EventCandidate`. */
  event?: Maybe<Event>;
  eventId: Scalars['Int']['output'];
  icalUid?: Maybe<Scalars['String']['output']>;
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  updatedAt: Scalars['Datetime']['output'];
};

/** A condition to be used against `EventCandidate` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type EventCandidateCondition = {
  /** Checks for equality with the object’s `candidateId` field. */
  candidateId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `eventId` field. */
  eventId?: InputMaybe<Scalars['Int']['input']>;
};

/** A filter to be used against `EventCandidate` object types. All fields are combined with a logical ‘and.’ */
export type EventCandidateFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<EventCandidateFilter>>;
  /** Filter by the object’s `candidate` relation. */
  candidate?: InputMaybe<CandidateFilter>;
  /** Filter by the object’s `candidateId` field. */
  candidateId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `event` relation. */
  event?: InputMaybe<EventFilter>;
  /** Filter by the object’s `eventId` field. */
  eventId?: InputMaybe<IntFilter>;
  /** Negates the expression. */
  not?: InputMaybe<EventCandidateFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<EventCandidateFilter>>;
};

/** An input for mutations affecting `EventCandidate` */
export type EventCandidateInput = {
  candidate?: InputMaybe<EventCandidatesCandidateIdFkeyInput>;
  candidateId?: InputMaybe<Scalars['Int']['input']>;
  event?: InputMaybe<EventCandidatesEventIdFkeyInput>;
  eventId?: InputMaybe<Scalars['Int']['input']>;
  icalUid?: InputMaybe<Scalars['String']['input']>;
};

/** The globally unique `ID` look up for the row to connect. */
export type EventCandidateNodeIdConnect = {
  /** The globally unique `ID` which identifies a single `eventCandidate` to be connected. */
  nodeId: Scalars['ID']['input'];
};

/** The globally unique `ID` look up for the row to delete. */
export type EventCandidateNodeIdDelete = {
  /** The globally unique `ID` which identifies a single `eventCandidate` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** The globally unique `ID` look up for the row to update. */
export type EventCandidateOnEventCandidateForEventCandidatesCandidateIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `candidate` to be connected. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `candidate` being updated. */
  patch: CandidatePatch;
};

/** The globally unique `ID` look up for the row to update. */
export type EventCandidateOnEventCandidateForEventCandidatesEventIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `event` to be connected. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `event` being updated. */
  patch: EventPatch;
};

/** Represents an update to a `EventCandidate`. Fields that are set will be updated. */
export type EventCandidatePatch = {
  candidate?: InputMaybe<EventCandidatesCandidateIdFkeyInput>;
  candidateId?: InputMaybe<Scalars['Int']['input']>;
  event?: InputMaybe<EventCandidatesEventIdFkeyInput>;
  eventId?: InputMaybe<Scalars['Int']['input']>;
  icalUid?: InputMaybe<Scalars['String']['input']>;
};

/** A connection to a list of `Candidate` values, with data from `EventCandidate`. */
export type EventCandidatesByEventCandidateEventIdAndCandidateIdManyToManyConnection = {
  __typename?: 'EventCandidatesByEventCandidateEventIdAndCandidateIdManyToManyConnection';
  /** A list of edges which contains the `Candidate`, info from the `EventCandidate`, and the cursor to aid in pagination. */
  edges: Array<EventCandidatesByEventCandidateEventIdAndCandidateIdManyToManyEdge>;
  /** A list of `Candidate` objects. */
  nodes: Array<Candidate>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Candidate` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `Candidate` edge in the connection, with data from `EventCandidate`. */
export type EventCandidatesByEventCandidateEventIdAndCandidateIdManyToManyEdge = {
  __typename?: 'EventCandidatesByEventCandidateEventIdAndCandidateIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** Reads and enables pagination through a set of `EventCandidate`. */
  eventCandidates: EventCandidatesConnection;
  /** The `Candidate` at the end of the edge. */
  node: Candidate;
};


/** A `Candidate` edge in the connection, with data from `EventCandidate`. */
export type EventCandidatesByEventCandidateEventIdAndCandidateIdManyToManyEdgeEventCandidatesArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<EventCandidateCondition>;
  filter?: InputMaybe<EventCandidateFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<EventCandidatesOrderBy>>;
};

/** The `candidate` to be created by this mutation. */
export type EventCandidatesCandidateIdFkeyCandidatesCreateInput = {
  birthday?: InputMaybe<Scalars['Date']['input']>;
  candidateDraftEvaluations?: InputMaybe<DraftEvaluationsCandidateIdFkeyInverseInput>;
  candidateEventDraftEvaluations?: InputMaybe<EventDraftEvaluationsCandidateIdFkeyInverseInput>;
  candidateImportCandidate?: InputMaybe<CandidateImportCandidatesCandidateIdFkeyInverseInput>;
  candidateQuestionnaires?: InputMaybe<CandidateQuestionnairesCandidateIdFkeyInverseInput>;
  candidateQuestions?: InputMaybe<CandidateQuestionsCandidateIdFkeyInverseInput>;
  candidateTags?: InputMaybe<CandidateTagsCandidateIdFkeyInverseInput>;
  cvText?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  emails?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  evaluations?: InputMaybe<EvaluationsCandidateIdFkeyInverseInput>;
  eventCandidates?: InputMaybe<EventCandidatesCandidateIdFkeyInverseInput>;
  files?: InputMaybe<CandidateFilesCandidateIdFkeyInverseInput>;
  gender?: InputMaybe<Gender>;
  jobsApplications?: InputMaybe<JobsApplicationsCandidateIdFkeyInverseInput>;
  language: Language;
  links?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  militaryStatus?: InputMaybe<MilitaryStatus>;
  phones?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  photoExternalId?: InputMaybe<Scalars['UUID']['input']>;
  resumeExternalId?: InputMaybe<Scalars['UUID']['input']>;
  socialLinks?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  sources?: InputMaybe<Array<Scalars['String']['input']>>;
  tags?: InputMaybe<Array<Scalars['String']['input']>>;
  threads?: InputMaybe<ThreadsCandidateIdFkeyInverseInput>;
  translations?: InputMaybe<CandidateTranslationsCandidateIdFkeyInverseInput>;
};

/** The `eventCandidate` to be created by this mutation. */
export type EventCandidatesCandidateIdFkeyEventCandidatesCreateInput = {
  candidate?: InputMaybe<EventCandidatesCandidateIdFkeyInput>;
  event?: InputMaybe<EventCandidatesEventIdFkeyInput>;
  eventId?: InputMaybe<Scalars['Int']['input']>;
  icalUid?: InputMaybe<Scalars['String']['input']>;
};

/** Input for the nested mutation of `candidate` in the `EventCandidateInput` mutation. */
export type EventCandidatesCandidateIdFkeyInput = {
  /** The primary key(s) for `candidate` for the far side of the relationship. */
  connectById?: InputMaybe<CandidateCandidatesPkeyConnect>;
  /** The primary key(s) for `candidate` for the far side of the relationship. */
  connectByNodeId?: InputMaybe<CandidateNodeIdConnect>;
  /** A `CandidateInput` object that will be created and connected to this object. */
  create?: InputMaybe<EventCandidatesCandidateIdFkeyCandidatesCreateInput>;
  /** The primary key(s) and patch data for `candidate` for the far side of the relationship. */
  updateById?: InputMaybe<CandidateOnEventCandidateForEventCandidatesCandidateIdFkeyUsingCandidatesPkeyUpdate>;
  /** The primary key(s) and patch data for `candidate` for the far side of the relationship. */
  updateByNodeId?: InputMaybe<EventCandidateOnEventCandidateForEventCandidatesCandidateIdFkeyNodeIdUpdate>;
};

/** Input for the nested mutation of `eventCandidate` in the `CandidateInput` mutation. */
export type EventCandidatesCandidateIdFkeyInverseInput = {
  /** The primary key(s) for `eventCandidate` for the far side of the relationship. */
  connectByNodeId?: InputMaybe<Array<EventCandidateNodeIdConnect>>;
  /** A `EventCandidateInput` object that will be created and connected to this object. */
  create?: InputMaybe<Array<EventCandidatesCandidateIdFkeyEventCandidatesCreateInput>>;
  /** The primary key(s) for `eventCandidate` for the far side of the relationship. */
  deleteByNodeId?: InputMaybe<Array<EventCandidateNodeIdDelete>>;
  /** Flag indicating whether all other `eventCandidate` records that match this relationship should be removed. */
  deleteOthers?: InputMaybe<Scalars['Boolean']['input']>;
  /** The primary key(s) and patch data for `eventCandidate` for the far side of the relationship. */
  updateByNodeId?: InputMaybe<Array<CandidateOnEventCandidateForEventCandidatesCandidateIdFkeyNodeIdUpdate>>;
};

/** A connection to a list of `EventCandidate` values. */
export type EventCandidatesConnection = {
  __typename?: 'EventCandidatesConnection';
  /** A list of edges which contains the `EventCandidate` and cursor to aid in pagination. */
  edges: Array<EventCandidatesEdge>;
  /** A list of `EventCandidate` objects. */
  nodes: Array<EventCandidate>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `EventCandidate` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `EventCandidate` edge in the connection. */
export type EventCandidatesEdge = {
  __typename?: 'EventCandidatesEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `EventCandidate` at the end of the edge. */
  node: EventCandidate;
};

/** The `eventCandidate` to be created by this mutation. */
export type EventCandidatesEventIdFkeyEventCandidatesCreateInput = {
  candidate?: InputMaybe<EventCandidatesCandidateIdFkeyInput>;
  candidateId?: InputMaybe<Scalars['Int']['input']>;
  event?: InputMaybe<EventCandidatesEventIdFkeyInput>;
  icalUid?: InputMaybe<Scalars['String']['input']>;
};

/** The `event` to be created by this mutation. */
export type EventCandidatesEventIdFkeyEventsCreateInput = {
  address?: InputMaybe<Scalars['String']['input']>;
  description?: InputMaybe<Scalars['String']['input']>;
  endTime: Scalars['Datetime']['input'];
  eventCandidates?: InputMaybe<EventCandidatesEventIdFkeyInverseInput>;
  eventDraftEvaluations?: InputMaybe<EventDraftEvaluationsEventIdFkeyInverseInput>;
  eventScorecards?: InputMaybe<EventScorecardsEventIdFkeyInverseInput>;
  eventUsers?: InputMaybe<EventUsersEventIdFkeyInverseInput>;
  startTime: Scalars['Datetime']['input'];
  title: Scalars['String']['input'];
  type: EventType;
  url?: InputMaybe<Scalars['String']['input']>;
};

/** Input for the nested mutation of `event` in the `EventCandidateInput` mutation. */
export type EventCandidatesEventIdFkeyInput = {
  /** The primary key(s) for `event` for the far side of the relationship. */
  connectById?: InputMaybe<EventEventsPkeyConnect>;
  /** The primary key(s) for `event` for the far side of the relationship. */
  connectByNodeId?: InputMaybe<EventNodeIdConnect>;
  /** A `EventInput` object that will be created and connected to this object. */
  create?: InputMaybe<EventCandidatesEventIdFkeyEventsCreateInput>;
  /** The primary key(s) and patch data for `event` for the far side of the relationship. */
  updateById?: InputMaybe<EventOnEventCandidateForEventCandidatesEventIdFkeyUsingEventsPkeyUpdate>;
  /** The primary key(s) and patch data for `event` for the far side of the relationship. */
  updateByNodeId?: InputMaybe<EventCandidateOnEventCandidateForEventCandidatesEventIdFkeyNodeIdUpdate>;
};

/** Input for the nested mutation of `eventCandidate` in the `EventInput` mutation. */
export type EventCandidatesEventIdFkeyInverseInput = {
  /** The primary key(s) for `eventCandidate` for the far side of the relationship. */
  connectByNodeId?: InputMaybe<Array<EventCandidateNodeIdConnect>>;
  /** A `EventCandidateInput` object that will be created and connected to this object. */
  create?: InputMaybe<Array<EventCandidatesEventIdFkeyEventCandidatesCreateInput>>;
  /** The primary key(s) for `eventCandidate` for the far side of the relationship. */
  deleteByNodeId?: InputMaybe<Array<EventCandidateNodeIdDelete>>;
  /** Flag indicating whether all other `eventCandidate` records that match this relationship should be removed. */
  deleteOthers?: InputMaybe<Scalars['Boolean']['input']>;
  /** The primary key(s) and patch data for `eventCandidate` for the far side of the relationship. */
  updateByNodeId?: InputMaybe<Array<EventOnEventCandidateForEventCandidatesEventIdFkeyNodeIdUpdate>>;
};

/** Methods to use when ordering `EventCandidate`. */
export enum EventCandidatesOrderBy {
  CandidateIdAsc = 'CANDIDATE_ID_ASC',
  CandidateIdDesc = 'CANDIDATE_ID_DESC',
  EventIdAsc = 'EVENT_ID_ASC',
  EventIdDesc = 'EVENT_ID_DESC',
  Natural = 'NATURAL',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC'
}

/** A connection to a list of `Company` values, with data from `EventDraftEvaluation`. */
export type EventCompaniesByEventDraftEvaluationEventIdAndCompanyIdManyToManyConnection = {
  __typename?: 'EventCompaniesByEventDraftEvaluationEventIdAndCompanyIdManyToManyConnection';
  /** A list of edges which contains the `Company`, info from the `EventDraftEvaluation`, and the cursor to aid in pagination. */
  edges: Array<EventCompaniesByEventDraftEvaluationEventIdAndCompanyIdManyToManyEdge>;
  /** A list of `Company` objects. */
  nodes: Array<Company>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Company` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `Company` edge in the connection, with data from `EventDraftEvaluation`. */
export type EventCompaniesByEventDraftEvaluationEventIdAndCompanyIdManyToManyEdge = {
  __typename?: 'EventCompaniesByEventDraftEvaluationEventIdAndCompanyIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** Reads and enables pagination through a set of `EventDraftEvaluation`. */
  eventDraftEvaluations: EventDraftEvaluationsConnection;
  /** The `Company` at the end of the edge. */
  node: Company;
};


/** A `Company` edge in the connection, with data from `EventDraftEvaluation`. */
export type EventCompaniesByEventDraftEvaluationEventIdAndCompanyIdManyToManyEdgeEventDraftEvaluationsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<EventDraftEvaluationCondition>;
  filter?: InputMaybe<EventDraftEvaluationFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<EventDraftEvaluationsOrderBy>>;
};

/** A condition to be used against `Event` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type EventCondition = {
  /** Checks for equality with the object’s `createdAt` field. */
  createdAt?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `deletedAt` field. */
  deletedAt?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `updatedAt` field. */
  updatedAt?: InputMaybe<Scalars['Datetime']['input']>;
};

export type EventDraftEvaluation = Node & {
  __typename?: 'EventDraftEvaluation';
  /** Reads a single `Candidate` that is related to this `EventDraftEvaluation`. */
  candidate?: Maybe<Candidate>;
  candidateId: Scalars['Int']['output'];
  /** Reads and enables pagination through a set of `Candidate`. */
  candidates: EventDraftEvaluationCandidatesByEvaluationEventDraftEvaluationIdAndCandidateIdManyToManyConnection;
  /** Reads a single `Company` that is related to this `EventDraftEvaluation`. */
  company?: Maybe<Company>;
  companyId: Scalars['Int']['output'];
  createdAt: Scalars['Datetime']['output'];
  deletedAt?: Maybe<Scalars['Datetime']['output']>;
  /** Reads and enables pagination through a set of `DraftEvaluation`. */
  draftEvaluations: EventDraftEvaluationDraftEvaluationsByEvaluationEventDraftEvaluationIdAndDraftEvaluationIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Evaluation`. */
  evaluations: EvaluationsConnection;
  /** Reads a single `Event` that is related to this `EventDraftEvaluation`. */
  event?: Maybe<Event>;
  eventId: Scalars['Int']['output'];
  id: Scalars['Int']['output'];
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  scorecardIds: Array<Maybe<Scalars['Int']['output']>>;
  /** Reads and enables pagination through a set of `Scorecard`. */
  scorecards: ScorecardsConnection;
  userIds: Array<Maybe<Scalars['Int']['output']>>;
};


export type EventDraftEvaluationCandidatesArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<CandidateCondition>;
  filter?: InputMaybe<CandidateFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<CandidatesOrderBy>>;
};


export type EventDraftEvaluationDraftEvaluationsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<DraftEvaluationCondition>;
  filter?: InputMaybe<DraftEvaluationFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<DraftEvaluationsOrderBy>>;
};


export type EventDraftEvaluationEvaluationsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<EvaluationCondition>;
  filter?: InputMaybe<EvaluationFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<EvaluationsOrderBy>>;
};


export type EventDraftEvaluationScorecardsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<ScorecardFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
};

/** A connection to a list of `Candidate` values, with data from `Evaluation`. */
export type EventDraftEvaluationCandidatesByEvaluationEventDraftEvaluationIdAndCandidateIdManyToManyConnection = {
  __typename?: 'EventDraftEvaluationCandidatesByEvaluationEventDraftEvaluationIdAndCandidateIdManyToManyConnection';
  /** A list of edges which contains the `Candidate`, info from the `Evaluation`, and the cursor to aid in pagination. */
  edges: Array<EventDraftEvaluationCandidatesByEvaluationEventDraftEvaluationIdAndCandidateIdManyToManyEdge>;
  /** A list of `Candidate` objects. */
  nodes: Array<Candidate>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Candidate` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `Candidate` edge in the connection, with data from `Evaluation`. */
export type EventDraftEvaluationCandidatesByEvaluationEventDraftEvaluationIdAndCandidateIdManyToManyEdge = {
  __typename?: 'EventDraftEvaluationCandidatesByEvaluationEventDraftEvaluationIdAndCandidateIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** Reads and enables pagination through a set of `Evaluation`. */
  evaluations: EvaluationsConnection;
  /** The `Candidate` at the end of the edge. */
  node: Candidate;
};


/** A `Candidate` edge in the connection, with data from `Evaluation`. */
export type EventDraftEvaluationCandidatesByEvaluationEventDraftEvaluationIdAndCandidateIdManyToManyEdgeEvaluationsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<EvaluationCondition>;
  filter?: InputMaybe<EvaluationFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<EvaluationsOrderBy>>;
};

/** A condition to be used against `EventDraftEvaluation` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type EventDraftEvaluationCondition = {
  /** Checks for equality with the object’s `candidateId` field. */
  candidateId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `companyId` field. */
  companyId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `createdAt` field. */
  createdAt?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `deletedAt` field. */
  deletedAt?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `eventId` field. */
  eventId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `scorecardIds` field. */
  scorecardIds?: InputMaybe<Array<InputMaybe<Scalars['Int']['input']>>>;
  /** Checks for equality with the object’s `userIds` field. */
  userIds?: InputMaybe<Array<InputMaybe<Scalars['Int']['input']>>>;
};

/** A connection to a list of `DraftEvaluation` values, with data from `Evaluation`. */
export type EventDraftEvaluationDraftEvaluationsByEvaluationEventDraftEvaluationIdAndDraftEvaluationIdManyToManyConnection = {
  __typename?: 'EventDraftEvaluationDraftEvaluationsByEvaluationEventDraftEvaluationIdAndDraftEvaluationIdManyToManyConnection';
  /** A list of edges which contains the `DraftEvaluation`, info from the `Evaluation`, and the cursor to aid in pagination. */
  edges: Array<EventDraftEvaluationDraftEvaluationsByEvaluationEventDraftEvaluationIdAndDraftEvaluationIdManyToManyEdge>;
  /** A list of `DraftEvaluation` objects. */
  nodes: Array<DraftEvaluation>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `DraftEvaluation` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `DraftEvaluation` edge in the connection, with data from `Evaluation`. */
export type EventDraftEvaluationDraftEvaluationsByEvaluationEventDraftEvaluationIdAndDraftEvaluationIdManyToManyEdge = {
  __typename?: 'EventDraftEvaluationDraftEvaluationsByEvaluationEventDraftEvaluationIdAndDraftEvaluationIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** Reads and enables pagination through a set of `Evaluation`. */
  evaluations: EvaluationsConnection;
  /** The `DraftEvaluation` at the end of the edge. */
  node: DraftEvaluation;
};


/** A `DraftEvaluation` edge in the connection, with data from `Evaluation`. */
export type EventDraftEvaluationDraftEvaluationsByEvaluationEventDraftEvaluationIdAndDraftEvaluationIdManyToManyEdgeEvaluationsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<EvaluationCondition>;
  filter?: InputMaybe<EvaluationFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<EvaluationsOrderBy>>;
};

/** The fields on `eventDraftEvaluation` to look up the row to connect. */
export type EventDraftEvaluationEventDraftEvaluationsEventIdCandidateIdKeyConnect = {
  candidateId: Scalars['Int']['input'];
  eventId: Scalars['Int']['input'];
};

/** The fields on `eventDraftEvaluation` to look up the row to connect. */
export type EventDraftEvaluationEventDraftEvaluationsPkeyConnect = {
  id: Scalars['Int']['input'];
};

/** A filter to be used against `EventDraftEvaluation` object types. All fields are combined with a logical ‘and.’ */
export type EventDraftEvaluationFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<EventDraftEvaluationFilter>>;
  /** Filter by the object’s `candidate` relation. */
  candidate?: InputMaybe<CandidateFilter>;
  /** Filter by the object’s `candidateId` field. */
  candidateId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `company` relation. */
  company?: InputMaybe<CompanyFilter>;
  /** Filter by the object’s `companyId` field. */
  companyId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `createdAt` field. */
  createdAt?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `deletedAt` field. */
  deletedAt?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `evaluations` relation. */
  evaluations?: InputMaybe<EventDraftEvaluationToManyEvaluationFilter>;
  /** Some related `evaluations` exist. */
  evaluationsExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `event` relation. */
  event?: InputMaybe<EventFilter>;
  /** Filter by the object’s `eventId` field. */
  eventId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<IntFilter>;
  /** Negates the expression. */
  not?: InputMaybe<EventDraftEvaluationFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<EventDraftEvaluationFilter>>;
  /** Filter by the object’s `scorecardIds` field. */
  scorecardIds?: InputMaybe<IntListFilter>;
  /** Filter by the object’s `userIds` field. */
  userIds?: InputMaybe<IntListFilter>;
};

/** The globally unique `ID` look up for the row to connect. */
export type EventDraftEvaluationNodeIdConnect = {
  /** The globally unique `ID` which identifies a single `eventDraftEvaluation` to be connected. */
  nodeId: Scalars['ID']['input'];
};

/** The globally unique `ID` look up for the row to update. */
export type EventDraftEvaluationOnEvaluationForEvaluationsEventDraftEvaluationIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `evaluation` to be connected. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `evaluation` being updated. */
  patch: EvaluationPatch;
};

/** The fields on `eventDraftEvaluation` to look up the row to update. */
export type EventDraftEvaluationOnEvaluationForEvaluationsEventDraftEvaluationIdFkeyUsingEventDraftEvaluationsEventIdCandidateIdKeyUpdate = {
  candidateId: Scalars['Int']['input'];
  eventId: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `eventDraftEvaluation` being updated. */
  patch: UpdateEventDraftEvaluationOnEvaluationForEvaluationsEventDraftEvaluationIdFkeyPatch;
};

/** The fields on `eventDraftEvaluation` to look up the row to update. */
export type EventDraftEvaluationOnEvaluationForEvaluationsEventDraftEvaluationIdFkeyUsingEventDraftEvaluationsPkeyUpdate = {
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `eventDraftEvaluation` being updated. */
  patch: UpdateEventDraftEvaluationOnEvaluationForEvaluationsEventDraftEvaluationIdFkeyPatch;
};

/** The globally unique `ID` look up for the row to update. */
export type EventDraftEvaluationOnEventDraftEvaluationForEventDraftEvaluationsCandidateIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `candidate` to be connected. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `candidate` being updated. */
  patch: CandidatePatch;
};

/** The fields on `eventDraftEvaluation` to look up the row to update. */
export type EventDraftEvaluationOnEventDraftEvaluationForEventDraftEvaluationsCandidateIdFkeyUsingEventDraftEvaluationsEventIdCandidateIdKeyUpdate = {
  candidateId: Scalars['Int']['input'];
  eventId: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `eventDraftEvaluation` being updated. */
  patch: UpdateEventDraftEvaluationOnEventDraftEvaluationForEventDraftEvaluationsCandidateIdFkeyPatch;
};

/** The fields on `eventDraftEvaluation` to look up the row to update. */
export type EventDraftEvaluationOnEventDraftEvaluationForEventDraftEvaluationsCandidateIdFkeyUsingEventDraftEvaluationsPkeyUpdate = {
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `eventDraftEvaluation` being updated. */
  patch: UpdateEventDraftEvaluationOnEventDraftEvaluationForEventDraftEvaluationsCandidateIdFkeyPatch;
};

/** The globally unique `ID` look up for the row to update. */
export type EventDraftEvaluationOnEventDraftEvaluationForEventDraftEvaluationsCompanyIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `company` to be connected. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `company` being updated. */
  patch: CompanyPatch;
};

/** The fields on `eventDraftEvaluation` to look up the row to update. */
export type EventDraftEvaluationOnEventDraftEvaluationForEventDraftEvaluationsCompanyIdFkeyUsingEventDraftEvaluationsEventIdCandidateIdKeyUpdate = {
  candidateId: Scalars['Int']['input'];
  eventId: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `eventDraftEvaluation` being updated. */
  patch: UpdateEventDraftEvaluationOnEventDraftEvaluationForEventDraftEvaluationsCompanyIdFkeyPatch;
};

/** The fields on `eventDraftEvaluation` to look up the row to update. */
export type EventDraftEvaluationOnEventDraftEvaluationForEventDraftEvaluationsCompanyIdFkeyUsingEventDraftEvaluationsPkeyUpdate = {
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `eventDraftEvaluation` being updated. */
  patch: UpdateEventDraftEvaluationOnEventDraftEvaluationForEventDraftEvaluationsCompanyIdFkeyPatch;
};

/** The globally unique `ID` look up for the row to update. */
export type EventDraftEvaluationOnEventDraftEvaluationForEventDraftEvaluationsEventIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `event` to be connected. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `event` being updated. */
  patch: EventPatch;
};

/** The fields on `eventDraftEvaluation` to look up the row to update. */
export type EventDraftEvaluationOnEventDraftEvaluationForEventDraftEvaluationsEventIdFkeyUsingEventDraftEvaluationsEventIdCandidateIdKeyUpdate = {
  candidateId: Scalars['Int']['input'];
  eventId: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `eventDraftEvaluation` being updated. */
  patch: UpdateEventDraftEvaluationOnEventDraftEvaluationForEventDraftEvaluationsEventIdFkeyPatch;
};

/** The fields on `eventDraftEvaluation` to look up the row to update. */
export type EventDraftEvaluationOnEventDraftEvaluationForEventDraftEvaluationsEventIdFkeyUsingEventDraftEvaluationsPkeyUpdate = {
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `eventDraftEvaluation` being updated. */
  patch: UpdateEventDraftEvaluationOnEventDraftEvaluationForEventDraftEvaluationsEventIdFkeyPatch;
};

/** Represents an update to a `EventDraftEvaluation`. Fields that are set will be updated. */
export type EventDraftEvaluationPatch = {
  candidate?: InputMaybe<EventDraftEvaluationsCandidateIdFkeyInput>;
  candidateId?: InputMaybe<Scalars['Int']['input']>;
  company?: InputMaybe<EventDraftEvaluationsCompanyIdFkeyInput>;
  companyId?: InputMaybe<Scalars['Int']['input']>;
  createdAt?: InputMaybe<Scalars['Datetime']['input']>;
  deletedAt?: InputMaybe<Scalars['Datetime']['input']>;
  evaluations?: InputMaybe<EvaluationsEventDraftEvaluationIdFkeyInverseInput>;
  event?: InputMaybe<EventDraftEvaluationsEventIdFkeyInput>;
  eventId?: InputMaybe<Scalars['Int']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  scorecardIds?: InputMaybe<Array<InputMaybe<Scalars['Int']['input']>>>;
  userIds?: InputMaybe<Array<InputMaybe<Scalars['Int']['input']>>>;
};

/** A filter to be used against many `Evaluation` object types. All fields are combined with a logical ‘and.’ */
export type EventDraftEvaluationToManyEvaluationFilter = {
  /** Every related `Evaluation` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<EvaluationFilter>;
  /** No related `Evaluation` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<EvaluationFilter>;
  /** Some related `Evaluation` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<EvaluationFilter>;
};

/** The `candidate` to be created by this mutation. */
export type EventDraftEvaluationsCandidateIdFkeyCandidatesCreateInput = {
  birthday?: InputMaybe<Scalars['Date']['input']>;
  candidateDraftEvaluations?: InputMaybe<DraftEvaluationsCandidateIdFkeyInverseInput>;
  candidateEventDraftEvaluations?: InputMaybe<EventDraftEvaluationsCandidateIdFkeyInverseInput>;
  candidateImportCandidate?: InputMaybe<CandidateImportCandidatesCandidateIdFkeyInverseInput>;
  candidateQuestionnaires?: InputMaybe<CandidateQuestionnairesCandidateIdFkeyInverseInput>;
  candidateQuestions?: InputMaybe<CandidateQuestionsCandidateIdFkeyInverseInput>;
  candidateTags?: InputMaybe<CandidateTagsCandidateIdFkeyInverseInput>;
  cvText?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  emails?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  evaluations?: InputMaybe<EvaluationsCandidateIdFkeyInverseInput>;
  eventCandidates?: InputMaybe<EventCandidatesCandidateIdFkeyInverseInput>;
  files?: InputMaybe<CandidateFilesCandidateIdFkeyInverseInput>;
  gender?: InputMaybe<Gender>;
  jobsApplications?: InputMaybe<JobsApplicationsCandidateIdFkeyInverseInput>;
  language: Language;
  links?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  militaryStatus?: InputMaybe<MilitaryStatus>;
  phones?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  photoExternalId?: InputMaybe<Scalars['UUID']['input']>;
  resumeExternalId?: InputMaybe<Scalars['UUID']['input']>;
  socialLinks?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  sources?: InputMaybe<Array<Scalars['String']['input']>>;
  tags?: InputMaybe<Array<Scalars['String']['input']>>;
  threads?: InputMaybe<ThreadsCandidateIdFkeyInverseInput>;
  translations?: InputMaybe<CandidateTranslationsCandidateIdFkeyInverseInput>;
};

/** Input for the nested mutation of `candidate` in the `EventDraftEvaluationInput` mutation. */
export type EventDraftEvaluationsCandidateIdFkeyInput = {
  /** The primary key(s) for `candidate` for the far side of the relationship. */
  connectById?: InputMaybe<CandidateCandidatesPkeyConnect>;
  /** The primary key(s) for `candidate` for the far side of the relationship. */
  connectByNodeId?: InputMaybe<CandidateNodeIdConnect>;
  /** A `CandidateInput` object that will be created and connected to this object. */
  create?: InputMaybe<EventDraftEvaluationsCandidateIdFkeyCandidatesCreateInput>;
  /** The primary key(s) and patch data for `candidate` for the far side of the relationship. */
  updateById?: InputMaybe<CandidateOnEventDraftEvaluationForEventDraftEvaluationsCandidateIdFkeyUsingCandidatesPkeyUpdate>;
  /** The primary key(s) and patch data for `candidate` for the far side of the relationship. */
  updateByNodeId?: InputMaybe<EventDraftEvaluationOnEventDraftEvaluationForEventDraftEvaluationsCandidateIdFkeyNodeIdUpdate>;
};

/** Input for the nested mutation of `eventDraftEvaluation` in the `CandidateInput` mutation. */
export type EventDraftEvaluationsCandidateIdFkeyInverseInput = {
  /** The primary key(s) for `eventDraftEvaluation` for the far side of the relationship. */
  connectByEventIdAndCandidateId?: InputMaybe<Array<EventDraftEvaluationEventDraftEvaluationsEventIdCandidateIdKeyConnect>>;
  /** The primary key(s) for `eventDraftEvaluation` for the far side of the relationship. */
  connectById?: InputMaybe<Array<EventDraftEvaluationEventDraftEvaluationsPkeyConnect>>;
  /** The primary key(s) for `eventDraftEvaluation` for the far side of the relationship. */
  connectByNodeId?: InputMaybe<Array<EventDraftEvaluationNodeIdConnect>>;
  /** The primary key(s) and patch data for `eventDraftEvaluation` for the far side of the relationship. */
  updateByEventIdAndCandidateId?: InputMaybe<Array<EventDraftEvaluationOnEventDraftEvaluationForEventDraftEvaluationsCandidateIdFkeyUsingEventDraftEvaluationsEventIdCandidateIdKeyUpdate>>;
  /** The primary key(s) and patch data for `eventDraftEvaluation` for the far side of the relationship. */
  updateById?: InputMaybe<Array<EventDraftEvaluationOnEventDraftEvaluationForEventDraftEvaluationsCandidateIdFkeyUsingEventDraftEvaluationsPkeyUpdate>>;
  /** The primary key(s) and patch data for `eventDraftEvaluation` for the far side of the relationship. */
  updateByNodeId?: InputMaybe<Array<CandidateOnEventDraftEvaluationForEventDraftEvaluationsCandidateIdFkeyNodeIdUpdate>>;
};

/** Input for the nested mutation of `company` in the `EventDraftEvaluationInput` mutation. */
export type EventDraftEvaluationsCompanyIdFkeyInput = {
  /** The primary key(s) for `company` for the far side of the relationship. */
  connectById?: InputMaybe<CompanyCompaniesPkeyConnect>;
  /** The primary key(s) for `company` for the far side of the relationship. */
  connectByNodeId?: InputMaybe<CompanyNodeIdConnect>;
  /** The primary key(s) for `company` for the far side of the relationship. */
  connectBySlug?: InputMaybe<CompanyCompaniesSlugKeyConnect>;
  /** The primary key(s) and patch data for `company` for the far side of the relationship. */
  updateById?: InputMaybe<CompanyOnEventDraftEvaluationForEventDraftEvaluationsCompanyIdFkeyUsingCompaniesPkeyUpdate>;
  /** The primary key(s) and patch data for `company` for the far side of the relationship. */
  updateByNodeId?: InputMaybe<EventDraftEvaluationOnEventDraftEvaluationForEventDraftEvaluationsCompanyIdFkeyNodeIdUpdate>;
  /** The primary key(s) and patch data for `company` for the far side of the relationship. */
  updateBySlug?: InputMaybe<CompanyOnEventDraftEvaluationForEventDraftEvaluationsCompanyIdFkeyUsingCompaniesSlugKeyUpdate>;
};

/** Input for the nested mutation of `eventDraftEvaluation` in the `CompanyInput` mutation. */
export type EventDraftEvaluationsCompanyIdFkeyInverseInput = {
  /** The primary key(s) for `eventDraftEvaluation` for the far side of the relationship. */
  connectByEventIdAndCandidateId?: InputMaybe<Array<EventDraftEvaluationEventDraftEvaluationsEventIdCandidateIdKeyConnect>>;
  /** The primary key(s) for `eventDraftEvaluation` for the far side of the relationship. */
  connectById?: InputMaybe<Array<EventDraftEvaluationEventDraftEvaluationsPkeyConnect>>;
  /** The primary key(s) for `eventDraftEvaluation` for the far side of the relationship. */
  connectByNodeId?: InputMaybe<Array<EventDraftEvaluationNodeIdConnect>>;
  /** The primary key(s) and patch data for `eventDraftEvaluation` for the far side of the relationship. */
  updateByEventIdAndCandidateId?: InputMaybe<Array<EventDraftEvaluationOnEventDraftEvaluationForEventDraftEvaluationsCompanyIdFkeyUsingEventDraftEvaluationsEventIdCandidateIdKeyUpdate>>;
  /** The primary key(s) and patch data for `eventDraftEvaluation` for the far side of the relationship. */
  updateById?: InputMaybe<Array<EventDraftEvaluationOnEventDraftEvaluationForEventDraftEvaluationsCompanyIdFkeyUsingEventDraftEvaluationsPkeyUpdate>>;
  /** The primary key(s) and patch data for `eventDraftEvaluation` for the far side of the relationship. */
  updateByNodeId?: InputMaybe<Array<CompanyOnEventDraftEvaluationForEventDraftEvaluationsCompanyIdFkeyNodeIdUpdate>>;
};

/** A connection to a list of `EventDraftEvaluation` values. */
export type EventDraftEvaluationsConnection = {
  __typename?: 'EventDraftEvaluationsConnection';
  /** A list of edges which contains the `EventDraftEvaluation` and cursor to aid in pagination. */
  edges: Array<EventDraftEvaluationsEdge>;
  /** A list of `EventDraftEvaluation` objects. */
  nodes: Array<EventDraftEvaluation>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `EventDraftEvaluation` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `EventDraftEvaluation` edge in the connection. */
export type EventDraftEvaluationsEdge = {
  __typename?: 'EventDraftEvaluationsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `EventDraftEvaluation` at the end of the edge. */
  node: EventDraftEvaluation;
};

/** The `event` to be created by this mutation. */
export type EventDraftEvaluationsEventIdFkeyEventsCreateInput = {
  address?: InputMaybe<Scalars['String']['input']>;
  description?: InputMaybe<Scalars['String']['input']>;
  endTime: Scalars['Datetime']['input'];
  eventCandidates?: InputMaybe<EventCandidatesEventIdFkeyInverseInput>;
  eventDraftEvaluations?: InputMaybe<EventDraftEvaluationsEventIdFkeyInverseInput>;
  eventScorecards?: InputMaybe<EventScorecardsEventIdFkeyInverseInput>;
  eventUsers?: InputMaybe<EventUsersEventIdFkeyInverseInput>;
  startTime: Scalars['Datetime']['input'];
  title: Scalars['String']['input'];
  type: EventType;
  url?: InputMaybe<Scalars['String']['input']>;
};

/** Input for the nested mutation of `event` in the `EventDraftEvaluationInput` mutation. */
export type EventDraftEvaluationsEventIdFkeyInput = {
  /** The primary key(s) for `event` for the far side of the relationship. */
  connectById?: InputMaybe<EventEventsPkeyConnect>;
  /** The primary key(s) for `event` for the far side of the relationship. */
  connectByNodeId?: InputMaybe<EventNodeIdConnect>;
  /** A `EventInput` object that will be created and connected to this object. */
  create?: InputMaybe<EventDraftEvaluationsEventIdFkeyEventsCreateInput>;
  /** The primary key(s) and patch data for `event` for the far side of the relationship. */
  updateById?: InputMaybe<EventOnEventDraftEvaluationForEventDraftEvaluationsEventIdFkeyUsingEventsPkeyUpdate>;
  /** The primary key(s) and patch data for `event` for the far side of the relationship. */
  updateByNodeId?: InputMaybe<EventDraftEvaluationOnEventDraftEvaluationForEventDraftEvaluationsEventIdFkeyNodeIdUpdate>;
};

/** Input for the nested mutation of `eventDraftEvaluation` in the `EventInput` mutation. */
export type EventDraftEvaluationsEventIdFkeyInverseInput = {
  /** The primary key(s) for `eventDraftEvaluation` for the far side of the relationship. */
  connectByEventIdAndCandidateId?: InputMaybe<Array<EventDraftEvaluationEventDraftEvaluationsEventIdCandidateIdKeyConnect>>;
  /** The primary key(s) for `eventDraftEvaluation` for the far side of the relationship. */
  connectById?: InputMaybe<Array<EventDraftEvaluationEventDraftEvaluationsPkeyConnect>>;
  /** The primary key(s) for `eventDraftEvaluation` for the far side of the relationship. */
  connectByNodeId?: InputMaybe<Array<EventDraftEvaluationNodeIdConnect>>;
  /** The primary key(s) and patch data for `eventDraftEvaluation` for the far side of the relationship. */
  updateByEventIdAndCandidateId?: InputMaybe<Array<EventDraftEvaluationOnEventDraftEvaluationForEventDraftEvaluationsEventIdFkeyUsingEventDraftEvaluationsEventIdCandidateIdKeyUpdate>>;
  /** The primary key(s) and patch data for `eventDraftEvaluation` for the far side of the relationship. */
  updateById?: InputMaybe<Array<EventDraftEvaluationOnEventDraftEvaluationForEventDraftEvaluationsEventIdFkeyUsingEventDraftEvaluationsPkeyUpdate>>;
  /** The primary key(s) and patch data for `eventDraftEvaluation` for the far side of the relationship. */
  updateByNodeId?: InputMaybe<Array<EventOnEventDraftEvaluationForEventDraftEvaluationsEventIdFkeyNodeIdUpdate>>;
};

/** Methods to use when ordering `EventDraftEvaluation`. */
export enum EventDraftEvaluationsOrderBy {
  CandidateIdAsc = 'CANDIDATE_ID_ASC',
  CandidateIdDesc = 'CANDIDATE_ID_DESC',
  CompanyIdAsc = 'COMPANY_ID_ASC',
  CompanyIdDesc = 'COMPANY_ID_DESC',
  CreatedAtAsc = 'CREATED_AT_ASC',
  CreatedAtDesc = 'CREATED_AT_DESC',
  DeletedAtAsc = 'DELETED_AT_ASC',
  DeletedAtDesc = 'DELETED_AT_DESC',
  EventIdAsc = 'EVENT_ID_ASC',
  EventIdDesc = 'EVENT_ID_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  Natural = 'NATURAL',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  ScorecardIdsAsc = 'SCORECARD_IDS_ASC',
  ScorecardIdsDesc = 'SCORECARD_IDS_DESC',
  UserIdsAsc = 'USER_IDS_ASC',
  UserIdsDesc = 'USER_IDS_DESC'
}

/** The fields on `event` to look up the row to connect. */
export type EventEventsPkeyConnect = {
  id: Scalars['Int']['input'];
};

/** A filter to be used against `Event` object types. All fields are combined with a logical ‘and.’ */
export type EventFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<EventFilter>>;
  /** Filter by the object’s `createdAt` field. */
  createdAt?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `deletedAt` field. */
  deletedAt?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `eventCandidates` relation. */
  eventCandidates?: InputMaybe<EventToManyEventCandidateFilter>;
  /** Some related `eventCandidates` exist. */
  eventCandidatesExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `eventDraftEvaluations` relation. */
  eventDraftEvaluations?: InputMaybe<EventToManyEventDraftEvaluationFilter>;
  /** Some related `eventDraftEvaluations` exist. */
  eventDraftEvaluationsExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `eventScorecards` relation. */
  eventScorecards?: InputMaybe<EventToManyEventScorecardFilter>;
  /** Some related `eventScorecards` exist. */
  eventScorecardsExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `eventUsers` relation. */
  eventUsers?: InputMaybe<EventToManyEventUserFilter>;
  /** Some related `eventUsers` exist. */
  eventUsersExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<IntFilter>;
  /** Negates the expression. */
  not?: InputMaybe<EventFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<EventFilter>>;
  /** Filter by the object’s `updatedAt` field. */
  updatedAt?: InputMaybe<DatetimeFilter>;
};

/** An input for mutations affecting `Event` */
export type EventInput = {
  address?: InputMaybe<Scalars['String']['input']>;
  description?: InputMaybe<Scalars['String']['input']>;
  endTime: Scalars['Datetime']['input'];
  eventCandidates?: InputMaybe<EventCandidatesEventIdFkeyInverseInput>;
  eventDraftEvaluations?: InputMaybe<EventDraftEvaluationsEventIdFkeyInverseInput>;
  eventScorecards?: InputMaybe<EventScorecardsEventIdFkeyInverseInput>;
  eventUsers?: InputMaybe<EventUsersEventIdFkeyInverseInput>;
  startTime: Scalars['Datetime']['input'];
  title: Scalars['String']['input'];
  type: EventType;
  url?: InputMaybe<Scalars['String']['input']>;
};

/** The globally unique `ID` look up for the row to connect. */
export type EventNodeIdConnect = {
  /** The globally unique `ID` which identifies a single `event` to be connected. */
  nodeId: Scalars['ID']['input'];
};

/** The globally unique `ID` look up for the row to update. */
export type EventOnEventCandidateForEventCandidatesEventIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `eventCandidate` to be connected. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `eventCandidate` being updated. */
  patch: EventCandidatePatch;
};

/** The fields on `event` to look up the row to update. */
export type EventOnEventCandidateForEventCandidatesEventIdFkeyUsingEventsPkeyUpdate = {
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `event` being updated. */
  patch: UpdateEventOnEventCandidateForEventCandidatesEventIdFkeyPatch;
};

/** The globally unique `ID` look up for the row to update. */
export type EventOnEventDraftEvaluationForEventDraftEvaluationsEventIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `eventDraftEvaluation` to be connected. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `eventDraftEvaluation` being updated. */
  patch: EventDraftEvaluationPatch;
};

/** The fields on `event` to look up the row to update. */
export type EventOnEventDraftEvaluationForEventDraftEvaluationsEventIdFkeyUsingEventsPkeyUpdate = {
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `event` being updated. */
  patch: UpdateEventOnEventDraftEvaluationForEventDraftEvaluationsEventIdFkeyPatch;
};

/** The globally unique `ID` look up for the row to update. */
export type EventOnEventScorecardForEventScorecardsEventIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `eventScorecard` to be connected. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `eventScorecard` being updated. */
  patch: EventScorecardPatch;
};

/** The fields on `event` to look up the row to update. */
export type EventOnEventScorecardForEventScorecardsEventIdFkeyUsingEventsPkeyUpdate = {
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `event` being updated. */
  patch: UpdateEventOnEventScorecardForEventScorecardsEventIdFkeyPatch;
};

/** The globally unique `ID` look up for the row to update. */
export type EventOnEventUserForEventUsersEventIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `eventUser` to be connected. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `eventUser` being updated. */
  patch: EventUserPatch;
};

/** The fields on `event` to look up the row to update. */
export type EventOnEventUserForEventUsersEventIdFkeyUsingEventsPkeyUpdate = {
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `event` being updated. */
  patch: UpdateEventOnEventUserForEventUsersEventIdFkeyPatch;
};

/** Represents an update to a `Event`. Fields that are set will be updated. */
export type EventPatch = {
  address?: InputMaybe<Scalars['String']['input']>;
  deletedAt?: InputMaybe<Scalars['Datetime']['input']>;
  description?: InputMaybe<Scalars['String']['input']>;
  endTime?: InputMaybe<Scalars['Datetime']['input']>;
  eventCandidates?: InputMaybe<EventCandidatesEventIdFkeyInverseInput>;
  eventDraftEvaluations?: InputMaybe<EventDraftEvaluationsEventIdFkeyInverseInput>;
  eventScorecards?: InputMaybe<EventScorecardsEventIdFkeyInverseInput>;
  eventUsers?: InputMaybe<EventUsersEventIdFkeyInverseInput>;
  startTime?: InputMaybe<Scalars['Datetime']['input']>;
  title?: InputMaybe<Scalars['String']['input']>;
  type?: InputMaybe<EventType>;
  url?: InputMaybe<Scalars['String']['input']>;
};

export type EventScorecard = Node & {
  __typename?: 'EventScorecard';
  createdAt: Scalars['Datetime']['output'];
  /** Reads a single `Event` that is related to this `EventScorecard`. */
  event?: Maybe<Event>;
  eventId: Scalars['Int']['output'];
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  /** Reads a single `Scorecard` that is related to this `EventScorecard`. */
  scorecard?: Maybe<Scorecard>;
  scorecardId: Scalars['Int']['output'];
  updatedAt: Scalars['Datetime']['output'];
};

/** A condition to be used against `EventScorecard` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type EventScorecardCondition = {
  /** Checks for equality with the object’s `eventId` field. */
  eventId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `scorecardId` field. */
  scorecardId?: InputMaybe<Scalars['Int']['input']>;
};

/** A filter to be used against `EventScorecard` object types. All fields are combined with a logical ‘and.’ */
export type EventScorecardFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<EventScorecardFilter>>;
  /** Filter by the object’s `event` relation. */
  event?: InputMaybe<EventFilter>;
  /** Filter by the object’s `eventId` field. */
  eventId?: InputMaybe<IntFilter>;
  /** Negates the expression. */
  not?: InputMaybe<EventScorecardFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<EventScorecardFilter>>;
  /** Filter by the object’s `scorecard` relation. */
  scorecard?: InputMaybe<ScorecardFilter>;
  /** Filter by the object’s `scorecardId` field. */
  scorecardId?: InputMaybe<IntFilter>;
};

/** An input for mutations affecting `EventScorecard` */
export type EventScorecardInput = {
  event?: InputMaybe<EventScorecardsEventIdFkeyInput>;
  eventId?: InputMaybe<Scalars['Int']['input']>;
  scorecard?: InputMaybe<EventScorecardsScorecardIdFkeyInput>;
  scorecardId?: InputMaybe<Scalars['Int']['input']>;
};

/** The globally unique `ID` look up for the row to connect. */
export type EventScorecardNodeIdConnect = {
  /** The globally unique `ID` which identifies a single `eventScorecard` to be connected. */
  nodeId: Scalars['ID']['input'];
};

/** The globally unique `ID` look up for the row to delete. */
export type EventScorecardNodeIdDelete = {
  /** The globally unique `ID` which identifies a single `eventScorecard` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** The globally unique `ID` look up for the row to update. */
export type EventScorecardOnEventScorecardForEventScorecardsEventIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `event` to be connected. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `event` being updated. */
  patch: EventPatch;
};

/** The globally unique `ID` look up for the row to update. */
export type EventScorecardOnEventScorecardForEventScorecardsScorecardIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `scorecard` to be connected. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `scorecard` being updated. */
  patch: ScorecardPatch;
};

/** Represents an update to a `EventScorecard`. Fields that are set will be updated. */
export type EventScorecardPatch = {
  event?: InputMaybe<EventScorecardsEventIdFkeyInput>;
  eventId?: InputMaybe<Scalars['Int']['input']>;
  scorecard?: InputMaybe<EventScorecardsScorecardIdFkeyInput>;
  scorecardId?: InputMaybe<Scalars['Int']['input']>;
};

/** A connection to a list of `Scorecard` values, with data from `EventScorecard`. */
export type EventScorecardsByEventScorecardEventIdAndScorecardIdManyToManyConnection = {
  __typename?: 'EventScorecardsByEventScorecardEventIdAndScorecardIdManyToManyConnection';
  /** A list of edges which contains the `Scorecard`, info from the `EventScorecard`, and the cursor to aid in pagination. */
  edges: Array<EventScorecardsByEventScorecardEventIdAndScorecardIdManyToManyEdge>;
  /** A list of `Scorecard` objects. */
  nodes: Array<Scorecard>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Scorecard` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `Scorecard` edge in the connection, with data from `EventScorecard`. */
export type EventScorecardsByEventScorecardEventIdAndScorecardIdManyToManyEdge = {
  __typename?: 'EventScorecardsByEventScorecardEventIdAndScorecardIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** Reads and enables pagination through a set of `EventScorecard`. */
  eventScorecards: EventScorecardsConnection;
  /** The `Scorecard` at the end of the edge. */
  node: Scorecard;
};


/** A `Scorecard` edge in the connection, with data from `EventScorecard`. */
export type EventScorecardsByEventScorecardEventIdAndScorecardIdManyToManyEdgeEventScorecardsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<EventScorecardCondition>;
  filter?: InputMaybe<EventScorecardFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<EventScorecardsOrderBy>>;
};

/** A connection to a list of `EventScorecard` values. */
export type EventScorecardsConnection = {
  __typename?: 'EventScorecardsConnection';
  /** A list of edges which contains the `EventScorecard` and cursor to aid in pagination. */
  edges: Array<EventScorecardsEdge>;
  /** A list of `EventScorecard` objects. */
  nodes: Array<EventScorecard>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `EventScorecard` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `EventScorecard` edge in the connection. */
export type EventScorecardsEdge = {
  __typename?: 'EventScorecardsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `EventScorecard` at the end of the edge. */
  node: EventScorecard;
};

/** The `eventScorecard` to be created by this mutation. */
export type EventScorecardsEventIdFkeyEventScorecardsCreateInput = {
  event?: InputMaybe<EventScorecardsEventIdFkeyInput>;
  scorecard?: InputMaybe<EventScorecardsScorecardIdFkeyInput>;
  scorecardId?: InputMaybe<Scalars['Int']['input']>;
};

/** The `event` to be created by this mutation. */
export type EventScorecardsEventIdFkeyEventsCreateInput = {
  address?: InputMaybe<Scalars['String']['input']>;
  description?: InputMaybe<Scalars['String']['input']>;
  endTime: Scalars['Datetime']['input'];
  eventCandidates?: InputMaybe<EventCandidatesEventIdFkeyInverseInput>;
  eventDraftEvaluations?: InputMaybe<EventDraftEvaluationsEventIdFkeyInverseInput>;
  eventScorecards?: InputMaybe<EventScorecardsEventIdFkeyInverseInput>;
  eventUsers?: InputMaybe<EventUsersEventIdFkeyInverseInput>;
  startTime: Scalars['Datetime']['input'];
  title: Scalars['String']['input'];
  type: EventType;
  url?: InputMaybe<Scalars['String']['input']>;
};

/** Input for the nested mutation of `event` in the `EventScorecardInput` mutation. */
export type EventScorecardsEventIdFkeyInput = {
  /** The primary key(s) for `event` for the far side of the relationship. */
  connectById?: InputMaybe<EventEventsPkeyConnect>;
  /** The primary key(s) for `event` for the far side of the relationship. */
  connectByNodeId?: InputMaybe<EventNodeIdConnect>;
  /** A `EventInput` object that will be created and connected to this object. */
  create?: InputMaybe<EventScorecardsEventIdFkeyEventsCreateInput>;
  /** The primary key(s) and patch data for `event` for the far side of the relationship. */
  updateById?: InputMaybe<EventOnEventScorecardForEventScorecardsEventIdFkeyUsingEventsPkeyUpdate>;
  /** The primary key(s) and patch data for `event` for the far side of the relationship. */
  updateByNodeId?: InputMaybe<EventScorecardOnEventScorecardForEventScorecardsEventIdFkeyNodeIdUpdate>;
};

/** Input for the nested mutation of `eventScorecard` in the `EventInput` mutation. */
export type EventScorecardsEventIdFkeyInverseInput = {
  /** The primary key(s) for `eventScorecard` for the far side of the relationship. */
  connectByNodeId?: InputMaybe<Array<EventScorecardNodeIdConnect>>;
  /** A `EventScorecardInput` object that will be created and connected to this object. */
  create?: InputMaybe<Array<EventScorecardsEventIdFkeyEventScorecardsCreateInput>>;
  /** The primary key(s) for `eventScorecard` for the far side of the relationship. */
  deleteByNodeId?: InputMaybe<Array<EventScorecardNodeIdDelete>>;
  /** Flag indicating whether all other `eventScorecard` records that match this relationship should be removed. */
  deleteOthers?: InputMaybe<Scalars['Boolean']['input']>;
  /** The primary key(s) and patch data for `eventScorecard` for the far side of the relationship. */
  updateByNodeId?: InputMaybe<Array<EventOnEventScorecardForEventScorecardsEventIdFkeyNodeIdUpdate>>;
};

/** Methods to use when ordering `EventScorecard`. */
export enum EventScorecardsOrderBy {
  EventIdAsc = 'EVENT_ID_ASC',
  EventIdDesc = 'EVENT_ID_DESC',
  Natural = 'NATURAL',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  ScorecardIdAsc = 'SCORECARD_ID_ASC',
  ScorecardIdDesc = 'SCORECARD_ID_DESC'
}

/** The `eventScorecard` to be created by this mutation. */
export type EventScorecardsScorecardIdFkeyEventScorecardsCreateInput = {
  event?: InputMaybe<EventScorecardsEventIdFkeyInput>;
  eventId?: InputMaybe<Scalars['Int']['input']>;
  scorecard?: InputMaybe<EventScorecardsScorecardIdFkeyInput>;
};

/** Input for the nested mutation of `scorecard` in the `EventScorecardInput` mutation. */
export type EventScorecardsScorecardIdFkeyInput = {
  /** The primary key(s) for `scorecard` for the far side of the relationship. */
  connectById?: InputMaybe<ScorecardScorecardsPkeyConnect>;
  /** The primary key(s) for `scorecard` for the far side of the relationship. */
  connectByNodeId?: InputMaybe<ScorecardNodeIdConnect>;
  /** A `ScorecardInput` object that will be created and connected to this object. */
  create?: InputMaybe<EventScorecardsScorecardIdFkeyScorecardsCreateInput>;
  /** The primary key(s) and patch data for `scorecard` for the far side of the relationship. */
  updateById?: InputMaybe<ScorecardOnEventScorecardForEventScorecardsScorecardIdFkeyUsingScorecardsPkeyUpdate>;
  /** The primary key(s) and patch data for `scorecard` for the far side of the relationship. */
  updateByNodeId?: InputMaybe<EventScorecardOnEventScorecardForEventScorecardsScorecardIdFkeyNodeIdUpdate>;
};

/** Input for the nested mutation of `eventScorecard` in the `ScorecardInput` mutation. */
export type EventScorecardsScorecardIdFkeyInverseInput = {
  /** The primary key(s) for `eventScorecard` for the far side of the relationship. */
  connectByNodeId?: InputMaybe<Array<EventScorecardNodeIdConnect>>;
  /** A `EventScorecardInput` object that will be created and connected to this object. */
  create?: InputMaybe<Array<EventScorecardsScorecardIdFkeyEventScorecardsCreateInput>>;
  /** The primary key(s) for `eventScorecard` for the far side of the relationship. */
  deleteByNodeId?: InputMaybe<Array<EventScorecardNodeIdDelete>>;
  /** Flag indicating whether all other `eventScorecard` records that match this relationship should be removed. */
  deleteOthers?: InputMaybe<Scalars['Boolean']['input']>;
  /** The primary key(s) and patch data for `eventScorecard` for the far side of the relationship. */
  updateByNodeId?: InputMaybe<Array<ScorecardOnEventScorecardForEventScorecardsScorecardIdFkeyNodeIdUpdate>>;
};

/** The `scorecard` to be created by this mutation. */
export type EventScorecardsScorecardIdFkeyScorecardsCreateInput = {
  criterias?: InputMaybe<ScorecardCriteriasScorecardIdFkeyInverseInput>;
  evaluationScorecards?: InputMaybe<EvaluationScorecardsScorecardIdFkeyInverseInput>;
  eventScorecards?: InputMaybe<EventScorecardsScorecardIdFkeyInverseInput>;
  pipelineStageScorecards?: InputMaybe<PipelineStageScorecardsScorecardIdFkeyInverseInput>;
  translations?: InputMaybe<ScorecardTranslationsScorecardIdFkeyInverseInput>;
};

/** A filter to be used against many `EventCandidate` object types. All fields are combined with a logical ‘and.’ */
export type EventToManyEventCandidateFilter = {
  /** Every related `EventCandidate` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<EventCandidateFilter>;
  /** No related `EventCandidate` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<EventCandidateFilter>;
  /** Some related `EventCandidate` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<EventCandidateFilter>;
};

/** A filter to be used against many `EventDraftEvaluation` object types. All fields are combined with a logical ‘and.’ */
export type EventToManyEventDraftEvaluationFilter = {
  /** Every related `EventDraftEvaluation` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<EventDraftEvaluationFilter>;
  /** No related `EventDraftEvaluation` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<EventDraftEvaluationFilter>;
  /** Some related `EventDraftEvaluation` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<EventDraftEvaluationFilter>;
};

/** A filter to be used against many `EventScorecard` object types. All fields are combined with a logical ‘and.’ */
export type EventToManyEventScorecardFilter = {
  /** Every related `EventScorecard` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<EventScorecardFilter>;
  /** No related `EventScorecard` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<EventScorecardFilter>;
  /** Some related `EventScorecard` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<EventScorecardFilter>;
};

/** A filter to be used against many `EventUser` object types. All fields are combined with a logical ‘and.’ */
export type EventToManyEventUserFilter = {
  /** Every related `EventUser` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<EventUserFilter>;
  /** No related `EventUser` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<EventUserFilter>;
  /** Some related `EventUser` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<EventUserFilter>;
};

export enum EventType {
  Meeting = 'MEETING',
  Online = 'ONLINE',
  OnSite = 'ON_SITE',
  Phone = 'PHONE'
}

export type EventUser = Node & {
  __typename?: 'EventUser';
  createdAt: Scalars['Datetime']['output'];
  /** Reads a single `Event` that is related to this `EventUser`. */
  event?: Maybe<Event>;
  eventId: Scalars['Int']['output'];
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  updatedAt: Scalars['Datetime']['output'];
  /** Reads a single `User` that is related to this `EventUser`. */
  user?: Maybe<User>;
  userId: Scalars['Int']['output'];
};

/** A condition to be used against `EventUser` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type EventUserCondition = {
  /** Checks for equality with the object’s `eventId` field. */
  eventId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `userId` field. */
  userId?: InputMaybe<Scalars['Int']['input']>;
};

/** A filter to be used against `EventUser` object types. All fields are combined with a logical ‘and.’ */
export type EventUserFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<EventUserFilter>>;
  /** Filter by the object’s `event` relation. */
  event?: InputMaybe<EventFilter>;
  /** Filter by the object’s `eventId` field. */
  eventId?: InputMaybe<IntFilter>;
  /** Negates the expression. */
  not?: InputMaybe<EventUserFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<EventUserFilter>>;
  /** Filter by the object’s `user` relation. */
  user?: InputMaybe<UserFilter>;
  /** Filter by the object’s `userId` field. */
  userId?: InputMaybe<IntFilter>;
};

/** An input for mutations affecting `EventUser` */
export type EventUserInput = {
  event?: InputMaybe<EventUsersEventIdFkeyInput>;
  eventId?: InputMaybe<Scalars['Int']['input']>;
  user?: InputMaybe<EventUsersUserIdFkeyInput>;
  userId?: InputMaybe<Scalars['Int']['input']>;
};

/** The globally unique `ID` look up for the row to connect. */
export type EventUserNodeIdConnect = {
  /** The globally unique `ID` which identifies a single `eventUser` to be connected. */
  nodeId: Scalars['ID']['input'];
};

/** The globally unique `ID` look up for the row to delete. */
export type EventUserNodeIdDelete = {
  /** The globally unique `ID` which identifies a single `eventUser` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** The globally unique `ID` look up for the row to update. */
export type EventUserOnEventUserForEventUsersEventIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `event` to be connected. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `event` being updated. */
  patch: EventPatch;
};

/** The globally unique `ID` look up for the row to update. */
export type EventUserOnEventUserForEventUsersUserIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `user` to be connected. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `user` being updated. */
  patch: UserPatch;
};

/** Represents an update to a `EventUser`. Fields that are set will be updated. */
export type EventUserPatch = {
  event?: InputMaybe<EventUsersEventIdFkeyInput>;
  eventId?: InputMaybe<Scalars['Int']['input']>;
  user?: InputMaybe<EventUsersUserIdFkeyInput>;
  userId?: InputMaybe<Scalars['Int']['input']>;
};

/** A connection to a list of `User` values, with data from `EventUser`. */
export type EventUsersByEventUserEventIdAndUserIdManyToManyConnection = {
  __typename?: 'EventUsersByEventUserEventIdAndUserIdManyToManyConnection';
  /** A list of edges which contains the `User`, info from the `EventUser`, and the cursor to aid in pagination. */
  edges: Array<EventUsersByEventUserEventIdAndUserIdManyToManyEdge>;
  /** A list of `User` objects. */
  nodes: Array<User>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `User` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `User` edge in the connection, with data from `EventUser`. */
export type EventUsersByEventUserEventIdAndUserIdManyToManyEdge = {
  __typename?: 'EventUsersByEventUserEventIdAndUserIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** Reads and enables pagination through a set of `EventUser`. */
  eventUsers: EventUsersConnection;
  /** The `User` at the end of the edge. */
  node: User;
};


/** A `User` edge in the connection, with data from `EventUser`. */
export type EventUsersByEventUserEventIdAndUserIdManyToManyEdgeEventUsersArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<EventUserCondition>;
  filter?: InputMaybe<EventUserFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<EventUsersOrderBy>>;
};

/** A connection to a list of `EventUser` values. */
export type EventUsersConnection = {
  __typename?: 'EventUsersConnection';
  /** A list of edges which contains the `EventUser` and cursor to aid in pagination. */
  edges: Array<EventUsersEdge>;
  /** A list of `EventUser` objects. */
  nodes: Array<EventUser>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `EventUser` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `EventUser` edge in the connection. */
export type EventUsersEdge = {
  __typename?: 'EventUsersEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `EventUser` at the end of the edge. */
  node: EventUser;
};

/** The `eventUser` to be created by this mutation. */
export type EventUsersEventIdFkeyEventUsersCreateInput = {
  event?: InputMaybe<EventUsersEventIdFkeyInput>;
  user?: InputMaybe<EventUsersUserIdFkeyInput>;
  userId?: InputMaybe<Scalars['Int']['input']>;
};

/** The `event` to be created by this mutation. */
export type EventUsersEventIdFkeyEventsCreateInput = {
  address?: InputMaybe<Scalars['String']['input']>;
  description?: InputMaybe<Scalars['String']['input']>;
  endTime: Scalars['Datetime']['input'];
  eventCandidates?: InputMaybe<EventCandidatesEventIdFkeyInverseInput>;
  eventDraftEvaluations?: InputMaybe<EventDraftEvaluationsEventIdFkeyInverseInput>;
  eventScorecards?: InputMaybe<EventScorecardsEventIdFkeyInverseInput>;
  eventUsers?: InputMaybe<EventUsersEventIdFkeyInverseInput>;
  startTime: Scalars['Datetime']['input'];
  title: Scalars['String']['input'];
  type: EventType;
  url?: InputMaybe<Scalars['String']['input']>;
};

/** Input for the nested mutation of `event` in the `EventUserInput` mutation. */
export type EventUsersEventIdFkeyInput = {
  /** The primary key(s) for `event` for the far side of the relationship. */
  connectById?: InputMaybe<EventEventsPkeyConnect>;
  /** The primary key(s) for `event` for the far side of the relationship. */
  connectByNodeId?: InputMaybe<EventNodeIdConnect>;
  /** A `EventInput` object that will be created and connected to this object. */
  create?: InputMaybe<EventUsersEventIdFkeyEventsCreateInput>;
  /** The primary key(s) and patch data for `event` for the far side of the relationship. */
  updateById?: InputMaybe<EventOnEventUserForEventUsersEventIdFkeyUsingEventsPkeyUpdate>;
  /** The primary key(s) and patch data for `event` for the far side of the relationship. */
  updateByNodeId?: InputMaybe<EventUserOnEventUserForEventUsersEventIdFkeyNodeIdUpdate>;
};

/** Input for the nested mutation of `eventUser` in the `EventInput` mutation. */
export type EventUsersEventIdFkeyInverseInput = {
  /** The primary key(s) for `eventUser` for the far side of the relationship. */
  connectByNodeId?: InputMaybe<Array<EventUserNodeIdConnect>>;
  /** A `EventUserInput` object that will be created and connected to this object. */
  create?: InputMaybe<Array<EventUsersEventIdFkeyEventUsersCreateInput>>;
  /** The primary key(s) for `eventUser` for the far side of the relationship. */
  deleteByNodeId?: InputMaybe<Array<EventUserNodeIdDelete>>;
  /** Flag indicating whether all other `eventUser` records that match this relationship should be removed. */
  deleteOthers?: InputMaybe<Scalars['Boolean']['input']>;
  /** The primary key(s) and patch data for `eventUser` for the far side of the relationship. */
  updateByNodeId?: InputMaybe<Array<EventOnEventUserForEventUsersEventIdFkeyNodeIdUpdate>>;
};

/** Methods to use when ordering `EventUser`. */
export enum EventUsersOrderBy {
  EventIdAsc = 'EVENT_ID_ASC',
  EventIdDesc = 'EVENT_ID_DESC',
  Natural = 'NATURAL',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  UserIdAsc = 'USER_ID_ASC',
  UserIdDesc = 'USER_ID_DESC'
}

/** The `eventUser` to be created by this mutation. */
export type EventUsersUserIdFkeyEventUsersCreateInput = {
  event?: InputMaybe<EventUsersEventIdFkeyInput>;
  eventId?: InputMaybe<Scalars['Int']['input']>;
  user?: InputMaybe<EventUsersUserIdFkeyInput>;
};

/** Input for the nested mutation of `user` in the `EventUserInput` mutation. */
export type EventUsersUserIdFkeyInput = {
  /** The primary key(s) for `user` for the far side of the relationship. */
  connectByEmail?: InputMaybe<UserUsersEmailKeyConnect>;
  /** The primary key(s) for `user` for the far side of the relationship. */
  connectById?: InputMaybe<UserUsersPkeyConnect>;
  /** The primary key(s) for `user` for the far side of the relationship. */
  connectByNodeId?: InputMaybe<UserNodeIdConnect>;
  /** The primary key(s) and patch data for `user` for the far side of the relationship. */
  updateByEmail?: InputMaybe<UserOnEventUserForEventUsersUserIdFkeyUsingUsersEmailKeyUpdate>;
  /** The primary key(s) and patch data for `user` for the far side of the relationship. */
  updateById?: InputMaybe<UserOnEventUserForEventUsersUserIdFkeyUsingUsersPkeyUpdate>;
  /** The primary key(s) and patch data for `user` for the far side of the relationship. */
  updateByNodeId?: InputMaybe<EventUserOnEventUserForEventUsersUserIdFkeyNodeIdUpdate>;
};

/** Input for the nested mutation of `eventUser` in the `UserInput` mutation. */
export type EventUsersUserIdFkeyInverseInput = {
  /** The primary key(s) for `eventUser` for the far side of the relationship. */
  connectByNodeId?: InputMaybe<Array<EventUserNodeIdConnect>>;
  /** A `EventUserInput` object that will be created and connected to this object. */
  create?: InputMaybe<Array<EventUsersUserIdFkeyEventUsersCreateInput>>;
  /** The primary key(s) for `eventUser` for the far side of the relationship. */
  deleteByNodeId?: InputMaybe<Array<EventUserNodeIdDelete>>;
  /** Flag indicating whether all other `eventUser` records that match this relationship should be removed. */
  deleteOthers?: InputMaybe<Scalars['Boolean']['input']>;
  /** The primary key(s) and patch data for `eventUser` for the far side of the relationship. */
  updateByNodeId?: InputMaybe<Array<UserOnEventUserForEventUsersUserIdFkeyNodeIdUpdate>>;
};

/** A connection to a list of `Event` values. */
export type EventsConnection = {
  __typename?: 'EventsConnection';
  /** A list of edges which contains the `Event` and cursor to aid in pagination. */
  edges: Array<EventsEdge>;
  /** A list of `Event` objects. */
  nodes: Array<Event>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Event` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `Event` edge in the connection. */
export type EventsEdge = {
  __typename?: 'EventsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Event` at the end of the edge. */
  node: Event;
};

/** Methods to use when ordering `Event`. */
export enum EventsOrderBy {
  CreatedAtAsc = 'CREATED_AT_ASC',
  CreatedAtDesc = 'CREATED_AT_DESC',
  DeletedAtAsc = 'DELETED_AT_ASC',
  DeletedAtDesc = 'DELETED_AT_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  Natural = 'NATURAL',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  UpdatedAtAsc = 'UPDATED_AT_ASC',
  UpdatedAtDesc = 'UPDATED_AT_DESC'
}

export enum ExternalFileType {
  Candidate = 'Candidate',
  CandidateImport = 'CandidateImport',
  Message = 'Message',
  Website = 'Website'
}

export type Field = Node & {
  __typename?: 'Field';
  id: Scalars['Int']['output'];
  /** Reads a single `Job` that is related to this `Field`. */
  job?: Maybe<Job>;
  jobId: Scalars['Int']['output'];
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  position: Scalars['Int']['output'];
  required: Scalars['Boolean']['output'];
  type: JobField;
};

/** A condition to be used against `Field` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type FieldCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `jobId` field. */
  jobId?: InputMaybe<Scalars['Int']['input']>;
};

/** A filter to be used against `Field` object types. All fields are combined with a logical ‘and.’ */
export type FieldFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<FieldFilter>>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<IntFilter>;
  /** Filter by the object’s `job` relation. */
  job?: InputMaybe<JobFilter>;
  /** Filter by the object’s `jobId` field. */
  jobId?: InputMaybe<IntFilter>;
  /** Negates the expression. */
  not?: InputMaybe<FieldFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<FieldFilter>>;
};

/** An input for mutations affecting `Field` */
export type FieldInput = {
  job?: InputMaybe<JobFieldsJobIdFkeyInput>;
  jobId?: InputMaybe<Scalars['Int']['input']>;
  position: Scalars['Int']['input'];
  required: Scalars['Boolean']['input'];
  type: JobField;
};

/** The fields on `field` to look up the row to connect. */
export type FieldJobFieldsPkeyConnect = {
  id: Scalars['Int']['input'];
};

/** The fields on `field` to look up the row to delete. */
export type FieldJobFieldsPkeyDelete = {
  id: Scalars['Int']['input'];
};

/** The globally unique `ID` look up for the row to connect. */
export type FieldNodeIdConnect = {
  /** The globally unique `ID` which identifies a single `field` to be connected. */
  nodeId: Scalars['ID']['input'];
};

/** The globally unique `ID` look up for the row to delete. */
export type FieldNodeIdDelete = {
  /** The globally unique `ID` which identifies a single `field` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** The globally unique `ID` look up for the row to update. */
export type FieldOnFieldForJobFieldsJobIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `job` to be connected. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `job` being updated. */
  patch: JobPatch;
};

/** The fields on `field` to look up the row to update. */
export type FieldOnFieldForJobFieldsJobIdFkeyUsingJobFieldsPkeyUpdate = {
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `field` being updated. */
  patch: UpdateFieldOnFieldForJobFieldsJobIdFkeyPatch;
};

/** Represents an update to a `Field`. Fields that are set will be updated. */
export type FieldPatch = {
  job?: InputMaybe<JobFieldsJobIdFkeyInput>;
  jobId?: InputMaybe<Scalars['Int']['input']>;
  position?: InputMaybe<Scalars['Int']['input']>;
  required?: InputMaybe<Scalars['Boolean']['input']>;
};

/** A connection to a list of `Field` values. */
export type FieldsConnection = {
  __typename?: 'FieldsConnection';
  /** A list of edges which contains the `Field` and cursor to aid in pagination. */
  edges: Array<FieldsEdge>;
  /** A list of `Field` objects. */
  nodes: Array<Field>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Field` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `Field` edge in the connection. */
export type FieldsEdge = {
  __typename?: 'FieldsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Field` at the end of the edge. */
  node: Field;
};

/** Methods to use when ordering `Field`. */
export enum FieldsOrderBy {
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  JobIdAsc = 'JOB_ID_ASC',
  JobIdDesc = 'JOB_ID_DESC',
  Natural = 'NATURAL',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC'
}

export enum Gender {
  Female = 'FEMALE',
  Male = 'MALE',
  Other = 'OTHER'
}

/** A filter to be used against Gender fields. All fields are combined with a logical ‘and.’ */
export type GenderFilter = {
  /** Not equal to the specified value, treating null like an ordinary value. */
  distinctFrom?: InputMaybe<Gender>;
  /** Equal to the specified value. */
  equalTo?: InputMaybe<Gender>;
  /** Greater than the specified value. */
  greaterThan?: InputMaybe<Gender>;
  /** Greater than or equal to the specified value. */
  greaterThanOrEqualTo?: InputMaybe<Gender>;
  /** Included in the specified list. */
  in?: InputMaybe<Array<Gender>>;
  /** Is null (if `true` is specified) or is not null (if `false` is specified). */
  isNull?: InputMaybe<Scalars['Boolean']['input']>;
  /** Less than the specified value. */
  lessThan?: InputMaybe<Gender>;
  /** Less than or equal to the specified value. */
  lessThanOrEqualTo?: InputMaybe<Gender>;
  /** Equal to the specified value, treating null like an ordinary value. */
  notDistinctFrom?: InputMaybe<Gender>;
  /** Not equal to the specified value. */
  notEqualTo?: InputMaybe<Gender>;
  /** Not included in the specified list. */
  notIn?: InputMaybe<Array<Gender>>;
};

export enum GradeCondition {
  Bachelor = 'BACHELOR',
  Diploma = 'DIPLOMA',
  Master = 'MASTER',
  Phd = 'PHD',
  Postdoctoral = 'POSTDOCTORAL'
}

/** A filter to be used against Html fields. All fields are combined with a logical ‘and.’ */
export type HtmlFilter = {
  /** Not equal to the specified value, treating null like an ordinary value. */
  distinctFrom?: InputMaybe<Scalars['Html']['input']>;
  /** Ends with the specified string (case-sensitive). */
  endsWith?: InputMaybe<Scalars['Html']['input']>;
  /** Ends with the specified string (case-insensitive). */
  endsWithInsensitive?: InputMaybe<Scalars['Html']['input']>;
  /** Equal to the specified value. */
  equalTo?: InputMaybe<Scalars['Html']['input']>;
  /** Greater than the specified value. */
  greaterThan?: InputMaybe<Scalars['Html']['input']>;
  /** Greater than or equal to the specified value. */
  greaterThanOrEqualTo?: InputMaybe<Scalars['Html']['input']>;
  /** Included in the specified list. */
  in?: InputMaybe<Array<Scalars['Html']['input']>>;
  /** Contains the specified string (case-sensitive). */
  includes?: InputMaybe<Scalars['Html']['input']>;
  /** Contains the specified string (case-insensitive). */
  includesInsensitive?: InputMaybe<Scalars['Html']['input']>;
  /** Is null (if `true` is specified) or is not null (if `false` is specified). */
  isNull?: InputMaybe<Scalars['Boolean']['input']>;
  /** Less than the specified value. */
  lessThan?: InputMaybe<Scalars['Html']['input']>;
  /** Less than or equal to the specified value. */
  lessThanOrEqualTo?: InputMaybe<Scalars['Html']['input']>;
  /** Matches the specified pattern (case-sensitive). An underscore (_) matches any single character; a percent sign (%) matches any sequence of zero or more characters. */
  like?: InputMaybe<Scalars['Html']['input']>;
  /** Matches the specified pattern (case-insensitive). An underscore (_) matches any single character; a percent sign (%) matches any sequence of zero or more characters. */
  likeInsensitive?: InputMaybe<Scalars['Html']['input']>;
  /** Equal to the specified value, treating null like an ordinary value. */
  notDistinctFrom?: InputMaybe<Scalars['Html']['input']>;
  /** Does not end with the specified string (case-sensitive). */
  notEndsWith?: InputMaybe<Scalars['Html']['input']>;
  /** Does not end with the specified string (case-insensitive). */
  notEndsWithInsensitive?: InputMaybe<Scalars['Html']['input']>;
  /** Not equal to the specified value. */
  notEqualTo?: InputMaybe<Scalars['Html']['input']>;
  /** Not included in the specified list. */
  notIn?: InputMaybe<Array<Scalars['Html']['input']>>;
  /** Does not contain the specified string (case-sensitive). */
  notIncludes?: InputMaybe<Scalars['Html']['input']>;
  /** Does not contain the specified string (case-insensitive). */
  notIncludesInsensitive?: InputMaybe<Scalars['Html']['input']>;
  /** Does not match the specified pattern (case-sensitive). An underscore (_) matches any single character; a percent sign (%) matches any sequence of zero or more characters. */
  notLike?: InputMaybe<Scalars['Html']['input']>;
  /** Does not match the specified pattern (case-insensitive). An underscore (_) matches any single character; a percent sign (%) matches any sequence of zero or more characters. */
  notLikeInsensitive?: InputMaybe<Scalars['Html']['input']>;
  /** Does not match the specified pattern using the SQL standard's definition of a regular expression. */
  notSimilarTo?: InputMaybe<Scalars['Html']['input']>;
  /** Does not start with the specified string (case-sensitive). */
  notStartsWith?: InputMaybe<Scalars['Html']['input']>;
  /** Does not start with the specified string (case-insensitive). */
  notStartsWithInsensitive?: InputMaybe<Scalars['Html']['input']>;
  /** Matches the specified pattern using the SQL standard's definition of a regular expression. */
  similarTo?: InputMaybe<Scalars['Html']['input']>;
  /** Starts with the specified string (case-sensitive). */
  startsWith?: InputMaybe<Scalars['Html']['input']>;
  /** Starts with the specified string (case-insensitive). */
  startsWithInsensitive?: InputMaybe<Scalars['Html']['input']>;
};

/** A filter to be used against Int fields. All fields are combined with a logical ‘and.’ */
export type IntFilter = {
  /** Not equal to the specified value, treating null like an ordinary value. */
  distinctFrom?: InputMaybe<Scalars['Int']['input']>;
  /** Equal to the specified value. */
  equalTo?: InputMaybe<Scalars['Int']['input']>;
  /** Greater than the specified value. */
  greaterThan?: InputMaybe<Scalars['Int']['input']>;
  /** Greater than or equal to the specified value. */
  greaterThanOrEqualTo?: InputMaybe<Scalars['Int']['input']>;
  /** Included in the specified list. */
  in?: InputMaybe<Array<Scalars['Int']['input']>>;
  /** Is null (if `true` is specified) or is not null (if `false` is specified). */
  isNull?: InputMaybe<Scalars['Boolean']['input']>;
  /** Less than the specified value. */
  lessThan?: InputMaybe<Scalars['Int']['input']>;
  /** Less than or equal to the specified value. */
  lessThanOrEqualTo?: InputMaybe<Scalars['Int']['input']>;
  /** Equal to the specified value, treating null like an ordinary value. */
  notDistinctFrom?: InputMaybe<Scalars['Int']['input']>;
  /** Not equal to the specified value. */
  notEqualTo?: InputMaybe<Scalars['Int']['input']>;
  /** Not included in the specified list. */
  notIn?: InputMaybe<Array<Scalars['Int']['input']>>;
};

/** A filter to be used against Int List fields. All fields are combined with a logical ‘and.’ */
export type IntListFilter = {
  /** Any array item is equal to the specified value. */
  anyEqualTo?: InputMaybe<Scalars['Int']['input']>;
  /** Any array item is greater than the specified value. */
  anyGreaterThan?: InputMaybe<Scalars['Int']['input']>;
  /** Any array item is greater than or equal to the specified value. */
  anyGreaterThanOrEqualTo?: InputMaybe<Scalars['Int']['input']>;
  /** Any array item is less than the specified value. */
  anyLessThan?: InputMaybe<Scalars['Int']['input']>;
  /** Any array item is less than or equal to the specified value. */
  anyLessThanOrEqualTo?: InputMaybe<Scalars['Int']['input']>;
  /** Any array item is not equal to the specified value. */
  anyNotEqualTo?: InputMaybe<Scalars['Int']['input']>;
  /** Contained by the specified list of values. */
  containedBy?: InputMaybe<Array<InputMaybe<Scalars['Int']['input']>>>;
  /** Contains the specified list of values. */
  contains?: InputMaybe<Array<InputMaybe<Scalars['Int']['input']>>>;
  /** Not equal to the specified value, treating null like an ordinary value. */
  distinctFrom?: InputMaybe<Array<InputMaybe<Scalars['Int']['input']>>>;
  /** Equal to the specified value. */
  equalTo?: InputMaybe<Array<InputMaybe<Scalars['Int']['input']>>>;
  /** Greater than the specified value. */
  greaterThan?: InputMaybe<Array<InputMaybe<Scalars['Int']['input']>>>;
  /** Greater than or equal to the specified value. */
  greaterThanOrEqualTo?: InputMaybe<Array<InputMaybe<Scalars['Int']['input']>>>;
  /** Is null (if `true` is specified) or is not null (if `false` is specified). */
  isNull?: InputMaybe<Scalars['Boolean']['input']>;
  /** Less than the specified value. */
  lessThan?: InputMaybe<Array<InputMaybe<Scalars['Int']['input']>>>;
  /** Less than or equal to the specified value. */
  lessThanOrEqualTo?: InputMaybe<Array<InputMaybe<Scalars['Int']['input']>>>;
  /** Equal to the specified value, treating null like an ordinary value. */
  notDistinctFrom?: InputMaybe<Array<InputMaybe<Scalars['Int']['input']>>>;
  /** Not equal to the specified value. */
  notEqualTo?: InputMaybe<Array<InputMaybe<Scalars['Int']['input']>>>;
  /** Overlaps the specified list of values. */
  overlaps?: InputMaybe<Array<InputMaybe<Scalars['Int']['input']>>>;
};

/** A range of `Int`. */
export type IntRange = {
  __typename?: 'IntRange';
  /** The ending bound of our range. */
  end?: Maybe<IntRangeBound>;
  /** The starting bound of our range. */
  start?: Maybe<IntRangeBound>;
};

/** The value at one end of a range. A range can either include this value, or not. */
export type IntRangeBound = {
  __typename?: 'IntRangeBound';
  /** Whether or not the value of this bound is included in the range. */
  inclusive: Scalars['Boolean']['output'];
  /** The value at one end of our range. */
  value: Scalars['Int']['output'];
};

/** The value at one end of a range. A range can either include this value, or not. */
export type IntRangeBoundInput = {
  /** Whether or not the value of this bound is included in the range. */
  inclusive: Scalars['Boolean']['input'];
  /** The value at one end of our range. */
  value: Scalars['Int']['input'];
};

/** A range of `Int`. */
export type IntRangeInput = {
  /** The ending bound of our range. */
  end?: InputMaybe<IntRangeBoundInput>;
  /** The starting bound of our range. */
  start?: InputMaybe<IntRangeBoundInput>;
};

export type Invoice = Node & {
  __typename?: 'Invoice';
  candidatesCount?: Maybe<Scalars['Int']['output']>;
  /** Reads a single `Company` that is related to this `Invoice`. */
  company?: Maybe<Company>;
  companyId: Scalars['Int']['output'];
  createdAt: Scalars['Datetime']['output'];
  deletedAt?: Maybe<Scalars['Datetime']['output']>;
  id: Scalars['Int']['output'];
  jobsCount?: Maybe<Scalars['Int']['output']>;
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  price: Scalars['Int']['output'];
  refId?: Maybe<Scalars['String']['output']>;
  status: InvoiceStatus;
  /** Reads a single `Subscription` that is related to this `Invoice`. */
  subscription?: Maybe<Subscription>;
  subscriptionId: Scalars['Int']['output'];
  updatedAt: Scalars['Datetime']['output'];
};

/** A condition to be used against `Invoice` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type InvoiceCondition = {
  /** Checks for equality with the object’s `companyId` field. */
  companyId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `createdAt` field. */
  createdAt?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `deletedAt` field. */
  deletedAt?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `status` field. */
  status?: InputMaybe<InvoiceStatus>;
  /** Checks for equality with the object’s `subscriptionId` field. */
  subscriptionId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `updatedAt` field. */
  updatedAt?: InputMaybe<Scalars['Datetime']['input']>;
};

/** A filter to be used against `Invoice` object types. All fields are combined with a logical ‘and.’ */
export type InvoiceFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<InvoiceFilter>>;
  /** Filter by the object’s `candidatesCount` field. */
  candidatesCount?: InputMaybe<IntFilter>;
  /** Filter by the object’s `company` relation. */
  company?: InputMaybe<CompanyFilter>;
  /** Filter by the object’s `companyId` field. */
  companyId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `createdAt` field. */
  createdAt?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `deletedAt` field. */
  deletedAt?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<IntFilter>;
  /** Filter by the object’s `jobsCount` field. */
  jobsCount?: InputMaybe<IntFilter>;
  /** Negates the expression. */
  not?: InputMaybe<InvoiceFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<InvoiceFilter>>;
  /** Filter by the object’s `status` field. */
  status?: InputMaybe<InvoiceStatusFilter>;
  /** Filter by the object’s `subscription` relation. */
  subscription?: InputMaybe<SubscriptionFilter>;
  /** Filter by the object’s `subscriptionId` field. */
  subscriptionId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `updatedAt` field. */
  updatedAt?: InputMaybe<DatetimeFilter>;
};

/** An input for mutations affecting `Invoice` */
export type InvoiceInput = {
  company?: InputMaybe<InvoicesCompanyIdFkeyInput>;
  companyId?: InputMaybe<Scalars['Int']['input']>;
  deletedAt?: InputMaybe<Scalars['Datetime']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  price: Scalars['Int']['input'];
  refId?: InputMaybe<Scalars['String']['input']>;
  status: InvoiceStatus;
  subscription?: InputMaybe<InvoicesSubscriptionIdFkeyInput>;
  subscriptionId?: InputMaybe<Scalars['Int']['input']>;
};

/** The fields on `invoice` to look up the row to connect. */
export type InvoiceInvoicesPkeyConnect = {
  id: Scalars['Int']['input'];
};

/** The globally unique `ID` look up for the row to connect. */
export type InvoiceNodeIdConnect = {
  /** The globally unique `ID` which identifies a single `invoice` to be connected. */
  nodeId: Scalars['ID']['input'];
};

/** The globally unique `ID` look up for the row to update. */
export type InvoiceOnInvoiceForInvoicesCompanyIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `company` to be connected. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `company` being updated. */
  patch: CompanyPatch;
};

/** The fields on `invoice` to look up the row to update. */
export type InvoiceOnInvoiceForInvoicesCompanyIdFkeyUsingInvoicesPkeyUpdate = {
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `invoice` being updated. */
  patch: UpdateInvoiceOnInvoiceForInvoicesCompanyIdFkeyPatch;
};

/** The globally unique `ID` look up for the row to update. */
export type InvoiceOnInvoiceForInvoicesSubscriptionIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `subscription` to be connected. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `subscription` being updated. */
  patch: SubscriptionPatch;
};

/** The fields on `invoice` to look up the row to update. */
export type InvoiceOnInvoiceForInvoicesSubscriptionIdFkeyUsingInvoicesPkeyUpdate = {
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `invoice` being updated. */
  patch: UpdateInvoiceOnInvoiceForInvoicesSubscriptionIdFkeyPatch;
};

/** Represents an update to a `Invoice`. Fields that are set will be updated. */
export type InvoicePatch = {
  company?: InputMaybe<InvoicesCompanyIdFkeyInput>;
  companyId?: InputMaybe<Scalars['Int']['input']>;
  deletedAt?: InputMaybe<Scalars['Datetime']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  price?: InputMaybe<Scalars['Int']['input']>;
  refId?: InputMaybe<Scalars['String']['input']>;
  status?: InputMaybe<InvoiceStatus>;
  subscription?: InputMaybe<InvoicesSubscriptionIdFkeyInput>;
  subscriptionId?: InputMaybe<Scalars['Int']['input']>;
};

export enum InvoiceStatus {
  Expired = 'EXPIRED',
  New = 'NEW',
  Paid = 'PAID'
}

/** A filter to be used against InvoiceStatus fields. All fields are combined with a logical ‘and.’ */
export type InvoiceStatusFilter = {
  /** Not equal to the specified value, treating null like an ordinary value. */
  distinctFrom?: InputMaybe<InvoiceStatus>;
  /** Equal to the specified value. */
  equalTo?: InputMaybe<InvoiceStatus>;
  /** Greater than the specified value. */
  greaterThan?: InputMaybe<InvoiceStatus>;
  /** Greater than or equal to the specified value. */
  greaterThanOrEqualTo?: InputMaybe<InvoiceStatus>;
  /** Included in the specified list. */
  in?: InputMaybe<Array<InvoiceStatus>>;
  /** Is null (if `true` is specified) or is not null (if `false` is specified). */
  isNull?: InputMaybe<Scalars['Boolean']['input']>;
  /** Less than the specified value. */
  lessThan?: InputMaybe<InvoiceStatus>;
  /** Less than or equal to the specified value. */
  lessThanOrEqualTo?: InputMaybe<InvoiceStatus>;
  /** Equal to the specified value, treating null like an ordinary value. */
  notDistinctFrom?: InputMaybe<InvoiceStatus>;
  /** Not equal to the specified value. */
  notEqualTo?: InputMaybe<InvoiceStatus>;
  /** Not included in the specified list. */
  notIn?: InputMaybe<Array<InvoiceStatus>>;
};

/** Input for the nested mutation of `company` in the `InvoiceInput` mutation. */
export type InvoicesCompanyIdFkeyInput = {
  /** The primary key(s) for `company` for the far side of the relationship. */
  connectById?: InputMaybe<CompanyCompaniesPkeyConnect>;
  /** The primary key(s) for `company` for the far side of the relationship. */
  connectByNodeId?: InputMaybe<CompanyNodeIdConnect>;
  /** The primary key(s) for `company` for the far side of the relationship. */
  connectBySlug?: InputMaybe<CompanyCompaniesSlugKeyConnect>;
  /** The primary key(s) and patch data for `company` for the far side of the relationship. */
  updateById?: InputMaybe<CompanyOnInvoiceForInvoicesCompanyIdFkeyUsingCompaniesPkeyUpdate>;
  /** The primary key(s) and patch data for `company` for the far side of the relationship. */
  updateByNodeId?: InputMaybe<InvoiceOnInvoiceForInvoicesCompanyIdFkeyNodeIdUpdate>;
  /** The primary key(s) and patch data for `company` for the far side of the relationship. */
  updateBySlug?: InputMaybe<CompanyOnInvoiceForInvoicesCompanyIdFkeyUsingCompaniesSlugKeyUpdate>;
};

/** Input for the nested mutation of `invoice` in the `CompanyInput` mutation. */
export type InvoicesCompanyIdFkeyInverseInput = {
  /** The primary key(s) for `invoice` for the far side of the relationship. */
  connectById?: InputMaybe<Array<InvoiceInvoicesPkeyConnect>>;
  /** The primary key(s) for `invoice` for the far side of the relationship. */
  connectByNodeId?: InputMaybe<Array<InvoiceNodeIdConnect>>;
  /** A `InvoiceInput` object that will be created and connected to this object. */
  create?: InputMaybe<Array<InvoicesCompanyIdFkeyInvoicesCreateInput>>;
  /** The primary key(s) and patch data for `invoice` for the far side of the relationship. */
  updateById?: InputMaybe<Array<InvoiceOnInvoiceForInvoicesCompanyIdFkeyUsingInvoicesPkeyUpdate>>;
  /** The primary key(s) and patch data for `invoice` for the far side of the relationship. */
  updateByNodeId?: InputMaybe<Array<CompanyOnInvoiceForInvoicesCompanyIdFkeyNodeIdUpdate>>;
};

/** The `invoice` to be created by this mutation. */
export type InvoicesCompanyIdFkeyInvoicesCreateInput = {
  company?: InputMaybe<InvoicesCompanyIdFkeyInput>;
  deletedAt?: InputMaybe<Scalars['Datetime']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  price: Scalars['Int']['input'];
  refId?: InputMaybe<Scalars['String']['input']>;
  status: InvoiceStatus;
  subscription?: InputMaybe<InvoicesSubscriptionIdFkeyInput>;
  subscriptionId?: InputMaybe<Scalars['Int']['input']>;
};

/** A connection to a list of `Invoice` values. */
export type InvoicesConnection = {
  __typename?: 'InvoicesConnection';
  /** A list of edges which contains the `Invoice` and cursor to aid in pagination. */
  edges: Array<InvoicesEdge>;
  /** A list of `Invoice` objects. */
  nodes: Array<Invoice>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Invoice` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `Invoice` edge in the connection. */
export type InvoicesEdge = {
  __typename?: 'InvoicesEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Invoice` at the end of the edge. */
  node: Invoice;
};

/** Methods to use when ordering `Invoice`. */
export enum InvoicesOrderBy {
  CompanyIdAsc = 'COMPANY_ID_ASC',
  CompanyIdDesc = 'COMPANY_ID_DESC',
  CreatedAtAsc = 'CREATED_AT_ASC',
  CreatedAtDesc = 'CREATED_AT_DESC',
  DeletedAtAsc = 'DELETED_AT_ASC',
  DeletedAtDesc = 'DELETED_AT_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  Natural = 'NATURAL',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  StatusAsc = 'STATUS_ASC',
  StatusDesc = 'STATUS_DESC',
  SubscriptionIdAsc = 'SUBSCRIPTION_ID_ASC',
  SubscriptionIdDesc = 'SUBSCRIPTION_ID_DESC',
  UpdatedAtAsc = 'UPDATED_AT_ASC',
  UpdatedAtDesc = 'UPDATED_AT_DESC'
}

/** Input for the nested mutation of `subscription` in the `InvoiceInput` mutation. */
export type InvoicesSubscriptionIdFkeyInput = {
  /** The primary key(s) for `subscription` for the far side of the relationship. */
  connectById?: InputMaybe<SubscriptionSubscriptionsPkeyConnect>;
  /** The primary key(s) for `subscription` for the far side of the relationship. */
  connectByNodeId?: InputMaybe<SubscriptionNodeIdConnect>;
  /** The primary key(s) and patch data for `subscription` for the far side of the relationship. */
  updateById?: InputMaybe<SubscriptionOnInvoiceForInvoicesSubscriptionIdFkeyUsingSubscriptionsPkeyUpdate>;
  /** The primary key(s) and patch data for `subscription` for the far side of the relationship. */
  updateByNodeId?: InputMaybe<InvoiceOnInvoiceForInvoicesSubscriptionIdFkeyNodeIdUpdate>;
};

/** Input for the nested mutation of `invoice` in the `SubscriptionInput` mutation. */
export type InvoicesSubscriptionIdFkeyInverseInput = {
  /** The primary key(s) for `invoice` for the far side of the relationship. */
  connectById?: InputMaybe<Array<InvoiceInvoicesPkeyConnect>>;
  /** The primary key(s) for `invoice` for the far side of the relationship. */
  connectByNodeId?: InputMaybe<Array<InvoiceNodeIdConnect>>;
  /** A `InvoiceInput` object that will be created and connected to this object. */
  create?: InputMaybe<Array<InvoicesSubscriptionIdFkeyInvoicesCreateInput>>;
  /** The primary key(s) and patch data for `invoice` for the far side of the relationship. */
  updateById?: InputMaybe<Array<InvoiceOnInvoiceForInvoicesSubscriptionIdFkeyUsingInvoicesPkeyUpdate>>;
  /** The primary key(s) and patch data for `invoice` for the far side of the relationship. */
  updateByNodeId?: InputMaybe<Array<SubscriptionOnInvoiceForInvoicesSubscriptionIdFkeyNodeIdUpdate>>;
};

/** The `invoice` to be created by this mutation. */
export type InvoicesSubscriptionIdFkeyInvoicesCreateInput = {
  company?: InputMaybe<InvoicesCompanyIdFkeyInput>;
  companyId?: InputMaybe<Scalars['Int']['input']>;
  deletedAt?: InputMaybe<Scalars['Datetime']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  price: Scalars['Int']['input'];
  refId?: InputMaybe<Scalars['String']['input']>;
  status: InvoiceStatus;
  subscription?: InputMaybe<InvoicesSubscriptionIdFkeyInput>;
};

export type Job = Node & {
  __typename?: 'Job';
  address?: Maybe<Scalars['String']['output']>;
  /** Reads and enables pagination through a set of `JobsApplication`. */
  applications: JobsApplicationsConnection;
  canManageCandidates?: Maybe<Scalars['Boolean']['output']>;
  /** Reads and enables pagination through a set of `Candidate`. */
  candidates: JobCandidatesByJobsApplicationJobIdAndCandidateIdManyToManyConnection;
  city?: Maybe<Scalars['String']['output']>;
  /** Reads and enables pagination through a set of `Company`. */
  companies: JobCompaniesByDraftEvaluationJobIdAndCompanyIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Competency`. */
  competencies: JobCompetenciesByJobCompetencyJobIdAndCompetenceIdManyToManyConnection;
  country?: Maybe<Scalars['Int']['output']>;
  createdAt: Scalars['Datetime']['output'];
  /** Reads a single `Department` that is related to this `Job`. */
  department?: Maybe<Department>;
  departmentId?: Maybe<Scalars['Int']['output']>;
  /** Reads and enables pagination through a set of `DisqualifyReason`. */
  disqualifyReasons: JobDisqualifyReasonsByJobsApplicationJobIdAndDisqualifyReasonIdManyToManyConnection;
  /** Reads and enables pagination through a set of `DraftEvaluation`. */
  draftEvaluations: DraftEvaluationsConnection;
  education?: Maybe<JobEducation>;
  /** Reads and enables pagination through a set of `Evaluation`. */
  evaluations: EvaluationsConnection;
  /** Reads and enables pagination through a set of `Field`. */
  fields: FieldsConnection;
  genders?: Maybe<Array<Maybe<Gender>>>;
  gradeConditions?: Maybe<Array<Maybe<GradeCondition>>>;
  hoursPerWeek?: Maybe<IntRange>;
  id: Scalars['Int']['output'];
  isRemote?: Maybe<Scalars['Boolean']['output']>;
  /** Reads and enables pagination through a set of `JobCompetency`. */
  jobCompetencies: JobCompetenciesConnection;
  /** Reads and enables pagination through a set of `JobKnowledge`. */
  jobKnowledges: JobKnowledgesConnection;
  /** Reads and enables pagination through a set of `JobQuestionnaire`. */
  jobQuestionnaires: JobQuestionnairesConnection;
  /** Reads and enables pagination through a set of `JobSkill`. */
  jobSkills: JobSkillsConnection;
  /** Reads and enables pagination through a set of `JobTag`. */
  jobTags: JobTagsConnection;
  /** Reads and enables pagination through a set of `Knowledge`. */
  knowledges: JobKnowledgesByJobKnowledgeJobIdAndKnowledgeIdManyToManyConnection;
  languages: Array<Maybe<Language>>;
  matches?: Maybe<Array<Maybe<Scalars['String']['output']>>>;
  maxAgeCondition?: Maybe<Scalars['Int']['output']>;
  militaryStatus?: Maybe<Array<Maybe<MilitaryStatus>>>;
  minAgeCondition?: Maybe<Scalars['Int']['output']>;
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  /** Reads and enables pagination through a set of `JobOwner`. */
  owners: JobOwnersConnection;
  /** Reads a single `Pipeline` that is related to this `Job`. */
  pipeline?: Maybe<Pipeline>;
  pipelineId: Scalars['Int']['output'];
  /** Reads and enables pagination through a set of `PipelineStage`. */
  pipelineStages: JobPipelineStagesByJobsApplicationJobIdAndPipelineStageIdManyToManyConnection;
  position: Scalars['Int']['output'];
  publishedAt?: Maybe<Scalars['Datetime']['output']>;
  /** Reads and enables pagination through a set of `Questionnaire`. */
  questionnaires: JobQuestionnairesByJobQuestionnaireJobIdAndQuestionnaireIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Skill`. */
  skills: JobSkillsByJobSkillJobIdAndSkillIdManyToManyConnection;
  state?: Maybe<Scalars['Int']['output']>;
  status: JobStatus;
  /** Reads and enables pagination through a set of `Tag`. */
  tags: JobTagsByJobTagJobIdAndTagIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Thread`. */
  threads: ThreadsConnection;
  /** Reads and enables pagination through a set of `JobTranslation`. */
  translations: JobTranslationsConnection;
  updatedAt: Scalars['Datetime']['output'];
  /** Reads and enables pagination through a set of `User`. */
  users: JobUsersByJobOwnerJobIdAndUserIdManyToManyConnection;
  workExperienceCondition?: Maybe<Scalars['Int']['output']>;
};


export type JobApplicationsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<JobsApplicationCondition>;
  filter?: InputMaybe<JobsApplicationFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<JobsApplicationsOrderBy>>;
};


export type JobCandidatesArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<CandidateCondition>;
  filter?: InputMaybe<CandidateFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<CandidatesOrderBy>>;
};


export type JobCompaniesArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<CompanyCondition>;
  filter?: InputMaybe<CompanyFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<CompaniesOrderBy>>;
};


export type JobCompetenciesArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<CompetencyCondition>;
  filter?: InputMaybe<CompetencyFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<CompetenciesOrderBy>>;
};


export type JobDisqualifyReasonsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<DisqualifyReasonCondition>;
  filter?: InputMaybe<DisqualifyReasonFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<DisqualifyReasonsOrderBy>>;
};


export type JobDraftEvaluationsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<DraftEvaluationCondition>;
  filter?: InputMaybe<DraftEvaluationFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<DraftEvaluationsOrderBy>>;
};


export type JobEvaluationsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<EvaluationCondition>;
  filter?: InputMaybe<EvaluationFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<EvaluationsOrderBy>>;
};


export type JobFieldsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<FieldCondition>;
  filter?: InputMaybe<FieldFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<FieldsOrderBy>>;
};


export type JobJobCompetenciesArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<JobCompetencyCondition>;
  filter?: InputMaybe<JobCompetencyFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<JobCompetenciesOrderBy>>;
};


export type JobJobKnowledgesArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<JobKnowledgeCondition>;
  filter?: InputMaybe<JobKnowledgeFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<JobKnowledgesOrderBy>>;
};


export type JobJobQuestionnairesArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<JobQuestionnaireCondition>;
  filter?: InputMaybe<JobQuestionnaireFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<JobQuestionnairesOrderBy>>;
};


export type JobJobSkillsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<JobSkillCondition>;
  filter?: InputMaybe<JobSkillFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<JobSkillsOrderBy>>;
};


export type JobJobTagsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<JobTagCondition>;
  filter?: InputMaybe<JobTagFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<JobTagsOrderBy>>;
};


export type JobKnowledgesArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<KnowledgeCondition>;
  filter?: InputMaybe<KnowledgeFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<KnowledgesOrderBy>>;
};


export type JobOwnersArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<JobOwnerCondition>;
  filter?: InputMaybe<JobOwnerFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<JobOwnersOrderBy>>;
};


export type JobPipelineStagesArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<PipelineStageCondition>;
  filter?: InputMaybe<PipelineStageFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<PipelineStagesOrderBy>>;
};


export type JobQuestionnairesArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<QuestionnaireCondition>;
  filter?: InputMaybe<QuestionnaireFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<QuestionnairesOrderBy>>;
};


export type JobSkillsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<SkillCondition>;
  filter?: InputMaybe<SkillFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<SkillsOrderBy>>;
};


export type JobTagsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<TagCondition>;
  filter?: InputMaybe<TagFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<TagsOrderBy>>;
};


export type JobThreadsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<ThreadCondition>;
  filter?: InputMaybe<ThreadFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<ThreadsOrderBy>>;
};


export type JobTranslationsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<JobTranslationCondition>;
  filter?: InputMaybe<JobTranslationFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<JobTranslationsOrderBy>>;
};


export type JobUsersArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<UserCondition>;
  filter?: InputMaybe<UserFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<UsersOrderBy>>;
};

/** A connection to a list of `Candidate` values, with data from `JobsApplication`. */
export type JobCandidatesByJobsApplicationJobIdAndCandidateIdManyToManyConnection = {
  __typename?: 'JobCandidatesByJobsApplicationJobIdAndCandidateIdManyToManyConnection';
  /** A list of edges which contains the `Candidate`, info from the `JobsApplication`, and the cursor to aid in pagination. */
  edges: Array<JobCandidatesByJobsApplicationJobIdAndCandidateIdManyToManyEdge>;
  /** A list of `Candidate` objects. */
  nodes: Array<Candidate>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Candidate` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `Candidate` edge in the connection, with data from `JobsApplication`. */
export type JobCandidatesByJobsApplicationJobIdAndCandidateIdManyToManyEdge = {
  __typename?: 'JobCandidatesByJobsApplicationJobIdAndCandidateIdManyToManyEdge';
  coverLetter?: Maybe<Scalars['String']['output']>;
  createdAt: Scalars['Datetime']['output'];
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  disqualifiedAt?: Maybe<Scalars['Datetime']['output']>;
  disqualifyReasonId?: Maybe<Scalars['Int']['output']>;
  evaluation?: Maybe<Scalars['Int']['output']>;
  id: Scalars['Int']['output'];
  /** The `Candidate` at the end of the edge. */
  node: Candidate;
  pipelineStageId: Scalars['Int']['output'];
  previousId: Scalars['Int']['output'];
  updatedAt: Scalars['Datetime']['output'];
};

/** A connection to a list of `Company` values, with data from `DraftEvaluation`. */
export type JobCompaniesByDraftEvaluationJobIdAndCompanyIdManyToManyConnection = {
  __typename?: 'JobCompaniesByDraftEvaluationJobIdAndCompanyIdManyToManyConnection';
  /** A list of edges which contains the `Company`, info from the `DraftEvaluation`, and the cursor to aid in pagination. */
  edges: Array<JobCompaniesByDraftEvaluationJobIdAndCompanyIdManyToManyEdge>;
  /** A list of `Company` objects. */
  nodes: Array<Company>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Company` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `Company` edge in the connection, with data from `DraftEvaluation`. */
export type JobCompaniesByDraftEvaluationJobIdAndCompanyIdManyToManyEdge = {
  __typename?: 'JobCompaniesByDraftEvaluationJobIdAndCompanyIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** Reads and enables pagination through a set of `DraftEvaluation`. */
  draftEvaluations: DraftEvaluationsConnection;
  /** The `Company` at the end of the edge. */
  node: Company;
};


/** A `Company` edge in the connection, with data from `DraftEvaluation`. */
export type JobCompaniesByDraftEvaluationJobIdAndCompanyIdManyToManyEdgeDraftEvaluationsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<DraftEvaluationCondition>;
  filter?: InputMaybe<DraftEvaluationFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<DraftEvaluationsOrderBy>>;
};

/** A connection to a list of `Competency` values, with data from `JobCompetency`. */
export type JobCompetenciesByJobCompetencyJobIdAndCompetenceIdManyToManyConnection = {
  __typename?: 'JobCompetenciesByJobCompetencyJobIdAndCompetenceIdManyToManyConnection';
  /** A list of edges which contains the `Competency`, info from the `JobCompetency`, and the cursor to aid in pagination. */
  edges: Array<JobCompetenciesByJobCompetencyJobIdAndCompetenceIdManyToManyEdge>;
  /** A list of `Competency` objects. */
  nodes: Array<Competency>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Competency` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `Competency` edge in the connection, with data from `JobCompetency`. */
export type JobCompetenciesByJobCompetencyJobIdAndCompetenceIdManyToManyEdge = {
  __typename?: 'JobCompetenciesByJobCompetencyJobIdAndCompetenceIdManyToManyEdge';
  createdAt: Scalars['Datetime']['output'];
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Competency` at the end of the edge. */
  node: Competency;
};

/** The `competency` to be created by this mutation. */
export type JobCompetenciesCompetenceIdFkeyCompetenciesCreateInput = {
  jobCompetencies?: InputMaybe<JobCompetenciesCompetenceIdFkeyInverseInput>;
  title: Scalars['String']['input'];
};

/** Input for the nested mutation of `competency` in the `JobCompetencyInput` mutation. */
export type JobCompetenciesCompetenceIdFkeyInput = {
  /** The primary key(s) for `competency` for the far side of the relationship. */
  connectById?: InputMaybe<CompetencyCompetenciesPkeyConnect>;
  /** The primary key(s) for `competency` for the far side of the relationship. */
  connectByNodeId?: InputMaybe<CompetencyNodeIdConnect>;
  /** A `CompetencyInput` object that will be created and connected to this object. */
  create?: InputMaybe<JobCompetenciesCompetenceIdFkeyCompetenciesCreateInput>;
  /** The primary key(s) and patch data for `competency` for the far side of the relationship. */
  updateById?: InputMaybe<CompetencyOnJobCompetencyForJobCompetenciesCompetenceIdFkeyUsingCompetenciesPkeyUpdate>;
  /** The primary key(s) and patch data for `competency` for the far side of the relationship. */
  updateByNodeId?: InputMaybe<JobCompetencyOnJobCompetencyForJobCompetenciesCompetenceIdFkeyNodeIdUpdate>;
};

/** Input for the nested mutation of `jobCompetency` in the `CompetencyInput` mutation. */
export type JobCompetenciesCompetenceIdFkeyInverseInput = {
  /** The primary key(s) for `jobCompetency` for the far side of the relationship. */
  connectByCompetenceIdAndJobId?: InputMaybe<Array<JobCompetencyJobCompetenciesPkeyConnect>>;
  /** The primary key(s) for `jobCompetency` for the far side of the relationship. */
  connectByNodeId?: InputMaybe<Array<JobCompetencyNodeIdConnect>>;
  /** A `JobCompetencyInput` object that will be created and connected to this object. */
  create?: InputMaybe<Array<JobCompetenciesCompetenceIdFkeyJobCompetenciesCreateInput>>;
  /** The primary key(s) for `jobCompetency` for the far side of the relationship. */
  deleteByCompetenceIdAndJobId?: InputMaybe<Array<JobCompetencyJobCompetenciesPkeyDelete>>;
  /** The primary key(s) for `jobCompetency` for the far side of the relationship. */
  deleteByNodeId?: InputMaybe<Array<JobCompetencyNodeIdDelete>>;
  /** Flag indicating whether all other `jobCompetency` records that match this relationship should be removed. */
  deleteOthers?: InputMaybe<Scalars['Boolean']['input']>;
  /** The primary key(s) and patch data for `jobCompetency` for the far side of the relationship. */
  updateByCompetenceIdAndJobId?: InputMaybe<Array<JobCompetencyOnJobCompetencyForJobCompetenciesCompetenceIdFkeyUsingJobCompetenciesPkeyUpdate>>;
  /** The primary key(s) and patch data for `jobCompetency` for the far side of the relationship. */
  updateByNodeId?: InputMaybe<Array<CompetencyOnJobCompetencyForJobCompetenciesCompetenceIdFkeyNodeIdUpdate>>;
};

/** The `jobCompetency` to be created by this mutation. */
export type JobCompetenciesCompetenceIdFkeyJobCompetenciesCreateInput = {
  competency?: InputMaybe<JobCompetenciesCompetenceIdFkeyInput>;
  job?: InputMaybe<JobCompetenciesJobIdFkeyInput>;
  jobId?: InputMaybe<Scalars['Int']['input']>;
};

/** A connection to a list of `JobCompetency` values. */
export type JobCompetenciesConnection = {
  __typename?: 'JobCompetenciesConnection';
  /** A list of edges which contains the `JobCompetency` and cursor to aid in pagination. */
  edges: Array<JobCompetenciesEdge>;
  /** A list of `JobCompetency` objects. */
  nodes: Array<JobCompetency>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `JobCompetency` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `JobCompetency` edge in the connection. */
export type JobCompetenciesEdge = {
  __typename?: 'JobCompetenciesEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `JobCompetency` at the end of the edge. */
  node: JobCompetency;
};

/** Input for the nested mutation of `job` in the `JobCompetencyInput` mutation. */
export type JobCompetenciesJobIdFkeyInput = {
  /** The primary key(s) for `job` for the far side of the relationship. */
  connectById?: InputMaybe<JobJobsPkeyConnect>;
  /** The primary key(s) for `job` for the far side of the relationship. */
  connectByNodeId?: InputMaybe<JobNodeIdConnect>;
  /** A `JobInput` object that will be created and connected to this object. */
  create?: InputMaybe<JobCompetenciesJobIdFkeyJobsCreateInput>;
  /** The primary key(s) and patch data for `job` for the far side of the relationship. */
  updateById?: InputMaybe<JobOnJobCompetencyForJobCompetenciesJobIdFkeyUsingJobsPkeyUpdate>;
  /** The primary key(s) and patch data for `job` for the far side of the relationship. */
  updateByNodeId?: InputMaybe<JobCompetencyOnJobCompetencyForJobCompetenciesJobIdFkeyNodeIdUpdate>;
};

/** Input for the nested mutation of `jobCompetency` in the `JobInput` mutation. */
export type JobCompetenciesJobIdFkeyInverseInput = {
  /** The primary key(s) for `jobCompetency` for the far side of the relationship. */
  connectByCompetenceIdAndJobId?: InputMaybe<Array<JobCompetencyJobCompetenciesPkeyConnect>>;
  /** The primary key(s) for `jobCompetency` for the far side of the relationship. */
  connectByNodeId?: InputMaybe<Array<JobCompetencyNodeIdConnect>>;
  /** A `JobCompetencyInput` object that will be created and connected to this object. */
  create?: InputMaybe<Array<JobCompetenciesJobIdFkeyJobCompetenciesCreateInput>>;
  /** The primary key(s) for `jobCompetency` for the far side of the relationship. */
  deleteByCompetenceIdAndJobId?: InputMaybe<Array<JobCompetencyJobCompetenciesPkeyDelete>>;
  /** The primary key(s) for `jobCompetency` for the far side of the relationship. */
  deleteByNodeId?: InputMaybe<Array<JobCompetencyNodeIdDelete>>;
  /** Flag indicating whether all other `jobCompetency` records that match this relationship should be removed. */
  deleteOthers?: InputMaybe<Scalars['Boolean']['input']>;
  /** The primary key(s) and patch data for `jobCompetency` for the far side of the relationship. */
  updateByCompetenceIdAndJobId?: InputMaybe<Array<JobCompetencyOnJobCompetencyForJobCompetenciesJobIdFkeyUsingJobCompetenciesPkeyUpdate>>;
  /** The primary key(s) and patch data for `jobCompetency` for the far side of the relationship. */
  updateByNodeId?: InputMaybe<Array<JobOnJobCompetencyForJobCompetenciesJobIdFkeyNodeIdUpdate>>;
};

/** The `jobCompetency` to be created by this mutation. */
export type JobCompetenciesJobIdFkeyJobCompetenciesCreateInput = {
  competenceId?: InputMaybe<Scalars['Int']['input']>;
  competency?: InputMaybe<JobCompetenciesCompetenceIdFkeyInput>;
  job?: InputMaybe<JobCompetenciesJobIdFkeyInput>;
};

/** The `job` to be created by this mutation. */
export type JobCompetenciesJobIdFkeyJobsCreateInput = {
  address?: InputMaybe<Scalars['String']['input']>;
  applications?: InputMaybe<JobsApplicationsJobIdFkeyInverseInput>;
  city?: InputMaybe<Scalars['String']['input']>;
  competencies?: InputMaybe<Array<Scalars['String']['input']>>;
  country?: InputMaybe<Scalars['Int']['input']>;
  department?: InputMaybe<JobsDepartmentIdFkeyInput>;
  departmentId?: InputMaybe<Scalars['Int']['input']>;
  draftEvaluations?: InputMaybe<DraftEvaluationsJobIdFkeyInverseInput>;
  education?: InputMaybe<JobEducation>;
  evaluations?: InputMaybe<EvaluationsJobIdFkeyInverseInput>;
  fields?: InputMaybe<JobFieldsJobIdFkeyInverseInput>;
  genders?: InputMaybe<Array<InputMaybe<Gender>>>;
  gradeConditions?: InputMaybe<Array<InputMaybe<GradeCondition>>>;
  hoursPerWeek?: InputMaybe<IntRangeInput>;
  isRemote?: InputMaybe<Scalars['Boolean']['input']>;
  jobCompetencies?: InputMaybe<JobCompetenciesJobIdFkeyInverseInput>;
  jobKnowledges?: InputMaybe<JobKnowledgesJobIdFkeyInverseInput>;
  jobQuestionnaires?: InputMaybe<JobQuestionnairesJobIdFkeyInverseInput>;
  jobSkills?: InputMaybe<JobSkillsJobIdFkeyInverseInput>;
  jobTags?: InputMaybe<JobTagsJobIdFkeyInverseInput>;
  knowledges?: InputMaybe<Array<Scalars['String']['input']>>;
  languages: Array<InputMaybe<Language>>;
  maxAgeCondition?: InputMaybe<Scalars['Int']['input']>;
  militaryStatus?: InputMaybe<Array<InputMaybe<MilitaryStatus>>>;
  minAgeCondition?: InputMaybe<Scalars['Int']['input']>;
  owners?: InputMaybe<JobOwnersJobIdFkeyInverseInput>;
  pipeline?: InputMaybe<JobsPipelineIdFkeyInput>;
  pipelineId?: InputMaybe<Scalars['Int']['input']>;
  position: Scalars['Int']['input'];
  publishedAt?: InputMaybe<Scalars['Datetime']['input']>;
  skills?: InputMaybe<Array<Scalars['String']['input']>>;
  state?: InputMaybe<Scalars['Int']['input']>;
  status: JobStatus;
  tags?: InputMaybe<Array<Scalars['String']['input']>>;
  threads?: InputMaybe<ThreadsJobIdFkeyInverseInput>;
  translations?: InputMaybe<JobTranslationsJobIdFkeyInverseInput>;
  workExperienceCondition?: InputMaybe<Scalars['Int']['input']>;
};

/** Methods to use when ordering `JobCompetency`. */
export enum JobCompetenciesOrderBy {
  CompetenceIdAsc = 'COMPETENCE_ID_ASC',
  CompetenceIdDesc = 'COMPETENCE_ID_DESC',
  JobIdAsc = 'JOB_ID_ASC',
  JobIdDesc = 'JOB_ID_DESC',
  Natural = 'NATURAL',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC'
}

export type JobCompetency = Node & {
  __typename?: 'JobCompetency';
  /** Reads a single `Competency` that is related to this `JobCompetency`. */
  competence?: Maybe<Competency>;
  competenceId: Scalars['Int']['output'];
  createdAt: Scalars['Datetime']['output'];
  /** Reads a single `Job` that is related to this `JobCompetency`. */
  job?: Maybe<Job>;
  jobId: Scalars['Int']['output'];
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
};

/** A condition to be used against `JobCompetency` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type JobCompetencyCondition = {
  /** Checks for equality with the object’s `competenceId` field. */
  competenceId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `jobId` field. */
  jobId?: InputMaybe<Scalars['Int']['input']>;
};

/** A filter to be used against `JobCompetency` object types. All fields are combined with a logical ‘and.’ */
export type JobCompetencyFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<JobCompetencyFilter>>;
  /** Filter by the object’s `competence` relation. */
  competence?: InputMaybe<CompetencyFilter>;
  /** Filter by the object’s `competenceId` field. */
  competenceId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `job` relation. */
  job?: InputMaybe<JobFilter>;
  /** Filter by the object’s `jobId` field. */
  jobId?: InputMaybe<IntFilter>;
  /** Negates the expression. */
  not?: InputMaybe<JobCompetencyFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<JobCompetencyFilter>>;
};

/** An input for mutations affecting `JobCompetency` */
export type JobCompetencyInput = {
  competenceId?: InputMaybe<Scalars['Int']['input']>;
  competency?: InputMaybe<JobCompetenciesCompetenceIdFkeyInput>;
  job?: InputMaybe<JobCompetenciesJobIdFkeyInput>;
  jobId?: InputMaybe<Scalars['Int']['input']>;
};

/** The fields on `jobCompetency` to look up the row to connect. */
export type JobCompetencyJobCompetenciesPkeyConnect = {
  competenceId: Scalars['Int']['input'];
  jobId: Scalars['Int']['input'];
};

/** The fields on `jobCompetency` to look up the row to delete. */
export type JobCompetencyJobCompetenciesPkeyDelete = {
  competenceId: Scalars['Int']['input'];
  jobId: Scalars['Int']['input'];
};

/** The globally unique `ID` look up for the row to connect. */
export type JobCompetencyNodeIdConnect = {
  /** The globally unique `ID` which identifies a single `jobCompetency` to be connected. */
  nodeId: Scalars['ID']['input'];
};

/** The globally unique `ID` look up for the row to delete. */
export type JobCompetencyNodeIdDelete = {
  /** The globally unique `ID` which identifies a single `jobCompetency` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** The globally unique `ID` look up for the row to update. */
export type JobCompetencyOnJobCompetencyForJobCompetenciesCompetenceIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `competency` to be connected. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `competency` being updated. */
  patch: CompetencyPatch;
};

/** The fields on `jobCompetency` to look up the row to update. */
export type JobCompetencyOnJobCompetencyForJobCompetenciesCompetenceIdFkeyUsingJobCompetenciesPkeyUpdate = {
  competenceId: Scalars['Int']['input'];
  jobId: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `jobCompetency` being updated. */
  patch: UpdateJobCompetencyOnJobCompetencyForJobCompetenciesCompetenceIdFkeyPatch;
};

/** The globally unique `ID` look up for the row to update. */
export type JobCompetencyOnJobCompetencyForJobCompetenciesJobIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `job` to be connected. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `job` being updated. */
  patch: JobPatch;
};

/** The fields on `jobCompetency` to look up the row to update. */
export type JobCompetencyOnJobCompetencyForJobCompetenciesJobIdFkeyUsingJobCompetenciesPkeyUpdate = {
  competenceId: Scalars['Int']['input'];
  jobId: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `jobCompetency` being updated. */
  patch: UpdateJobCompetencyOnJobCompetencyForJobCompetenciesJobIdFkeyPatch;
};

/** Represents an update to a `JobCompetency`. Fields that are set will be updated. */
export type JobCompetencyPatch = {
  competenceId?: InputMaybe<Scalars['Int']['input']>;
  competency?: InputMaybe<JobCompetenciesCompetenceIdFkeyInput>;
  job?: InputMaybe<JobCompetenciesJobIdFkeyInput>;
  jobId?: InputMaybe<Scalars['Int']['input']>;
};

/** A condition to be used against `Job` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type JobCondition = {
  /** Checks for equality with the object’s `createdAt` field. */
  createdAt?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `departmentId` field. */
  departmentId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `maxAgeCondition` field. */
  maxAgeCondition?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `minAgeCondition` field. */
  minAgeCondition?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `pipelineId` field. */
  pipelineId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `status` field. */
  status?: InputMaybe<JobStatus>;
  /** Checks for equality with the object’s `updatedAt` field. */
  updatedAt?: InputMaybe<Scalars['Datetime']['input']>;
};

/** A connection to a list of `DisqualifyReason` values, with data from `JobsApplication`. */
export type JobDisqualifyReasonsByJobsApplicationJobIdAndDisqualifyReasonIdManyToManyConnection = {
  __typename?: 'JobDisqualifyReasonsByJobsApplicationJobIdAndDisqualifyReasonIdManyToManyConnection';
  /** A list of edges which contains the `DisqualifyReason`, info from the `JobsApplication`, and the cursor to aid in pagination. */
  edges: Array<JobDisqualifyReasonsByJobsApplicationJobIdAndDisqualifyReasonIdManyToManyEdge>;
  /** A list of `DisqualifyReason` objects. */
  nodes: Array<DisqualifyReason>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `DisqualifyReason` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `DisqualifyReason` edge in the connection, with data from `JobsApplication`. */
export type JobDisqualifyReasonsByJobsApplicationJobIdAndDisqualifyReasonIdManyToManyEdge = {
  __typename?: 'JobDisqualifyReasonsByJobsApplicationJobIdAndDisqualifyReasonIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** Reads and enables pagination through a set of `JobsApplication`. */
  jobsApplications: JobsApplicationsConnection;
  /** The `DisqualifyReason` at the end of the edge. */
  node: DisqualifyReason;
};


/** A `DisqualifyReason` edge in the connection, with data from `JobsApplication`. */
export type JobDisqualifyReasonsByJobsApplicationJobIdAndDisqualifyReasonIdManyToManyEdgeJobsApplicationsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<JobsApplicationCondition>;
  filter?: InputMaybe<JobsApplicationFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<JobsApplicationsOrderBy>>;
};

export enum JobEducation {
  Associate = 'ASSOCIATE',
  Bachelor = 'BACHELOR',
  Diploma = 'DIPLOMA',
  Master = 'MASTER',
  Phd = 'PHD'
}

export enum JobField {
  Address = 'ADDRESS',
  Birthday = 'BIRTHDAY',
  CoverLetter = 'COVER_LETTER',
  Gender = 'GENDER',
  MilitaryStatus = 'MILITARY_STATUS',
  Resume = 'RESUME'
}

/** Input for the nested mutation of `job` in the `FieldInput` mutation. */
export type JobFieldsJobIdFkeyInput = {
  /** The primary key(s) for `job` for the far side of the relationship. */
  connectById?: InputMaybe<JobJobsPkeyConnect>;
  /** The primary key(s) for `job` for the far side of the relationship. */
  connectByNodeId?: InputMaybe<JobNodeIdConnect>;
  /** A `JobInput` object that will be created and connected to this object. */
  create?: InputMaybe<JobFieldsJobIdFkeyJobsCreateInput>;
  /** The primary key(s) and patch data for `job` for the far side of the relationship. */
  updateById?: InputMaybe<JobOnFieldForJobFieldsJobIdFkeyUsingJobsPkeyUpdate>;
  /** The primary key(s) and patch data for `job` for the far side of the relationship. */
  updateByNodeId?: InputMaybe<FieldOnFieldForJobFieldsJobIdFkeyNodeIdUpdate>;
};

/** Input for the nested mutation of `field` in the `JobInput` mutation. */
export type JobFieldsJobIdFkeyInverseInput = {
  /** The primary key(s) for `field` for the far side of the relationship. */
  connectById?: InputMaybe<Array<FieldJobFieldsPkeyConnect>>;
  /** The primary key(s) for `field` for the far side of the relationship. */
  connectByNodeId?: InputMaybe<Array<FieldNodeIdConnect>>;
  /** A `FieldInput` object that will be created and connected to this object. */
  create?: InputMaybe<Array<JobFieldsJobIdFkeyJobFieldsCreateInput>>;
  /** The primary key(s) for `field` for the far side of the relationship. */
  deleteById?: InputMaybe<Array<FieldJobFieldsPkeyDelete>>;
  /** The primary key(s) for `field` for the far side of the relationship. */
  deleteByNodeId?: InputMaybe<Array<FieldNodeIdDelete>>;
  /** Flag indicating whether all other `field` records that match this relationship should be removed. */
  deleteOthers?: InputMaybe<Scalars['Boolean']['input']>;
  /** The primary key(s) and patch data for `field` for the far side of the relationship. */
  updateById?: InputMaybe<Array<FieldOnFieldForJobFieldsJobIdFkeyUsingJobFieldsPkeyUpdate>>;
  /** The primary key(s) and patch data for `field` for the far side of the relationship. */
  updateByNodeId?: InputMaybe<Array<JobOnFieldForJobFieldsJobIdFkeyNodeIdUpdate>>;
};

/** The `field` to be created by this mutation. */
export type JobFieldsJobIdFkeyJobFieldsCreateInput = {
  job?: InputMaybe<JobFieldsJobIdFkeyInput>;
  position: Scalars['Int']['input'];
  required: Scalars['Boolean']['input'];
  type: JobField;
};

/** The `job` to be created by this mutation. */
export type JobFieldsJobIdFkeyJobsCreateInput = {
  address?: InputMaybe<Scalars['String']['input']>;
  applications?: InputMaybe<JobsApplicationsJobIdFkeyInverseInput>;
  city?: InputMaybe<Scalars['String']['input']>;
  competencies?: InputMaybe<Array<Scalars['String']['input']>>;
  country?: InputMaybe<Scalars['Int']['input']>;
  department?: InputMaybe<JobsDepartmentIdFkeyInput>;
  departmentId?: InputMaybe<Scalars['Int']['input']>;
  draftEvaluations?: InputMaybe<DraftEvaluationsJobIdFkeyInverseInput>;
  education?: InputMaybe<JobEducation>;
  evaluations?: InputMaybe<EvaluationsJobIdFkeyInverseInput>;
  fields?: InputMaybe<JobFieldsJobIdFkeyInverseInput>;
  genders?: InputMaybe<Array<InputMaybe<Gender>>>;
  gradeConditions?: InputMaybe<Array<InputMaybe<GradeCondition>>>;
  hoursPerWeek?: InputMaybe<IntRangeInput>;
  isRemote?: InputMaybe<Scalars['Boolean']['input']>;
  jobCompetencies?: InputMaybe<JobCompetenciesJobIdFkeyInverseInput>;
  jobKnowledges?: InputMaybe<JobKnowledgesJobIdFkeyInverseInput>;
  jobQuestionnaires?: InputMaybe<JobQuestionnairesJobIdFkeyInverseInput>;
  jobSkills?: InputMaybe<JobSkillsJobIdFkeyInverseInput>;
  jobTags?: InputMaybe<JobTagsJobIdFkeyInverseInput>;
  knowledges?: InputMaybe<Array<Scalars['String']['input']>>;
  languages: Array<InputMaybe<Language>>;
  maxAgeCondition?: InputMaybe<Scalars['Int']['input']>;
  militaryStatus?: InputMaybe<Array<InputMaybe<MilitaryStatus>>>;
  minAgeCondition?: InputMaybe<Scalars['Int']['input']>;
  owners?: InputMaybe<JobOwnersJobIdFkeyInverseInput>;
  pipeline?: InputMaybe<JobsPipelineIdFkeyInput>;
  pipelineId?: InputMaybe<Scalars['Int']['input']>;
  position: Scalars['Int']['input'];
  publishedAt?: InputMaybe<Scalars['Datetime']['input']>;
  skills?: InputMaybe<Array<Scalars['String']['input']>>;
  state?: InputMaybe<Scalars['Int']['input']>;
  status: JobStatus;
  tags?: InputMaybe<Array<Scalars['String']['input']>>;
  threads?: InputMaybe<ThreadsJobIdFkeyInverseInput>;
  translations?: InputMaybe<JobTranslationsJobIdFkeyInverseInput>;
  workExperienceCondition?: InputMaybe<Scalars['Int']['input']>;
};

/** A filter to be used against `Job` object types. All fields are combined with a logical ‘and.’ */
export type JobFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<JobFilter>>;
  /** Filter by the object’s `applications` relation. */
  applications?: InputMaybe<JobToManyJobsApplicationFilter>;
  /** Some related `applications` exist. */
  applicationsExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `canManageCandidates` field. */
  canManageCandidates?: InputMaybe<BooleanFilter>;
  /** Filter by the object’s `createdAt` field. */
  createdAt?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `department` relation. */
  department?: InputMaybe<DepartmentFilter>;
  /** A related `department` exists. */
  departmentExists?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `departmentId` field. */
  departmentId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `draftEvaluations` relation. */
  draftEvaluations?: InputMaybe<JobToManyDraftEvaluationFilter>;
  /** Some related `draftEvaluations` exist. */
  draftEvaluationsExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `evaluations` relation. */
  evaluations?: InputMaybe<JobToManyEvaluationFilter>;
  /** Some related `evaluations` exist. */
  evaluationsExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `fields` relation. */
  fields?: InputMaybe<JobToManyFieldFilter>;
  /** Some related `fields` exist. */
  fieldsExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<IntFilter>;
  /** Filter by the object’s `jobCompetencies` relation. */
  jobCompetencies?: InputMaybe<JobToManyJobCompetencyFilter>;
  /** Some related `jobCompetencies` exist. */
  jobCompetenciesExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `jobKnowledges` relation. */
  jobKnowledges?: InputMaybe<JobToManyJobKnowledgeFilter>;
  /** Some related `jobKnowledges` exist. */
  jobKnowledgesExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `jobQuestionnaires` relation. */
  jobQuestionnaires?: InputMaybe<JobToManyJobQuestionnaireFilter>;
  /** Some related `jobQuestionnaires` exist. */
  jobQuestionnairesExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `jobSkills` relation. */
  jobSkills?: InputMaybe<JobToManyJobSkillFilter>;
  /** Some related `jobSkills` exist. */
  jobSkillsExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `jobTags` relation. */
  jobTags?: InputMaybe<JobToManyJobTagFilter>;
  /** Some related `jobTags` exist. */
  jobTagsExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `maxAgeCondition` field. */
  maxAgeCondition?: InputMaybe<IntFilter>;
  /** Filter by the object’s `minAgeCondition` field. */
  minAgeCondition?: InputMaybe<IntFilter>;
  /** Negates the expression. */
  not?: InputMaybe<JobFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<JobFilter>>;
  /** Filter by the object’s `owners` relation. */
  owners?: InputMaybe<JobToManyJobOwnerFilter>;
  /** Some related `owners` exist. */
  ownersExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `pipeline` relation. */
  pipeline?: InputMaybe<PipelineFilter>;
  /** Filter by the object’s `pipelineId` field. */
  pipelineId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `status` field. */
  status?: InputMaybe<JobStatusFilter>;
  /** Filter by the object’s `threads` relation. */
  threads?: InputMaybe<JobToManyThreadFilter>;
  /** Some related `threads` exist. */
  threadsExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `translations` relation. */
  translations?: InputMaybe<JobToManyJobTranslationFilter>;
  /** Some related `translations` exist. */
  translationsExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `updatedAt` field. */
  updatedAt?: InputMaybe<DatetimeFilter>;
};

/** An input for mutations affecting `Job` */
export type JobInput = {
  address?: InputMaybe<Scalars['String']['input']>;
  applications?: InputMaybe<JobsApplicationsJobIdFkeyInverseInput>;
  city?: InputMaybe<Scalars['String']['input']>;
  competencies?: InputMaybe<Array<Scalars['String']['input']>>;
  country?: InputMaybe<Scalars['Int']['input']>;
  department?: InputMaybe<JobsDepartmentIdFkeyInput>;
  departmentId?: InputMaybe<Scalars['Int']['input']>;
  draftEvaluations?: InputMaybe<DraftEvaluationsJobIdFkeyInverseInput>;
  education?: InputMaybe<JobEducation>;
  evaluations?: InputMaybe<EvaluationsJobIdFkeyInverseInput>;
  fields?: InputMaybe<JobFieldsJobIdFkeyInverseInput>;
  genders?: InputMaybe<Array<InputMaybe<Gender>>>;
  gradeConditions?: InputMaybe<Array<InputMaybe<GradeCondition>>>;
  hoursPerWeek?: InputMaybe<IntRangeInput>;
  isRemote?: InputMaybe<Scalars['Boolean']['input']>;
  jobCompetencies?: InputMaybe<JobCompetenciesJobIdFkeyInverseInput>;
  jobKnowledges?: InputMaybe<JobKnowledgesJobIdFkeyInverseInput>;
  jobQuestionnaires?: InputMaybe<JobQuestionnairesJobIdFkeyInverseInput>;
  jobSkills?: InputMaybe<JobSkillsJobIdFkeyInverseInput>;
  jobTags?: InputMaybe<JobTagsJobIdFkeyInverseInput>;
  knowledges?: InputMaybe<Array<Scalars['String']['input']>>;
  languages: Array<InputMaybe<Language>>;
  maxAgeCondition?: InputMaybe<Scalars['Int']['input']>;
  militaryStatus?: InputMaybe<Array<InputMaybe<MilitaryStatus>>>;
  minAgeCondition?: InputMaybe<Scalars['Int']['input']>;
  owners?: InputMaybe<JobOwnersJobIdFkeyInverseInput>;
  pipeline?: InputMaybe<JobsPipelineIdFkeyInput>;
  pipelineId?: InputMaybe<Scalars['Int']['input']>;
  position: Scalars['Int']['input'];
  publishedAt?: InputMaybe<Scalars['Datetime']['input']>;
  skills?: InputMaybe<Array<Scalars['String']['input']>>;
  state?: InputMaybe<Scalars['Int']['input']>;
  status: JobStatus;
  tags?: InputMaybe<Array<Scalars['String']['input']>>;
  threads?: InputMaybe<ThreadsJobIdFkeyInverseInput>;
  translations?: InputMaybe<JobTranslationsJobIdFkeyInverseInput>;
  workExperienceCondition?: InputMaybe<Scalars['Int']['input']>;
};

/** The fields on `job` to look up the row to connect. */
export type JobJobsPkeyConnect = {
  id: Scalars['Int']['input'];
};

export type JobKnowledge = Node & {
  __typename?: 'JobKnowledge';
  createdAt: Scalars['Datetime']['output'];
  /** Reads a single `Job` that is related to this `JobKnowledge`. */
  job?: Maybe<Job>;
  jobId: Scalars['Int']['output'];
  /** Reads a single `Knowledge` that is related to this `JobKnowledge`. */
  knowledge?: Maybe<Knowledge>;
  knowledgeId: Scalars['Int']['output'];
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
};

/** A condition to be used against `JobKnowledge` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type JobKnowledgeCondition = {
  /** Checks for equality with the object’s `jobId` field. */
  jobId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `knowledgeId` field. */
  knowledgeId?: InputMaybe<Scalars['Int']['input']>;
};

/** A filter to be used against `JobKnowledge` object types. All fields are combined with a logical ‘and.’ */
export type JobKnowledgeFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<JobKnowledgeFilter>>;
  /** Filter by the object’s `job` relation. */
  job?: InputMaybe<JobFilter>;
  /** Filter by the object’s `jobId` field. */
  jobId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `knowledge` relation. */
  knowledge?: InputMaybe<KnowledgeFilter>;
  /** Filter by the object’s `knowledgeId` field. */
  knowledgeId?: InputMaybe<IntFilter>;
  /** Negates the expression. */
  not?: InputMaybe<JobKnowledgeFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<JobKnowledgeFilter>>;
};

/** An input for mutations affecting `JobKnowledge` */
export type JobKnowledgeInput = {
  job?: InputMaybe<JobKnowledgesJobIdFkeyInput>;
  jobId?: InputMaybe<Scalars['Int']['input']>;
  knowledge?: InputMaybe<JobKnowledgesKnowledgeIdFkeyInput>;
  knowledgeId?: InputMaybe<Scalars['Int']['input']>;
};

/** The fields on `jobKnowledge` to look up the row to connect. */
export type JobKnowledgeJobKnowledgesPkeyConnect = {
  jobId: Scalars['Int']['input'];
  knowledgeId: Scalars['Int']['input'];
};

/** The fields on `jobKnowledge` to look up the row to delete. */
export type JobKnowledgeJobKnowledgesPkeyDelete = {
  jobId: Scalars['Int']['input'];
  knowledgeId: Scalars['Int']['input'];
};

/** The globally unique `ID` look up for the row to connect. */
export type JobKnowledgeNodeIdConnect = {
  /** The globally unique `ID` which identifies a single `jobKnowledge` to be connected. */
  nodeId: Scalars['ID']['input'];
};

/** The globally unique `ID` look up for the row to delete. */
export type JobKnowledgeNodeIdDelete = {
  /** The globally unique `ID` which identifies a single `jobKnowledge` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** The globally unique `ID` look up for the row to update. */
export type JobKnowledgeOnJobKnowledgeForJobKnowledgesJobIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `job` to be connected. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `job` being updated. */
  patch: JobPatch;
};

/** The fields on `jobKnowledge` to look up the row to update. */
export type JobKnowledgeOnJobKnowledgeForJobKnowledgesJobIdFkeyUsingJobKnowledgesPkeyUpdate = {
  jobId: Scalars['Int']['input'];
  knowledgeId: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `jobKnowledge` being updated. */
  patch: UpdateJobKnowledgeOnJobKnowledgeForJobKnowledgesJobIdFkeyPatch;
};

/** The globally unique `ID` look up for the row to update. */
export type JobKnowledgeOnJobKnowledgeForJobKnowledgesKnowledgeIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `knowledge` to be connected. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `knowledge` being updated. */
  patch: KnowledgePatch;
};

/** The fields on `jobKnowledge` to look up the row to update. */
export type JobKnowledgeOnJobKnowledgeForJobKnowledgesKnowledgeIdFkeyUsingJobKnowledgesPkeyUpdate = {
  jobId: Scalars['Int']['input'];
  knowledgeId: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `jobKnowledge` being updated. */
  patch: UpdateJobKnowledgeOnJobKnowledgeForJobKnowledgesKnowledgeIdFkeyPatch;
};

/** Represents an update to a `JobKnowledge`. Fields that are set will be updated. */
export type JobKnowledgePatch = {
  job?: InputMaybe<JobKnowledgesJobIdFkeyInput>;
  jobId?: InputMaybe<Scalars['Int']['input']>;
  knowledge?: InputMaybe<JobKnowledgesKnowledgeIdFkeyInput>;
  knowledgeId?: InputMaybe<Scalars['Int']['input']>;
};

/** A connection to a list of `Knowledge` values, with data from `JobKnowledge`. */
export type JobKnowledgesByJobKnowledgeJobIdAndKnowledgeIdManyToManyConnection = {
  __typename?: 'JobKnowledgesByJobKnowledgeJobIdAndKnowledgeIdManyToManyConnection';
  /** A list of edges which contains the `Knowledge`, info from the `JobKnowledge`, and the cursor to aid in pagination. */
  edges: Array<JobKnowledgesByJobKnowledgeJobIdAndKnowledgeIdManyToManyEdge>;
  /** A list of `Knowledge` objects. */
  nodes: Array<Knowledge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Knowledge` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `Knowledge` edge in the connection, with data from `JobKnowledge`. */
export type JobKnowledgesByJobKnowledgeJobIdAndKnowledgeIdManyToManyEdge = {
  __typename?: 'JobKnowledgesByJobKnowledgeJobIdAndKnowledgeIdManyToManyEdge';
  createdAt: Scalars['Datetime']['output'];
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Knowledge` at the end of the edge. */
  node: Knowledge;
};

/** A connection to a list of `JobKnowledge` values. */
export type JobKnowledgesConnection = {
  __typename?: 'JobKnowledgesConnection';
  /** A list of edges which contains the `JobKnowledge` and cursor to aid in pagination. */
  edges: Array<JobKnowledgesEdge>;
  /** A list of `JobKnowledge` objects. */
  nodes: Array<JobKnowledge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `JobKnowledge` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `JobKnowledge` edge in the connection. */
export type JobKnowledgesEdge = {
  __typename?: 'JobKnowledgesEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `JobKnowledge` at the end of the edge. */
  node: JobKnowledge;
};

/** Input for the nested mutation of `job` in the `JobKnowledgeInput` mutation. */
export type JobKnowledgesJobIdFkeyInput = {
  /** The primary key(s) for `job` for the far side of the relationship. */
  connectById?: InputMaybe<JobJobsPkeyConnect>;
  /** The primary key(s) for `job` for the far side of the relationship. */
  connectByNodeId?: InputMaybe<JobNodeIdConnect>;
  /** A `JobInput` object that will be created and connected to this object. */
  create?: InputMaybe<JobKnowledgesJobIdFkeyJobsCreateInput>;
  /** The primary key(s) and patch data for `job` for the far side of the relationship. */
  updateById?: InputMaybe<JobOnJobKnowledgeForJobKnowledgesJobIdFkeyUsingJobsPkeyUpdate>;
  /** The primary key(s) and patch data for `job` for the far side of the relationship. */
  updateByNodeId?: InputMaybe<JobKnowledgeOnJobKnowledgeForJobKnowledgesJobIdFkeyNodeIdUpdate>;
};

/** Input for the nested mutation of `jobKnowledge` in the `JobInput` mutation. */
export type JobKnowledgesJobIdFkeyInverseInput = {
  /** The primary key(s) for `jobKnowledge` for the far side of the relationship. */
  connectByKnowledgeIdAndJobId?: InputMaybe<Array<JobKnowledgeJobKnowledgesPkeyConnect>>;
  /** The primary key(s) for `jobKnowledge` for the far side of the relationship. */
  connectByNodeId?: InputMaybe<Array<JobKnowledgeNodeIdConnect>>;
  /** A `JobKnowledgeInput` object that will be created and connected to this object. */
  create?: InputMaybe<Array<JobKnowledgesJobIdFkeyJobKnowledgesCreateInput>>;
  /** The primary key(s) for `jobKnowledge` for the far side of the relationship. */
  deleteByKnowledgeIdAndJobId?: InputMaybe<Array<JobKnowledgeJobKnowledgesPkeyDelete>>;
  /** The primary key(s) for `jobKnowledge` for the far side of the relationship. */
  deleteByNodeId?: InputMaybe<Array<JobKnowledgeNodeIdDelete>>;
  /** Flag indicating whether all other `jobKnowledge` records that match this relationship should be removed. */
  deleteOthers?: InputMaybe<Scalars['Boolean']['input']>;
  /** The primary key(s) and patch data for `jobKnowledge` for the far side of the relationship. */
  updateByKnowledgeIdAndJobId?: InputMaybe<Array<JobKnowledgeOnJobKnowledgeForJobKnowledgesJobIdFkeyUsingJobKnowledgesPkeyUpdate>>;
  /** The primary key(s) and patch data for `jobKnowledge` for the far side of the relationship. */
  updateByNodeId?: InputMaybe<Array<JobOnJobKnowledgeForJobKnowledgesJobIdFkeyNodeIdUpdate>>;
};

/** The `jobKnowledge` to be created by this mutation. */
export type JobKnowledgesJobIdFkeyJobKnowledgesCreateInput = {
  job?: InputMaybe<JobKnowledgesJobIdFkeyInput>;
  knowledge?: InputMaybe<JobKnowledgesKnowledgeIdFkeyInput>;
  knowledgeId?: InputMaybe<Scalars['Int']['input']>;
};

/** The `job` to be created by this mutation. */
export type JobKnowledgesJobIdFkeyJobsCreateInput = {
  address?: InputMaybe<Scalars['String']['input']>;
  applications?: InputMaybe<JobsApplicationsJobIdFkeyInverseInput>;
  city?: InputMaybe<Scalars['String']['input']>;
  competencies?: InputMaybe<Array<Scalars['String']['input']>>;
  country?: InputMaybe<Scalars['Int']['input']>;
  department?: InputMaybe<JobsDepartmentIdFkeyInput>;
  departmentId?: InputMaybe<Scalars['Int']['input']>;
  draftEvaluations?: InputMaybe<DraftEvaluationsJobIdFkeyInverseInput>;
  education?: InputMaybe<JobEducation>;
  evaluations?: InputMaybe<EvaluationsJobIdFkeyInverseInput>;
  fields?: InputMaybe<JobFieldsJobIdFkeyInverseInput>;
  genders?: InputMaybe<Array<InputMaybe<Gender>>>;
  gradeConditions?: InputMaybe<Array<InputMaybe<GradeCondition>>>;
  hoursPerWeek?: InputMaybe<IntRangeInput>;
  isRemote?: InputMaybe<Scalars['Boolean']['input']>;
  jobCompetencies?: InputMaybe<JobCompetenciesJobIdFkeyInverseInput>;
  jobKnowledges?: InputMaybe<JobKnowledgesJobIdFkeyInverseInput>;
  jobQuestionnaires?: InputMaybe<JobQuestionnairesJobIdFkeyInverseInput>;
  jobSkills?: InputMaybe<JobSkillsJobIdFkeyInverseInput>;
  jobTags?: InputMaybe<JobTagsJobIdFkeyInverseInput>;
  knowledges?: InputMaybe<Array<Scalars['String']['input']>>;
  languages: Array<InputMaybe<Language>>;
  maxAgeCondition?: InputMaybe<Scalars['Int']['input']>;
  militaryStatus?: InputMaybe<Array<InputMaybe<MilitaryStatus>>>;
  minAgeCondition?: InputMaybe<Scalars['Int']['input']>;
  owners?: InputMaybe<JobOwnersJobIdFkeyInverseInput>;
  pipeline?: InputMaybe<JobsPipelineIdFkeyInput>;
  pipelineId?: InputMaybe<Scalars['Int']['input']>;
  position: Scalars['Int']['input'];
  publishedAt?: InputMaybe<Scalars['Datetime']['input']>;
  skills?: InputMaybe<Array<Scalars['String']['input']>>;
  state?: InputMaybe<Scalars['Int']['input']>;
  status: JobStatus;
  tags?: InputMaybe<Array<Scalars['String']['input']>>;
  threads?: InputMaybe<ThreadsJobIdFkeyInverseInput>;
  translations?: InputMaybe<JobTranslationsJobIdFkeyInverseInput>;
  workExperienceCondition?: InputMaybe<Scalars['Int']['input']>;
};

/** Input for the nested mutation of `knowledge` in the `JobKnowledgeInput` mutation. */
export type JobKnowledgesKnowledgeIdFkeyInput = {
  /** The primary key(s) for `knowledge` for the far side of the relationship. */
  connectById?: InputMaybe<KnowledgeKnowledgesPkeyConnect>;
  /** The primary key(s) for `knowledge` for the far side of the relationship. */
  connectByNodeId?: InputMaybe<KnowledgeNodeIdConnect>;
  /** A `KnowledgeInput` object that will be created and connected to this object. */
  create?: InputMaybe<JobKnowledgesKnowledgeIdFkeyKnowledgesCreateInput>;
  /** The primary key(s) and patch data for `knowledge` for the far side of the relationship. */
  updateById?: InputMaybe<KnowledgeOnJobKnowledgeForJobKnowledgesKnowledgeIdFkeyUsingKnowledgesPkeyUpdate>;
  /** The primary key(s) and patch data for `knowledge` for the far side of the relationship. */
  updateByNodeId?: InputMaybe<JobKnowledgeOnJobKnowledgeForJobKnowledgesKnowledgeIdFkeyNodeIdUpdate>;
};

/** Input for the nested mutation of `jobKnowledge` in the `KnowledgeInput` mutation. */
export type JobKnowledgesKnowledgeIdFkeyInverseInput = {
  /** The primary key(s) for `jobKnowledge` for the far side of the relationship. */
  connectByKnowledgeIdAndJobId?: InputMaybe<Array<JobKnowledgeJobKnowledgesPkeyConnect>>;
  /** The primary key(s) for `jobKnowledge` for the far side of the relationship. */
  connectByNodeId?: InputMaybe<Array<JobKnowledgeNodeIdConnect>>;
  /** A `JobKnowledgeInput` object that will be created and connected to this object. */
  create?: InputMaybe<Array<JobKnowledgesKnowledgeIdFkeyJobKnowledgesCreateInput>>;
  /** The primary key(s) for `jobKnowledge` for the far side of the relationship. */
  deleteByKnowledgeIdAndJobId?: InputMaybe<Array<JobKnowledgeJobKnowledgesPkeyDelete>>;
  /** The primary key(s) for `jobKnowledge` for the far side of the relationship. */
  deleteByNodeId?: InputMaybe<Array<JobKnowledgeNodeIdDelete>>;
  /** Flag indicating whether all other `jobKnowledge` records that match this relationship should be removed. */
  deleteOthers?: InputMaybe<Scalars['Boolean']['input']>;
  /** The primary key(s) and patch data for `jobKnowledge` for the far side of the relationship. */
  updateByKnowledgeIdAndJobId?: InputMaybe<Array<JobKnowledgeOnJobKnowledgeForJobKnowledgesKnowledgeIdFkeyUsingJobKnowledgesPkeyUpdate>>;
  /** The primary key(s) and patch data for `jobKnowledge` for the far side of the relationship. */
  updateByNodeId?: InputMaybe<Array<KnowledgeOnJobKnowledgeForJobKnowledgesKnowledgeIdFkeyNodeIdUpdate>>;
};

/** The `jobKnowledge` to be created by this mutation. */
export type JobKnowledgesKnowledgeIdFkeyJobKnowledgesCreateInput = {
  job?: InputMaybe<JobKnowledgesJobIdFkeyInput>;
  jobId?: InputMaybe<Scalars['Int']['input']>;
  knowledge?: InputMaybe<JobKnowledgesKnowledgeIdFkeyInput>;
};

/** The `knowledge` to be created by this mutation. */
export type JobKnowledgesKnowledgeIdFkeyKnowledgesCreateInput = {
  jobKnowledges?: InputMaybe<JobKnowledgesKnowledgeIdFkeyInverseInput>;
  title: Scalars['String']['input'];
};

/** Methods to use when ordering `JobKnowledge`. */
export enum JobKnowledgesOrderBy {
  JobIdAsc = 'JOB_ID_ASC',
  JobIdDesc = 'JOB_ID_DESC',
  KnowledgeIdAsc = 'KNOWLEDGE_ID_ASC',
  KnowledgeIdDesc = 'KNOWLEDGE_ID_DESC',
  Natural = 'NATURAL',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC'
}

/** The globally unique `ID` look up for the row to connect. */
export type JobNodeIdConnect = {
  /** The globally unique `ID` which identifies a single `job` to be connected. */
  nodeId: Scalars['ID']['input'];
};

/** The globally unique `ID` look up for the row to update. */
export type JobOnDraftEvaluationForDraftEvaluationsJobIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `draftEvaluation` to be connected. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `draftEvaluation` being updated. */
  patch: DraftEvaluationPatch;
};

/** The fields on `job` to look up the row to update. */
export type JobOnDraftEvaluationForDraftEvaluationsJobIdFkeyUsingJobsPkeyUpdate = {
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `job` being updated. */
  patch: UpdateJobOnDraftEvaluationForDraftEvaluationsJobIdFkeyPatch;
};

/** The globally unique `ID` look up for the row to update. */
export type JobOnEvaluationForEvaluationsJobIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `evaluation` to be connected. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `evaluation` being updated. */
  patch: EvaluationPatch;
};

/** The fields on `job` to look up the row to update. */
export type JobOnEvaluationForEvaluationsJobIdFkeyUsingJobsPkeyUpdate = {
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `job` being updated. */
  patch: UpdateJobOnEvaluationForEvaluationsJobIdFkeyPatch;
};

/** The globally unique `ID` look up for the row to update. */
export type JobOnFieldForJobFieldsJobIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `field` to be connected. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `field` being updated. */
  patch: FieldPatch;
};

/** The fields on `job` to look up the row to update. */
export type JobOnFieldForJobFieldsJobIdFkeyUsingJobsPkeyUpdate = {
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `job` being updated. */
  patch: UpdateJobOnFieldForJobFieldsJobIdFkeyPatch;
};

/** The globally unique `ID` look up for the row to update. */
export type JobOnJobCompetencyForJobCompetenciesJobIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `jobCompetency` to be connected. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `jobCompetency` being updated. */
  patch: JobCompetencyPatch;
};

/** The fields on `job` to look up the row to update. */
export type JobOnJobCompetencyForJobCompetenciesJobIdFkeyUsingJobsPkeyUpdate = {
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `job` being updated. */
  patch: UpdateJobOnJobCompetencyForJobCompetenciesJobIdFkeyPatch;
};

/** The globally unique `ID` look up for the row to update. */
export type JobOnJobForJobsDepartmentIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `department` to be connected. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `department` being updated. */
  patch: DepartmentPatch;
};

/** The fields on `job` to look up the row to update. */
export type JobOnJobForJobsDepartmentIdFkeyUsingJobsPkeyUpdate = {
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `job` being updated. */
  patch: UpdateJobOnJobForJobsDepartmentIdFkeyPatch;
};

/** The globally unique `ID` look up for the row to update. */
export type JobOnJobForJobsPipelineIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `pipeline` to be connected. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `pipeline` being updated. */
  patch: PipelinePatch;
};

/** The fields on `job` to look up the row to update. */
export type JobOnJobForJobsPipelineIdFkeyUsingJobsPkeyUpdate = {
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `job` being updated. */
  patch: UpdateJobOnJobForJobsPipelineIdFkeyPatch;
};

/** The globally unique `ID` look up for the row to update. */
export type JobOnJobKnowledgeForJobKnowledgesJobIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `jobKnowledge` to be connected. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `jobKnowledge` being updated. */
  patch: JobKnowledgePatch;
};

/** The fields on `job` to look up the row to update. */
export type JobOnJobKnowledgeForJobKnowledgesJobIdFkeyUsingJobsPkeyUpdate = {
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `job` being updated. */
  patch: UpdateJobOnJobKnowledgeForJobKnowledgesJobIdFkeyPatch;
};

/** The globally unique `ID` look up for the row to update. */
export type JobOnJobOwnerForJobOwnersJobIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `jobOwner` to be connected. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `jobOwner` being updated. */
  patch: JobOwnerPatch;
};

/** The fields on `job` to look up the row to update. */
export type JobOnJobOwnerForJobOwnersJobIdFkeyUsingJobsPkeyUpdate = {
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `job` being updated. */
  patch: UpdateJobOnJobOwnerForJobOwnersJobIdFkeyPatch;
};

/** The globally unique `ID` look up for the row to update. */
export type JobOnJobQuestionnaireForJobQuestionnairesJobIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `jobQuestionnaire` to be connected. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `jobQuestionnaire` being updated. */
  patch: JobQuestionnairePatch;
};

/** The fields on `job` to look up the row to update. */
export type JobOnJobQuestionnaireForJobQuestionnairesJobIdFkeyUsingJobsPkeyUpdate = {
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `job` being updated. */
  patch: UpdateJobOnJobQuestionnaireForJobQuestionnairesJobIdFkeyPatch;
};

/** The globally unique `ID` look up for the row to update. */
export type JobOnJobSkillForJobSkillsJobIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `jobSkill` to be connected. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `jobSkill` being updated. */
  patch: JobSkillPatch;
};

/** The fields on `job` to look up the row to update. */
export type JobOnJobSkillForJobSkillsJobIdFkeyUsingJobsPkeyUpdate = {
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `job` being updated. */
  patch: UpdateJobOnJobSkillForJobSkillsJobIdFkeyPatch;
};

/** The globally unique `ID` look up for the row to update. */
export type JobOnJobTagForJobTagsJobIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `jobTag` to be connected. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `jobTag` being updated. */
  patch: JobTagPatch;
};

/** The fields on `job` to look up the row to update. */
export type JobOnJobTagForJobTagsJobIdFkeyUsingJobsPkeyUpdate = {
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `job` being updated. */
  patch: UpdateJobOnJobTagForJobTagsJobIdFkeyPatch;
};

/** The globally unique `ID` look up for the row to update. */
export type JobOnJobTranslationForJobTranslationsJobIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `jobTranslation` to be connected. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `jobTranslation` being updated. */
  patch: JobTranslationPatch;
};

/** The fields on `job` to look up the row to update. */
export type JobOnJobTranslationForJobTranslationsJobIdFkeyUsingJobsPkeyUpdate = {
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `job` being updated. */
  patch: UpdateJobOnJobTranslationForJobTranslationsJobIdFkeyPatch;
};

/** The globally unique `ID` look up for the row to update. */
export type JobOnJobsApplicationForJobsApplicationsJobIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `jobsApplication` to be connected. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `jobsApplication` being updated. */
  patch: JobsApplicationPatch;
};

/** The fields on `job` to look up the row to update. */
export type JobOnJobsApplicationForJobsApplicationsJobIdFkeyUsingJobsPkeyUpdate = {
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `job` being updated. */
  patch: UpdateJobOnJobsApplicationForJobsApplicationsJobIdFkeyPatch;
};

/** The globally unique `ID` look up for the row to update. */
export type JobOnThreadForThreadsJobIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `thread` to be connected. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `thread` being updated. */
  patch: ThreadPatch;
};

/** The fields on `job` to look up the row to update. */
export type JobOnThreadForThreadsJobIdFkeyUsingJobsPkeyUpdate = {
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `job` being updated. */
  patch: UpdateJobOnThreadForThreadsJobIdFkeyPatch;
};

export type JobOwner = Node & {
  __typename?: 'JobOwner';
  createdAt: Scalars['Datetime']['output'];
  /** Reads a single `Job` that is related to this `JobOwner`. */
  job?: Maybe<Job>;
  jobId: Scalars['Int']['output'];
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  /** Reads a single `User` that is related to this `JobOwner`. */
  user?: Maybe<User>;
  userId: Scalars['Int']['output'];
};

/** A condition to be used against `JobOwner` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type JobOwnerCondition = {
  /** Checks for equality with the object’s `jobId` field. */
  jobId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `userId` field. */
  userId?: InputMaybe<Scalars['Int']['input']>;
};

/** A filter to be used against `JobOwner` object types. All fields are combined with a logical ‘and.’ */
export type JobOwnerFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<JobOwnerFilter>>;
  /** Filter by the object’s `job` relation. */
  job?: InputMaybe<JobFilter>;
  /** Filter by the object’s `jobId` field. */
  jobId?: InputMaybe<IntFilter>;
  /** Negates the expression. */
  not?: InputMaybe<JobOwnerFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<JobOwnerFilter>>;
  /** Filter by the object’s `user` relation. */
  user?: InputMaybe<UserFilter>;
  /** Filter by the object’s `userId` field. */
  userId?: InputMaybe<IntFilter>;
};

/** An input for mutations affecting `JobOwner` */
export type JobOwnerInput = {
  job?: InputMaybe<JobOwnersJobIdFkeyInput>;
  jobId?: InputMaybe<Scalars['Int']['input']>;
  user?: InputMaybe<JobOwnersUserIdFkeyInput>;
  userId?: InputMaybe<Scalars['Int']['input']>;
};

/** The fields on `jobOwner` to look up the row to connect. */
export type JobOwnerJobOwnersPkeyConnect = {
  jobId: Scalars['Int']['input'];
  userId: Scalars['Int']['input'];
};

/** The fields on `jobOwner` to look up the row to delete. */
export type JobOwnerJobOwnersPkeyDelete = {
  jobId: Scalars['Int']['input'];
  userId: Scalars['Int']['input'];
};

/** The globally unique `ID` look up for the row to connect. */
export type JobOwnerNodeIdConnect = {
  /** The globally unique `ID` which identifies a single `jobOwner` to be connected. */
  nodeId: Scalars['ID']['input'];
};

/** The globally unique `ID` look up for the row to delete. */
export type JobOwnerNodeIdDelete = {
  /** The globally unique `ID` which identifies a single `jobOwner` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** The globally unique `ID` look up for the row to update. */
export type JobOwnerOnJobOwnerForJobOwnersJobIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `job` to be connected. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `job` being updated. */
  patch: JobPatch;
};

/** The fields on `jobOwner` to look up the row to update. */
export type JobOwnerOnJobOwnerForJobOwnersJobIdFkeyUsingJobOwnersPkeyUpdate = {
  jobId: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `jobOwner` being updated. */
  patch: UpdateJobOwnerOnJobOwnerForJobOwnersJobIdFkeyPatch;
  userId: Scalars['Int']['input'];
};

/** The globally unique `ID` look up for the row to update. */
export type JobOwnerOnJobOwnerForJobOwnersUserIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `user` to be connected. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `user` being updated. */
  patch: UserPatch;
};

/** The fields on `jobOwner` to look up the row to update. */
export type JobOwnerOnJobOwnerForJobOwnersUserIdFkeyUsingJobOwnersPkeyUpdate = {
  jobId: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `jobOwner` being updated. */
  patch: UpdateJobOwnerOnJobOwnerForJobOwnersUserIdFkeyPatch;
  userId: Scalars['Int']['input'];
};

/** Represents an update to a `JobOwner`. Fields that are set will be updated. */
export type JobOwnerPatch = {
  job?: InputMaybe<JobOwnersJobIdFkeyInput>;
  jobId?: InputMaybe<Scalars['Int']['input']>;
  user?: InputMaybe<JobOwnersUserIdFkeyInput>;
  userId?: InputMaybe<Scalars['Int']['input']>;
};

/** A connection to a list of `JobOwner` values. */
export type JobOwnersConnection = {
  __typename?: 'JobOwnersConnection';
  /** A list of edges which contains the `JobOwner` and cursor to aid in pagination. */
  edges: Array<JobOwnersEdge>;
  /** A list of `JobOwner` objects. */
  nodes: Array<JobOwner>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `JobOwner` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `JobOwner` edge in the connection. */
export type JobOwnersEdge = {
  __typename?: 'JobOwnersEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `JobOwner` at the end of the edge. */
  node: JobOwner;
};

/** Input for the nested mutation of `job` in the `JobOwnerInput` mutation. */
export type JobOwnersJobIdFkeyInput = {
  /** The primary key(s) for `job` for the far side of the relationship. */
  connectById?: InputMaybe<JobJobsPkeyConnect>;
  /** The primary key(s) for `job` for the far side of the relationship. */
  connectByNodeId?: InputMaybe<JobNodeIdConnect>;
  /** A `JobInput` object that will be created and connected to this object. */
  create?: InputMaybe<JobOwnersJobIdFkeyJobsCreateInput>;
  /** The primary key(s) and patch data for `job` for the far side of the relationship. */
  updateById?: InputMaybe<JobOnJobOwnerForJobOwnersJobIdFkeyUsingJobsPkeyUpdate>;
  /** The primary key(s) and patch data for `job` for the far side of the relationship. */
  updateByNodeId?: InputMaybe<JobOwnerOnJobOwnerForJobOwnersJobIdFkeyNodeIdUpdate>;
};

/** Input for the nested mutation of `jobOwner` in the `JobInput` mutation. */
export type JobOwnersJobIdFkeyInverseInput = {
  /** The primary key(s) for `jobOwner` for the far side of the relationship. */
  connectByNodeId?: InputMaybe<Array<JobOwnerNodeIdConnect>>;
  /** The primary key(s) for `jobOwner` for the far side of the relationship. */
  connectByUserIdAndJobId?: InputMaybe<Array<JobOwnerJobOwnersPkeyConnect>>;
  /** A `JobOwnerInput` object that will be created and connected to this object. */
  create?: InputMaybe<Array<JobOwnersJobIdFkeyJobOwnersCreateInput>>;
  /** The primary key(s) for `jobOwner` for the far side of the relationship. */
  deleteByNodeId?: InputMaybe<Array<JobOwnerNodeIdDelete>>;
  /** The primary key(s) for `jobOwner` for the far side of the relationship. */
  deleteByUserIdAndJobId?: InputMaybe<Array<JobOwnerJobOwnersPkeyDelete>>;
  /** Flag indicating whether all other `jobOwner` records that match this relationship should be removed. */
  deleteOthers?: InputMaybe<Scalars['Boolean']['input']>;
  /** The primary key(s) and patch data for `jobOwner` for the far side of the relationship. */
  updateByNodeId?: InputMaybe<Array<JobOnJobOwnerForJobOwnersJobIdFkeyNodeIdUpdate>>;
  /** The primary key(s) and patch data for `jobOwner` for the far side of the relationship. */
  updateByUserIdAndJobId?: InputMaybe<Array<JobOwnerOnJobOwnerForJobOwnersJobIdFkeyUsingJobOwnersPkeyUpdate>>;
};

/** The `jobOwner` to be created by this mutation. */
export type JobOwnersJobIdFkeyJobOwnersCreateInput = {
  job?: InputMaybe<JobOwnersJobIdFkeyInput>;
  user?: InputMaybe<JobOwnersUserIdFkeyInput>;
  userId?: InputMaybe<Scalars['Int']['input']>;
};

/** The `job` to be created by this mutation. */
export type JobOwnersJobIdFkeyJobsCreateInput = {
  address?: InputMaybe<Scalars['String']['input']>;
  applications?: InputMaybe<JobsApplicationsJobIdFkeyInverseInput>;
  city?: InputMaybe<Scalars['String']['input']>;
  competencies?: InputMaybe<Array<Scalars['String']['input']>>;
  country?: InputMaybe<Scalars['Int']['input']>;
  department?: InputMaybe<JobsDepartmentIdFkeyInput>;
  departmentId?: InputMaybe<Scalars['Int']['input']>;
  draftEvaluations?: InputMaybe<DraftEvaluationsJobIdFkeyInverseInput>;
  education?: InputMaybe<JobEducation>;
  evaluations?: InputMaybe<EvaluationsJobIdFkeyInverseInput>;
  fields?: InputMaybe<JobFieldsJobIdFkeyInverseInput>;
  genders?: InputMaybe<Array<InputMaybe<Gender>>>;
  gradeConditions?: InputMaybe<Array<InputMaybe<GradeCondition>>>;
  hoursPerWeek?: InputMaybe<IntRangeInput>;
  isRemote?: InputMaybe<Scalars['Boolean']['input']>;
  jobCompetencies?: InputMaybe<JobCompetenciesJobIdFkeyInverseInput>;
  jobKnowledges?: InputMaybe<JobKnowledgesJobIdFkeyInverseInput>;
  jobQuestionnaires?: InputMaybe<JobQuestionnairesJobIdFkeyInverseInput>;
  jobSkills?: InputMaybe<JobSkillsJobIdFkeyInverseInput>;
  jobTags?: InputMaybe<JobTagsJobIdFkeyInverseInput>;
  knowledges?: InputMaybe<Array<Scalars['String']['input']>>;
  languages: Array<InputMaybe<Language>>;
  maxAgeCondition?: InputMaybe<Scalars['Int']['input']>;
  militaryStatus?: InputMaybe<Array<InputMaybe<MilitaryStatus>>>;
  minAgeCondition?: InputMaybe<Scalars['Int']['input']>;
  owners?: InputMaybe<JobOwnersJobIdFkeyInverseInput>;
  pipeline?: InputMaybe<JobsPipelineIdFkeyInput>;
  pipelineId?: InputMaybe<Scalars['Int']['input']>;
  position: Scalars['Int']['input'];
  publishedAt?: InputMaybe<Scalars['Datetime']['input']>;
  skills?: InputMaybe<Array<Scalars['String']['input']>>;
  state?: InputMaybe<Scalars['Int']['input']>;
  status: JobStatus;
  tags?: InputMaybe<Array<Scalars['String']['input']>>;
  threads?: InputMaybe<ThreadsJobIdFkeyInverseInput>;
  translations?: InputMaybe<JobTranslationsJobIdFkeyInverseInput>;
  workExperienceCondition?: InputMaybe<Scalars['Int']['input']>;
};

/** Methods to use when ordering `JobOwner`. */
export enum JobOwnersOrderBy {
  JobIdAsc = 'JOB_ID_ASC',
  JobIdDesc = 'JOB_ID_DESC',
  Natural = 'NATURAL',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  UserIdAsc = 'USER_ID_ASC',
  UserIdDesc = 'USER_ID_DESC'
}

/** Input for the nested mutation of `user` in the `JobOwnerInput` mutation. */
export type JobOwnersUserIdFkeyInput = {
  /** The primary key(s) for `user` for the far side of the relationship. */
  connectByEmail?: InputMaybe<UserUsersEmailKeyConnect>;
  /** The primary key(s) for `user` for the far side of the relationship. */
  connectById?: InputMaybe<UserUsersPkeyConnect>;
  /** The primary key(s) for `user` for the far side of the relationship. */
  connectByNodeId?: InputMaybe<UserNodeIdConnect>;
  /** The primary key(s) and patch data for `user` for the far side of the relationship. */
  updateByEmail?: InputMaybe<UserOnJobOwnerForJobOwnersUserIdFkeyUsingUsersEmailKeyUpdate>;
  /** The primary key(s) and patch data for `user` for the far side of the relationship. */
  updateById?: InputMaybe<UserOnJobOwnerForJobOwnersUserIdFkeyUsingUsersPkeyUpdate>;
  /** The primary key(s) and patch data for `user` for the far side of the relationship. */
  updateByNodeId?: InputMaybe<JobOwnerOnJobOwnerForJobOwnersUserIdFkeyNodeIdUpdate>;
};

/** Input for the nested mutation of `jobOwner` in the `UserInput` mutation. */
export type JobOwnersUserIdFkeyInverseInput = {
  /** The primary key(s) for `jobOwner` for the far side of the relationship. */
  connectByNodeId?: InputMaybe<Array<JobOwnerNodeIdConnect>>;
  /** The primary key(s) for `jobOwner` for the far side of the relationship. */
  connectByUserIdAndJobId?: InputMaybe<Array<JobOwnerJobOwnersPkeyConnect>>;
  /** A `JobOwnerInput` object that will be created and connected to this object. */
  create?: InputMaybe<Array<JobOwnersUserIdFkeyJobOwnersCreateInput>>;
  /** The primary key(s) for `jobOwner` for the far side of the relationship. */
  deleteByNodeId?: InputMaybe<Array<JobOwnerNodeIdDelete>>;
  /** The primary key(s) for `jobOwner` for the far side of the relationship. */
  deleteByUserIdAndJobId?: InputMaybe<Array<JobOwnerJobOwnersPkeyDelete>>;
  /** Flag indicating whether all other `jobOwner` records that match this relationship should be removed. */
  deleteOthers?: InputMaybe<Scalars['Boolean']['input']>;
  /** The primary key(s) and patch data for `jobOwner` for the far side of the relationship. */
  updateByNodeId?: InputMaybe<Array<UserOnJobOwnerForJobOwnersUserIdFkeyNodeIdUpdate>>;
  /** The primary key(s) and patch data for `jobOwner` for the far side of the relationship. */
  updateByUserIdAndJobId?: InputMaybe<Array<JobOwnerOnJobOwnerForJobOwnersUserIdFkeyUsingJobOwnersPkeyUpdate>>;
};

/** The `jobOwner` to be created by this mutation. */
export type JobOwnersUserIdFkeyJobOwnersCreateInput = {
  job?: InputMaybe<JobOwnersJobIdFkeyInput>;
  jobId?: InputMaybe<Scalars['Int']['input']>;
  user?: InputMaybe<JobOwnersUserIdFkeyInput>;
};

/** Represents an update to a `Job`. Fields that are set will be updated. */
export type JobPatch = {
  address?: InputMaybe<Scalars['String']['input']>;
  applications?: InputMaybe<JobsApplicationsJobIdFkeyInverseInput>;
  city?: InputMaybe<Scalars['String']['input']>;
  competencies?: InputMaybe<Array<Scalars['String']['input']>>;
  country?: InputMaybe<Scalars['Int']['input']>;
  department?: InputMaybe<JobsDepartmentIdFkeyInput>;
  departmentId?: InputMaybe<Scalars['Int']['input']>;
  draftEvaluations?: InputMaybe<DraftEvaluationsJobIdFkeyInverseInput>;
  education?: InputMaybe<JobEducation>;
  evaluations?: InputMaybe<EvaluationsJobIdFkeyInverseInput>;
  fields?: InputMaybe<JobFieldsJobIdFkeyInverseInput>;
  genders?: InputMaybe<Array<InputMaybe<Gender>>>;
  gradeConditions?: InputMaybe<Array<InputMaybe<GradeCondition>>>;
  hoursPerWeek?: InputMaybe<IntRangeInput>;
  isRemote?: InputMaybe<Scalars['Boolean']['input']>;
  jobCompetencies?: InputMaybe<JobCompetenciesJobIdFkeyInverseInput>;
  jobKnowledges?: InputMaybe<JobKnowledgesJobIdFkeyInverseInput>;
  jobQuestionnaires?: InputMaybe<JobQuestionnairesJobIdFkeyInverseInput>;
  jobSkills?: InputMaybe<JobSkillsJobIdFkeyInverseInput>;
  jobTags?: InputMaybe<JobTagsJobIdFkeyInverseInput>;
  knowledges?: InputMaybe<Array<Scalars['String']['input']>>;
  languages?: InputMaybe<Array<InputMaybe<Language>>>;
  maxAgeCondition?: InputMaybe<Scalars['Int']['input']>;
  militaryStatus?: InputMaybe<Array<InputMaybe<MilitaryStatus>>>;
  minAgeCondition?: InputMaybe<Scalars['Int']['input']>;
  owners?: InputMaybe<JobOwnersJobIdFkeyInverseInput>;
  pipeline?: InputMaybe<JobsPipelineIdFkeyInput>;
  pipelineId?: InputMaybe<Scalars['Int']['input']>;
  position?: InputMaybe<Scalars['Int']['input']>;
  publishedAt?: InputMaybe<Scalars['Datetime']['input']>;
  skills?: InputMaybe<Array<Scalars['String']['input']>>;
  state?: InputMaybe<Scalars['Int']['input']>;
  status?: InputMaybe<JobStatus>;
  tags?: InputMaybe<Array<Scalars['String']['input']>>;
  threads?: InputMaybe<ThreadsJobIdFkeyInverseInput>;
  translations?: InputMaybe<JobTranslationsJobIdFkeyInverseInput>;
  workExperienceCondition?: InputMaybe<Scalars['Int']['input']>;
};

export type JobPatch__ = {
  departmentId?: InputMaybe<Scalars['Int']['input']>;
  genders?: InputMaybe<Array<InputMaybe<Gender>>>;
  gradeConditions?: InputMaybe<Array<InputMaybe<GradeCondition>>>;
  jobQuestionnairesIds?: InputMaybe<Array<Scalars['Int']['input']>>;
  maxAgeCondition?: InputMaybe<Scalars['Int']['input']>;
  minAgeCondition?: InputMaybe<Scalars['Int']['input']>;
  ownerIds?: InputMaybe<Array<Scalars['Int']['input']>>;
  translations?: InputMaybe<Array<JobTranlationsInput__>>;
  workExperienceCondition?: InputMaybe<Scalars['Int']['input']>;
};

/** A connection to a list of `PipelineStage` values, with data from `JobsApplication`. */
export type JobPipelineStagesByJobsApplicationJobIdAndPipelineStageIdManyToManyConnection = {
  __typename?: 'JobPipelineStagesByJobsApplicationJobIdAndPipelineStageIdManyToManyConnection';
  /** A list of edges which contains the `PipelineStage`, info from the `JobsApplication`, and the cursor to aid in pagination. */
  edges: Array<JobPipelineStagesByJobsApplicationJobIdAndPipelineStageIdManyToManyEdge>;
  /** A list of `PipelineStage` objects. */
  nodes: Array<PipelineStage>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `PipelineStage` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `PipelineStage` edge in the connection, with data from `JobsApplication`. */
export type JobPipelineStagesByJobsApplicationJobIdAndPipelineStageIdManyToManyEdge = {
  __typename?: 'JobPipelineStagesByJobsApplicationJobIdAndPipelineStageIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** Reads and enables pagination through a set of `JobsApplication`. */
  jobsApplications: JobsApplicationsConnection;
  /** The `PipelineStage` at the end of the edge. */
  node: PipelineStage;
};


/** A `PipelineStage` edge in the connection, with data from `JobsApplication`. */
export type JobPipelineStagesByJobsApplicationJobIdAndPipelineStageIdManyToManyEdgeJobsApplicationsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<JobsApplicationCondition>;
  filter?: InputMaybe<JobsApplicationFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<JobsApplicationsOrderBy>>;
};

export type JobQuestionnaire = Node & {
  __typename?: 'JobQuestionnaire';
  /** Reads a single `Job` that is related to this `JobQuestionnaire`. */
  job?: Maybe<Job>;
  jobId: Scalars['Int']['output'];
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  /** Reads a single `Questionnaire` that is related to this `JobQuestionnaire`. */
  questionnaire?: Maybe<Questionnaire>;
  questionnaireId: Scalars['Int']['output'];
};

/** A condition to be used against `JobQuestionnaire` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type JobQuestionnaireCondition = {
  /** Checks for equality with the object’s `jobId` field. */
  jobId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `questionnaireId` field. */
  questionnaireId?: InputMaybe<Scalars['Int']['input']>;
};

/** A filter to be used against `JobQuestionnaire` object types. All fields are combined with a logical ‘and.’ */
export type JobQuestionnaireFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<JobQuestionnaireFilter>>;
  /** Filter by the object’s `job` relation. */
  job?: InputMaybe<JobFilter>;
  /** Filter by the object’s `jobId` field. */
  jobId?: InputMaybe<IntFilter>;
  /** Negates the expression. */
  not?: InputMaybe<JobQuestionnaireFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<JobQuestionnaireFilter>>;
  /** Filter by the object’s `questionnaire` relation. */
  questionnaire?: InputMaybe<QuestionnaireFilter>;
  /** Filter by the object’s `questionnaireId` field. */
  questionnaireId?: InputMaybe<IntFilter>;
};

/** An input for mutations affecting `JobQuestionnaire` */
export type JobQuestionnaireInput = {
  job?: InputMaybe<JobQuestionnairesJobIdFkeyInput>;
  jobId?: InputMaybe<Scalars['Int']['input']>;
  questionnaire?: InputMaybe<JobQuestionnairesQuestionnaireIdFkeyInput>;
  questionnaireId?: InputMaybe<Scalars['Int']['input']>;
};

/** The fields on `jobQuestionnaire` to look up the row to connect. */
export type JobQuestionnaireJobQuestionnairesPkeyConnect = {
  jobId: Scalars['Int']['input'];
  questionnaireId: Scalars['Int']['input'];
};

/** The globally unique `ID` look up for the row to connect. */
export type JobQuestionnaireNodeIdConnect = {
  /** The globally unique `ID` which identifies a single `jobQuestionnaire` to be connected. */
  nodeId: Scalars['ID']['input'];
};

/** The globally unique `ID` look up for the row to update. */
export type JobQuestionnaireOnJobQuestionnaireForJobQuestionnairesJobIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `job` to be connected. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `job` being updated. */
  patch: JobPatch;
};

/** The fields on `jobQuestionnaire` to look up the row to update. */
export type JobQuestionnaireOnJobQuestionnaireForJobQuestionnairesJobIdFkeyUsingJobQuestionnairesPkeyUpdate = {
  jobId: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `jobQuestionnaire` being updated. */
  patch: UpdateJobQuestionnaireOnJobQuestionnaireForJobQuestionnairesJobIdFkeyPatch;
  questionnaireId: Scalars['Int']['input'];
};

/** The globally unique `ID` look up for the row to update. */
export type JobQuestionnaireOnJobQuestionnaireForJobQuestionnairesQuestionnaireIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `questionnaire` to be connected. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `questionnaire` being updated. */
  patch: QuestionnairePatch;
};

/** The fields on `jobQuestionnaire` to look up the row to update. */
export type JobQuestionnaireOnJobQuestionnaireForJobQuestionnairesQuestionnaireIdFkeyUsingJobQuestionnairesPkeyUpdate = {
  jobId: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `jobQuestionnaire` being updated. */
  patch: UpdateJobQuestionnaireOnJobQuestionnaireForJobQuestionnairesQuestionnaireIdFkeyPatch;
  questionnaireId: Scalars['Int']['input'];
};

/** Represents an update to a `JobQuestionnaire`. Fields that are set will be updated. */
export type JobQuestionnairePatch = {
  job?: InputMaybe<JobQuestionnairesJobIdFkeyInput>;
  jobId?: InputMaybe<Scalars['Int']['input']>;
  questionnaire?: InputMaybe<JobQuestionnairesQuestionnaireIdFkeyInput>;
  questionnaireId?: InputMaybe<Scalars['Int']['input']>;
};

/** A connection to a list of `Questionnaire` values, with data from `JobQuestionnaire`. */
export type JobQuestionnairesByJobQuestionnaireJobIdAndQuestionnaireIdManyToManyConnection = {
  __typename?: 'JobQuestionnairesByJobQuestionnaireJobIdAndQuestionnaireIdManyToManyConnection';
  /** A list of edges which contains the `Questionnaire`, info from the `JobQuestionnaire`, and the cursor to aid in pagination. */
  edges: Array<JobQuestionnairesByJobQuestionnaireJobIdAndQuestionnaireIdManyToManyEdge>;
  /** A list of `Questionnaire` objects. */
  nodes: Array<Questionnaire>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Questionnaire` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `Questionnaire` edge in the connection, with data from `JobQuestionnaire`. */
export type JobQuestionnairesByJobQuestionnaireJobIdAndQuestionnaireIdManyToManyEdge = {
  __typename?: 'JobQuestionnairesByJobQuestionnaireJobIdAndQuestionnaireIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Questionnaire` at the end of the edge. */
  node: Questionnaire;
};

/** A connection to a list of `JobQuestionnaire` values. */
export type JobQuestionnairesConnection = {
  __typename?: 'JobQuestionnairesConnection';
  /** A list of edges which contains the `JobQuestionnaire` and cursor to aid in pagination. */
  edges: Array<JobQuestionnairesEdge>;
  /** A list of `JobQuestionnaire` objects. */
  nodes: Array<JobQuestionnaire>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `JobQuestionnaire` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `JobQuestionnaire` edge in the connection. */
export type JobQuestionnairesEdge = {
  __typename?: 'JobQuestionnairesEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `JobQuestionnaire` at the end of the edge. */
  node: JobQuestionnaire;
};

/** Input for the nested mutation of `job` in the `JobQuestionnaireInput` mutation. */
export type JobQuestionnairesJobIdFkeyInput = {
  /** The primary key(s) for `job` for the far side of the relationship. */
  connectById?: InputMaybe<JobJobsPkeyConnect>;
  /** The primary key(s) for `job` for the far side of the relationship. */
  connectByNodeId?: InputMaybe<JobNodeIdConnect>;
  /** A `JobInput` object that will be created and connected to this object. */
  create?: InputMaybe<JobQuestionnairesJobIdFkeyJobsCreateInput>;
  /** The primary key(s) and patch data for `job` for the far side of the relationship. */
  updateById?: InputMaybe<JobOnJobQuestionnaireForJobQuestionnairesJobIdFkeyUsingJobsPkeyUpdate>;
  /** The primary key(s) and patch data for `job` for the far side of the relationship. */
  updateByNodeId?: InputMaybe<JobQuestionnaireOnJobQuestionnaireForJobQuestionnairesJobIdFkeyNodeIdUpdate>;
};

/** Input for the nested mutation of `jobQuestionnaire` in the `JobInput` mutation. */
export type JobQuestionnairesJobIdFkeyInverseInput = {
  /** The primary key(s) for `jobQuestionnaire` for the far side of the relationship. */
  connectByJobIdAndQuestionnaireId?: InputMaybe<Array<JobQuestionnaireJobQuestionnairesPkeyConnect>>;
  /** The primary key(s) for `jobQuestionnaire` for the far side of the relationship. */
  connectByNodeId?: InputMaybe<Array<JobQuestionnaireNodeIdConnect>>;
  /** A `JobQuestionnaireInput` object that will be created and connected to this object. */
  create?: InputMaybe<Array<JobQuestionnairesJobIdFkeyJobQuestionnairesCreateInput>>;
  /** The primary key(s) and patch data for `jobQuestionnaire` for the far side of the relationship. */
  updateByJobIdAndQuestionnaireId?: InputMaybe<Array<JobQuestionnaireOnJobQuestionnaireForJobQuestionnairesJobIdFkeyUsingJobQuestionnairesPkeyUpdate>>;
  /** The primary key(s) and patch data for `jobQuestionnaire` for the far side of the relationship. */
  updateByNodeId?: InputMaybe<Array<JobOnJobQuestionnaireForJobQuestionnairesJobIdFkeyNodeIdUpdate>>;
};

/** The `jobQuestionnaire` to be created by this mutation. */
export type JobQuestionnairesJobIdFkeyJobQuestionnairesCreateInput = {
  job?: InputMaybe<JobQuestionnairesJobIdFkeyInput>;
  questionnaire?: InputMaybe<JobQuestionnairesQuestionnaireIdFkeyInput>;
  questionnaireId?: InputMaybe<Scalars['Int']['input']>;
};

/** The `job` to be created by this mutation. */
export type JobQuestionnairesJobIdFkeyJobsCreateInput = {
  address?: InputMaybe<Scalars['String']['input']>;
  applications?: InputMaybe<JobsApplicationsJobIdFkeyInverseInput>;
  city?: InputMaybe<Scalars['String']['input']>;
  competencies?: InputMaybe<Array<Scalars['String']['input']>>;
  country?: InputMaybe<Scalars['Int']['input']>;
  department?: InputMaybe<JobsDepartmentIdFkeyInput>;
  departmentId?: InputMaybe<Scalars['Int']['input']>;
  draftEvaluations?: InputMaybe<DraftEvaluationsJobIdFkeyInverseInput>;
  education?: InputMaybe<JobEducation>;
  evaluations?: InputMaybe<EvaluationsJobIdFkeyInverseInput>;
  fields?: InputMaybe<JobFieldsJobIdFkeyInverseInput>;
  genders?: InputMaybe<Array<InputMaybe<Gender>>>;
  gradeConditions?: InputMaybe<Array<InputMaybe<GradeCondition>>>;
  hoursPerWeek?: InputMaybe<IntRangeInput>;
  isRemote?: InputMaybe<Scalars['Boolean']['input']>;
  jobCompetencies?: InputMaybe<JobCompetenciesJobIdFkeyInverseInput>;
  jobKnowledges?: InputMaybe<JobKnowledgesJobIdFkeyInverseInput>;
  jobQuestionnaires?: InputMaybe<JobQuestionnairesJobIdFkeyInverseInput>;
  jobSkills?: InputMaybe<JobSkillsJobIdFkeyInverseInput>;
  jobTags?: InputMaybe<JobTagsJobIdFkeyInverseInput>;
  knowledges?: InputMaybe<Array<Scalars['String']['input']>>;
  languages: Array<InputMaybe<Language>>;
  maxAgeCondition?: InputMaybe<Scalars['Int']['input']>;
  militaryStatus?: InputMaybe<Array<InputMaybe<MilitaryStatus>>>;
  minAgeCondition?: InputMaybe<Scalars['Int']['input']>;
  owners?: InputMaybe<JobOwnersJobIdFkeyInverseInput>;
  pipeline?: InputMaybe<JobsPipelineIdFkeyInput>;
  pipelineId?: InputMaybe<Scalars['Int']['input']>;
  position: Scalars['Int']['input'];
  publishedAt?: InputMaybe<Scalars['Datetime']['input']>;
  skills?: InputMaybe<Array<Scalars['String']['input']>>;
  state?: InputMaybe<Scalars['Int']['input']>;
  status: JobStatus;
  tags?: InputMaybe<Array<Scalars['String']['input']>>;
  threads?: InputMaybe<ThreadsJobIdFkeyInverseInput>;
  translations?: InputMaybe<JobTranslationsJobIdFkeyInverseInput>;
  workExperienceCondition?: InputMaybe<Scalars['Int']['input']>;
};

/** Methods to use when ordering `JobQuestionnaire`. */
export enum JobQuestionnairesOrderBy {
  JobIdAsc = 'JOB_ID_ASC',
  JobIdDesc = 'JOB_ID_DESC',
  Natural = 'NATURAL',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  QuestionnaireIdAsc = 'QUESTIONNAIRE_ID_ASC',
  QuestionnaireIdDesc = 'QUESTIONNAIRE_ID_DESC'
}

/** Input for the nested mutation of `questionnaire` in the `JobQuestionnaireInput` mutation. */
export type JobQuestionnairesQuestionnaireIdFkeyInput = {
  /** The primary key(s) for `questionnaire` for the far side of the relationship. */
  connectById?: InputMaybe<QuestionnaireQuestionnairesPkeyConnect>;
  /** The primary key(s) for `questionnaire` for the far side of the relationship. */
  connectByNodeId?: InputMaybe<QuestionnaireNodeIdConnect>;
  /** A `QuestionnaireInput` object that will be created and connected to this object. */
  create?: InputMaybe<JobQuestionnairesQuestionnaireIdFkeyQuestionnairesCreateInput>;
  /** The primary key(s) and patch data for `questionnaire` for the far side of the relationship. */
  updateById?: InputMaybe<QuestionnaireOnJobQuestionnaireForJobQuestionnairesQuestionnaireIdFkeyUsingQuestionnairesPkeyUpdate>;
  /** The primary key(s) and patch data for `questionnaire` for the far side of the relationship. */
  updateByNodeId?: InputMaybe<JobQuestionnaireOnJobQuestionnaireForJobQuestionnairesQuestionnaireIdFkeyNodeIdUpdate>;
};

/** Input for the nested mutation of `jobQuestionnaire` in the `QuestionnaireInput` mutation. */
export type JobQuestionnairesQuestionnaireIdFkeyInverseInput = {
  /** The primary key(s) for `jobQuestionnaire` for the far side of the relationship. */
  connectByJobIdAndQuestionnaireId?: InputMaybe<Array<JobQuestionnaireJobQuestionnairesPkeyConnect>>;
  /** The primary key(s) for `jobQuestionnaire` for the far side of the relationship. */
  connectByNodeId?: InputMaybe<Array<JobQuestionnaireNodeIdConnect>>;
  /** A `JobQuestionnaireInput` object that will be created and connected to this object. */
  create?: InputMaybe<Array<JobQuestionnairesQuestionnaireIdFkeyJobQuestionnairesCreateInput>>;
  /** The primary key(s) and patch data for `jobQuestionnaire` for the far side of the relationship. */
  updateByJobIdAndQuestionnaireId?: InputMaybe<Array<JobQuestionnaireOnJobQuestionnaireForJobQuestionnairesQuestionnaireIdFkeyUsingJobQuestionnairesPkeyUpdate>>;
  /** The primary key(s) and patch data for `jobQuestionnaire` for the far side of the relationship. */
  updateByNodeId?: InputMaybe<Array<QuestionnaireOnJobQuestionnaireForJobQuestionnairesQuestionnaireIdFkeyNodeIdUpdate>>;
};

/** The `jobQuestionnaire` to be created by this mutation. */
export type JobQuestionnairesQuestionnaireIdFkeyJobQuestionnairesCreateInput = {
  job?: InputMaybe<JobQuestionnairesJobIdFkeyInput>;
  jobId?: InputMaybe<Scalars['Int']['input']>;
  questionnaire?: InputMaybe<JobQuestionnairesQuestionnaireIdFkeyInput>;
};

/** The `questionnaire` to be created by this mutation. */
export type JobQuestionnairesQuestionnaireIdFkeyQuestionnairesCreateInput = {
  candidateQuestionnaires?: InputMaybe<CandidateQuestionnairesQuestionnaireIdFkeyInverseInput>;
  candidateQuestions?: InputMaybe<CandidateQuestionsQuestionnaireIdFkeyInverseInput>;
  category: Scalars['String']['input'];
  deletedAt?: InputMaybe<Scalars['Datetime']['input']>;
  jobQuestionnaires?: InputMaybe<JobQuestionnairesQuestionnaireIdFkeyInverseInput>;
  questionnaireQuestions?: InputMaybe<QuestionnaireQuestionsQuestionnaireIdFkeyInverseInput>;
  translations?: InputMaybe<QuestionnaireTranslationsQuestionnaireIdFkeyInverseInput>;
};

export type JobSkill = Node & {
  __typename?: 'JobSkill';
  createdAt: Scalars['Datetime']['output'];
  /** Reads a single `Job` that is related to this `JobSkill`. */
  job?: Maybe<Job>;
  jobId: Scalars['Int']['output'];
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  /** Reads a single `Skill` that is related to this `JobSkill`. */
  skill?: Maybe<Skill>;
  skillId: Scalars['Int']['output'];
};

/** A condition to be used against `JobSkill` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type JobSkillCondition = {
  /** Checks for equality with the object’s `jobId` field. */
  jobId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `skillId` field. */
  skillId?: InputMaybe<Scalars['Int']['input']>;
};

/** A filter to be used against `JobSkill` object types. All fields are combined with a logical ‘and.’ */
export type JobSkillFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<JobSkillFilter>>;
  /** Filter by the object’s `job` relation. */
  job?: InputMaybe<JobFilter>;
  /** Filter by the object’s `jobId` field. */
  jobId?: InputMaybe<IntFilter>;
  /** Negates the expression. */
  not?: InputMaybe<JobSkillFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<JobSkillFilter>>;
  /** Filter by the object’s `skill` relation. */
  skill?: InputMaybe<SkillFilter>;
  /** Filter by the object’s `skillId` field. */
  skillId?: InputMaybe<IntFilter>;
};

/** An input for mutations affecting `JobSkill` */
export type JobSkillInput = {
  job?: InputMaybe<JobSkillsJobIdFkeyInput>;
  jobId?: InputMaybe<Scalars['Int']['input']>;
  skill?: InputMaybe<JobSkillsSkillIdFkeyInput>;
  skillId?: InputMaybe<Scalars['Int']['input']>;
};

/** The fields on `jobSkill` to look up the row to connect. */
export type JobSkillJobSkillsPkeyConnect = {
  jobId: Scalars['Int']['input'];
  skillId: Scalars['Int']['input'];
};

/** The fields on `jobSkill` to look up the row to delete. */
export type JobSkillJobSkillsPkeyDelete = {
  jobId: Scalars['Int']['input'];
  skillId: Scalars['Int']['input'];
};

/** The globally unique `ID` look up for the row to connect. */
export type JobSkillNodeIdConnect = {
  /** The globally unique `ID` which identifies a single `jobSkill` to be connected. */
  nodeId: Scalars['ID']['input'];
};

/** The globally unique `ID` look up for the row to delete. */
export type JobSkillNodeIdDelete = {
  /** The globally unique `ID` which identifies a single `jobSkill` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** The globally unique `ID` look up for the row to update. */
export type JobSkillOnJobSkillForJobSkillsJobIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `job` to be connected. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `job` being updated. */
  patch: JobPatch;
};

/** The fields on `jobSkill` to look up the row to update. */
export type JobSkillOnJobSkillForJobSkillsJobIdFkeyUsingJobSkillsPkeyUpdate = {
  jobId: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `jobSkill` being updated. */
  patch: UpdateJobSkillOnJobSkillForJobSkillsJobIdFkeyPatch;
  skillId: Scalars['Int']['input'];
};

/** The globally unique `ID` look up for the row to update. */
export type JobSkillOnJobSkillForJobSkillsSkillIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `skill` to be connected. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `skill` being updated. */
  patch: SkillPatch;
};

/** The fields on `jobSkill` to look up the row to update. */
export type JobSkillOnJobSkillForJobSkillsSkillIdFkeyUsingJobSkillsPkeyUpdate = {
  jobId: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `jobSkill` being updated. */
  patch: UpdateJobSkillOnJobSkillForJobSkillsSkillIdFkeyPatch;
  skillId: Scalars['Int']['input'];
};

/** Represents an update to a `JobSkill`. Fields that are set will be updated. */
export type JobSkillPatch = {
  job?: InputMaybe<JobSkillsJobIdFkeyInput>;
  jobId?: InputMaybe<Scalars['Int']['input']>;
  skill?: InputMaybe<JobSkillsSkillIdFkeyInput>;
  skillId?: InputMaybe<Scalars['Int']['input']>;
};

/** A connection to a list of `Skill` values, with data from `JobSkill`. */
export type JobSkillsByJobSkillJobIdAndSkillIdManyToManyConnection = {
  __typename?: 'JobSkillsByJobSkillJobIdAndSkillIdManyToManyConnection';
  /** A list of edges which contains the `Skill`, info from the `JobSkill`, and the cursor to aid in pagination. */
  edges: Array<JobSkillsByJobSkillJobIdAndSkillIdManyToManyEdge>;
  /** A list of `Skill` objects. */
  nodes: Array<Skill>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Skill` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `Skill` edge in the connection, with data from `JobSkill`. */
export type JobSkillsByJobSkillJobIdAndSkillIdManyToManyEdge = {
  __typename?: 'JobSkillsByJobSkillJobIdAndSkillIdManyToManyEdge';
  createdAt: Scalars['Datetime']['output'];
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Skill` at the end of the edge. */
  node: Skill;
};

/** A connection to a list of `JobSkill` values. */
export type JobSkillsConnection = {
  __typename?: 'JobSkillsConnection';
  /** A list of edges which contains the `JobSkill` and cursor to aid in pagination. */
  edges: Array<JobSkillsEdge>;
  /** A list of `JobSkill` objects. */
  nodes: Array<JobSkill>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `JobSkill` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `JobSkill` edge in the connection. */
export type JobSkillsEdge = {
  __typename?: 'JobSkillsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `JobSkill` at the end of the edge. */
  node: JobSkill;
};

/** Input for the nested mutation of `job` in the `JobSkillInput` mutation. */
export type JobSkillsJobIdFkeyInput = {
  /** The primary key(s) for `job` for the far side of the relationship. */
  connectById?: InputMaybe<JobJobsPkeyConnect>;
  /** The primary key(s) for `job` for the far side of the relationship. */
  connectByNodeId?: InputMaybe<JobNodeIdConnect>;
  /** A `JobInput` object that will be created and connected to this object. */
  create?: InputMaybe<JobSkillsJobIdFkeyJobsCreateInput>;
  /** The primary key(s) and patch data for `job` for the far side of the relationship. */
  updateById?: InputMaybe<JobOnJobSkillForJobSkillsJobIdFkeyUsingJobsPkeyUpdate>;
  /** The primary key(s) and patch data for `job` for the far side of the relationship. */
  updateByNodeId?: InputMaybe<JobSkillOnJobSkillForJobSkillsJobIdFkeyNodeIdUpdate>;
};

/** Input for the nested mutation of `jobSkill` in the `JobInput` mutation. */
export type JobSkillsJobIdFkeyInverseInput = {
  /** The primary key(s) for `jobSkill` for the far side of the relationship. */
  connectByNodeId?: InputMaybe<Array<JobSkillNodeIdConnect>>;
  /** The primary key(s) for `jobSkill` for the far side of the relationship. */
  connectBySkillIdAndJobId?: InputMaybe<Array<JobSkillJobSkillsPkeyConnect>>;
  /** A `JobSkillInput` object that will be created and connected to this object. */
  create?: InputMaybe<Array<JobSkillsJobIdFkeyJobSkillsCreateInput>>;
  /** The primary key(s) for `jobSkill` for the far side of the relationship. */
  deleteByNodeId?: InputMaybe<Array<JobSkillNodeIdDelete>>;
  /** The primary key(s) for `jobSkill` for the far side of the relationship. */
  deleteBySkillIdAndJobId?: InputMaybe<Array<JobSkillJobSkillsPkeyDelete>>;
  /** Flag indicating whether all other `jobSkill` records that match this relationship should be removed. */
  deleteOthers?: InputMaybe<Scalars['Boolean']['input']>;
  /** The primary key(s) and patch data for `jobSkill` for the far side of the relationship. */
  updateByNodeId?: InputMaybe<Array<JobOnJobSkillForJobSkillsJobIdFkeyNodeIdUpdate>>;
  /** The primary key(s) and patch data for `jobSkill` for the far side of the relationship. */
  updateBySkillIdAndJobId?: InputMaybe<Array<JobSkillOnJobSkillForJobSkillsJobIdFkeyUsingJobSkillsPkeyUpdate>>;
};

/** The `jobSkill` to be created by this mutation. */
export type JobSkillsJobIdFkeyJobSkillsCreateInput = {
  job?: InputMaybe<JobSkillsJobIdFkeyInput>;
  skill?: InputMaybe<JobSkillsSkillIdFkeyInput>;
  skillId?: InputMaybe<Scalars['Int']['input']>;
};

/** The `job` to be created by this mutation. */
export type JobSkillsJobIdFkeyJobsCreateInput = {
  address?: InputMaybe<Scalars['String']['input']>;
  applications?: InputMaybe<JobsApplicationsJobIdFkeyInverseInput>;
  city?: InputMaybe<Scalars['String']['input']>;
  competencies?: InputMaybe<Array<Scalars['String']['input']>>;
  country?: InputMaybe<Scalars['Int']['input']>;
  department?: InputMaybe<JobsDepartmentIdFkeyInput>;
  departmentId?: InputMaybe<Scalars['Int']['input']>;
  draftEvaluations?: InputMaybe<DraftEvaluationsJobIdFkeyInverseInput>;
  education?: InputMaybe<JobEducation>;
  evaluations?: InputMaybe<EvaluationsJobIdFkeyInverseInput>;
  fields?: InputMaybe<JobFieldsJobIdFkeyInverseInput>;
  genders?: InputMaybe<Array<InputMaybe<Gender>>>;
  gradeConditions?: InputMaybe<Array<InputMaybe<GradeCondition>>>;
  hoursPerWeek?: InputMaybe<IntRangeInput>;
  isRemote?: InputMaybe<Scalars['Boolean']['input']>;
  jobCompetencies?: InputMaybe<JobCompetenciesJobIdFkeyInverseInput>;
  jobKnowledges?: InputMaybe<JobKnowledgesJobIdFkeyInverseInput>;
  jobQuestionnaires?: InputMaybe<JobQuestionnairesJobIdFkeyInverseInput>;
  jobSkills?: InputMaybe<JobSkillsJobIdFkeyInverseInput>;
  jobTags?: InputMaybe<JobTagsJobIdFkeyInverseInput>;
  knowledges?: InputMaybe<Array<Scalars['String']['input']>>;
  languages: Array<InputMaybe<Language>>;
  maxAgeCondition?: InputMaybe<Scalars['Int']['input']>;
  militaryStatus?: InputMaybe<Array<InputMaybe<MilitaryStatus>>>;
  minAgeCondition?: InputMaybe<Scalars['Int']['input']>;
  owners?: InputMaybe<JobOwnersJobIdFkeyInverseInput>;
  pipeline?: InputMaybe<JobsPipelineIdFkeyInput>;
  pipelineId?: InputMaybe<Scalars['Int']['input']>;
  position: Scalars['Int']['input'];
  publishedAt?: InputMaybe<Scalars['Datetime']['input']>;
  skills?: InputMaybe<Array<Scalars['String']['input']>>;
  state?: InputMaybe<Scalars['Int']['input']>;
  status: JobStatus;
  tags?: InputMaybe<Array<Scalars['String']['input']>>;
  threads?: InputMaybe<ThreadsJobIdFkeyInverseInput>;
  translations?: InputMaybe<JobTranslationsJobIdFkeyInverseInput>;
  workExperienceCondition?: InputMaybe<Scalars['Int']['input']>;
};

/** Methods to use when ordering `JobSkill`. */
export enum JobSkillsOrderBy {
  JobIdAsc = 'JOB_ID_ASC',
  JobIdDesc = 'JOB_ID_DESC',
  Natural = 'NATURAL',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  SkillIdAsc = 'SKILL_ID_ASC',
  SkillIdDesc = 'SKILL_ID_DESC'
}

/** Input for the nested mutation of `skill` in the `JobSkillInput` mutation. */
export type JobSkillsSkillIdFkeyInput = {
  /** The primary key(s) for `skill` for the far side of the relationship. */
  connectById?: InputMaybe<SkillSkillsPkeyConnect>;
  /** The primary key(s) for `skill` for the far side of the relationship. */
  connectByNodeId?: InputMaybe<SkillNodeIdConnect>;
  /** A `SkillInput` object that will be created and connected to this object. */
  create?: InputMaybe<JobSkillsSkillIdFkeySkillsCreateInput>;
  /** The primary key(s) and patch data for `skill` for the far side of the relationship. */
  updateById?: InputMaybe<SkillOnJobSkillForJobSkillsSkillIdFkeyUsingSkillsPkeyUpdate>;
  /** The primary key(s) and patch data for `skill` for the far side of the relationship. */
  updateByNodeId?: InputMaybe<JobSkillOnJobSkillForJobSkillsSkillIdFkeyNodeIdUpdate>;
};

/** Input for the nested mutation of `jobSkill` in the `SkillInput` mutation. */
export type JobSkillsSkillIdFkeyInverseInput = {
  /** The primary key(s) for `jobSkill` for the far side of the relationship. */
  connectByNodeId?: InputMaybe<Array<JobSkillNodeIdConnect>>;
  /** The primary key(s) for `jobSkill` for the far side of the relationship. */
  connectBySkillIdAndJobId?: InputMaybe<Array<JobSkillJobSkillsPkeyConnect>>;
  /** A `JobSkillInput` object that will be created and connected to this object. */
  create?: InputMaybe<Array<JobSkillsSkillIdFkeyJobSkillsCreateInput>>;
  /** The primary key(s) for `jobSkill` for the far side of the relationship. */
  deleteByNodeId?: InputMaybe<Array<JobSkillNodeIdDelete>>;
  /** The primary key(s) for `jobSkill` for the far side of the relationship. */
  deleteBySkillIdAndJobId?: InputMaybe<Array<JobSkillJobSkillsPkeyDelete>>;
  /** Flag indicating whether all other `jobSkill` records that match this relationship should be removed. */
  deleteOthers?: InputMaybe<Scalars['Boolean']['input']>;
  /** The primary key(s) and patch data for `jobSkill` for the far side of the relationship. */
  updateByNodeId?: InputMaybe<Array<SkillOnJobSkillForJobSkillsSkillIdFkeyNodeIdUpdate>>;
  /** The primary key(s) and patch data for `jobSkill` for the far side of the relationship. */
  updateBySkillIdAndJobId?: InputMaybe<Array<JobSkillOnJobSkillForJobSkillsSkillIdFkeyUsingJobSkillsPkeyUpdate>>;
};

/** The `jobSkill` to be created by this mutation. */
export type JobSkillsSkillIdFkeyJobSkillsCreateInput = {
  job?: InputMaybe<JobSkillsJobIdFkeyInput>;
  jobId?: InputMaybe<Scalars['Int']['input']>;
  skill?: InputMaybe<JobSkillsSkillIdFkeyInput>;
};

/** The `skill` to be created by this mutation. */
export type JobSkillsSkillIdFkeySkillsCreateInput = {
  jobSkills?: InputMaybe<JobSkillsSkillIdFkeyInverseInput>;
  title: Scalars['String']['input'];
};

export enum JobStatus {
  Archived = 'ARCHIVED',
  Draft = 'DRAFT',
  Published = 'PUBLISHED',
  PublishedInternal = 'PUBLISHED_INTERNAL'
}

/** A filter to be used against JobStatus fields. All fields are combined with a logical ‘and.’ */
export type JobStatusFilter = {
  /** Not equal to the specified value, treating null like an ordinary value. */
  distinctFrom?: InputMaybe<JobStatus>;
  /** Equal to the specified value. */
  equalTo?: InputMaybe<JobStatus>;
  /** Greater than the specified value. */
  greaterThan?: InputMaybe<JobStatus>;
  /** Greater than or equal to the specified value. */
  greaterThanOrEqualTo?: InputMaybe<JobStatus>;
  /** Included in the specified list. */
  in?: InputMaybe<Array<JobStatus>>;
  /** Is null (if `true` is specified) or is not null (if `false` is specified). */
  isNull?: InputMaybe<Scalars['Boolean']['input']>;
  /** Less than the specified value. */
  lessThan?: InputMaybe<JobStatus>;
  /** Less than or equal to the specified value. */
  lessThanOrEqualTo?: InputMaybe<JobStatus>;
  /** Equal to the specified value, treating null like an ordinary value. */
  notDistinctFrom?: InputMaybe<JobStatus>;
  /** Not equal to the specified value. */
  notEqualTo?: InputMaybe<JobStatus>;
  /** Not included in the specified list. */
  notIn?: InputMaybe<Array<JobStatus>>;
};

export type JobTag = Node & {
  __typename?: 'JobTag';
  createdAt: Scalars['Datetime']['output'];
  /** Reads a single `Job` that is related to this `JobTag`. */
  job?: Maybe<Job>;
  jobId: Scalars['Int']['output'];
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  /** Reads a single `Tag` that is related to this `JobTag`. */
  tag?: Maybe<Tag>;
  tagId: Scalars['Int']['output'];
};

/** A condition to be used against `JobTag` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type JobTagCondition = {
  /** Checks for equality with the object’s `jobId` field. */
  jobId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `tagId` field. */
  tagId?: InputMaybe<Scalars['Int']['input']>;
};

/** A filter to be used against `JobTag` object types. All fields are combined with a logical ‘and.’ */
export type JobTagFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<JobTagFilter>>;
  /** Filter by the object’s `job` relation. */
  job?: InputMaybe<JobFilter>;
  /** Filter by the object’s `jobId` field. */
  jobId?: InputMaybe<IntFilter>;
  /** Negates the expression. */
  not?: InputMaybe<JobTagFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<JobTagFilter>>;
  /** Filter by the object’s `tag` relation. */
  tag?: InputMaybe<TagFilter>;
  /** Filter by the object’s `tagId` field. */
  tagId?: InputMaybe<IntFilter>;
};

/** An input for mutations affecting `JobTag` */
export type JobTagInput = {
  job?: InputMaybe<JobTagsJobIdFkeyInput>;
  jobId?: InputMaybe<Scalars['Int']['input']>;
  tag?: InputMaybe<JobTagsTagIdFkeyInput>;
  tagId?: InputMaybe<Scalars['Int']['input']>;
};

/** The fields on `jobTag` to look up the row to connect. */
export type JobTagJobTagsPkeyConnect = {
  jobId: Scalars['Int']['input'];
  tagId: Scalars['Int']['input'];
};

/** The fields on `jobTag` to look up the row to delete. */
export type JobTagJobTagsPkeyDelete = {
  jobId: Scalars['Int']['input'];
  tagId: Scalars['Int']['input'];
};

/** The globally unique `ID` look up for the row to connect. */
export type JobTagNodeIdConnect = {
  /** The globally unique `ID` which identifies a single `jobTag` to be connected. */
  nodeId: Scalars['ID']['input'];
};

/** The globally unique `ID` look up for the row to delete. */
export type JobTagNodeIdDelete = {
  /** The globally unique `ID` which identifies a single `jobTag` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** The globally unique `ID` look up for the row to update. */
export type JobTagOnJobTagForJobTagsJobIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `job` to be connected. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `job` being updated. */
  patch: JobPatch;
};

/** The fields on `jobTag` to look up the row to update. */
export type JobTagOnJobTagForJobTagsJobIdFkeyUsingJobTagsPkeyUpdate = {
  jobId: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `jobTag` being updated. */
  patch: UpdateJobTagOnJobTagForJobTagsJobIdFkeyPatch;
  tagId: Scalars['Int']['input'];
};

/** The globally unique `ID` look up for the row to update. */
export type JobTagOnJobTagForJobTagsTagIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `tag` to be connected. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `tag` being updated. */
  patch: TagPatch;
};

/** The fields on `jobTag` to look up the row to update. */
export type JobTagOnJobTagForJobTagsTagIdFkeyUsingJobTagsPkeyUpdate = {
  jobId: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `jobTag` being updated. */
  patch: UpdateJobTagOnJobTagForJobTagsTagIdFkeyPatch;
  tagId: Scalars['Int']['input'];
};

/** Represents an update to a `JobTag`. Fields that are set will be updated. */
export type JobTagPatch = {
  job?: InputMaybe<JobTagsJobIdFkeyInput>;
  jobId?: InputMaybe<Scalars['Int']['input']>;
  tag?: InputMaybe<JobTagsTagIdFkeyInput>;
  tagId?: InputMaybe<Scalars['Int']['input']>;
};

/** A connection to a list of `Tag` values, with data from `JobTag`. */
export type JobTagsByJobTagJobIdAndTagIdManyToManyConnection = {
  __typename?: 'JobTagsByJobTagJobIdAndTagIdManyToManyConnection';
  /** A list of edges which contains the `Tag`, info from the `JobTag`, and the cursor to aid in pagination. */
  edges: Array<JobTagsByJobTagJobIdAndTagIdManyToManyEdge>;
  /** A list of `Tag` objects. */
  nodes: Array<Tag>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Tag` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `Tag` edge in the connection, with data from `JobTag`. */
export type JobTagsByJobTagJobIdAndTagIdManyToManyEdge = {
  __typename?: 'JobTagsByJobTagJobIdAndTagIdManyToManyEdge';
  createdAt: Scalars['Datetime']['output'];
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Tag` at the end of the edge. */
  node: Tag;
};

/** A connection to a list of `JobTag` values. */
export type JobTagsConnection = {
  __typename?: 'JobTagsConnection';
  /** A list of edges which contains the `JobTag` and cursor to aid in pagination. */
  edges: Array<JobTagsEdge>;
  /** A list of `JobTag` objects. */
  nodes: Array<JobTag>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `JobTag` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `JobTag` edge in the connection. */
export type JobTagsEdge = {
  __typename?: 'JobTagsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `JobTag` at the end of the edge. */
  node: JobTag;
};

/** Input for the nested mutation of `job` in the `JobTagInput` mutation. */
export type JobTagsJobIdFkeyInput = {
  /** The primary key(s) for `job` for the far side of the relationship. */
  connectById?: InputMaybe<JobJobsPkeyConnect>;
  /** The primary key(s) for `job` for the far side of the relationship. */
  connectByNodeId?: InputMaybe<JobNodeIdConnect>;
  /** A `JobInput` object that will be created and connected to this object. */
  create?: InputMaybe<JobTagsJobIdFkeyJobsCreateInput>;
  /** The primary key(s) and patch data for `job` for the far side of the relationship. */
  updateById?: InputMaybe<JobOnJobTagForJobTagsJobIdFkeyUsingJobsPkeyUpdate>;
  /** The primary key(s) and patch data for `job` for the far side of the relationship. */
  updateByNodeId?: InputMaybe<JobTagOnJobTagForJobTagsJobIdFkeyNodeIdUpdate>;
};

/** Input for the nested mutation of `jobTag` in the `JobInput` mutation. */
export type JobTagsJobIdFkeyInverseInput = {
  /** The primary key(s) for `jobTag` for the far side of the relationship. */
  connectByNodeId?: InputMaybe<Array<JobTagNodeIdConnect>>;
  /** The primary key(s) for `jobTag` for the far side of the relationship. */
  connectByTagIdAndJobId?: InputMaybe<Array<JobTagJobTagsPkeyConnect>>;
  /** A `JobTagInput` object that will be created and connected to this object. */
  create?: InputMaybe<Array<JobTagsJobIdFkeyJobTagsCreateInput>>;
  /** The primary key(s) for `jobTag` for the far side of the relationship. */
  deleteByNodeId?: InputMaybe<Array<JobTagNodeIdDelete>>;
  /** The primary key(s) for `jobTag` for the far side of the relationship. */
  deleteByTagIdAndJobId?: InputMaybe<Array<JobTagJobTagsPkeyDelete>>;
  /** Flag indicating whether all other `jobTag` records that match this relationship should be removed. */
  deleteOthers?: InputMaybe<Scalars['Boolean']['input']>;
  /** The primary key(s) and patch data for `jobTag` for the far side of the relationship. */
  updateByNodeId?: InputMaybe<Array<JobOnJobTagForJobTagsJobIdFkeyNodeIdUpdate>>;
  /** The primary key(s) and patch data for `jobTag` for the far side of the relationship. */
  updateByTagIdAndJobId?: InputMaybe<Array<JobTagOnJobTagForJobTagsJobIdFkeyUsingJobTagsPkeyUpdate>>;
};

/** The `jobTag` to be created by this mutation. */
export type JobTagsJobIdFkeyJobTagsCreateInput = {
  job?: InputMaybe<JobTagsJobIdFkeyInput>;
  tag?: InputMaybe<JobTagsTagIdFkeyInput>;
  tagId?: InputMaybe<Scalars['Int']['input']>;
};

/** The `job` to be created by this mutation. */
export type JobTagsJobIdFkeyJobsCreateInput = {
  address?: InputMaybe<Scalars['String']['input']>;
  applications?: InputMaybe<JobsApplicationsJobIdFkeyInverseInput>;
  city?: InputMaybe<Scalars['String']['input']>;
  competencies?: InputMaybe<Array<Scalars['String']['input']>>;
  country?: InputMaybe<Scalars['Int']['input']>;
  department?: InputMaybe<JobsDepartmentIdFkeyInput>;
  departmentId?: InputMaybe<Scalars['Int']['input']>;
  draftEvaluations?: InputMaybe<DraftEvaluationsJobIdFkeyInverseInput>;
  education?: InputMaybe<JobEducation>;
  evaluations?: InputMaybe<EvaluationsJobIdFkeyInverseInput>;
  fields?: InputMaybe<JobFieldsJobIdFkeyInverseInput>;
  genders?: InputMaybe<Array<InputMaybe<Gender>>>;
  gradeConditions?: InputMaybe<Array<InputMaybe<GradeCondition>>>;
  hoursPerWeek?: InputMaybe<IntRangeInput>;
  isRemote?: InputMaybe<Scalars['Boolean']['input']>;
  jobCompetencies?: InputMaybe<JobCompetenciesJobIdFkeyInverseInput>;
  jobKnowledges?: InputMaybe<JobKnowledgesJobIdFkeyInverseInput>;
  jobQuestionnaires?: InputMaybe<JobQuestionnairesJobIdFkeyInverseInput>;
  jobSkills?: InputMaybe<JobSkillsJobIdFkeyInverseInput>;
  jobTags?: InputMaybe<JobTagsJobIdFkeyInverseInput>;
  knowledges?: InputMaybe<Array<Scalars['String']['input']>>;
  languages: Array<InputMaybe<Language>>;
  maxAgeCondition?: InputMaybe<Scalars['Int']['input']>;
  militaryStatus?: InputMaybe<Array<InputMaybe<MilitaryStatus>>>;
  minAgeCondition?: InputMaybe<Scalars['Int']['input']>;
  owners?: InputMaybe<JobOwnersJobIdFkeyInverseInput>;
  pipeline?: InputMaybe<JobsPipelineIdFkeyInput>;
  pipelineId?: InputMaybe<Scalars['Int']['input']>;
  position: Scalars['Int']['input'];
  publishedAt?: InputMaybe<Scalars['Datetime']['input']>;
  skills?: InputMaybe<Array<Scalars['String']['input']>>;
  state?: InputMaybe<Scalars['Int']['input']>;
  status: JobStatus;
  tags?: InputMaybe<Array<Scalars['String']['input']>>;
  threads?: InputMaybe<ThreadsJobIdFkeyInverseInput>;
  translations?: InputMaybe<JobTranslationsJobIdFkeyInverseInput>;
  workExperienceCondition?: InputMaybe<Scalars['Int']['input']>;
};

/** Methods to use when ordering `JobTag`. */
export enum JobTagsOrderBy {
  JobIdAsc = 'JOB_ID_ASC',
  JobIdDesc = 'JOB_ID_DESC',
  Natural = 'NATURAL',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  TagIdAsc = 'TAG_ID_ASC',
  TagIdDesc = 'TAG_ID_DESC'
}

/** Input for the nested mutation of `tag` in the `JobTagInput` mutation. */
export type JobTagsTagIdFkeyInput = {
  /** The primary key(s) for `tag` for the far side of the relationship. */
  connectById?: InputMaybe<TagTagsPkeyConnect>;
  /** The primary key(s) for `tag` for the far side of the relationship. */
  connectByNodeId?: InputMaybe<TagNodeIdConnect>;
  /** A `TagInput` object that will be created and connected to this object. */
  create?: InputMaybe<JobTagsTagIdFkeyTagsCreateInput>;
  /** The primary key(s) and patch data for `tag` for the far side of the relationship. */
  updateById?: InputMaybe<TagOnJobTagForJobTagsTagIdFkeyUsingTagsPkeyUpdate>;
  /** The primary key(s) and patch data for `tag` for the far side of the relationship. */
  updateByNodeId?: InputMaybe<JobTagOnJobTagForJobTagsTagIdFkeyNodeIdUpdate>;
};

/** Input for the nested mutation of `jobTag` in the `TagInput` mutation. */
export type JobTagsTagIdFkeyInverseInput = {
  /** The primary key(s) for `jobTag` for the far side of the relationship. */
  connectByNodeId?: InputMaybe<Array<JobTagNodeIdConnect>>;
  /** The primary key(s) for `jobTag` for the far side of the relationship. */
  connectByTagIdAndJobId?: InputMaybe<Array<JobTagJobTagsPkeyConnect>>;
  /** A `JobTagInput` object that will be created and connected to this object. */
  create?: InputMaybe<Array<JobTagsTagIdFkeyJobTagsCreateInput>>;
  /** The primary key(s) for `jobTag` for the far side of the relationship. */
  deleteByNodeId?: InputMaybe<Array<JobTagNodeIdDelete>>;
  /** The primary key(s) for `jobTag` for the far side of the relationship. */
  deleteByTagIdAndJobId?: InputMaybe<Array<JobTagJobTagsPkeyDelete>>;
  /** Flag indicating whether all other `jobTag` records that match this relationship should be removed. */
  deleteOthers?: InputMaybe<Scalars['Boolean']['input']>;
  /** The primary key(s) and patch data for `jobTag` for the far side of the relationship. */
  updateByNodeId?: InputMaybe<Array<TagOnJobTagForJobTagsTagIdFkeyNodeIdUpdate>>;
  /** The primary key(s) and patch data for `jobTag` for the far side of the relationship. */
  updateByTagIdAndJobId?: InputMaybe<Array<JobTagOnJobTagForJobTagsTagIdFkeyUsingJobTagsPkeyUpdate>>;
};

/** The `jobTag` to be created by this mutation. */
export type JobTagsTagIdFkeyJobTagsCreateInput = {
  job?: InputMaybe<JobTagsJobIdFkeyInput>;
  jobId?: InputMaybe<Scalars['Int']['input']>;
  tag?: InputMaybe<JobTagsTagIdFkeyInput>;
};

/** The `tag` to be created by this mutation. */
export type JobTagsTagIdFkeyTagsCreateInput = {
  candidateTags?: InputMaybe<CandidateTagsTagIdFkeyInverseInput>;
  jobTags?: InputMaybe<JobTagsTagIdFkeyInverseInput>;
  title: Scalars['String']['input'];
};

/** A filter to be used against many `DraftEvaluation` object types. All fields are combined with a logical ‘and.’ */
export type JobToManyDraftEvaluationFilter = {
  /** Every related `DraftEvaluation` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<DraftEvaluationFilter>;
  /** No related `DraftEvaluation` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<DraftEvaluationFilter>;
  /** Some related `DraftEvaluation` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<DraftEvaluationFilter>;
};

/** A filter to be used against many `Evaluation` object types. All fields are combined with a logical ‘and.’ */
export type JobToManyEvaluationFilter = {
  /** Every related `Evaluation` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<EvaluationFilter>;
  /** No related `Evaluation` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<EvaluationFilter>;
  /** Some related `Evaluation` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<EvaluationFilter>;
};

/** A filter to be used against many `Field` object types. All fields are combined with a logical ‘and.’ */
export type JobToManyFieldFilter = {
  /** Every related `Field` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<FieldFilter>;
  /** No related `Field` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<FieldFilter>;
  /** Some related `Field` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<FieldFilter>;
};

/** A filter to be used against many `JobCompetency` object types. All fields are combined with a logical ‘and.’ */
export type JobToManyJobCompetencyFilter = {
  /** Every related `JobCompetency` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<JobCompetencyFilter>;
  /** No related `JobCompetency` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<JobCompetencyFilter>;
  /** Some related `JobCompetency` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<JobCompetencyFilter>;
};

/** A filter to be used against many `JobKnowledge` object types. All fields are combined with a logical ‘and.’ */
export type JobToManyJobKnowledgeFilter = {
  /** Every related `JobKnowledge` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<JobKnowledgeFilter>;
  /** No related `JobKnowledge` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<JobKnowledgeFilter>;
  /** Some related `JobKnowledge` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<JobKnowledgeFilter>;
};

/** A filter to be used against many `JobOwner` object types. All fields are combined with a logical ‘and.’ */
export type JobToManyJobOwnerFilter = {
  /** Every related `JobOwner` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<JobOwnerFilter>;
  /** No related `JobOwner` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<JobOwnerFilter>;
  /** Some related `JobOwner` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<JobOwnerFilter>;
};

/** A filter to be used against many `JobQuestionnaire` object types. All fields are combined with a logical ‘and.’ */
export type JobToManyJobQuestionnaireFilter = {
  /** Every related `JobQuestionnaire` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<JobQuestionnaireFilter>;
  /** No related `JobQuestionnaire` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<JobQuestionnaireFilter>;
  /** Some related `JobQuestionnaire` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<JobQuestionnaireFilter>;
};

/** A filter to be used against many `JobSkill` object types. All fields are combined with a logical ‘and.’ */
export type JobToManyJobSkillFilter = {
  /** Every related `JobSkill` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<JobSkillFilter>;
  /** No related `JobSkill` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<JobSkillFilter>;
  /** Some related `JobSkill` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<JobSkillFilter>;
};

/** A filter to be used against many `JobTag` object types. All fields are combined with a logical ‘and.’ */
export type JobToManyJobTagFilter = {
  /** Every related `JobTag` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<JobTagFilter>;
  /** No related `JobTag` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<JobTagFilter>;
  /** Some related `JobTag` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<JobTagFilter>;
};

/** A filter to be used against many `JobTranslation` object types. All fields are combined with a logical ‘and.’ */
export type JobToManyJobTranslationFilter = {
  /** Every related `JobTranslation` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<JobTranslationFilter>;
  /** No related `JobTranslation` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<JobTranslationFilter>;
  /** Some related `JobTranslation` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<JobTranslationFilter>;
};

/** A filter to be used against many `JobsApplication` object types. All fields are combined with a logical ‘and.’ */
export type JobToManyJobsApplicationFilter = {
  /** Every related `JobsApplication` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<JobsApplicationFilter>;
  /** No related `JobsApplication` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<JobsApplicationFilter>;
  /** Some related `JobsApplication` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<JobsApplicationFilter>;
};

/** A filter to be used against many `Thread` object types. All fields are combined with a logical ‘and.’ */
export type JobToManyThreadFilter = {
  /** Every related `Thread` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<ThreadFilter>;
  /** No related `Thread` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<ThreadFilter>;
  /** Some related `Thread` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<ThreadFilter>;
};

export type JobTranlationsInput__ = {
  description?: InputMaybe<Scalars['Html']['input']>;
  fieldOfStudy?: InputMaybe<Scalars['String']['input']>;
  lang: Language;
  orientation?: InputMaybe<Scalars['String']['input']>;
  requirements?: InputMaybe<Scalars['Html']['input']>;
  title: Scalars['String']['input'];
};

export type JobTranslation = Node & {
  __typename?: 'JobTranslation';
  description?: Maybe<Scalars['Html']['output']>;
  fieldOfStudy?: Maybe<Scalars['String']['output']>;
  /** Reads a single `Job` that is related to this `JobTranslation`. */
  job?: Maybe<Job>;
  jobId: Scalars['Int']['output'];
  lang: Language;
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  orientation?: Maybe<Scalars['String']['output']>;
  requirements?: Maybe<Scalars['Html']['output']>;
  title: Scalars['String']['output'];
};

/** A condition to be used against `JobTranslation` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type JobTranslationCondition = {
  /** Checks for equality with the object’s `description` field. */
  description?: InputMaybe<Scalars['Html']['input']>;
  /** Checks for equality with the object’s `jobId` field. */
  jobId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `requirements` field. */
  requirements?: InputMaybe<Scalars['Html']['input']>;
  /** Checks for equality with the object’s `title` field. */
  title?: InputMaybe<Scalars['String']['input']>;
};

/** A filter to be used against `JobTranslation` object types. All fields are combined with a logical ‘and.’ */
export type JobTranslationFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<JobTranslationFilter>>;
  /** Filter by the object’s `description` field. */
  description?: InputMaybe<HtmlFilter>;
  /** Filter by the object’s `job` relation. */
  job?: InputMaybe<JobFilter>;
  /** Filter by the object’s `jobId` field. */
  jobId?: InputMaybe<IntFilter>;
  /** Negates the expression. */
  not?: InputMaybe<JobTranslationFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<JobTranslationFilter>>;
  /** Filter by the object’s `requirements` field. */
  requirements?: InputMaybe<HtmlFilter>;
  /** Filter by the object’s `title` field. */
  title?: InputMaybe<StringFilter>;
};

/** An input for mutations affecting `JobTranslation` */
export type JobTranslationInput = {
  description?: InputMaybe<Scalars['Html']['input']>;
  fieldOfStudy?: InputMaybe<Scalars['String']['input']>;
  job?: InputMaybe<JobTranslationsJobIdFkeyInput>;
  jobId?: InputMaybe<Scalars['Int']['input']>;
  lang: Language;
  orientation?: InputMaybe<Scalars['String']['input']>;
  requirements?: InputMaybe<Scalars['Html']['input']>;
  title: Scalars['String']['input'];
};

/** The fields on `jobTranslation` to look up the row to connect. */
export type JobTranslationJobTranslationsPkeyConnect = {
  jobId: Scalars['Int']['input'];
  lang: Language;
};

/** The fields on `jobTranslation` to look up the row to delete. */
export type JobTranslationJobTranslationsPkeyDelete = {
  jobId: Scalars['Int']['input'];
  lang: Language;
};

/** The globally unique `ID` look up for the row to connect. */
export type JobTranslationNodeIdConnect = {
  /** The globally unique `ID` which identifies a single `jobTranslation` to be connected. */
  nodeId: Scalars['ID']['input'];
};

/** The globally unique `ID` look up for the row to delete. */
export type JobTranslationNodeIdDelete = {
  /** The globally unique `ID` which identifies a single `jobTranslation` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** The globally unique `ID` look up for the row to update. */
export type JobTranslationOnJobTranslationForJobTranslationsJobIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `job` to be connected. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `job` being updated. */
  patch: JobPatch;
};

/** The fields on `jobTranslation` to look up the row to update. */
export type JobTranslationOnJobTranslationForJobTranslationsJobIdFkeyUsingJobTranslationsPkeyUpdate = {
  jobId: Scalars['Int']['input'];
  lang: Language;
  /** An object where the defined keys will be set on the `jobTranslation` being updated. */
  patch: UpdateJobTranslationOnJobTranslationForJobTranslationsJobIdFkeyPatch;
};

/** Represents an update to a `JobTranslation`. Fields that are set will be updated. */
export type JobTranslationPatch = {
  description?: InputMaybe<Scalars['Html']['input']>;
  fieldOfStudy?: InputMaybe<Scalars['String']['input']>;
  job?: InputMaybe<JobTranslationsJobIdFkeyInput>;
  jobId?: InputMaybe<Scalars['Int']['input']>;
  orientation?: InputMaybe<Scalars['String']['input']>;
  requirements?: InputMaybe<Scalars['Html']['input']>;
  title?: InputMaybe<Scalars['String']['input']>;
};

/** A connection to a list of `JobTranslation` values. */
export type JobTranslationsConnection = {
  __typename?: 'JobTranslationsConnection';
  /** A list of edges which contains the `JobTranslation` and cursor to aid in pagination. */
  edges: Array<JobTranslationsEdge>;
  /** A list of `JobTranslation` objects. */
  nodes: Array<JobTranslation>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `JobTranslation` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `JobTranslation` edge in the connection. */
export type JobTranslationsEdge = {
  __typename?: 'JobTranslationsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `JobTranslation` at the end of the edge. */
  node: JobTranslation;
};

/** Input for the nested mutation of `job` in the `JobTranslationInput` mutation. */
export type JobTranslationsJobIdFkeyInput = {
  /** The primary key(s) for `job` for the far side of the relationship. */
  connectById?: InputMaybe<JobJobsPkeyConnect>;
  /** The primary key(s) for `job` for the far side of the relationship. */
  connectByNodeId?: InputMaybe<JobNodeIdConnect>;
  /** A `JobInput` object that will be created and connected to this object. */
  create?: InputMaybe<JobTranslationsJobIdFkeyJobsCreateInput>;
  /** The primary key(s) and patch data for `job` for the far side of the relationship. */
  updateById?: InputMaybe<JobOnJobTranslationForJobTranslationsJobIdFkeyUsingJobsPkeyUpdate>;
  /** The primary key(s) and patch data for `job` for the far side of the relationship. */
  updateByNodeId?: InputMaybe<JobTranslationOnJobTranslationForJobTranslationsJobIdFkeyNodeIdUpdate>;
};

/** Input for the nested mutation of `jobTranslation` in the `JobInput` mutation. */
export type JobTranslationsJobIdFkeyInverseInput = {
  /** The primary key(s) for `jobTranslation` for the far side of the relationship. */
  connectByJobIdAndLang?: InputMaybe<Array<JobTranslationJobTranslationsPkeyConnect>>;
  /** The primary key(s) for `jobTranslation` for the far side of the relationship. */
  connectByNodeId?: InputMaybe<Array<JobTranslationNodeIdConnect>>;
  /** A `JobTranslationInput` object that will be created and connected to this object. */
  create?: InputMaybe<Array<JobTranslationsJobIdFkeyJobTranslationsCreateInput>>;
  /** The primary key(s) for `jobTranslation` for the far side of the relationship. */
  deleteByJobIdAndLang?: InputMaybe<Array<JobTranslationJobTranslationsPkeyDelete>>;
  /** The primary key(s) for `jobTranslation` for the far side of the relationship. */
  deleteByNodeId?: InputMaybe<Array<JobTranslationNodeIdDelete>>;
  /** Flag indicating whether all other `jobTranslation` records that match this relationship should be removed. */
  deleteOthers?: InputMaybe<Scalars['Boolean']['input']>;
  /** The primary key(s) and patch data for `jobTranslation` for the far side of the relationship. */
  updateByJobIdAndLang?: InputMaybe<Array<JobTranslationOnJobTranslationForJobTranslationsJobIdFkeyUsingJobTranslationsPkeyUpdate>>;
  /** The primary key(s) and patch data for `jobTranslation` for the far side of the relationship. */
  updateByNodeId?: InputMaybe<Array<JobOnJobTranslationForJobTranslationsJobIdFkeyNodeIdUpdate>>;
};

/** The `jobTranslation` to be created by this mutation. */
export type JobTranslationsJobIdFkeyJobTranslationsCreateInput = {
  description?: InputMaybe<Scalars['Html']['input']>;
  fieldOfStudy?: InputMaybe<Scalars['String']['input']>;
  job?: InputMaybe<JobTranslationsJobIdFkeyInput>;
  lang: Language;
  orientation?: InputMaybe<Scalars['String']['input']>;
  requirements?: InputMaybe<Scalars['Html']['input']>;
  title: Scalars['String']['input'];
};

/** The `job` to be created by this mutation. */
export type JobTranslationsJobIdFkeyJobsCreateInput = {
  address?: InputMaybe<Scalars['String']['input']>;
  applications?: InputMaybe<JobsApplicationsJobIdFkeyInverseInput>;
  city?: InputMaybe<Scalars['String']['input']>;
  competencies?: InputMaybe<Array<Scalars['String']['input']>>;
  country?: InputMaybe<Scalars['Int']['input']>;
  department?: InputMaybe<JobsDepartmentIdFkeyInput>;
  departmentId?: InputMaybe<Scalars['Int']['input']>;
  draftEvaluations?: InputMaybe<DraftEvaluationsJobIdFkeyInverseInput>;
  education?: InputMaybe<JobEducation>;
  evaluations?: InputMaybe<EvaluationsJobIdFkeyInverseInput>;
  fields?: InputMaybe<JobFieldsJobIdFkeyInverseInput>;
  genders?: InputMaybe<Array<InputMaybe<Gender>>>;
  gradeConditions?: InputMaybe<Array<InputMaybe<GradeCondition>>>;
  hoursPerWeek?: InputMaybe<IntRangeInput>;
  isRemote?: InputMaybe<Scalars['Boolean']['input']>;
  jobCompetencies?: InputMaybe<JobCompetenciesJobIdFkeyInverseInput>;
  jobKnowledges?: InputMaybe<JobKnowledgesJobIdFkeyInverseInput>;
  jobQuestionnaires?: InputMaybe<JobQuestionnairesJobIdFkeyInverseInput>;
  jobSkills?: InputMaybe<JobSkillsJobIdFkeyInverseInput>;
  jobTags?: InputMaybe<JobTagsJobIdFkeyInverseInput>;
  knowledges?: InputMaybe<Array<Scalars['String']['input']>>;
  languages: Array<InputMaybe<Language>>;
  maxAgeCondition?: InputMaybe<Scalars['Int']['input']>;
  militaryStatus?: InputMaybe<Array<InputMaybe<MilitaryStatus>>>;
  minAgeCondition?: InputMaybe<Scalars['Int']['input']>;
  owners?: InputMaybe<JobOwnersJobIdFkeyInverseInput>;
  pipeline?: InputMaybe<JobsPipelineIdFkeyInput>;
  pipelineId?: InputMaybe<Scalars['Int']['input']>;
  position: Scalars['Int']['input'];
  publishedAt?: InputMaybe<Scalars['Datetime']['input']>;
  skills?: InputMaybe<Array<Scalars['String']['input']>>;
  state?: InputMaybe<Scalars['Int']['input']>;
  status: JobStatus;
  tags?: InputMaybe<Array<Scalars['String']['input']>>;
  threads?: InputMaybe<ThreadsJobIdFkeyInverseInput>;
  translations?: InputMaybe<JobTranslationsJobIdFkeyInverseInput>;
  workExperienceCondition?: InputMaybe<Scalars['Int']['input']>;
};

/** Methods to use when ordering `JobTranslation`. */
export enum JobTranslationsOrderBy {
  DescriptionAsc = 'DESCRIPTION_ASC',
  DescriptionDesc = 'DESCRIPTION_DESC',
  JobIdAsc = 'JOB_ID_ASC',
  JobIdDesc = 'JOB_ID_DESC',
  Natural = 'NATURAL',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  RequirementsAsc = 'REQUIREMENTS_ASC',
  RequirementsDesc = 'REQUIREMENTS_DESC',
  TitleAsc = 'TITLE_ASC',
  TitleDesc = 'TITLE_DESC'
}

/** A connection to a list of `User` values, with data from `JobOwner`. */
export type JobUsersByJobOwnerJobIdAndUserIdManyToManyConnection = {
  __typename?: 'JobUsersByJobOwnerJobIdAndUserIdManyToManyConnection';
  /** A list of edges which contains the `User`, info from the `JobOwner`, and the cursor to aid in pagination. */
  edges: Array<JobUsersByJobOwnerJobIdAndUserIdManyToManyEdge>;
  /** A list of `User` objects. */
  nodes: Array<User>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `User` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `User` edge in the connection, with data from `JobOwner`. */
export type JobUsersByJobOwnerJobIdAndUserIdManyToManyEdge = {
  __typename?: 'JobUsersByJobOwnerJobIdAndUserIdManyToManyEdge';
  createdAt: Scalars['Datetime']['output'];
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `User` at the end of the edge. */
  node: User;
};

export type JobsApplication = Node & {
  __typename?: 'JobsApplication';
  /** Reads a single `Candidate` that is related to this `JobsApplication`. */
  candidate?: Maybe<Candidate>;
  candidateId: Scalars['Int']['output'];
  coverLetter?: Maybe<Scalars['String']['output']>;
  createdAt: Scalars['Datetime']['output'];
  disqualifiedAt?: Maybe<Scalars['Datetime']['output']>;
  /** Reads a single `DisqualifyReason` that is related to this `JobsApplication`. */
  disqualifyReason?: Maybe<DisqualifyReason>;
  disqualifyReasonId?: Maybe<Scalars['Int']['output']>;
  evaluation?: Maybe<Scalars['Int']['output']>;
  id: Scalars['Int']['output'];
  /** Reads a single `Job` that is related to this `JobsApplication`. */
  job?: Maybe<Job>;
  jobId: Scalars['Int']['output'];
  matchesRank?: Maybe<Scalars['Float']['output']>;
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  /** Reads a single `PipelineStage` that is related to this `JobsApplication`. */
  pipelineStage?: Maybe<PipelineStage>;
  pipelineStageId: Scalars['Int']['output'];
  previousId: Scalars['Int']['output'];
  updatedAt: Scalars['Datetime']['output'];
};

/** A condition to be used against `JobsApplication` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type JobsApplicationCondition = {
  /** Checks for equality with the object’s `candidateId` field. */
  candidateId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `createdAt` field. */
  createdAt?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `disqualifiedAt` field. */
  disqualifiedAt?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `disqualifyReasonId` field. */
  disqualifyReasonId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `jobId` field. */
  jobId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `pipelineStageId` field. */
  pipelineStageId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `updatedAt` field. */
  updatedAt?: InputMaybe<Scalars['Datetime']['input']>;
};

/** A filter to be used against `JobsApplication` object types. All fields are combined with a logical ‘and.’ */
export type JobsApplicationFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<JobsApplicationFilter>>;
  /** Filter by the object’s `candidate` relation. */
  candidate?: InputMaybe<CandidateFilter>;
  /** Filter by the object’s `candidateId` field. */
  candidateId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `createdAt` field. */
  createdAt?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `disqualifiedAt` field. */
  disqualifiedAt?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `disqualifyReason` relation. */
  disqualifyReason?: InputMaybe<DisqualifyReasonFilter>;
  /** A related `disqualifyReason` exists. */
  disqualifyReasonExists?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `disqualifyReasonId` field. */
  disqualifyReasonId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<IntFilter>;
  /** Filter by the object’s `job` relation. */
  job?: InputMaybe<JobFilter>;
  /** Filter by the object’s `jobId` field. */
  jobId?: InputMaybe<IntFilter>;
  /** Negates the expression. */
  not?: InputMaybe<JobsApplicationFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<JobsApplicationFilter>>;
  /** Filter by the object’s `pipelineStage` relation. */
  pipelineStage?: InputMaybe<PipelineStageFilter>;
  /** Filter by the object’s `pipelineStageId` field. */
  pipelineStageId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `updatedAt` field. */
  updatedAt?: InputMaybe<DatetimeFilter>;
};

/** An input for mutations affecting `JobsApplication` */
export type JobsApplicationInput = {
  candidate?: InputMaybe<JobsApplicationsCandidateIdFkeyInput>;
  candidateId?: InputMaybe<Scalars['Int']['input']>;
  coverLetter?: InputMaybe<Scalars['String']['input']>;
  disqualifyReason?: InputMaybe<JobsApplicationsDisqualifyReasonIdFkeyInput>;
  disqualifyReasonId?: InputMaybe<Scalars['Int']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  job?: InputMaybe<JobsApplicationsJobIdFkeyInput>;
  jobId?: InputMaybe<Scalars['Int']['input']>;
  pipelineStage?: InputMaybe<JobsApplicationsPipelineStageIdFkeyInput>;
  pipelineStageId?: InputMaybe<Scalars['Int']['input']>;
};

/** The fields on `jobsApplication` to look up the row to connect. */
export type JobsApplicationJobsApplicationsCandidateIdJobIdKeyConnect = {
  candidateId: Scalars['Int']['input'];
  jobId: Scalars['Int']['input'];
};

/** The fields on `jobsApplication` to look up the row to connect. */
export type JobsApplicationJobsApplicationsPkeyConnect = {
  id: Scalars['Int']['input'];
};

/** The globally unique `ID` look up for the row to connect. */
export type JobsApplicationNodeIdConnect = {
  /** The globally unique `ID` which identifies a single `jobsApplication` to be connected. */
  nodeId: Scalars['ID']['input'];
};

/** The globally unique `ID` look up for the row to update. */
export type JobsApplicationOnJobsApplicationForJobsApplicationsCandidateIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `candidate` to be connected. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `candidate` being updated. */
  patch: CandidatePatch;
};

/** The fields on `jobsApplication` to look up the row to update. */
export type JobsApplicationOnJobsApplicationForJobsApplicationsCandidateIdFkeyUsingJobsApplicationsCandidateIdJobIdKeyUpdate = {
  candidateId: Scalars['Int']['input'];
  jobId: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `jobsApplication` being updated. */
  patch: UpdateJobsApplicationOnJobsApplicationForJobsApplicationsCandidateIdFkeyPatch;
};

/** The fields on `jobsApplication` to look up the row to update. */
export type JobsApplicationOnJobsApplicationForJobsApplicationsCandidateIdFkeyUsingJobsApplicationsPkeyUpdate = {
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `jobsApplication` being updated. */
  patch: UpdateJobsApplicationOnJobsApplicationForJobsApplicationsCandidateIdFkeyPatch;
};

/** The globally unique `ID` look up for the row to update. */
export type JobsApplicationOnJobsApplicationForJobsApplicationsDisqualifyReasonIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `disqualifyReason` to be connected. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `disqualifyReason` being updated. */
  patch: DisqualifyReasonPatch;
};

/** The fields on `jobsApplication` to look up the row to update. */
export type JobsApplicationOnJobsApplicationForJobsApplicationsDisqualifyReasonIdFkeyUsingJobsApplicationsCandidateIdJobIdKeyUpdate = {
  candidateId: Scalars['Int']['input'];
  jobId: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `jobsApplication` being updated. */
  patch: UpdateJobsApplicationOnJobsApplicationForJobsApplicationsDisqualifyReasonIdFkeyPatch;
};

/** The fields on `jobsApplication` to look up the row to update. */
export type JobsApplicationOnJobsApplicationForJobsApplicationsDisqualifyReasonIdFkeyUsingJobsApplicationsPkeyUpdate = {
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `jobsApplication` being updated. */
  patch: UpdateJobsApplicationOnJobsApplicationForJobsApplicationsDisqualifyReasonIdFkeyPatch;
};

/** The globally unique `ID` look up for the row to update. */
export type JobsApplicationOnJobsApplicationForJobsApplicationsJobIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `job` to be connected. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `job` being updated. */
  patch: JobPatch;
};

/** The fields on `jobsApplication` to look up the row to update. */
export type JobsApplicationOnJobsApplicationForJobsApplicationsJobIdFkeyUsingJobsApplicationsCandidateIdJobIdKeyUpdate = {
  candidateId: Scalars['Int']['input'];
  jobId: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `jobsApplication` being updated. */
  patch: UpdateJobsApplicationOnJobsApplicationForJobsApplicationsJobIdFkeyPatch;
};

/** The fields on `jobsApplication` to look up the row to update. */
export type JobsApplicationOnJobsApplicationForJobsApplicationsJobIdFkeyUsingJobsApplicationsPkeyUpdate = {
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `jobsApplication` being updated. */
  patch: UpdateJobsApplicationOnJobsApplicationForJobsApplicationsJobIdFkeyPatch;
};

/** The globally unique `ID` look up for the row to update. */
export type JobsApplicationOnJobsApplicationForJobsApplicationsPipelineStageIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `pipelineStage` to be connected. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `pipelineStage` being updated. */
  patch: PipelineStagePatch;
};

/** The fields on `jobsApplication` to look up the row to update. */
export type JobsApplicationOnJobsApplicationForJobsApplicationsPipelineStageIdFkeyUsingJobsApplicationsCandidateIdJobIdKeyUpdate = {
  candidateId: Scalars['Int']['input'];
  jobId: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `jobsApplication` being updated. */
  patch: UpdateJobsApplicationOnJobsApplicationForJobsApplicationsPipelineStageIdFkeyPatch;
};

/** The fields on `jobsApplication` to look up the row to update. */
export type JobsApplicationOnJobsApplicationForJobsApplicationsPipelineStageIdFkeyUsingJobsApplicationsPkeyUpdate = {
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `jobsApplication` being updated. */
  patch: UpdateJobsApplicationOnJobsApplicationForJobsApplicationsPipelineStageIdFkeyPatch;
};

/** Represents an update to a `JobsApplication`. Fields that are set will be updated. */
export type JobsApplicationPatch = {
  candidate?: InputMaybe<JobsApplicationsCandidateIdFkeyInput>;
  candidateId?: InputMaybe<Scalars['Int']['input']>;
  coverLetter?: InputMaybe<Scalars['String']['input']>;
  disqualifyReason?: InputMaybe<JobsApplicationsDisqualifyReasonIdFkeyInput>;
  disqualifyReasonId?: InputMaybe<Scalars['Int']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  job?: InputMaybe<JobsApplicationsJobIdFkeyInput>;
  jobId?: InputMaybe<Scalars['Int']['input']>;
  pipelineStage?: InputMaybe<JobsApplicationsPipelineStageIdFkeyInput>;
  pipelineStageId?: InputMaybe<Scalars['Int']['input']>;
};

/** The `candidate` to be created by this mutation. */
export type JobsApplicationsCandidateIdFkeyCandidatesCreateInput = {
  birthday?: InputMaybe<Scalars['Date']['input']>;
  candidateDraftEvaluations?: InputMaybe<DraftEvaluationsCandidateIdFkeyInverseInput>;
  candidateEventDraftEvaluations?: InputMaybe<EventDraftEvaluationsCandidateIdFkeyInverseInput>;
  candidateImportCandidate?: InputMaybe<CandidateImportCandidatesCandidateIdFkeyInverseInput>;
  candidateQuestionnaires?: InputMaybe<CandidateQuestionnairesCandidateIdFkeyInverseInput>;
  candidateQuestions?: InputMaybe<CandidateQuestionsCandidateIdFkeyInverseInput>;
  candidateTags?: InputMaybe<CandidateTagsCandidateIdFkeyInverseInput>;
  cvText?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  emails?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  evaluations?: InputMaybe<EvaluationsCandidateIdFkeyInverseInput>;
  eventCandidates?: InputMaybe<EventCandidatesCandidateIdFkeyInverseInput>;
  files?: InputMaybe<CandidateFilesCandidateIdFkeyInverseInput>;
  gender?: InputMaybe<Gender>;
  jobsApplications?: InputMaybe<JobsApplicationsCandidateIdFkeyInverseInput>;
  language: Language;
  links?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  militaryStatus?: InputMaybe<MilitaryStatus>;
  phones?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  photoExternalId?: InputMaybe<Scalars['UUID']['input']>;
  resumeExternalId?: InputMaybe<Scalars['UUID']['input']>;
  socialLinks?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  sources?: InputMaybe<Array<Scalars['String']['input']>>;
  tags?: InputMaybe<Array<Scalars['String']['input']>>;
  threads?: InputMaybe<ThreadsCandidateIdFkeyInverseInput>;
  translations?: InputMaybe<CandidateTranslationsCandidateIdFkeyInverseInput>;
};

/** Input for the nested mutation of `candidate` in the `JobsApplicationInput` mutation. */
export type JobsApplicationsCandidateIdFkeyInput = {
  /** The primary key(s) for `candidate` for the far side of the relationship. */
  connectById?: InputMaybe<CandidateCandidatesPkeyConnect>;
  /** The primary key(s) for `candidate` for the far side of the relationship. */
  connectByNodeId?: InputMaybe<CandidateNodeIdConnect>;
  /** A `CandidateInput` object that will be created and connected to this object. */
  create?: InputMaybe<JobsApplicationsCandidateIdFkeyCandidatesCreateInput>;
  /** The primary key(s) and patch data for `candidate` for the far side of the relationship. */
  updateById?: InputMaybe<CandidateOnJobsApplicationForJobsApplicationsCandidateIdFkeyUsingCandidatesPkeyUpdate>;
  /** The primary key(s) and patch data for `candidate` for the far side of the relationship. */
  updateByNodeId?: InputMaybe<JobsApplicationOnJobsApplicationForJobsApplicationsCandidateIdFkeyNodeIdUpdate>;
};

/** Input for the nested mutation of `jobsApplication` in the `CandidateInput` mutation. */
export type JobsApplicationsCandidateIdFkeyInverseInput = {
  /** The primary key(s) for `jobsApplication` for the far side of the relationship. */
  connectByCandidateIdAndJobId?: InputMaybe<Array<JobsApplicationJobsApplicationsCandidateIdJobIdKeyConnect>>;
  /** The primary key(s) for `jobsApplication` for the far side of the relationship. */
  connectById?: InputMaybe<Array<JobsApplicationJobsApplicationsPkeyConnect>>;
  /** The primary key(s) for `jobsApplication` for the far side of the relationship. */
  connectByNodeId?: InputMaybe<Array<JobsApplicationNodeIdConnect>>;
  /** A `JobsApplicationInput` object that will be created and connected to this object. */
  create?: InputMaybe<Array<JobsApplicationsCandidateIdFkeyJobsApplicationsCreateInput>>;
  /** The primary key(s) and patch data for `jobsApplication` for the far side of the relationship. */
  updateByCandidateIdAndJobId?: InputMaybe<Array<JobsApplicationOnJobsApplicationForJobsApplicationsCandidateIdFkeyUsingJobsApplicationsCandidateIdJobIdKeyUpdate>>;
  /** The primary key(s) and patch data for `jobsApplication` for the far side of the relationship. */
  updateById?: InputMaybe<Array<JobsApplicationOnJobsApplicationForJobsApplicationsCandidateIdFkeyUsingJobsApplicationsPkeyUpdate>>;
  /** The primary key(s) and patch data for `jobsApplication` for the far side of the relationship. */
  updateByNodeId?: InputMaybe<Array<CandidateOnJobsApplicationForJobsApplicationsCandidateIdFkeyNodeIdUpdate>>;
};

/** The `jobsApplication` to be created by this mutation. */
export type JobsApplicationsCandidateIdFkeyJobsApplicationsCreateInput = {
  candidate?: InputMaybe<JobsApplicationsCandidateIdFkeyInput>;
  coverLetter?: InputMaybe<Scalars['String']['input']>;
  disqualifyReason?: InputMaybe<JobsApplicationsDisqualifyReasonIdFkeyInput>;
  disqualifyReasonId?: InputMaybe<Scalars['Int']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  job?: InputMaybe<JobsApplicationsJobIdFkeyInput>;
  jobId?: InputMaybe<Scalars['Int']['input']>;
  pipelineStage?: InputMaybe<JobsApplicationsPipelineStageIdFkeyInput>;
  pipelineStageId?: InputMaybe<Scalars['Int']['input']>;
};

/** A connection to a list of `JobsApplication` values. */
export type JobsApplicationsConnection = {
  __typename?: 'JobsApplicationsConnection';
  /** A list of edges which contains the `JobsApplication` and cursor to aid in pagination. */
  edges: Array<JobsApplicationsEdge>;
  /** A list of `JobsApplication` objects. */
  nodes: Array<JobsApplication>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `JobsApplication` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** The `disqualifyReason` to be created by this mutation. */
export type JobsApplicationsDisqualifyReasonIdFkeyDisqualifyReasonsCreateInput = {
  jobsApplications?: InputMaybe<JobsApplicationsDisqualifyReasonIdFkeyInverseInput>;
  position?: InputMaybe<Scalars['Int']['input']>;
  translations?: InputMaybe<DisqualifyReasonTranslationsDisqualifyReasonIdFkeyInverseInput>;
};

/** Input for the nested mutation of `disqualifyReason` in the `JobsApplicationInput` mutation. */
export type JobsApplicationsDisqualifyReasonIdFkeyInput = {
  /** The primary key(s) for `disqualifyReason` for the far side of the relationship. */
  connectById?: InputMaybe<DisqualifyReasonDisqualifyReasonsPkeyConnect>;
  /** The primary key(s) for `disqualifyReason` for the far side of the relationship. */
  connectByNodeId?: InputMaybe<DisqualifyReasonNodeIdConnect>;
  /** A `DisqualifyReasonInput` object that will be created and connected to this object. */
  create?: InputMaybe<JobsApplicationsDisqualifyReasonIdFkeyDisqualifyReasonsCreateInput>;
  /** The primary key(s) and patch data for `disqualifyReason` for the far side of the relationship. */
  updateById?: InputMaybe<DisqualifyReasonOnJobsApplicationForJobsApplicationsDisqualifyReasonIdFkeyUsingDisqualifyReasonsPkeyUpdate>;
  /** The primary key(s) and patch data for `disqualifyReason` for the far side of the relationship. */
  updateByNodeId?: InputMaybe<JobsApplicationOnJobsApplicationForJobsApplicationsDisqualifyReasonIdFkeyNodeIdUpdate>;
};

/** Input for the nested mutation of `jobsApplication` in the `DisqualifyReasonInput` mutation. */
export type JobsApplicationsDisqualifyReasonIdFkeyInverseInput = {
  /** The primary key(s) for `jobsApplication` for the far side of the relationship. */
  connectByCandidateIdAndJobId?: InputMaybe<Array<JobsApplicationJobsApplicationsCandidateIdJobIdKeyConnect>>;
  /** The primary key(s) for `jobsApplication` for the far side of the relationship. */
  connectById?: InputMaybe<Array<JobsApplicationJobsApplicationsPkeyConnect>>;
  /** The primary key(s) for `jobsApplication` for the far side of the relationship. */
  connectByNodeId?: InputMaybe<Array<JobsApplicationNodeIdConnect>>;
  /** A `JobsApplicationInput` object that will be created and connected to this object. */
  create?: InputMaybe<Array<JobsApplicationsDisqualifyReasonIdFkeyJobsApplicationsCreateInput>>;
  /** The primary key(s) and patch data for `jobsApplication` for the far side of the relationship. */
  updateByCandidateIdAndJobId?: InputMaybe<Array<JobsApplicationOnJobsApplicationForJobsApplicationsDisqualifyReasonIdFkeyUsingJobsApplicationsCandidateIdJobIdKeyUpdate>>;
  /** The primary key(s) and patch data for `jobsApplication` for the far side of the relationship. */
  updateById?: InputMaybe<Array<JobsApplicationOnJobsApplicationForJobsApplicationsDisqualifyReasonIdFkeyUsingJobsApplicationsPkeyUpdate>>;
  /** The primary key(s) and patch data for `jobsApplication` for the far side of the relationship. */
  updateByNodeId?: InputMaybe<Array<DisqualifyReasonOnJobsApplicationForJobsApplicationsDisqualifyReasonIdFkeyNodeIdUpdate>>;
};

/** The `jobsApplication` to be created by this mutation. */
export type JobsApplicationsDisqualifyReasonIdFkeyJobsApplicationsCreateInput = {
  candidate?: InputMaybe<JobsApplicationsCandidateIdFkeyInput>;
  candidateId?: InputMaybe<Scalars['Int']['input']>;
  coverLetter?: InputMaybe<Scalars['String']['input']>;
  disqualifyReason?: InputMaybe<JobsApplicationsDisqualifyReasonIdFkeyInput>;
  id?: InputMaybe<Scalars['Int']['input']>;
  job?: InputMaybe<JobsApplicationsJobIdFkeyInput>;
  jobId?: InputMaybe<Scalars['Int']['input']>;
  pipelineStage?: InputMaybe<JobsApplicationsPipelineStageIdFkeyInput>;
  pipelineStageId?: InputMaybe<Scalars['Int']['input']>;
};

/** A `JobsApplication` edge in the connection. */
export type JobsApplicationsEdge = {
  __typename?: 'JobsApplicationsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `JobsApplication` at the end of the edge. */
  node: JobsApplication;
};

/** Input for the nested mutation of `job` in the `JobsApplicationInput` mutation. */
export type JobsApplicationsJobIdFkeyInput = {
  /** The primary key(s) for `job` for the far side of the relationship. */
  connectById?: InputMaybe<JobJobsPkeyConnect>;
  /** The primary key(s) for `job` for the far side of the relationship. */
  connectByNodeId?: InputMaybe<JobNodeIdConnect>;
  /** A `JobInput` object that will be created and connected to this object. */
  create?: InputMaybe<JobsApplicationsJobIdFkeyJobsCreateInput>;
  /** The primary key(s) and patch data for `job` for the far side of the relationship. */
  updateById?: InputMaybe<JobOnJobsApplicationForJobsApplicationsJobIdFkeyUsingJobsPkeyUpdate>;
  /** The primary key(s) and patch data for `job` for the far side of the relationship. */
  updateByNodeId?: InputMaybe<JobsApplicationOnJobsApplicationForJobsApplicationsJobIdFkeyNodeIdUpdate>;
};

/** Input for the nested mutation of `jobsApplication` in the `JobInput` mutation. */
export type JobsApplicationsJobIdFkeyInverseInput = {
  /** The primary key(s) for `jobsApplication` for the far side of the relationship. */
  connectByCandidateIdAndJobId?: InputMaybe<Array<JobsApplicationJobsApplicationsCandidateIdJobIdKeyConnect>>;
  /** The primary key(s) for `jobsApplication` for the far side of the relationship. */
  connectById?: InputMaybe<Array<JobsApplicationJobsApplicationsPkeyConnect>>;
  /** The primary key(s) for `jobsApplication` for the far side of the relationship. */
  connectByNodeId?: InputMaybe<Array<JobsApplicationNodeIdConnect>>;
  /** A `JobsApplicationInput` object that will be created and connected to this object. */
  create?: InputMaybe<Array<JobsApplicationsJobIdFkeyJobsApplicationsCreateInput>>;
  /** The primary key(s) and patch data for `jobsApplication` for the far side of the relationship. */
  updateByCandidateIdAndJobId?: InputMaybe<Array<JobsApplicationOnJobsApplicationForJobsApplicationsJobIdFkeyUsingJobsApplicationsCandidateIdJobIdKeyUpdate>>;
  /** The primary key(s) and patch data for `jobsApplication` for the far side of the relationship. */
  updateById?: InputMaybe<Array<JobsApplicationOnJobsApplicationForJobsApplicationsJobIdFkeyUsingJobsApplicationsPkeyUpdate>>;
  /** The primary key(s) and patch data for `jobsApplication` for the far side of the relationship. */
  updateByNodeId?: InputMaybe<Array<JobOnJobsApplicationForJobsApplicationsJobIdFkeyNodeIdUpdate>>;
};

/** The `jobsApplication` to be created by this mutation. */
export type JobsApplicationsJobIdFkeyJobsApplicationsCreateInput = {
  candidate?: InputMaybe<JobsApplicationsCandidateIdFkeyInput>;
  candidateId?: InputMaybe<Scalars['Int']['input']>;
  coverLetter?: InputMaybe<Scalars['String']['input']>;
  disqualifyReason?: InputMaybe<JobsApplicationsDisqualifyReasonIdFkeyInput>;
  disqualifyReasonId?: InputMaybe<Scalars['Int']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  job?: InputMaybe<JobsApplicationsJobIdFkeyInput>;
  pipelineStage?: InputMaybe<JobsApplicationsPipelineStageIdFkeyInput>;
  pipelineStageId?: InputMaybe<Scalars['Int']['input']>;
};

/** The `job` to be created by this mutation. */
export type JobsApplicationsJobIdFkeyJobsCreateInput = {
  address?: InputMaybe<Scalars['String']['input']>;
  applications?: InputMaybe<JobsApplicationsJobIdFkeyInverseInput>;
  city?: InputMaybe<Scalars['String']['input']>;
  competencies?: InputMaybe<Array<Scalars['String']['input']>>;
  country?: InputMaybe<Scalars['Int']['input']>;
  department?: InputMaybe<JobsDepartmentIdFkeyInput>;
  departmentId?: InputMaybe<Scalars['Int']['input']>;
  draftEvaluations?: InputMaybe<DraftEvaluationsJobIdFkeyInverseInput>;
  education?: InputMaybe<JobEducation>;
  evaluations?: InputMaybe<EvaluationsJobIdFkeyInverseInput>;
  fields?: InputMaybe<JobFieldsJobIdFkeyInverseInput>;
  genders?: InputMaybe<Array<InputMaybe<Gender>>>;
  gradeConditions?: InputMaybe<Array<InputMaybe<GradeCondition>>>;
  hoursPerWeek?: InputMaybe<IntRangeInput>;
  isRemote?: InputMaybe<Scalars['Boolean']['input']>;
  jobCompetencies?: InputMaybe<JobCompetenciesJobIdFkeyInverseInput>;
  jobKnowledges?: InputMaybe<JobKnowledgesJobIdFkeyInverseInput>;
  jobQuestionnaires?: InputMaybe<JobQuestionnairesJobIdFkeyInverseInput>;
  jobSkills?: InputMaybe<JobSkillsJobIdFkeyInverseInput>;
  jobTags?: InputMaybe<JobTagsJobIdFkeyInverseInput>;
  knowledges?: InputMaybe<Array<Scalars['String']['input']>>;
  languages: Array<InputMaybe<Language>>;
  maxAgeCondition?: InputMaybe<Scalars['Int']['input']>;
  militaryStatus?: InputMaybe<Array<InputMaybe<MilitaryStatus>>>;
  minAgeCondition?: InputMaybe<Scalars['Int']['input']>;
  owners?: InputMaybe<JobOwnersJobIdFkeyInverseInput>;
  pipeline?: InputMaybe<JobsPipelineIdFkeyInput>;
  pipelineId?: InputMaybe<Scalars['Int']['input']>;
  position: Scalars['Int']['input'];
  publishedAt?: InputMaybe<Scalars['Datetime']['input']>;
  skills?: InputMaybe<Array<Scalars['String']['input']>>;
  state?: InputMaybe<Scalars['Int']['input']>;
  status: JobStatus;
  tags?: InputMaybe<Array<Scalars['String']['input']>>;
  threads?: InputMaybe<ThreadsJobIdFkeyInverseInput>;
  translations?: InputMaybe<JobTranslationsJobIdFkeyInverseInput>;
  workExperienceCondition?: InputMaybe<Scalars['Int']['input']>;
};

/** Methods to use when ordering `JobsApplication`. */
export enum JobsApplicationsOrderBy {
  CandidateIdAsc = 'CANDIDATE_ID_ASC',
  CandidateIdDesc = 'CANDIDATE_ID_DESC',
  CreatedAtAsc = 'CREATED_AT_ASC',
  CreatedAtDesc = 'CREATED_AT_DESC',
  DisqualifiedAtAsc = 'DISQUALIFIED_AT_ASC',
  DisqualifiedAtDesc = 'DISQUALIFIED_AT_DESC',
  DisqualifyReasonIdAsc = 'DISQUALIFY_REASON_ID_ASC',
  DisqualifyReasonIdDesc = 'DISQUALIFY_REASON_ID_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  JobIdAsc = 'JOB_ID_ASC',
  JobIdDesc = 'JOB_ID_DESC',
  Natural = 'NATURAL',
  PipelineStageIdAsc = 'PIPELINE_STAGE_ID_ASC',
  PipelineStageIdDesc = 'PIPELINE_STAGE_ID_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  UpdatedAtAsc = 'UPDATED_AT_ASC',
  UpdatedAtDesc = 'UPDATED_AT_DESC'
}

/** Input for the nested mutation of `pipelineStage` in the `JobsApplicationInput` mutation. */
export type JobsApplicationsPipelineStageIdFkeyInput = {
  /** The primary key(s) for `pipelineStage` for the far side of the relationship. */
  connectById?: InputMaybe<PipelineStagePipelineStagesPkeyConnect>;
  /** The primary key(s) for `pipelineStage` for the far side of the relationship. */
  connectByNodeId?: InputMaybe<PipelineStageNodeIdConnect>;
  /** A `PipelineStageInput` object that will be created and connected to this object. */
  create?: InputMaybe<JobsApplicationsPipelineStageIdFkeyPipelineStagesCreateInput>;
  /** The primary key(s) for `pipelineStage` for the far side of the relationship. */
  deleteById?: InputMaybe<PipelineStagePipelineStagesPkeyDelete>;
  /** The primary key(s) for `pipelineStage` for the far side of the relationship. */
  deleteByNodeId?: InputMaybe<PipelineStageNodeIdDelete>;
  /** The primary key(s) and patch data for `pipelineStage` for the far side of the relationship. */
  updateById?: InputMaybe<PipelineStageOnJobsApplicationForJobsApplicationsPipelineStageIdFkeyUsingPipelineStagesPkeyUpdate>;
  /** The primary key(s) and patch data for `pipelineStage` for the far side of the relationship. */
  updateByNodeId?: InputMaybe<JobsApplicationOnJobsApplicationForJobsApplicationsPipelineStageIdFkeyNodeIdUpdate>;
};

/** Input for the nested mutation of `jobsApplication` in the `PipelineStageInput` mutation. */
export type JobsApplicationsPipelineStageIdFkeyInverseInput = {
  /** The primary key(s) for `jobsApplication` for the far side of the relationship. */
  connectByCandidateIdAndJobId?: InputMaybe<Array<JobsApplicationJobsApplicationsCandidateIdJobIdKeyConnect>>;
  /** The primary key(s) for `jobsApplication` for the far side of the relationship. */
  connectById?: InputMaybe<Array<JobsApplicationJobsApplicationsPkeyConnect>>;
  /** The primary key(s) for `jobsApplication` for the far side of the relationship. */
  connectByNodeId?: InputMaybe<Array<JobsApplicationNodeIdConnect>>;
  /** A `JobsApplicationInput` object that will be created and connected to this object. */
  create?: InputMaybe<Array<JobsApplicationsPipelineStageIdFkeyJobsApplicationsCreateInput>>;
  /** The primary key(s) and patch data for `jobsApplication` for the far side of the relationship. */
  updateByCandidateIdAndJobId?: InputMaybe<Array<JobsApplicationOnJobsApplicationForJobsApplicationsPipelineStageIdFkeyUsingJobsApplicationsCandidateIdJobIdKeyUpdate>>;
  /** The primary key(s) and patch data for `jobsApplication` for the far side of the relationship. */
  updateById?: InputMaybe<Array<JobsApplicationOnJobsApplicationForJobsApplicationsPipelineStageIdFkeyUsingJobsApplicationsPkeyUpdate>>;
  /** The primary key(s) and patch data for `jobsApplication` for the far side of the relationship. */
  updateByNodeId?: InputMaybe<Array<PipelineStageOnJobsApplicationForJobsApplicationsPipelineStageIdFkeyNodeIdUpdate>>;
};

/** The `jobsApplication` to be created by this mutation. */
export type JobsApplicationsPipelineStageIdFkeyJobsApplicationsCreateInput = {
  candidate?: InputMaybe<JobsApplicationsCandidateIdFkeyInput>;
  candidateId?: InputMaybe<Scalars['Int']['input']>;
  coverLetter?: InputMaybe<Scalars['String']['input']>;
  disqualifyReason?: InputMaybe<JobsApplicationsDisqualifyReasonIdFkeyInput>;
  disqualifyReasonId?: InputMaybe<Scalars['Int']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  job?: InputMaybe<JobsApplicationsJobIdFkeyInput>;
  jobId?: InputMaybe<Scalars['Int']['input']>;
  pipelineStage?: InputMaybe<JobsApplicationsPipelineStageIdFkeyInput>;
};

/** The `pipelineStage` to be created by this mutation. */
export type JobsApplicationsPipelineStageIdFkeyPipelineStagesCreateInput = {
  draftEvaluations?: InputMaybe<DraftEvaluationsPipelineStageIdFkeyInverseInput>;
  jobsApplications?: InputMaybe<JobsApplicationsPipelineStageIdFkeyInverseInput>;
  pipeline?: InputMaybe<PipelineStagesPipelineIdFkeyInput>;
  pipelineId?: InputMaybe<Scalars['Int']['input']>;
  position: Scalars['Int']['input'];
  stageScorecards?: InputMaybe<PipelineStageScorecardsPipelineStageIdFkeyInverseInput>;
  stageUsers?: InputMaybe<PipelineStageUsersPipelineStageIdFkeyInverseInput>;
  translations?: InputMaybe<PipelineStageTranslationsPipelineStageIdFkeyInverseInput>;
  type: PipelineStageType;
};

/** A connection to a list of `Job` values. */
export type JobsConnection = {
  __typename?: 'JobsConnection';
  /** A list of edges which contains the `Job` and cursor to aid in pagination. */
  edges: Array<JobsEdge>;
  /** A list of `Job` objects. */
  nodes: Array<Job>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Job` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** The `department` to be created by this mutation. */
export type JobsDepartmentIdFkeyDepartmentsCreateInput = {
  jobs?: InputMaybe<JobsDepartmentIdFkeyInverseInput>;
  translations?: InputMaybe<DepartmentTranslationsDepartmentIdFkeyInverseInput>;
};

/** Input for the nested mutation of `department` in the `JobInput` mutation. */
export type JobsDepartmentIdFkeyInput = {
  /** The primary key(s) for `department` for the far side of the relationship. */
  connectById?: InputMaybe<DepartmentDepartmentsPkeyConnect>;
  /** The primary key(s) for `department` for the far side of the relationship. */
  connectByNodeId?: InputMaybe<DepartmentNodeIdConnect>;
  /** A `DepartmentInput` object that will be created and connected to this object. */
  create?: InputMaybe<JobsDepartmentIdFkeyDepartmentsCreateInput>;
  /** The primary key(s) and patch data for `department` for the far side of the relationship. */
  updateById?: InputMaybe<DepartmentOnJobForJobsDepartmentIdFkeyUsingDepartmentsPkeyUpdate>;
  /** The primary key(s) and patch data for `department` for the far side of the relationship. */
  updateByNodeId?: InputMaybe<JobOnJobForJobsDepartmentIdFkeyNodeIdUpdate>;
};

/** Input for the nested mutation of `job` in the `DepartmentInput` mutation. */
export type JobsDepartmentIdFkeyInverseInput = {
  /** The primary key(s) for `job` for the far side of the relationship. */
  connectById?: InputMaybe<Array<JobJobsPkeyConnect>>;
  /** The primary key(s) for `job` for the far side of the relationship. */
  connectByNodeId?: InputMaybe<Array<JobNodeIdConnect>>;
  /** A `JobInput` object that will be created and connected to this object. */
  create?: InputMaybe<Array<JobsDepartmentIdFkeyJobsCreateInput>>;
  /** The primary key(s) and patch data for `job` for the far side of the relationship. */
  updateById?: InputMaybe<Array<JobOnJobForJobsDepartmentIdFkeyUsingJobsPkeyUpdate>>;
  /** The primary key(s) and patch data for `job` for the far side of the relationship. */
  updateByNodeId?: InputMaybe<Array<DepartmentOnJobForJobsDepartmentIdFkeyNodeIdUpdate>>;
};

/** The `job` to be created by this mutation. */
export type JobsDepartmentIdFkeyJobsCreateInput = {
  address?: InputMaybe<Scalars['String']['input']>;
  applications?: InputMaybe<JobsApplicationsJobIdFkeyInverseInput>;
  city?: InputMaybe<Scalars['String']['input']>;
  competencies?: InputMaybe<Array<Scalars['String']['input']>>;
  country?: InputMaybe<Scalars['Int']['input']>;
  department?: InputMaybe<JobsDepartmentIdFkeyInput>;
  draftEvaluations?: InputMaybe<DraftEvaluationsJobIdFkeyInverseInput>;
  education?: InputMaybe<JobEducation>;
  evaluations?: InputMaybe<EvaluationsJobIdFkeyInverseInput>;
  fields?: InputMaybe<JobFieldsJobIdFkeyInverseInput>;
  genders?: InputMaybe<Array<InputMaybe<Gender>>>;
  gradeConditions?: InputMaybe<Array<InputMaybe<GradeCondition>>>;
  hoursPerWeek?: InputMaybe<IntRangeInput>;
  isRemote?: InputMaybe<Scalars['Boolean']['input']>;
  jobCompetencies?: InputMaybe<JobCompetenciesJobIdFkeyInverseInput>;
  jobKnowledges?: InputMaybe<JobKnowledgesJobIdFkeyInverseInput>;
  jobQuestionnaires?: InputMaybe<JobQuestionnairesJobIdFkeyInverseInput>;
  jobSkills?: InputMaybe<JobSkillsJobIdFkeyInverseInput>;
  jobTags?: InputMaybe<JobTagsJobIdFkeyInverseInput>;
  knowledges?: InputMaybe<Array<Scalars['String']['input']>>;
  languages: Array<InputMaybe<Language>>;
  maxAgeCondition?: InputMaybe<Scalars['Int']['input']>;
  militaryStatus?: InputMaybe<Array<InputMaybe<MilitaryStatus>>>;
  minAgeCondition?: InputMaybe<Scalars['Int']['input']>;
  owners?: InputMaybe<JobOwnersJobIdFkeyInverseInput>;
  pipeline?: InputMaybe<JobsPipelineIdFkeyInput>;
  pipelineId?: InputMaybe<Scalars['Int']['input']>;
  position: Scalars['Int']['input'];
  publishedAt?: InputMaybe<Scalars['Datetime']['input']>;
  skills?: InputMaybe<Array<Scalars['String']['input']>>;
  state?: InputMaybe<Scalars['Int']['input']>;
  status: JobStatus;
  tags?: InputMaybe<Array<Scalars['String']['input']>>;
  threads?: InputMaybe<ThreadsJobIdFkeyInverseInput>;
  translations?: InputMaybe<JobTranslationsJobIdFkeyInverseInput>;
  workExperienceCondition?: InputMaybe<Scalars['Int']['input']>;
};

/** A `Job` edge in the connection. */
export type JobsEdge = {
  __typename?: 'JobsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Job` at the end of the edge. */
  node: Job;
};

/** Methods to use when ordering `Job`. */
export enum JobsOrderBy {
  CreatedAtAsc = 'CREATED_AT_ASC',
  CreatedAtDesc = 'CREATED_AT_DESC',
  DepartmentIdAsc = 'DEPARTMENT_ID_ASC',
  DepartmentIdDesc = 'DEPARTMENT_ID_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  MaxAgeConditionAsc = 'MAX_AGE_CONDITION_ASC',
  MaxAgeConditionDesc = 'MAX_AGE_CONDITION_DESC',
  MinAgeConditionAsc = 'MIN_AGE_CONDITION_ASC',
  MinAgeConditionDesc = 'MIN_AGE_CONDITION_DESC',
  Natural = 'NATURAL',
  PipelineIdAsc = 'PIPELINE_ID_ASC',
  PipelineIdDesc = 'PIPELINE_ID_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  StatusAsc = 'STATUS_ASC',
  StatusDesc = 'STATUS_DESC',
  UpdatedAtAsc = 'UPDATED_AT_ASC',
  UpdatedAtDesc = 'UPDATED_AT_DESC'
}

/** Input for the nested mutation of `pipeline` in the `JobInput` mutation. */
export type JobsPipelineIdFkeyInput = {
  /** The primary key(s) for `pipeline` for the far side of the relationship. */
  connectById?: InputMaybe<PipelinePipelinesPkeyConnect>;
  /** The primary key(s) for `pipeline` for the far side of the relationship. */
  connectByNodeId?: InputMaybe<PipelineNodeIdConnect>;
  /** A `PipelineInput` object that will be created and connected to this object. */
  create?: InputMaybe<JobsPipelineIdFkeyPipelinesCreateInput>;
  /** The primary key(s) and patch data for `pipeline` for the far side of the relationship. */
  updateById?: InputMaybe<PipelineOnJobForJobsPipelineIdFkeyUsingPipelinesPkeyUpdate>;
  /** The primary key(s) and patch data for `pipeline` for the far side of the relationship. */
  updateByNodeId?: InputMaybe<JobOnJobForJobsPipelineIdFkeyNodeIdUpdate>;
};

/** Input for the nested mutation of `job` in the `PipelineInput` mutation. */
export type JobsPipelineIdFkeyInverseInput = {
  /** The primary key(s) for `job` for the far side of the relationship. */
  connectById?: InputMaybe<Array<JobJobsPkeyConnect>>;
  /** The primary key(s) for `job` for the far side of the relationship. */
  connectByNodeId?: InputMaybe<Array<JobNodeIdConnect>>;
  /** A `JobInput` object that will be created and connected to this object. */
  create?: InputMaybe<Array<JobsPipelineIdFkeyJobsCreateInput>>;
  /** The primary key(s) and patch data for `job` for the far side of the relationship. */
  updateById?: InputMaybe<Array<JobOnJobForJobsPipelineIdFkeyUsingJobsPkeyUpdate>>;
  /** The primary key(s) and patch data for `job` for the far side of the relationship. */
  updateByNodeId?: InputMaybe<Array<PipelineOnJobForJobsPipelineIdFkeyNodeIdUpdate>>;
};

/** The `job` to be created by this mutation. */
export type JobsPipelineIdFkeyJobsCreateInput = {
  address?: InputMaybe<Scalars['String']['input']>;
  applications?: InputMaybe<JobsApplicationsJobIdFkeyInverseInput>;
  city?: InputMaybe<Scalars['String']['input']>;
  competencies?: InputMaybe<Array<Scalars['String']['input']>>;
  country?: InputMaybe<Scalars['Int']['input']>;
  department?: InputMaybe<JobsDepartmentIdFkeyInput>;
  departmentId?: InputMaybe<Scalars['Int']['input']>;
  draftEvaluations?: InputMaybe<DraftEvaluationsJobIdFkeyInverseInput>;
  education?: InputMaybe<JobEducation>;
  evaluations?: InputMaybe<EvaluationsJobIdFkeyInverseInput>;
  fields?: InputMaybe<JobFieldsJobIdFkeyInverseInput>;
  genders?: InputMaybe<Array<InputMaybe<Gender>>>;
  gradeConditions?: InputMaybe<Array<InputMaybe<GradeCondition>>>;
  hoursPerWeek?: InputMaybe<IntRangeInput>;
  isRemote?: InputMaybe<Scalars['Boolean']['input']>;
  jobCompetencies?: InputMaybe<JobCompetenciesJobIdFkeyInverseInput>;
  jobKnowledges?: InputMaybe<JobKnowledgesJobIdFkeyInverseInput>;
  jobQuestionnaires?: InputMaybe<JobQuestionnairesJobIdFkeyInverseInput>;
  jobSkills?: InputMaybe<JobSkillsJobIdFkeyInverseInput>;
  jobTags?: InputMaybe<JobTagsJobIdFkeyInverseInput>;
  knowledges?: InputMaybe<Array<Scalars['String']['input']>>;
  languages: Array<InputMaybe<Language>>;
  maxAgeCondition?: InputMaybe<Scalars['Int']['input']>;
  militaryStatus?: InputMaybe<Array<InputMaybe<MilitaryStatus>>>;
  minAgeCondition?: InputMaybe<Scalars['Int']['input']>;
  owners?: InputMaybe<JobOwnersJobIdFkeyInverseInput>;
  pipeline?: InputMaybe<JobsPipelineIdFkeyInput>;
  position: Scalars['Int']['input'];
  publishedAt?: InputMaybe<Scalars['Datetime']['input']>;
  skills?: InputMaybe<Array<Scalars['String']['input']>>;
  state?: InputMaybe<Scalars['Int']['input']>;
  status: JobStatus;
  tags?: InputMaybe<Array<Scalars['String']['input']>>;
  threads?: InputMaybe<ThreadsJobIdFkeyInverseInput>;
  translations?: InputMaybe<JobTranslationsJobIdFkeyInverseInput>;
  workExperienceCondition?: InputMaybe<Scalars['Int']['input']>;
};

/** The `pipeline` to be created by this mutation. */
export type JobsPipelineIdFkeyPipelinesCreateInput = {
  jobs?: InputMaybe<JobsPipelineIdFkeyInverseInput>;
  stages?: InputMaybe<PipelineStagesPipelineIdFkeyInverseInput>;
  translations?: InputMaybe<PipelineTranslationsPipelineIdFkeyInverseInput>;
};

export type JobsWithCompanyDetailsInput = {
  companyId: Scalars['Int']['input'];
};

export type JobsWithCompanyDetailsPayload = {
  __typename?: 'JobsWithCompanyDetailsPayload';
  company: CustomCompany;
  jobs: CustomJobsConnection;
};

export type Knowledge = Node & {
  __typename?: 'Knowledge';
  createdAt: Scalars['Datetime']['output'];
  id: Scalars['Int']['output'];
  /** Reads and enables pagination through a set of `JobKnowledge`. */
  jobKnowledges: JobKnowledgesConnection;
  /** Reads and enables pagination through a set of `Job`. */
  jobs: KnowledgeJobsByJobKnowledgeKnowledgeIdAndJobIdManyToManyConnection;
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  title: Scalars['String']['output'];
};


export type KnowledgeJobKnowledgesArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<JobKnowledgeCondition>;
  filter?: InputMaybe<JobKnowledgeFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<JobKnowledgesOrderBy>>;
};


export type KnowledgeJobsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<JobCondition>;
  filter?: InputMaybe<JobFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<JobsOrderBy>>;
};

/** A condition to be used against `Knowledge` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type KnowledgeCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `title` field. */
  title?: InputMaybe<Scalars['String']['input']>;
};

/** A filter to be used against `Knowledge` object types. All fields are combined with a logical ‘and.’ */
export type KnowledgeFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<KnowledgeFilter>>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<IntFilter>;
  /** Filter by the object’s `jobKnowledges` relation. */
  jobKnowledges?: InputMaybe<KnowledgeToManyJobKnowledgeFilter>;
  /** Some related `jobKnowledges` exist. */
  jobKnowledgesExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Negates the expression. */
  not?: InputMaybe<KnowledgeFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<KnowledgeFilter>>;
  /** Filter by the object’s `title` field. */
  title?: InputMaybe<StringFilter>;
};

/** An input for mutations affecting `Knowledge` */
export type KnowledgeInput = {
  jobKnowledges?: InputMaybe<JobKnowledgesKnowledgeIdFkeyInverseInput>;
  title: Scalars['String']['input'];
};

/** A connection to a list of `Job` values, with data from `JobKnowledge`. */
export type KnowledgeJobsByJobKnowledgeKnowledgeIdAndJobIdManyToManyConnection = {
  __typename?: 'KnowledgeJobsByJobKnowledgeKnowledgeIdAndJobIdManyToManyConnection';
  /** A list of edges which contains the `Job`, info from the `JobKnowledge`, and the cursor to aid in pagination. */
  edges: Array<KnowledgeJobsByJobKnowledgeKnowledgeIdAndJobIdManyToManyEdge>;
  /** A list of `Job` objects. */
  nodes: Array<Job>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Job` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `Job` edge in the connection, with data from `JobKnowledge`. */
export type KnowledgeJobsByJobKnowledgeKnowledgeIdAndJobIdManyToManyEdge = {
  __typename?: 'KnowledgeJobsByJobKnowledgeKnowledgeIdAndJobIdManyToManyEdge';
  createdAt: Scalars['Datetime']['output'];
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Job` at the end of the edge. */
  node: Job;
};

/** The fields on `knowledge` to look up the row to connect. */
export type KnowledgeKnowledgesPkeyConnect = {
  id: Scalars['Int']['input'];
};

/** The globally unique `ID` look up for the row to connect. */
export type KnowledgeNodeIdConnect = {
  /** The globally unique `ID` which identifies a single `knowledge` to be connected. */
  nodeId: Scalars['ID']['input'];
};

/** The globally unique `ID` look up for the row to update. */
export type KnowledgeOnJobKnowledgeForJobKnowledgesKnowledgeIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `jobKnowledge` to be connected. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `jobKnowledge` being updated. */
  patch: JobKnowledgePatch;
};

/** The fields on `knowledge` to look up the row to update. */
export type KnowledgeOnJobKnowledgeForJobKnowledgesKnowledgeIdFkeyUsingKnowledgesPkeyUpdate = {
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `knowledge` being updated. */
  patch: UpdateKnowledgeOnJobKnowledgeForJobKnowledgesKnowledgeIdFkeyPatch;
};

/** Represents an update to a `Knowledge`. Fields that are set will be updated. */
export type KnowledgePatch = {
  jobKnowledges?: InputMaybe<JobKnowledgesKnowledgeIdFkeyInverseInput>;
  title?: InputMaybe<Scalars['String']['input']>;
};

/** A filter to be used against many `JobKnowledge` object types. All fields are combined with a logical ‘and.’ */
export type KnowledgeToManyJobKnowledgeFilter = {
  /** Every related `JobKnowledge` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<JobKnowledgeFilter>;
  /** No related `JobKnowledge` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<JobKnowledgeFilter>;
  /** Some related `JobKnowledge` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<JobKnowledgeFilter>;
};

/** A connection to a list of `Knowledge` values. */
export type KnowledgesConnection = {
  __typename?: 'KnowledgesConnection';
  /** A list of edges which contains the `Knowledge` and cursor to aid in pagination. */
  edges: Array<KnowledgesEdge>;
  /** A list of `Knowledge` objects. */
  nodes: Array<Knowledge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Knowledge` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `Knowledge` edge in the connection. */
export type KnowledgesEdge = {
  __typename?: 'KnowledgesEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Knowledge` at the end of the edge. */
  node: Knowledge;
};

/** Methods to use when ordering `Knowledge`. */
export enum KnowledgesOrderBy {
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  Natural = 'NATURAL',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  TitleAsc = 'TITLE_ASC',
  TitleDesc = 'TITLE_DESC'
}

export enum Language {
  Ar = 'AR',
  En = 'EN',
  Fa = 'FA',
  Ku = 'KU',
  Tr = 'TR'
}

/** All input for the `markThreadAsRead` mutation. */
export type MarkThreadAsReadInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  threadId: Scalars['Int']['input'];
};

/** The output of our `markThreadAsRead` mutation. */
export type MarkThreadAsReadPayload = {
  __typename?: 'MarkThreadAsReadPayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `Thread` that is related to this `ThreadUser`. */
  thread?: Maybe<Thread>;
  threadUser?: Maybe<ThreadUser>;
  /** An edge for our `ThreadUser`. May be used by Relay 1. */
  threadUserEdge?: Maybe<ThreadUsersEdge>;
  /** Reads a single `User` that is related to this `ThreadUser`. */
  user?: Maybe<User>;
};


/** The output of our `markThreadAsRead` mutation. */
export type MarkThreadAsReadPayloadThreadUserEdgeArgs = {
  orderBy?: InputMaybe<Array<ThreadUsersOrderBy>>;
};

export type Message = Node & {
  __typename?: 'Message';
  content: Scalars['Html']['output'];
  createdAt: Scalars['Datetime']['output'];
  externalId: Scalars['UUID']['output'];
  externalMessageId?: Maybe<Scalars['String']['output']>;
  /** Reads and enables pagination through a set of `MessageFile`. */
  files: MessageFilesConnection;
  id: Scalars['Int']['output'];
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  source?: Maybe<Scalars['String']['output']>;
  /** Reads a single `Thread` that is related to this `Message`. */
  thread?: Maybe<Thread>;
  threadId: Scalars['Int']['output'];
  /** Reads a single `User` that is related to this `Message`. */
  user?: Maybe<User>;
  userId?: Maybe<Scalars['Int']['output']>;
};


export type MessageFilesArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<MessageFileCondition>;
  filter?: InputMaybe<MessageFileFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<MessageFilesOrderBy>>;
};

/** A condition to be used against `Message` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type MessageCondition = {
  /** Checks for equality with the object’s `content` field. */
  content?: InputMaybe<Scalars['Html']['input']>;
  /** Checks for equality with the object’s `createdAt` field. */
  createdAt?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `externalId` field. */
  externalId?: InputMaybe<Scalars['UUID']['input']>;
  /** Checks for equality with the object’s `externalMessageId` field. */
  externalMessageId?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `threadId` field. */
  threadId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `userId` field. */
  userId?: InputMaybe<Scalars['Int']['input']>;
};

export type MessageFile = Node & {
  __typename?: 'MessageFile';
  externalId: Scalars['UUID']['output'];
  /** Reads a single `Message` that is related to this `MessageFile`. */
  message?: Maybe<Message>;
  messageId: Scalars['Int']['output'];
  name: Scalars['String']['output'];
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
};

/** A condition to be used against `MessageFile` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type MessageFileCondition = {
  /** Checks for equality with the object’s `externalId` field. */
  externalId?: InputMaybe<Scalars['UUID']['input']>;
  /** Checks for equality with the object’s `messageId` field. */
  messageId?: InputMaybe<Scalars['Int']['input']>;
};

/** A filter to be used against `MessageFile` object types. All fields are combined with a logical ‘and.’ */
export type MessageFileFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<MessageFileFilter>>;
  /** Filter by the object’s `externalId` field. */
  externalId?: InputMaybe<UuidFilter>;
  /** Filter by the object’s `message` relation. */
  message?: InputMaybe<MessageFilter>;
  /** Filter by the object’s `messageId` field. */
  messageId?: InputMaybe<IntFilter>;
  /** Negates the expression. */
  not?: InputMaybe<MessageFileFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<MessageFileFilter>>;
};

/** An input for mutations affecting `MessageFile` */
export type MessageFileInput = {
  externalId: Scalars['UUID']['input'];
  message?: InputMaybe<MessageFilesMessageIdFkeyInput>;
  messageId?: InputMaybe<Scalars['Int']['input']>;
  name: Scalars['String']['input'];
};

/** The fields on `messageFile` to look up the row to connect. */
export type MessageFileMessageFilesPkeyConnect = {
  externalId: Scalars['UUID']['input'];
};

/** The globally unique `ID` look up for the row to connect. */
export type MessageFileNodeIdConnect = {
  /** The globally unique `ID` which identifies a single `messageFile` to be connected. */
  nodeId: Scalars['ID']['input'];
};

/** The globally unique `ID` look up for the row to update. */
export type MessageFileOnMessageFileForMessageFilesMessageIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `message` to be connected. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `message` being updated. */
  patch: MessagePatch;
};

/** The fields on `messageFile` to look up the row to update. */
export type MessageFileOnMessageFileForMessageFilesMessageIdFkeyUsingMessageFilesPkeyUpdate = {
  externalId: Scalars['UUID']['input'];
  /** An object where the defined keys will be set on the `messageFile` being updated. */
  patch: UpdateMessageFileOnMessageFileForMessageFilesMessageIdFkeyPatch;
};

/** Represents an update to a `MessageFile`. Fields that are set will be updated. */
export type MessageFilePatch = {
  message?: InputMaybe<MessageFilesMessageIdFkeyInput>;
  messageId?: InputMaybe<Scalars['Int']['input']>;
};

/** A connection to a list of `MessageFile` values. */
export type MessageFilesConnection = {
  __typename?: 'MessageFilesConnection';
  /** A list of edges which contains the `MessageFile` and cursor to aid in pagination. */
  edges: Array<MessageFilesEdge>;
  /** A list of `MessageFile` objects. */
  nodes: Array<MessageFile>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `MessageFile` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `MessageFile` edge in the connection. */
export type MessageFilesEdge = {
  __typename?: 'MessageFilesEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `MessageFile` at the end of the edge. */
  node: MessageFile;
};

/** Input for the nested mutation of `message` in the `MessageFileInput` mutation. */
export type MessageFilesMessageIdFkeyInput = {
  /** The primary key(s) for `message` for the far side of the relationship. */
  connectByExternalId?: InputMaybe<MessageMessagesExternalIdKeyConnect>;
  /** The primary key(s) for `message` for the far side of the relationship. */
  connectByExternalMessageId?: InputMaybe<MessageMessagesExternalMessageIdKeyConnect>;
  /** The primary key(s) for `message` for the far side of the relationship. */
  connectById?: InputMaybe<MessageMessagesPkeyConnect>;
  /** The primary key(s) for `message` for the far side of the relationship. */
  connectByNodeId?: InputMaybe<MessageNodeIdConnect>;
  /** A `MessageInput` object that will be created and connected to this object. */
  create?: InputMaybe<MessageFilesMessageIdFkeyMessagesCreateInput>;
  /** The primary key(s) and patch data for `message` for the far side of the relationship. */
  updateByExternalId?: InputMaybe<MessageOnMessageFileForMessageFilesMessageIdFkeyUsingMessagesExternalIdKeyUpdate>;
  /** The primary key(s) and patch data for `message` for the far side of the relationship. */
  updateByExternalMessageId?: InputMaybe<MessageOnMessageFileForMessageFilesMessageIdFkeyUsingMessagesExternalMessageIdKeyUpdate>;
  /** The primary key(s) and patch data for `message` for the far side of the relationship. */
  updateById?: InputMaybe<MessageOnMessageFileForMessageFilesMessageIdFkeyUsingMessagesPkeyUpdate>;
  /** The primary key(s) and patch data for `message` for the far side of the relationship. */
  updateByNodeId?: InputMaybe<MessageFileOnMessageFileForMessageFilesMessageIdFkeyNodeIdUpdate>;
};

/** Input for the nested mutation of `messageFile` in the `MessageInput` mutation. */
export type MessageFilesMessageIdFkeyInverseInput = {
  /** The primary key(s) for `messageFile` for the far side of the relationship. */
  connectByExternalId?: InputMaybe<Array<MessageFileMessageFilesPkeyConnect>>;
  /** The primary key(s) for `messageFile` for the far side of the relationship. */
  connectByNodeId?: InputMaybe<Array<MessageFileNodeIdConnect>>;
  /** A `MessageFileInput` object that will be created and connected to this object. */
  create?: InputMaybe<Array<MessageFilesMessageIdFkeyMessageFilesCreateInput>>;
  /** The primary key(s) and patch data for `messageFile` for the far side of the relationship. */
  updateByExternalId?: InputMaybe<Array<MessageFileOnMessageFileForMessageFilesMessageIdFkeyUsingMessageFilesPkeyUpdate>>;
  /** The primary key(s) and patch data for `messageFile` for the far side of the relationship. */
  updateByNodeId?: InputMaybe<Array<MessageOnMessageFileForMessageFilesMessageIdFkeyNodeIdUpdate>>;
};

/** The `messageFile` to be created by this mutation. */
export type MessageFilesMessageIdFkeyMessageFilesCreateInput = {
  externalId: Scalars['UUID']['input'];
  message?: InputMaybe<MessageFilesMessageIdFkeyInput>;
  name: Scalars['String']['input'];
};

/** The `message` to be created by this mutation. */
export type MessageFilesMessageIdFkeyMessagesCreateInput = {
  content: Scalars['Html']['input'];
  externalMessageId?: InputMaybe<Scalars['String']['input']>;
  files?: InputMaybe<MessageFilesMessageIdFkeyInverseInput>;
  source?: InputMaybe<Scalars['String']['input']>;
  thread?: InputMaybe<MessagesThreadIdFkeyInput>;
  threadId?: InputMaybe<Scalars['Int']['input']>;
  user?: InputMaybe<MessagesUserIdFkeyInput>;
  userId?: InputMaybe<Scalars['Int']['input']>;
};

/** Methods to use when ordering `MessageFile`. */
export enum MessageFilesOrderBy {
  ExternalIdAsc = 'EXTERNAL_ID_ASC',
  ExternalIdDesc = 'EXTERNAL_ID_DESC',
  MessageIdAsc = 'MESSAGE_ID_ASC',
  MessageIdDesc = 'MESSAGE_ID_DESC',
  Natural = 'NATURAL',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC'
}

/** A filter to be used against `Message` object types. All fields are combined with a logical ‘and.’ */
export type MessageFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<MessageFilter>>;
  /** Filter by the object’s `content` field. */
  content?: InputMaybe<HtmlFilter>;
  /** Filter by the object’s `createdAt` field. */
  createdAt?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `externalId` field. */
  externalId?: InputMaybe<UuidFilter>;
  /** Filter by the object’s `externalMessageId` field. */
  externalMessageId?: InputMaybe<StringFilter>;
  /** Filter by the object’s `files` relation. */
  files?: InputMaybe<MessageToManyMessageFileFilter>;
  /** Some related `files` exist. */
  filesExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<IntFilter>;
  /** Negates the expression. */
  not?: InputMaybe<MessageFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<MessageFilter>>;
  /** Filter by the object’s `thread` relation. */
  thread?: InputMaybe<ThreadFilter>;
  /** Filter by the object’s `threadId` field. */
  threadId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `user` relation. */
  user?: InputMaybe<UserFilter>;
  /** A related `user` exists. */
  userExists?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `userId` field. */
  userId?: InputMaybe<IntFilter>;
};

/** An input for mutations affecting `Message` */
export type MessageInput = {
  content: Scalars['Html']['input'];
  externalMessageId?: InputMaybe<Scalars['String']['input']>;
  files?: InputMaybe<MessageFilesMessageIdFkeyInverseInput>;
  source?: InputMaybe<Scalars['String']['input']>;
  thread?: InputMaybe<MessagesThreadIdFkeyInput>;
  threadId?: InputMaybe<Scalars['Int']['input']>;
  user?: InputMaybe<MessagesUserIdFkeyInput>;
  userId?: InputMaybe<Scalars['Int']['input']>;
};

/** The fields on `message` to look up the row to connect. */
export type MessageMessagesExternalIdKeyConnect = {
  externalId: Scalars['UUID']['input'];
};

/** The fields on `message` to look up the row to connect. */
export type MessageMessagesExternalMessageIdKeyConnect = {
  externalMessageId: Scalars['String']['input'];
};

/** The fields on `message` to look up the row to connect. */
export type MessageMessagesPkeyConnect = {
  id: Scalars['Int']['input'];
};

/** The globally unique `ID` look up for the row to connect. */
export type MessageNodeIdConnect = {
  /** The globally unique `ID` which identifies a single `message` to be connected. */
  nodeId: Scalars['ID']['input'];
};

/** The globally unique `ID` look up for the row to update. */
export type MessageOnMessageFileForMessageFilesMessageIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `messageFile` to be connected. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `messageFile` being updated. */
  patch: MessageFilePatch;
};

/** The fields on `message` to look up the row to update. */
export type MessageOnMessageFileForMessageFilesMessageIdFkeyUsingMessagesExternalIdKeyUpdate = {
  externalId: Scalars['UUID']['input'];
  /** An object where the defined keys will be set on the `message` being updated. */
  patch: UpdateMessageOnMessageFileForMessageFilesMessageIdFkeyPatch;
};

/** The fields on `message` to look up the row to update. */
export type MessageOnMessageFileForMessageFilesMessageIdFkeyUsingMessagesExternalMessageIdKeyUpdate = {
  externalMessageId: Scalars['String']['input'];
  /** An object where the defined keys will be set on the `message` being updated. */
  patch: UpdateMessageOnMessageFileForMessageFilesMessageIdFkeyPatch;
};

/** The fields on `message` to look up the row to update. */
export type MessageOnMessageFileForMessageFilesMessageIdFkeyUsingMessagesPkeyUpdate = {
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `message` being updated. */
  patch: UpdateMessageOnMessageFileForMessageFilesMessageIdFkeyPatch;
};

/** The globally unique `ID` look up for the row to update. */
export type MessageOnMessageForMessagesThreadIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `thread` to be connected. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `thread` being updated. */
  patch: ThreadPatch;
};

/** The fields on `message` to look up the row to update. */
export type MessageOnMessageForMessagesThreadIdFkeyUsingMessagesExternalIdKeyUpdate = {
  externalId: Scalars['UUID']['input'];
  /** An object where the defined keys will be set on the `message` being updated. */
  patch: UpdateMessageOnMessageForMessagesThreadIdFkeyPatch;
};

/** The fields on `message` to look up the row to update. */
export type MessageOnMessageForMessagesThreadIdFkeyUsingMessagesExternalMessageIdKeyUpdate = {
  externalMessageId: Scalars['String']['input'];
  /** An object where the defined keys will be set on the `message` being updated. */
  patch: UpdateMessageOnMessageForMessagesThreadIdFkeyPatch;
};

/** The fields on `message` to look up the row to update. */
export type MessageOnMessageForMessagesThreadIdFkeyUsingMessagesPkeyUpdate = {
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `message` being updated. */
  patch: UpdateMessageOnMessageForMessagesThreadIdFkeyPatch;
};

/** The globally unique `ID` look up for the row to update. */
export type MessageOnMessageForMessagesUserIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `user` to be connected. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `user` being updated. */
  patch: UserPatch;
};

/** The fields on `message` to look up the row to update. */
export type MessageOnMessageForMessagesUserIdFkeyUsingMessagesExternalIdKeyUpdate = {
  externalId: Scalars['UUID']['input'];
  /** An object where the defined keys will be set on the `message` being updated. */
  patch: UpdateMessageOnMessageForMessagesUserIdFkeyPatch;
};

/** The fields on `message` to look up the row to update. */
export type MessageOnMessageForMessagesUserIdFkeyUsingMessagesExternalMessageIdKeyUpdate = {
  externalMessageId: Scalars['String']['input'];
  /** An object where the defined keys will be set on the `message` being updated. */
  patch: UpdateMessageOnMessageForMessagesUserIdFkeyPatch;
};

/** The fields on `message` to look up the row to update. */
export type MessageOnMessageForMessagesUserIdFkeyUsingMessagesPkeyUpdate = {
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `message` being updated. */
  patch: UpdateMessageOnMessageForMessagesUserIdFkeyPatch;
};

/** Represents an update to a `Message`. Fields that are set will be updated. */
export type MessagePatch = {
  files?: InputMaybe<MessageFilesMessageIdFkeyInverseInput>;
  thread?: InputMaybe<MessagesThreadIdFkeyInput>;
  threadId?: InputMaybe<Scalars['Int']['input']>;
  user?: InputMaybe<MessagesUserIdFkeyInput>;
  userId?: InputMaybe<Scalars['Int']['input']>;
};

/** A filter to be used against many `MessageFile` object types. All fields are combined with a logical ‘and.’ */
export type MessageToManyMessageFileFilter = {
  /** Every related `MessageFile` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<MessageFileFilter>;
  /** No related `MessageFile` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<MessageFileFilter>;
  /** Some related `MessageFile` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<MessageFileFilter>;
};

/** A connection to a list of `Message` values. */
export type MessagesConnection = {
  __typename?: 'MessagesConnection';
  /** A list of edges which contains the `Message` and cursor to aid in pagination. */
  edges: Array<MessagesEdge>;
  /** A list of `Message` objects. */
  nodes: Array<Message>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Message` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `Message` edge in the connection. */
export type MessagesEdge = {
  __typename?: 'MessagesEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Message` at the end of the edge. */
  node: Message;
};

/** Methods to use when ordering `Message`. */
export enum MessagesOrderBy {
  ContentAsc = 'CONTENT_ASC',
  ContentDesc = 'CONTENT_DESC',
  CreatedAtAsc = 'CREATED_AT_ASC',
  CreatedAtDesc = 'CREATED_AT_DESC',
  ExternalIdAsc = 'EXTERNAL_ID_ASC',
  ExternalIdDesc = 'EXTERNAL_ID_DESC',
  ExternalMessageIdAsc = 'EXTERNAL_MESSAGE_ID_ASC',
  ExternalMessageIdDesc = 'EXTERNAL_MESSAGE_ID_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  Natural = 'NATURAL',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  ThreadIdAsc = 'THREAD_ID_ASC',
  ThreadIdDesc = 'THREAD_ID_DESC',
  UserIdAsc = 'USER_ID_ASC',
  UserIdDesc = 'USER_ID_DESC'
}

/** Input for the nested mutation of `thread` in the `MessageInput` mutation. */
export type MessagesThreadIdFkeyInput = {
  /** The primary key(s) for `thread` for the far side of the relationship. */
  connectById?: InputMaybe<ThreadThreadsPkeyConnect>;
  /** The primary key(s) for `thread` for the far side of the relationship. */
  connectByNodeId?: InputMaybe<ThreadNodeIdConnect>;
  /** A `ThreadInput` object that will be created and connected to this object. */
  create?: InputMaybe<MessagesThreadIdFkeyThreadsCreateInput>;
  /** The primary key(s) and patch data for `thread` for the far side of the relationship. */
  updateById?: InputMaybe<ThreadOnMessageForMessagesThreadIdFkeyUsingThreadsPkeyUpdate>;
  /** The primary key(s) and patch data for `thread` for the far side of the relationship. */
  updateByNodeId?: InputMaybe<MessageOnMessageForMessagesThreadIdFkeyNodeIdUpdate>;
};

/** Input for the nested mutation of `message` in the `ThreadInput` mutation. */
export type MessagesThreadIdFkeyInverseInput = {
  /** The primary key(s) for `message` for the far side of the relationship. */
  connectByExternalId?: InputMaybe<Array<MessageMessagesExternalIdKeyConnect>>;
  /** The primary key(s) for `message` for the far side of the relationship. */
  connectByExternalMessageId?: InputMaybe<Array<MessageMessagesExternalMessageIdKeyConnect>>;
  /** The primary key(s) for `message` for the far side of the relationship. */
  connectById?: InputMaybe<Array<MessageMessagesPkeyConnect>>;
  /** The primary key(s) for `message` for the far side of the relationship. */
  connectByNodeId?: InputMaybe<Array<MessageNodeIdConnect>>;
  /** A `MessageInput` object that will be created and connected to this object. */
  create?: InputMaybe<Array<MessagesThreadIdFkeyMessagesCreateInput>>;
  /** The primary key(s) and patch data for `message` for the far side of the relationship. */
  updateByExternalId?: InputMaybe<Array<MessageOnMessageForMessagesThreadIdFkeyUsingMessagesExternalIdKeyUpdate>>;
  /** The primary key(s) and patch data for `message` for the far side of the relationship. */
  updateByExternalMessageId?: InputMaybe<Array<MessageOnMessageForMessagesThreadIdFkeyUsingMessagesExternalMessageIdKeyUpdate>>;
  /** The primary key(s) and patch data for `message` for the far side of the relationship. */
  updateById?: InputMaybe<Array<MessageOnMessageForMessagesThreadIdFkeyUsingMessagesPkeyUpdate>>;
  /** The primary key(s) and patch data for `message` for the far side of the relationship. */
  updateByNodeId?: InputMaybe<Array<ThreadOnMessageForMessagesThreadIdFkeyNodeIdUpdate>>;
};

/** The `message` to be created by this mutation. */
export type MessagesThreadIdFkeyMessagesCreateInput = {
  content: Scalars['Html']['input'];
  externalMessageId?: InputMaybe<Scalars['String']['input']>;
  files?: InputMaybe<MessageFilesMessageIdFkeyInverseInput>;
  source?: InputMaybe<Scalars['String']['input']>;
  thread?: InputMaybe<MessagesThreadIdFkeyInput>;
  user?: InputMaybe<MessagesUserIdFkeyInput>;
  userId?: InputMaybe<Scalars['Int']['input']>;
};

/** The `thread` to be created by this mutation. */
export type MessagesThreadIdFkeyThreadsCreateInput = {
  candidate?: InputMaybe<ThreadsCandidateIdFkeyInput>;
  candidateId?: InputMaybe<Scalars['Int']['input']>;
  emails?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  job?: InputMaybe<ThreadsJobIdFkeyInput>;
  jobId?: InputMaybe<Scalars['Int']['input']>;
  messages?: InputMaybe<MessagesThreadIdFkeyInverseInput>;
  phones?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  senderName?: InputMaybe<Scalars['String']['input']>;
  subject: Scalars['String']['input'];
  threadUsers?: InputMaybe<ThreadUsersThreadIdFkeyInverseInput>;
  user?: InputMaybe<ThreadsUserIdFkeyInput>;
  userId?: InputMaybe<Scalars['Int']['input']>;
};

/** Input for the nested mutation of `user` in the `MessageInput` mutation. */
export type MessagesUserIdFkeyInput = {
  /** The primary key(s) for `user` for the far side of the relationship. */
  connectByEmail?: InputMaybe<UserUsersEmailKeyConnect>;
  /** The primary key(s) for `user` for the far side of the relationship. */
  connectById?: InputMaybe<UserUsersPkeyConnect>;
  /** The primary key(s) for `user` for the far side of the relationship. */
  connectByNodeId?: InputMaybe<UserNodeIdConnect>;
  /** The primary key(s) and patch data for `user` for the far side of the relationship. */
  updateByEmail?: InputMaybe<UserOnMessageForMessagesUserIdFkeyUsingUsersEmailKeyUpdate>;
  /** The primary key(s) and patch data for `user` for the far side of the relationship. */
  updateById?: InputMaybe<UserOnMessageForMessagesUserIdFkeyUsingUsersPkeyUpdate>;
  /** The primary key(s) and patch data for `user` for the far side of the relationship. */
  updateByNodeId?: InputMaybe<MessageOnMessageForMessagesUserIdFkeyNodeIdUpdate>;
};

/** Input for the nested mutation of `message` in the `UserInput` mutation. */
export type MessagesUserIdFkeyInverseInput = {
  /** The primary key(s) for `message` for the far side of the relationship. */
  connectByExternalId?: InputMaybe<Array<MessageMessagesExternalIdKeyConnect>>;
  /** The primary key(s) for `message` for the far side of the relationship. */
  connectByExternalMessageId?: InputMaybe<Array<MessageMessagesExternalMessageIdKeyConnect>>;
  /** The primary key(s) for `message` for the far side of the relationship. */
  connectById?: InputMaybe<Array<MessageMessagesPkeyConnect>>;
  /** The primary key(s) for `message` for the far side of the relationship. */
  connectByNodeId?: InputMaybe<Array<MessageNodeIdConnect>>;
  /** The primary key(s) and patch data for `message` for the far side of the relationship. */
  updateByExternalId?: InputMaybe<Array<MessageOnMessageForMessagesUserIdFkeyUsingMessagesExternalIdKeyUpdate>>;
  /** The primary key(s) and patch data for `message` for the far side of the relationship. */
  updateByExternalMessageId?: InputMaybe<Array<MessageOnMessageForMessagesUserIdFkeyUsingMessagesExternalMessageIdKeyUpdate>>;
  /** The primary key(s) and patch data for `message` for the far side of the relationship. */
  updateById?: InputMaybe<Array<MessageOnMessageForMessagesUserIdFkeyUsingMessagesPkeyUpdate>>;
  /** The primary key(s) and patch data for `message` for the far side of the relationship. */
  updateByNodeId?: InputMaybe<Array<UserOnMessageForMessagesUserIdFkeyNodeIdUpdate>>;
};

export enum MilitaryStatus {
  Completion = 'COMPLETION',
  EducationExemption = 'EDUCATION_EXEMPTION',
  MedicalExemption = 'MEDICAL_EXEMPTION',
  PermanentExemption = 'PERMANENT_EXEMPTION'
}

/** A filter to be used against MilitaryStatus fields. All fields are combined with a logical ‘and.’ */
export type MilitaryStatusFilter = {
  /** Not equal to the specified value, treating null like an ordinary value. */
  distinctFrom?: InputMaybe<MilitaryStatus>;
  /** Equal to the specified value. */
  equalTo?: InputMaybe<MilitaryStatus>;
  /** Greater than the specified value. */
  greaterThan?: InputMaybe<MilitaryStatus>;
  /** Greater than or equal to the specified value. */
  greaterThanOrEqualTo?: InputMaybe<MilitaryStatus>;
  /** Included in the specified list. */
  in?: InputMaybe<Array<MilitaryStatus>>;
  /** Is null (if `true` is specified) or is not null (if `false` is specified). */
  isNull?: InputMaybe<Scalars['Boolean']['input']>;
  /** Less than the specified value. */
  lessThan?: InputMaybe<MilitaryStatus>;
  /** Less than or equal to the specified value. */
  lessThanOrEqualTo?: InputMaybe<MilitaryStatus>;
  /** Equal to the specified value, treating null like an ordinary value. */
  notDistinctFrom?: InputMaybe<MilitaryStatus>;
  /** Not equal to the specified value. */
  notEqualTo?: InputMaybe<MilitaryStatus>;
  /** Not included in the specified list. */
  notIn?: InputMaybe<Array<MilitaryStatus>>;
};

/** All input for the `moveJobApplication` mutation. */
export type MoveJobApplicationInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  newId?: InputMaybe<Scalars['Int']['input']>;
  stageId?: InputMaybe<Scalars['Int']['input']>;
};

/** The output of our `moveJobApplication` mutation. */
export type MoveJobApplicationPayload = {
  __typename?: 'MoveJobApplicationPayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  jobsApplications?: Maybe<Array<JobsApplication>>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};

/** All input for the `movePipelineStage` mutation. */
export type MovePipelineStageInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
  newPosition: Scalars['Int']['input'];
};

/** The output of our `movePipelineStage` mutation. */
export type MovePipelineStagePayload = {
  __typename?: 'MovePipelineStagePayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  pipelineStages?: Maybe<Array<PipelineStage>>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};

export type MoveTempFileInput = {
  externalId: Scalars['UUID']['input'];
  fileType: ExternalFileType;
};

export type MoveTempFilePayload = {
  __typename?: 'MoveTempFilePayload';
  status: Scalars['Boolean']['output'];
};

/** The root mutation type which contains root level fields which mutate data. */
export type Mutation = {
  __typename?: 'Mutation';
  acceptInvitation?: Maybe<AcceptInvitationPayload>;
  assignJobs?: Maybe<AssignJobsPayload>;
  copyFileToTemp?: Maybe<CopyFileToTempPayload>;
  /** Creates a single `Candidate`. */
  createCandidate?: Maybe<CreateCandidatePayload>;
  /** Creates a single `CandidateFile`. */
  createCandidateFile?: Maybe<CreateCandidateFilePayload>;
  /** Creates a single `CandidateImport`. */
  createCandidateImport?: Maybe<CreateCandidateImportPayload>;
  /** Creates a single `CandidateImportCandidate`. */
  createCandidateImportCandidate?: Maybe<CreateCandidateImportCandidatePayload>;
  /** Creates a single `CandidateImportFile`. */
  createCandidateImportFile?: Maybe<CreateCandidateImportFilePayload>;
  /** Creates a single `CandidateQuestion`. */
  createCandidateQuestion?: Maybe<CreateCandidateQuestionPayload>;
  /** Creates a single `CandidateQuestionnaire`. */
  createCandidateQuestionnaire?: Maybe<CreateCandidateQuestionnairePayload>;
  /** Creates a single `CandidateTag`. */
  createCandidateTag?: Maybe<CreateCandidateTagPayload>;
  /** Creates a single `CandidateTranslation`. */
  createCandidateTranslation?: Maybe<CreateCandidateTranslationPayload>;
  createCompany?: Maybe<CreateCompanyPayload>;
  /** Creates a single `CompanyUser`. */
  createCompanyUser?: Maybe<CreateCompanyUserPayload>;
  /** @deprecated Use create_user_token + create_company_user_token_by_company_id */
  createCompanyUserToken?: Maybe<CreateCompanyUserTokenPayload>;
  createCompanyUserTokenByCompanyId?: Maybe<CreateCompanyUserTokenByCompanyIdPayload>;
  /** Creates a single `Competency`. */
  createCompetency?: Maybe<CreateCompetencyPayload>;
  createCustomPayment?: Maybe<CreateCustomJobfairPaymentPayload>;
  /** Creates a single `Department`. */
  createDepartment?: Maybe<CreateDepartmentPayload>;
  /** Creates a single `DepartmentTranslation`. */
  createDepartmentTranslation?: Maybe<CreateDepartmentTranslationPayload>;
  /** Creates a single `DisqualifyReason`. */
  createDisqualifyReason?: Maybe<CreateDisqualifyReasonPayload>;
  /** Creates a single `DisqualifyReasonTranslation`. */
  createDisqualifyReasonTranslation?: Maybe<CreateDisqualifyReasonTranslationPayload>;
  /** Creates a single `Evaluation`. */
  createEvaluation?: Maybe<CreateEvaluationPayload>;
  /** Creates a single `EvaluationScorecard`. */
  createEvaluationScorecard?: Maybe<CreateEvaluationScorecardPayload>;
  /** Creates a single `EvaluationScorecardCriteria`. */
  createEvaluationScorecardCriteria?: Maybe<CreateEvaluationScorecardCriteriaPayload>;
  /** Creates a single `Event`. */
  createEvent?: Maybe<CreateEventPayload>;
  /** Creates a single `EventCandidate`. */
  createEventCandidate?: Maybe<CreateEventCandidatePayload>;
  /** Creates a single `EventScorecard`. */
  createEventScorecard?: Maybe<CreateEventScorecardPayload>;
  /** Creates a single `EventUser`. */
  createEventUser?: Maybe<CreateEventUserPayload>;
  /** Creates a single `Field`. */
  createField?: Maybe<CreateFieldPayload>;
  createForgotPasswordToken?: Maybe<CreateForgotPasswordTokenPayload>;
  /** Creates a single `Invoice`. */
  createInvoice?: Maybe<CreateInvoicePayload>;
  /** Creates a single `Job`. */
  createJob?: Maybe<CreateJobPayload>;
  createJobApplicationPublic?: Maybe<CreateJobApplicationPublicPayload>;
  /** Creates a single `JobCompetency`. */
  createJobCompetency?: Maybe<CreateJobCompetencyPayload>;
  /** Creates a single `JobKnowledge`. */
  createJobKnowledge?: Maybe<CreateJobKnowledgePayload>;
  /** Creates a single `JobOwner`. */
  createJobOwner?: Maybe<CreateJobOwnerPayload>;
  /** Creates a single `JobQuestionnaire`. */
  createJobQuestionnaire?: Maybe<CreateJobQuestionnairePayload>;
  /** Creates a single `JobSkill`. */
  createJobSkill?: Maybe<CreateJobSkillPayload>;
  /** Creates a single `JobTag`. */
  createJobTag?: Maybe<CreateJobTagPayload>;
  /** Creates a single `JobTranslation`. */
  createJobTranslation?: Maybe<CreateJobTranslationPayload>;
  /** Creates a single `JobsApplication`. */
  createJobsApplication?: Maybe<CreateJobsApplicationPayload>;
  /** Creates a single `Knowledge`. */
  createKnowledge?: Maybe<CreateKnowledgePayload>;
  /** Creates a single `Message`. */
  createMessage?: Maybe<CreateMessagePayload>;
  /** Creates a single `MessageFile`. */
  createMessageFile?: Maybe<CreateMessageFilePayload>;
  createPaymentLink?: Maybe<CreatePaymentLinkPaylod>;
  /** Creates a single `Pipeline`. */
  createPipeline?: Maybe<CreatePipelinePayload>;
  /** Creates a single `PipelineStage`. */
  createPipelineStage?: Maybe<CreatePipelineStagePayload>;
  /** Creates a single `PipelineStageScorecard`. */
  createPipelineStageScorecard?: Maybe<CreatePipelineStageScorecardPayload>;
  /** Creates a single `PipelineStageTranslation`. */
  createPipelineStageTranslation?: Maybe<CreatePipelineStageTranslationPayload>;
  /** Creates a single `PipelineStageUser`. */
  createPipelineStageUser?: Maybe<CreatePipelineStageUserPayload>;
  /** Creates a single `PipelineTranslation`. */
  createPipelineTranslation?: Maybe<CreatePipelineTranslationPayload>;
  createPresignedUploadLink?: Maybe<CreatePresignedUploadLinkPayload>;
  /** Creates a single `Question`. */
  createQuestion?: Maybe<CreateQuestionPayload>;
  /** Creates a single `QuestionOption`. */
  createQuestionOption?: Maybe<CreateQuestionOptionPayload>;
  /** Creates a single `QuestionOptionTranslation`. */
  createQuestionOptionTranslation?: Maybe<CreateQuestionOptionTranslationPayload>;
  /** Creates a single `QuestionTranslation`. */
  createQuestionTranslation?: Maybe<CreateQuestionTranslationPayload>;
  /** Creates a single `Questionnaire`. */
  createQuestionnaire?: Maybe<CreateQuestionnairePayload>;
  /** Creates a single `QuestionnaireQuestion`. */
  createQuestionnaireQuestion?: Maybe<CreateQuestionnaireQuestionPayload>;
  /** Creates a single `QuestionnaireTranslation`. */
  createQuestionnaireTranslation?: Maybe<CreateQuestionnaireTranslationPayload>;
  /** Creates a single `Role`. */
  createRole?: Maybe<CreateRolePayload>;
  /** Creates a single `RoleTranslation`. */
  createRoleTranslation?: Maybe<CreateRoleTranslationPayload>;
  /** Creates a single `Scorecard`. */
  createScorecard?: Maybe<CreateScorecardPayload>;
  /** Creates a single `ScorecardCriteria`. */
  createScorecardCriteria?: Maybe<CreateScorecardCriteriaPayload>;
  /** Creates a single `ScorecardCriteriaTranslation`. */
  createScorecardCriteriaTranslation?: Maybe<CreateScorecardCriteriaTranslationPayload>;
  /** Creates a single `ScorecardTranslation`. */
  createScorecardTranslation?: Maybe<CreateScorecardTranslationPayload>;
  /** Creates a single `Skill`. */
  createSkill?: Maybe<CreateSkillPayload>;
  /** Creates a single `Tag`. */
  createTag?: Maybe<CreateTagPayload>;
  /** Creates a single `Thread`. */
  createThread?: Maybe<CreateThreadPayload>;
  /** Creates a single `ThreadUser`. */
  createThreadUser?: Maybe<CreateThreadUserPayload>;
  /** Creates a single `UserInvitation`. */
  createUserInvitation?: Maybe<CreateUserInvitationPayload>;
  createUserToken?: Maybe<CreateUserTokenPayload>;
  /** Creates a single `UserTranslation`. */
  createUserTranslation?: Maybe<CreateUserTranslationPayload>;
  /** Creates a single `WebsiteFile`. */
  createWebsiteFile?: Maybe<CreateWebsiteFilePayload>;
  /** Deletes a single `CandidateFile` using a unique key. */
  deleteCandidateFile?: Maybe<DeleteCandidateFilePayload>;
  /** Deletes a single `CandidateFile` using its globally unique id. */
  deleteCandidateFileByNodeId?: Maybe<DeleteCandidateFilePayload>;
  /** Deletes a single `CandidateTag` using a unique key. */
  deleteCandidateTag?: Maybe<DeleteCandidateTagPayload>;
  /** Deletes a single `CandidateTag` using its globally unique id. */
  deleteCandidateTagByNodeId?: Maybe<DeleteCandidateTagPayload>;
  /** Deletes a single `CandidateTranslation` using a unique key. */
  deleteCandidateTranslation?: Maybe<DeleteCandidateTranslationPayload>;
  /** Deletes a single `CandidateTranslation` using its globally unique id. */
  deleteCandidateTranslationByNodeId?: Maybe<DeleteCandidateTranslationPayload>;
  /** Deletes a single `CompanyUser` using its globally unique id. */
  deleteCompanyUserByNodeId?: Maybe<DeleteCompanyUserPayload>;
  deleteCompanyUserToken?: Maybe<DeleteCompanyUserTokenPayload>;
  /** Deletes a single `DepartmentTranslation` using a unique key. */
  deleteDepartmentTranslation?: Maybe<DeleteDepartmentTranslationPayload>;
  /** Deletes a single `DepartmentTranslation` using its globally unique id. */
  deleteDepartmentTranslationByNodeId?: Maybe<DeleteDepartmentTranslationPayload>;
  /** Deletes a single `DisqualifyReasonTranslation` using a unique key. */
  deleteDisqualifyReasonTranslation?: Maybe<DeleteDisqualifyReasonTranslationPayload>;
  /** Deletes a single `DisqualifyReasonTranslation` using its globally unique id. */
  deleteDisqualifyReasonTranslationByNodeId?: Maybe<DeleteDisqualifyReasonTranslationPayload>;
  /** Deletes a single `EventCandidate` using its globally unique id. */
  deleteEventCandidateByNodeId?: Maybe<DeleteEventCandidatePayload>;
  /** Deletes a single `EventScorecard` using its globally unique id. */
  deleteEventScorecardByNodeId?: Maybe<DeleteEventScorecardPayload>;
  /** Deletes a single `EventUser` using its globally unique id. */
  deleteEventUserByNodeId?: Maybe<DeleteEventUserPayload>;
  /** Deletes a single `Field` using a unique key. */
  deleteField?: Maybe<DeleteFieldPayload>;
  /** Deletes a single `Field` using its globally unique id. */
  deleteFieldByNodeId?: Maybe<DeleteFieldPayload>;
  /** Deletes a single `JobCompetency` using a unique key. */
  deleteJobCompetency?: Maybe<DeleteJobCompetencyPayload>;
  /** Deletes a single `JobCompetency` using its globally unique id. */
  deleteJobCompetencyByNodeId?: Maybe<DeleteJobCompetencyPayload>;
  /** Deletes a single `JobKnowledge` using a unique key. */
  deleteJobKnowledge?: Maybe<DeleteJobKnowledgePayload>;
  /** Deletes a single `JobKnowledge` using its globally unique id. */
  deleteJobKnowledgeByNodeId?: Maybe<DeleteJobKnowledgePayload>;
  /** Deletes a single `JobOwner` using a unique key. */
  deleteJobOwner?: Maybe<DeleteJobOwnerPayload>;
  /** Deletes a single `JobOwner` using its globally unique id. */
  deleteJobOwnerByNodeId?: Maybe<DeleteJobOwnerPayload>;
  /** Deletes a single `JobSkill` using a unique key. */
  deleteJobSkill?: Maybe<DeleteJobSkillPayload>;
  /** Deletes a single `JobSkill` using its globally unique id. */
  deleteJobSkillByNodeId?: Maybe<DeleteJobSkillPayload>;
  /** Deletes a single `JobTag` using a unique key. */
  deleteJobTag?: Maybe<DeleteJobTagPayload>;
  /** Deletes a single `JobTag` using its globally unique id. */
  deleteJobTagByNodeId?: Maybe<DeleteJobTagPayload>;
  /** Deletes a single `JobTranslation` using a unique key. */
  deleteJobTranslation?: Maybe<DeleteJobTranslationPayload>;
  /** Deletes a single `JobTranslation` using its globally unique id. */
  deleteJobTranslationByNodeId?: Maybe<DeleteJobTranslationPayload>;
  /** Deletes a single `PipelineStage` using a unique key. */
  deletePipelineStage?: Maybe<DeletePipelineStagePayload>;
  /** Deletes a single `PipelineStage` using its globally unique id. */
  deletePipelineStageByNodeId?: Maybe<DeletePipelineStagePayload>;
  /** Deletes a single `PipelineStageScorecard` using a unique key. */
  deletePipelineStageScorecard?: Maybe<DeletePipelineStageScorecardPayload>;
  /** Deletes a single `PipelineStageScorecard` using its globally unique id. */
  deletePipelineStageScorecardByNodeId?: Maybe<DeletePipelineStageScorecardPayload>;
  /** Deletes a single `PipelineStageTranslation` using a unique key. */
  deletePipelineStageTranslation?: Maybe<DeletePipelineStageTranslationPayload>;
  /** Deletes a single `PipelineStageTranslation` using its globally unique id. */
  deletePipelineStageTranslationByNodeId?: Maybe<DeletePipelineStageTranslationPayload>;
  /** Deletes a single `PipelineStageUser` using a unique key. */
  deletePipelineStageUser?: Maybe<DeletePipelineStageUserPayload>;
  /** Deletes a single `PipelineStageUser` using its globally unique id. */
  deletePipelineStageUserByNodeId?: Maybe<DeletePipelineStageUserPayload>;
  /** Deletes a single `PipelineTranslation` using a unique key. */
  deletePipelineTranslation?: Maybe<DeletePipelineTranslationPayload>;
  /** Deletes a single `PipelineTranslation` using its globally unique id. */
  deletePipelineTranslationByNodeId?: Maybe<DeletePipelineTranslationPayload>;
  /** Deletes a single `QuestionOption` using a unique key. */
  deleteQuestionOption?: Maybe<DeleteQuestionOptionPayload>;
  /** Deletes a single `QuestionOption` using its globally unique id. */
  deleteQuestionOptionByNodeId?: Maybe<DeleteQuestionOptionPayload>;
  /** Deletes a single `QuestionOptionTranslation` using a unique key. */
  deleteQuestionOptionTranslation?: Maybe<DeleteQuestionOptionTranslationPayload>;
  /** Deletes a single `QuestionOptionTranslation` using its globally unique id. */
  deleteQuestionOptionTranslationByNodeId?: Maybe<DeleteQuestionOptionTranslationPayload>;
  /** Deletes a single `QuestionTranslation` using a unique key. */
  deleteQuestionTranslation?: Maybe<DeleteQuestionTranslationPayload>;
  /** Deletes a single `QuestionTranslation` using its globally unique id. */
  deleteQuestionTranslationByNodeId?: Maybe<DeleteQuestionTranslationPayload>;
  /** Deletes a single `QuestionnaireQuestion` using a unique key. */
  deleteQuestionnaireQuestion?: Maybe<DeleteQuestionnaireQuestionPayload>;
  /** Deletes a single `QuestionnaireQuestion` using its globally unique id. */
  deleteQuestionnaireQuestionByNodeId?: Maybe<DeleteQuestionnaireQuestionPayload>;
  /** Deletes a single `QuestionnaireTranslation` using a unique key. */
  deleteQuestionnaireTranslation?: Maybe<DeleteQuestionnaireTranslationPayload>;
  /** Deletes a single `QuestionnaireTranslation` using its globally unique id. */
  deleteQuestionnaireTranslationByNodeId?: Maybe<DeleteQuestionnaireTranslationPayload>;
  /** Deletes a single `RoleTranslation` using a unique key. */
  deleteRoleTranslation?: Maybe<DeleteRoleTranslationPayload>;
  /** Deletes a single `RoleTranslation` using its globally unique id. */
  deleteRoleTranslationByNodeId?: Maybe<DeleteRoleTranslationPayload>;
  /** Deletes a single `ScorecardCriteriaTranslation` using a unique key. */
  deleteScorecardCriteriaTranslation?: Maybe<DeleteScorecardCriteriaTranslationPayload>;
  /** Deletes a single `ScorecardCriteriaTranslation` using its globally unique id. */
  deleteScorecardCriteriaTranslationByNodeId?: Maybe<DeleteScorecardCriteriaTranslationPayload>;
  /** Deletes a single `ScorecardTranslation` using a unique key. */
  deleteScorecardTranslation?: Maybe<DeleteScorecardTranslationPayload>;
  /** Deletes a single `ScorecardTranslation` using its globally unique id. */
  deleteScorecardTranslationByNodeId?: Maybe<DeleteScorecardTranslationPayload>;
  /** Deletes a single `UserTranslation` using a unique key. */
  deleteUserTranslation?: Maybe<DeleteUserTranslationPayload>;
  /** Deletes a single `UserTranslation` using its globally unique id. */
  deleteUserTranslationByNodeId?: Maybe<DeleteUserTranslationPayload>;
  /** Deletes a single `WebsiteFile` using a unique key. */
  deleteWebsiteFile?: Maybe<DeleteWebsiteFilePayload>;
  /** Deletes a single `WebsiteFile` using its globally unique id. */
  deleteWebsiteFileByNodeId?: Maybe<DeleteWebsiteFilePayload>;
  disableUserFromCompany?: Maybe<DisableUserFromCompanyPayload>;
  markThreadAsRead?: Maybe<MarkThreadAsReadPayload>;
  moveJobApplication?: Maybe<MoveJobApplicationPayload>;
  movePipelineStage?: Maybe<MovePipelineStagePayload>;
  moveTempFile?: Maybe<MoveTempFilePayload>;
  registerInvitationUser?: Maybe<RegisterInvitationUserPayload>;
  registerUser?: Maybe<RegisterUserPayload>;
  revokeInvitation?: Maybe<RevokeInvitationPayload>;
  /** Updates a single `Candidate` using a unique key and a patch. */
  updateCandidate?: Maybe<UpdateCandidatePayload>;
  /** Updates a single `Candidate` using its globally unique id and a patch. */
  updateCandidateByNodeId?: Maybe<UpdateCandidatePayload>;
  /** Updates a single `CandidateTranslation` using a unique key and a patch. */
  updateCandidateTranslation?: Maybe<UpdateCandidateTranslationPayload>;
  /** Updates a single `CandidateTranslation` using its globally unique id and a patch. */
  updateCandidateTranslationByNodeId?: Maybe<UpdateCandidateTranslationPayload>;
  updateCompany?: Maybe<UpdateCompanyPayload>;
  /** Updates a single `CompanyUser` using its globally unique id and a patch. */
  updateCompanyUserByNodeId?: Maybe<UpdateCompanyUserPayload>;
  /** Updates a single `DepartmentTranslation` using a unique key and a patch. */
  updateDepartmentTranslation?: Maybe<UpdateDepartmentTranslationPayload>;
  /** Updates a single `DepartmentTranslation` using its globally unique id and a patch. */
  updateDepartmentTranslationByNodeId?: Maybe<UpdateDepartmentTranslationPayload>;
  updateDepartment__?: Maybe<UpdateDepartmentPayload__>;
  /** Updates a single `DisqualifyReason` using a unique key and a patch. */
  updateDisqualifyReason?: Maybe<UpdateDisqualifyReasonPayload>;
  /** Updates a single `DisqualifyReason` using its globally unique id and a patch. */
  updateDisqualifyReasonByNodeId?: Maybe<UpdateDisqualifyReasonPayload>;
  /** Updates a single `DisqualifyReasonTranslation` using a unique key and a patch. */
  updateDisqualifyReasonTranslation?: Maybe<UpdateDisqualifyReasonTranslationPayload>;
  /** Updates a single `DisqualifyReasonTranslation` using its globally unique id and a patch. */
  updateDisqualifyReasonTranslationByNodeId?: Maybe<UpdateDisqualifyReasonTranslationPayload>;
  /** Updates a single `Event` using a unique key and a patch. */
  updateEvent?: Maybe<UpdateEventPayload>;
  /** Updates a single `Event` using its globally unique id and a patch. */
  updateEventByNodeId?: Maybe<UpdateEventPayload>;
  /** Updates a single `EventCandidate` using its globally unique id and a patch. */
  updateEventCandidateByNodeId?: Maybe<UpdateEventCandidatePayload>;
  /** Updates a single `Field` using a unique key and a patch. */
  updateField?: Maybe<UpdateFieldPayload>;
  /** Updates a single `Field` using its globally unique id and a patch. */
  updateFieldByNodeId?: Maybe<UpdateFieldPayload>;
  /** Updates a single `Invoice` using a unique key and a patch. */
  updateInvoice?: Maybe<UpdateInvoicePayload>;
  /** Updates a single `Invoice` using its globally unique id and a patch. */
  updateInvoiceByNodeId?: Maybe<UpdateInvoicePayload>;
  /** Updates a single `Job` using a unique key and a patch. */
  updateJob?: Maybe<UpdateJobPayload>;
  /** Updates a single `Job` using its globally unique id and a patch. */
  updateJobByNodeId?: Maybe<UpdateJobPayload>;
  /** Updates a single `JobTranslation` using a unique key and a patch. */
  updateJobTranslation?: Maybe<UpdateJobTranslationPayload>;
  /** Updates a single `JobTranslation` using its globally unique id and a patch. */
  updateJobTranslationByNodeId?: Maybe<UpdateJobTranslationPayload>;
  updateJob__?: Maybe<UpdateJobPayload__>;
  /** Updates a single `JobsApplication` using a unique key and a patch. */
  updateJobsApplication?: Maybe<UpdateJobsApplicationPayload>;
  /** Updates a single `JobsApplication` using a unique key and a patch. */
  updateJobsApplicationByCandidateIdAndJobId?: Maybe<UpdateJobsApplicationPayload>;
  /** Updates a single `JobsApplication` using its globally unique id and a patch. */
  updateJobsApplicationByNodeId?: Maybe<UpdateJobsApplicationPayload>;
  updatePasswordByToken?: Maybe<UpdatePasswordByTokenPayload>;
  updatePipeline?: Maybe<UpdatePipelinePayload>;
  /** Updates a single `PipelineStage` using a unique key and a patch. */
  updatePipelineStage?: Maybe<UpdatePipelineStagePayload>;
  /** Updates a single `PipelineStage` using its globally unique id and a patch. */
  updatePipelineStageByNodeId?: Maybe<UpdatePipelineStagePayload>;
  /** Updates a single `PipelineStageScorecard` using a unique key and a patch. */
  updatePipelineStageScorecard?: Maybe<UpdatePipelineStageScorecardPayload>;
  /** Updates a single `PipelineStageScorecard` using its globally unique id and a patch. */
  updatePipelineStageScorecardByNodeId?: Maybe<UpdatePipelineStageScorecardPayload>;
  /** Updates a single `PipelineStageTranslation` using a unique key and a patch. */
  updatePipelineStageTranslation?: Maybe<UpdatePipelineStageTranslationPayload>;
  /** Updates a single `PipelineStageTranslation` using its globally unique id and a patch. */
  updatePipelineStageTranslationByNodeId?: Maybe<UpdatePipelineStageTranslationPayload>;
  /** Updates a single `PipelineStageUser` using a unique key and a patch. */
  updatePipelineStageUser?: Maybe<UpdatePipelineStageUserPayload>;
  /** Updates a single `PipelineStageUser` using its globally unique id and a patch. */
  updatePipelineStageUserByNodeId?: Maybe<UpdatePipelineStageUserPayload>;
  /** Updates a single `PipelineTranslation` using a unique key and a patch. */
  updatePipelineTranslation?: Maybe<UpdatePipelineTranslationPayload>;
  /** Updates a single `PipelineTranslation` using its globally unique id and a patch. */
  updatePipelineTranslationByNodeId?: Maybe<UpdatePipelineTranslationPayload>;
  /** Updates a single `Question` using a unique key and a patch. */
  updateQuestion?: Maybe<UpdateQuestionPayload>;
  /** Updates a single `Question` using its globally unique id and a patch. */
  updateQuestionByNodeId?: Maybe<UpdateQuestionPayload>;
  /** Updates a single `QuestionOption` using a unique key and a patch. */
  updateQuestionOption?: Maybe<UpdateQuestionOptionPayload>;
  /** Updates a single `QuestionOption` using its globally unique id and a patch. */
  updateQuestionOptionByNodeId?: Maybe<UpdateQuestionOptionPayload>;
  /** Updates a single `QuestionOptionTranslation` using a unique key and a patch. */
  updateQuestionOptionTranslation?: Maybe<UpdateQuestionOptionTranslationPayload>;
  /** Updates a single `QuestionOptionTranslation` using its globally unique id and a patch. */
  updateQuestionOptionTranslationByNodeId?: Maybe<UpdateQuestionOptionTranslationPayload>;
  /** Updates a single `QuestionTranslation` using a unique key and a patch. */
  updateQuestionTranslation?: Maybe<UpdateQuestionTranslationPayload>;
  /** Updates a single `QuestionTranslation` using its globally unique id and a patch. */
  updateQuestionTranslationByNodeId?: Maybe<UpdateQuestionTranslationPayload>;
  /** Updates a single `Questionnaire` using a unique key and a patch. */
  updateQuestionnaire?: Maybe<UpdateQuestionnairePayload>;
  /** Updates a single `Questionnaire` using its globally unique id and a patch. */
  updateQuestionnaireByNodeId?: Maybe<UpdateQuestionnairePayload>;
  /** Updates a single `QuestionnaireQuestion` using a unique key and a patch. */
  updateQuestionnaireQuestion?: Maybe<UpdateQuestionnaireQuestionPayload>;
  /** Updates a single `QuestionnaireQuestion` using its globally unique id and a patch. */
  updateQuestionnaireQuestionByNodeId?: Maybe<UpdateQuestionnaireQuestionPayload>;
  /** Updates a single `QuestionnaireTranslation` using a unique key and a patch. */
  updateQuestionnaireTranslation?: Maybe<UpdateQuestionnaireTranslationPayload>;
  /** Updates a single `QuestionnaireTranslation` using its globally unique id and a patch. */
  updateQuestionnaireTranslationByNodeId?: Maybe<UpdateQuestionnaireTranslationPayload>;
  /** Updates a single `Role` using a unique key and a patch. */
  updateRole?: Maybe<UpdateRolePayload>;
  /** Updates a single `Role` using its globally unique id and a patch. */
  updateRoleByNodeId?: Maybe<UpdateRolePayload>;
  /** Updates a single `RoleTranslation` using a unique key and a patch. */
  updateRoleTranslation?: Maybe<UpdateRoleTranslationPayload>;
  /** Updates a single `RoleTranslation` using its globally unique id and a patch. */
  updateRoleTranslationByNodeId?: Maybe<UpdateRoleTranslationPayload>;
  /** Updates a single `ScorecardCriteria` using a unique key and a patch. */
  updateScorecardCriteria?: Maybe<UpdateScorecardCriteriaPayload>;
  /** Updates a single `ScorecardCriteria` using its globally unique id and a patch. */
  updateScorecardCriteriaByNodeId?: Maybe<UpdateScorecardCriteriaPayload>;
  /** Updates a single `ScorecardCriteriaTranslation` using a unique key and a patch. */
  updateScorecardCriteriaTranslation?: Maybe<UpdateScorecardCriteriaTranslationPayload>;
  /** Updates a single `ScorecardCriteriaTranslation` using its globally unique id and a patch. */
  updateScorecardCriteriaTranslationByNodeId?: Maybe<UpdateScorecardCriteriaTranslationPayload>;
  /** Updates a single `ScorecardTranslation` using a unique key and a patch. */
  updateScorecardTranslation?: Maybe<UpdateScorecardTranslationPayload>;
  /** Updates a single `ScorecardTranslation` using its globally unique id and a patch. */
  updateScorecardTranslationByNodeId?: Maybe<UpdateScorecardTranslationPayload>;
  /** Updates a single `User` using a unique key and a patch. */
  updateUser?: Maybe<UpdateUserPayload>;
  /** Updates a single `User` using a unique key and a patch. */
  updateUserByEmail?: Maybe<UpdateUserPayload>;
  /** Updates a single `User` using its globally unique id and a patch. */
  updateUserByNodeId?: Maybe<UpdateUserPayload>;
  /** Updates a single `UserInvitation` using a unique key and a patch. */
  updateUserInvitation?: Maybe<UpdateUserInvitationPayload>;
  /** Updates a single `UserInvitation` using its globally unique id and a patch. */
  updateUserInvitationByNodeId?: Maybe<UpdateUserInvitationPayload>;
  /** Updates a single `UserInvitation` using a unique key and a patch. */
  updateUserInvitationByToken?: Maybe<UpdateUserInvitationPayload>;
  updateUserSettings?: Maybe<UpdateUserSettingsPayload>;
  /** Updates a single `UserTranslation` using a unique key and a patch. */
  updateUserTranslation?: Maybe<UpdateUserTranslationPayload>;
  /** Updates a single `UserTranslation` using its globally unique id and a patch. */
  updateUserTranslationByNodeId?: Maybe<UpdateUserTranslationPayload>;
  /** Updates a single `Website` using a unique key and a patch. */
  updateWebsite?: Maybe<UpdateWebsitePayload>;
  /** Updates a single `Website` using a unique key and a patch. */
  updateWebsiteByHost?: Maybe<UpdateWebsitePayload>;
  /** Updates a single `Website` using its globally unique id and a patch. */
  updateWebsiteByNodeId?: Maybe<UpdateWebsitePayload>;
  updateWebsite__?: Maybe<UpdateWebsitePayload__>;
  verifyEmail?: Maybe<VerifyEmailPayload>;
  verifyPayment?: Maybe<VerifyPaymentPayload>;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationAcceptInvitationArgs = {
  input: AcceptInvitationInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationAssignJobsArgs = {
  input: AssignJobsInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCopyFileToTempArgs = {
  input: CopyFileToTempInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateCandidateArgs = {
  input: CreateCandidateInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateCandidateFileArgs = {
  input: CreateCandidateFileInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateCandidateImportArgs = {
  input: CreateCandidateImportInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateCandidateImportCandidateArgs = {
  input: CreateCandidateImportCandidateInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateCandidateImportFileArgs = {
  input: CreateCandidateImportFileInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateCandidateQuestionArgs = {
  input: CreateCandidateQuestionInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateCandidateQuestionnaireArgs = {
  input: CreateCandidateQuestionnaireInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateCandidateTagArgs = {
  input: CreateCandidateTagInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateCandidateTranslationArgs = {
  input: CreateCandidateTranslationInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateCompanyArgs = {
  input: CreateCompanyInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateCompanyUserArgs = {
  input: CreateCompanyUserInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateCompanyUserTokenArgs = {
  input: CreateCompanyUserTokenInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateCompanyUserTokenByCompanyIdArgs = {
  input: CreateCompanyUserTokenByCompanyIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateCompetencyArgs = {
  input: CreateCompetencyInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateDepartmentArgs = {
  input: CreateDepartmentInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateDepartmentTranslationArgs = {
  input: CreateDepartmentTranslationInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateDisqualifyReasonArgs = {
  input: CreateDisqualifyReasonInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateDisqualifyReasonTranslationArgs = {
  input: CreateDisqualifyReasonTranslationInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateEvaluationArgs = {
  input: CreateEvaluationInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateEvaluationScorecardArgs = {
  input: CreateEvaluationScorecardInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateEvaluationScorecardCriteriaArgs = {
  input: CreateEvaluationScorecardCriteriaInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateEventArgs = {
  input: CreateEventInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateEventCandidateArgs = {
  input: CreateEventCandidateInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateEventScorecardArgs = {
  input: CreateEventScorecardInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateEventUserArgs = {
  input: CreateEventUserInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateFieldArgs = {
  input: CreateFieldInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateForgotPasswordTokenArgs = {
  input: CreateForgotPasswordTokenInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateInvoiceArgs = {
  input: CreateInvoiceInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateJobArgs = {
  input: CreateJobInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateJobApplicationPublicArgs = {
  input: CreateJobApplicationPublicInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateJobCompetencyArgs = {
  input: CreateJobCompetencyInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateJobKnowledgeArgs = {
  input: CreateJobKnowledgeInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateJobOwnerArgs = {
  input: CreateJobOwnerInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateJobQuestionnaireArgs = {
  input: CreateJobQuestionnaireInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateJobSkillArgs = {
  input: CreateJobSkillInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateJobTagArgs = {
  input: CreateJobTagInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateJobTranslationArgs = {
  input: CreateJobTranslationInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateJobsApplicationArgs = {
  input: CreateJobsApplicationInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateKnowledgeArgs = {
  input: CreateKnowledgeInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateMessageArgs = {
  input: CreateMessageInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateMessageFileArgs = {
  input: CreateMessageFileInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreatePaymentLinkArgs = {
  input: CreatePaymentLinkInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreatePipelineArgs = {
  input: CreatePipelineInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreatePipelineStageArgs = {
  input: CreatePipelineStageInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreatePipelineStageScorecardArgs = {
  input: CreatePipelineStageScorecardInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreatePipelineStageTranslationArgs = {
  input: CreatePipelineStageTranslationInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreatePipelineStageUserArgs = {
  input: CreatePipelineStageUserInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreatePipelineTranslationArgs = {
  input: CreatePipelineTranslationInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreatePresignedUploadLinkArgs = {
  input: CreatePresignedUploadLinkInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateQuestionArgs = {
  input: CreateQuestionInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateQuestionOptionArgs = {
  input: CreateQuestionOptionInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateQuestionOptionTranslationArgs = {
  input: CreateQuestionOptionTranslationInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateQuestionTranslationArgs = {
  input: CreateQuestionTranslationInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateQuestionnaireArgs = {
  input: CreateQuestionnaireInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateQuestionnaireQuestionArgs = {
  input: CreateQuestionnaireQuestionInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateQuestionnaireTranslationArgs = {
  input: CreateQuestionnaireTranslationInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateRoleArgs = {
  input: CreateRoleInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateRoleTranslationArgs = {
  input: CreateRoleTranslationInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateScorecardArgs = {
  input: CreateScorecardInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateScorecardCriteriaArgs = {
  input: CreateScorecardCriteriaInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateScorecardCriteriaTranslationArgs = {
  input: CreateScorecardCriteriaTranslationInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateScorecardTranslationArgs = {
  input: CreateScorecardTranslationInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateSkillArgs = {
  input: CreateSkillInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateTagArgs = {
  input: CreateTagInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateThreadArgs = {
  input: CreateThreadInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateThreadUserArgs = {
  input: CreateThreadUserInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateUserInvitationArgs = {
  input: CreateUserInvitationInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateUserTokenArgs = {
  input: CreateUserTokenInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateUserTranslationArgs = {
  input: CreateUserTranslationInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateWebsiteFileArgs = {
  input: CreateWebsiteFileInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteCandidateFileArgs = {
  input: DeleteCandidateFileInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteCandidateFileByNodeIdArgs = {
  input: DeleteCandidateFileByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteCandidateTagArgs = {
  input: DeleteCandidateTagInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteCandidateTagByNodeIdArgs = {
  input: DeleteCandidateTagByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteCandidateTranslationArgs = {
  input: DeleteCandidateTranslationInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteCandidateTranslationByNodeIdArgs = {
  input: DeleteCandidateTranslationByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteCompanyUserByNodeIdArgs = {
  input: DeleteCompanyUserByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteCompanyUserTokenArgs = {
  input: DeleteCompanyUserTokenInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteDepartmentTranslationArgs = {
  input: DeleteDepartmentTranslationInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteDepartmentTranslationByNodeIdArgs = {
  input: DeleteDepartmentTranslationByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteDisqualifyReasonTranslationArgs = {
  input: DeleteDisqualifyReasonTranslationInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteDisqualifyReasonTranslationByNodeIdArgs = {
  input: DeleteDisqualifyReasonTranslationByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteEventCandidateByNodeIdArgs = {
  input: DeleteEventCandidateByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteEventScorecardByNodeIdArgs = {
  input: DeleteEventScorecardByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteEventUserByNodeIdArgs = {
  input: DeleteEventUserByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteFieldArgs = {
  input: DeleteFieldInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteFieldByNodeIdArgs = {
  input: DeleteFieldByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteJobCompetencyArgs = {
  input: DeleteJobCompetencyInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteJobCompetencyByNodeIdArgs = {
  input: DeleteJobCompetencyByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteJobKnowledgeArgs = {
  input: DeleteJobKnowledgeInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteJobKnowledgeByNodeIdArgs = {
  input: DeleteJobKnowledgeByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteJobOwnerArgs = {
  input: DeleteJobOwnerInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteJobOwnerByNodeIdArgs = {
  input: DeleteJobOwnerByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteJobSkillArgs = {
  input: DeleteJobSkillInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteJobSkillByNodeIdArgs = {
  input: DeleteJobSkillByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteJobTagArgs = {
  input: DeleteJobTagInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteJobTagByNodeIdArgs = {
  input: DeleteJobTagByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteJobTranslationArgs = {
  input: DeleteJobTranslationInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteJobTranslationByNodeIdArgs = {
  input: DeleteJobTranslationByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeletePipelineStageArgs = {
  input: DeletePipelineStageInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeletePipelineStageByNodeIdArgs = {
  input: DeletePipelineStageByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeletePipelineStageScorecardArgs = {
  input: DeletePipelineStageScorecardInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeletePipelineStageScorecardByNodeIdArgs = {
  input: DeletePipelineStageScorecardByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeletePipelineStageTranslationArgs = {
  input: DeletePipelineStageTranslationInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeletePipelineStageTranslationByNodeIdArgs = {
  input: DeletePipelineStageTranslationByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeletePipelineStageUserArgs = {
  input: DeletePipelineStageUserInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeletePipelineStageUserByNodeIdArgs = {
  input: DeletePipelineStageUserByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeletePipelineTranslationArgs = {
  input: DeletePipelineTranslationInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeletePipelineTranslationByNodeIdArgs = {
  input: DeletePipelineTranslationByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteQuestionOptionArgs = {
  input: DeleteQuestionOptionInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteQuestionOptionByNodeIdArgs = {
  input: DeleteQuestionOptionByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteQuestionOptionTranslationArgs = {
  input: DeleteQuestionOptionTranslationInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteQuestionOptionTranslationByNodeIdArgs = {
  input: DeleteQuestionOptionTranslationByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteQuestionTranslationArgs = {
  input: DeleteQuestionTranslationInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteQuestionTranslationByNodeIdArgs = {
  input: DeleteQuestionTranslationByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteQuestionnaireQuestionArgs = {
  input: DeleteQuestionnaireQuestionInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteQuestionnaireQuestionByNodeIdArgs = {
  input: DeleteQuestionnaireQuestionByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteQuestionnaireTranslationArgs = {
  input: DeleteQuestionnaireTranslationInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteQuestionnaireTranslationByNodeIdArgs = {
  input: DeleteQuestionnaireTranslationByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteRoleTranslationArgs = {
  input: DeleteRoleTranslationInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteRoleTranslationByNodeIdArgs = {
  input: DeleteRoleTranslationByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteScorecardCriteriaTranslationArgs = {
  input: DeleteScorecardCriteriaTranslationInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteScorecardCriteriaTranslationByNodeIdArgs = {
  input: DeleteScorecardCriteriaTranslationByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteScorecardTranslationArgs = {
  input: DeleteScorecardTranslationInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteScorecardTranslationByNodeIdArgs = {
  input: DeleteScorecardTranslationByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteUserTranslationArgs = {
  input: DeleteUserTranslationInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteUserTranslationByNodeIdArgs = {
  input: DeleteUserTranslationByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteWebsiteFileArgs = {
  input: DeleteWebsiteFileInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteWebsiteFileByNodeIdArgs = {
  input: DeleteWebsiteFileByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDisableUserFromCompanyArgs = {
  input: DisableUserFromCompanyInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationMarkThreadAsReadArgs = {
  input: MarkThreadAsReadInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationMoveJobApplicationArgs = {
  input: MoveJobApplicationInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationMovePipelineStageArgs = {
  input: MovePipelineStageInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationMoveTempFileArgs = {
  input: MoveTempFileInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationRegisterInvitationUserArgs = {
  input: RegisterInvitationUserInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationRegisterUserArgs = {
  input: RegisterUserInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationRevokeInvitationArgs = {
  input: RevokeInvitationInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateCandidateArgs = {
  input: UpdateCandidateInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateCandidateByNodeIdArgs = {
  input: UpdateCandidateByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateCandidateTranslationArgs = {
  input: UpdateCandidateTranslationInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateCandidateTranslationByNodeIdArgs = {
  input: UpdateCandidateTranslationByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateCompanyArgs = {
  input: UpdateCompanyInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateCompanyUserByNodeIdArgs = {
  input: UpdateCompanyUserByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateDepartmentTranslationArgs = {
  input: UpdateDepartmentTranslationInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateDepartmentTranslationByNodeIdArgs = {
  input: UpdateDepartmentTranslationByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateDepartment__Args = {
  input: UpdateDepartmentInput__;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateDisqualifyReasonArgs = {
  input: UpdateDisqualifyReasonInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateDisqualifyReasonByNodeIdArgs = {
  input: UpdateDisqualifyReasonByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateDisqualifyReasonTranslationArgs = {
  input: UpdateDisqualifyReasonTranslationInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateDisqualifyReasonTranslationByNodeIdArgs = {
  input: UpdateDisqualifyReasonTranslationByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateEventArgs = {
  input: UpdateEventInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateEventByNodeIdArgs = {
  input: UpdateEventByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateEventCandidateByNodeIdArgs = {
  input: UpdateEventCandidateByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateFieldArgs = {
  input: UpdateFieldInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateFieldByNodeIdArgs = {
  input: UpdateFieldByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateInvoiceArgs = {
  input: UpdateInvoiceInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateInvoiceByNodeIdArgs = {
  input: UpdateInvoiceByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateJobArgs = {
  input: UpdateJobInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateJobByNodeIdArgs = {
  input: UpdateJobByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateJobTranslationArgs = {
  input: UpdateJobTranslationInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateJobTranslationByNodeIdArgs = {
  input: UpdateJobTranslationByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateJob__Args = {
  input: UpdateJobInput__;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateJobsApplicationArgs = {
  input: UpdateJobsApplicationInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateJobsApplicationByCandidateIdAndJobIdArgs = {
  input: UpdateJobsApplicationByCandidateIdAndJobIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateJobsApplicationByNodeIdArgs = {
  input: UpdateJobsApplicationByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdatePasswordByTokenArgs = {
  input: UpdatePasswordByTokenInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdatePipelineArgs = {
  input: UpdatePipelineInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdatePipelineStageArgs = {
  input: UpdatePipelineStageInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdatePipelineStageByNodeIdArgs = {
  input: UpdatePipelineStageByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdatePipelineStageScorecardArgs = {
  input: UpdatePipelineStageScorecardInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdatePipelineStageScorecardByNodeIdArgs = {
  input: UpdatePipelineStageScorecardByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdatePipelineStageTranslationArgs = {
  input: UpdatePipelineStageTranslationInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdatePipelineStageTranslationByNodeIdArgs = {
  input: UpdatePipelineStageTranslationByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdatePipelineStageUserArgs = {
  input: UpdatePipelineStageUserInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdatePipelineStageUserByNodeIdArgs = {
  input: UpdatePipelineStageUserByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdatePipelineTranslationArgs = {
  input: UpdatePipelineTranslationInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdatePipelineTranslationByNodeIdArgs = {
  input: UpdatePipelineTranslationByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateQuestionArgs = {
  input: UpdateQuestionInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateQuestionByNodeIdArgs = {
  input: UpdateQuestionByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateQuestionOptionArgs = {
  input: UpdateQuestionOptionInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateQuestionOptionByNodeIdArgs = {
  input: UpdateQuestionOptionByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateQuestionOptionTranslationArgs = {
  input: UpdateQuestionOptionTranslationInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateQuestionOptionTranslationByNodeIdArgs = {
  input: UpdateQuestionOptionTranslationByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateQuestionTranslationArgs = {
  input: UpdateQuestionTranslationInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateQuestionTranslationByNodeIdArgs = {
  input: UpdateQuestionTranslationByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateQuestionnaireArgs = {
  input: UpdateQuestionnaireInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateQuestionnaireByNodeIdArgs = {
  input: UpdateQuestionnaireByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateQuestionnaireQuestionArgs = {
  input: UpdateQuestionnaireQuestionInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateQuestionnaireQuestionByNodeIdArgs = {
  input: UpdateQuestionnaireQuestionByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateQuestionnaireTranslationArgs = {
  input: UpdateQuestionnaireTranslationInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateQuestionnaireTranslationByNodeIdArgs = {
  input: UpdateQuestionnaireTranslationByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateRoleArgs = {
  input: UpdateRoleInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateRoleByNodeIdArgs = {
  input: UpdateRoleByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateRoleTranslationArgs = {
  input: UpdateRoleTranslationInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateRoleTranslationByNodeIdArgs = {
  input: UpdateRoleTranslationByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateScorecardCriteriaArgs = {
  input: UpdateScorecardCriteriaInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateScorecardCriteriaByNodeIdArgs = {
  input: UpdateScorecardCriteriaByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateScorecardCriteriaTranslationArgs = {
  input: UpdateScorecardCriteriaTranslationInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateScorecardCriteriaTranslationByNodeIdArgs = {
  input: UpdateScorecardCriteriaTranslationByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateScorecardTranslationArgs = {
  input: UpdateScorecardTranslationInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateScorecardTranslationByNodeIdArgs = {
  input: UpdateScorecardTranslationByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateUserArgs = {
  input: UpdateUserInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateUserByEmailArgs = {
  input: UpdateUserByEmailInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateUserByNodeIdArgs = {
  input: UpdateUserByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateUserInvitationArgs = {
  input: UpdateUserInvitationInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateUserInvitationByNodeIdArgs = {
  input: UpdateUserInvitationByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateUserInvitationByTokenArgs = {
  input: UpdateUserInvitationByTokenInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateUserSettingsArgs = {
  input: UpdateUserSettingsInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateUserTranslationArgs = {
  input: UpdateUserTranslationInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateUserTranslationByNodeIdArgs = {
  input: UpdateUserTranslationByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateWebsiteArgs = {
  input: UpdateWebsiteInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateWebsiteByHostArgs = {
  input: UpdateWebsiteByHostInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateWebsiteByNodeIdArgs = {
  input: UpdateWebsiteByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateWebsite__Args = {
  input: UpdateWebsiteInput__;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationVerifyEmailArgs = {
  input: VerifyEmailInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationVerifyPaymentArgs = {
  input: VerifyPaymentInput;
};

/** An object with a globally unique `ID`. */
export type Node = {
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
};

/** Information about pagination in a connection. */
export type PageInfo = {
  __typename?: 'PageInfo';
  /** When paginating forwards, the cursor to continue. */
  endCursor?: Maybe<Scalars['Cursor']['output']>;
  /** When paginating forwards, are there more items? */
  hasNextPage: Scalars['Boolean']['output'];
  /** When paginating backwards, are there more items? */
  hasPreviousPage: Scalars['Boolean']['output'];
  /** When paginating backwards, the cursor to continue. */
  startCursor?: Maybe<Scalars['Cursor']['output']>;
};

export type Pipeline = Node & {
  __typename?: 'Pipeline';
  createdAt: Scalars['Datetime']['output'];
  /** Reads and enables pagination through a set of `Department`. */
  departments: PipelineDepartmentsByJobPipelineIdAndDepartmentIdManyToManyConnection;
  id: Scalars['Int']['output'];
  /** Reads and enables pagination through a set of `Job`. */
  jobs: JobsConnection;
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  /** Reads and enables pagination through a set of `PipelineStage`. */
  stages: PipelineStagesConnection;
  /** Reads and enables pagination through a set of `PipelineTranslation`. */
  translations: PipelineTranslationsConnection;
  updatedAt: Scalars['Datetime']['output'];
};


export type PipelineDepartmentsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<DepartmentCondition>;
  filter?: InputMaybe<DepartmentFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<DepartmentsOrderBy>>;
};


export type PipelineJobsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<JobCondition>;
  filter?: InputMaybe<JobFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<JobsOrderBy>>;
};


export type PipelineStagesArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<PipelineStageCondition>;
  filter?: InputMaybe<PipelineStageFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<PipelineStagesOrderBy>>;
};


export type PipelineTranslationsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<PipelineTranslationCondition>;
  filter?: InputMaybe<PipelineTranslationFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<PipelineTranslationsOrderBy>>;
};

/** A condition to be used against `Pipeline` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type PipelineCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['Int']['input']>;
};

/** A connection to a list of `Department` values, with data from `Job`. */
export type PipelineDepartmentsByJobPipelineIdAndDepartmentIdManyToManyConnection = {
  __typename?: 'PipelineDepartmentsByJobPipelineIdAndDepartmentIdManyToManyConnection';
  /** A list of edges which contains the `Department`, info from the `Job`, and the cursor to aid in pagination. */
  edges: Array<PipelineDepartmentsByJobPipelineIdAndDepartmentIdManyToManyEdge>;
  /** A list of `Department` objects. */
  nodes: Array<Department>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Department` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `Department` edge in the connection, with data from `Job`. */
export type PipelineDepartmentsByJobPipelineIdAndDepartmentIdManyToManyEdge = {
  __typename?: 'PipelineDepartmentsByJobPipelineIdAndDepartmentIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** Reads and enables pagination through a set of `Job`. */
  jobs: JobsConnection;
  /** The `Department` at the end of the edge. */
  node: Department;
};


/** A `Department` edge in the connection, with data from `Job`. */
export type PipelineDepartmentsByJobPipelineIdAndDepartmentIdManyToManyEdgeJobsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<JobCondition>;
  filter?: InputMaybe<JobFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<JobsOrderBy>>;
};

/** A filter to be used against `Pipeline` object types. All fields are combined with a logical ‘and.’ */
export type PipelineFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<PipelineFilter>>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<IntFilter>;
  /** Filter by the object’s `jobs` relation. */
  jobs?: InputMaybe<PipelineToManyJobFilter>;
  /** Some related `jobs` exist. */
  jobsExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Negates the expression. */
  not?: InputMaybe<PipelineFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<PipelineFilter>>;
  /** Filter by the object’s `stages` relation. */
  stages?: InputMaybe<PipelineToManyPipelineStageFilter>;
  /** Some related `stages` exist. */
  stagesExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `translations` relation. */
  translations?: InputMaybe<PipelineToManyPipelineTranslationFilter>;
  /** Some related `translations` exist. */
  translationsExist?: InputMaybe<Scalars['Boolean']['input']>;
};

/** An input for mutations affecting `Pipeline` */
export type PipelineInput = {
  jobs?: InputMaybe<JobsPipelineIdFkeyInverseInput>;
  stages?: InputMaybe<PipelineStagesPipelineIdFkeyInverseInput>;
  translations?: InputMaybe<PipelineTranslationsPipelineIdFkeyInverseInput>;
};

/** The globally unique `ID` look up for the row to connect. */
export type PipelineNodeIdConnect = {
  /** The globally unique `ID` which identifies a single `pipeline` to be connected. */
  nodeId: Scalars['ID']['input'];
};

/** The globally unique `ID` look up for the row to update. */
export type PipelineOnJobForJobsPipelineIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `job` to be connected. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `job` being updated. */
  patch: JobPatch;
};

/** The fields on `pipeline` to look up the row to update. */
export type PipelineOnJobForJobsPipelineIdFkeyUsingPipelinesPkeyUpdate = {
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `pipeline` being updated. */
  patch: UpdatePipelineOnJobForJobsPipelineIdFkeyPatch;
};

/** The globally unique `ID` look up for the row to update. */
export type PipelineOnPipelineStageForPipelineStagesPipelineIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `pipelineStage` to be connected. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `pipelineStage` being updated. */
  patch: PipelineStagePatch;
};

/** The fields on `pipeline` to look up the row to update. */
export type PipelineOnPipelineStageForPipelineStagesPipelineIdFkeyUsingPipelinesPkeyUpdate = {
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `pipeline` being updated. */
  patch: UpdatePipelineOnPipelineStageForPipelineStagesPipelineIdFkeyPatch;
};

/** The globally unique `ID` look up for the row to update. */
export type PipelineOnPipelineTranslationForPipelineTranslationsPipelineIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `pipelineTranslation` to be connected. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `pipelineTranslation` being updated. */
  patch: PipelineTranslationPatch;
};

/** The fields on `pipeline` to look up the row to update. */
export type PipelineOnPipelineTranslationForPipelineTranslationsPipelineIdFkeyUsingPipelinesPkeyUpdate = {
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `pipeline` being updated. */
  patch: UpdatePipelineOnPipelineTranslationForPipelineTranslationsPipelineIdFkeyPatch;
};

/** Represents an update to a `Pipeline`. Fields that are set will be updated. */
export type PipelinePatch = {
  jobs?: InputMaybe<JobsPipelineIdFkeyInverseInput>;
  stages?: InputMaybe<PipelineStagesPipelineIdFkeyInverseInput>;
  translations?: InputMaybe<PipelineTranslationsPipelineIdFkeyInverseInput>;
};

/** The fields on `pipeline` to look up the row to connect. */
export type PipelinePipelinesPkeyConnect = {
  id: Scalars['Int']['input'];
};

export type PipelineSpeedByJobsReport = {
  __typename?: 'PipelineSpeedByJobsReport';
  jobId: Scalars['Int']['output'];
  stageStats: Array<PipelineSpeedByJobsStageStat>;
};

export type PipelineSpeedByJobsStageStat = {
  __typename?: 'PipelineSpeedByJobsStageStat';
  avgSeconds: Scalars['Int']['output'];
  maxSeconds: Scalars['Int']['output'];
  minSeconds: Scalars['Int']['output'];
  pipelineStageId: Scalars['Int']['output'];
};

export type PipelineStage = Node & {
  __typename?: 'PipelineStage';
  /** Reads and enables pagination through a set of `Candidate`. */
  candidates: PipelineStageCandidatesByJobsApplicationPipelineStageIdAndCandidateIdManyToManyConnection;
  createdAt: Scalars['Datetime']['output'];
  /** Reads and enables pagination through a set of `DisqualifyReason`. */
  disqualifyReasons: PipelineStageDisqualifyReasonsByJobsApplicationPipelineStageIdAndDisqualifyReasonIdManyToManyConnection;
  /** Reads and enables pagination through a set of `DraftEvaluation`. */
  draftEvaluations: DraftEvaluationsConnection;
  id: Scalars['Int']['output'];
  /** Reads and enables pagination through a set of `Job`. */
  jobs: PipelineStageJobsByJobsApplicationPipelineStageIdAndJobIdManyToManyConnection;
  /** Reads and enables pagination through a set of `JobsApplication`. */
  jobsApplications: JobsApplicationsConnection;
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  /** Reads a single `Pipeline` that is related to this `PipelineStage`. */
  pipeline?: Maybe<Pipeline>;
  pipelineId: Scalars['Int']['output'];
  position: Scalars['Int']['output'];
  /** Reads and enables pagination through a set of `Scorecard`. */
  scorecards: PipelineStageScorecardsByPipelineStageScorecardPipelineStageIdAndScorecardIdManyToManyConnection;
  /** Reads and enables pagination through a set of `PipelineStageScorecard`. */
  stageScorecards: PipelineStageScorecardsConnection;
  /** Reads and enables pagination through a set of `PipelineStageUser`. */
  stageUsers: PipelineStageUsersConnection;
  /** Reads and enables pagination through a set of `PipelineStageTranslation`. */
  translations: PipelineStageTranslationsConnection;
  type: PipelineStageType;
  updatedAt: Scalars['Datetime']['output'];
  /** Reads and enables pagination through a set of `User`. */
  users: PipelineStageUsersByPipelineStageUserPipelineStageIdAndUserIdManyToManyConnection;
};


export type PipelineStageCandidatesArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<CandidateCondition>;
  filter?: InputMaybe<CandidateFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<CandidatesOrderBy>>;
};


export type PipelineStageDisqualifyReasonsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<DisqualifyReasonCondition>;
  filter?: InputMaybe<DisqualifyReasonFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<DisqualifyReasonsOrderBy>>;
};


export type PipelineStageDraftEvaluationsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<DraftEvaluationCondition>;
  filter?: InputMaybe<DraftEvaluationFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<DraftEvaluationsOrderBy>>;
};


export type PipelineStageJobsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<JobCondition>;
  filter?: InputMaybe<JobFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<JobsOrderBy>>;
};


export type PipelineStageJobsApplicationsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<JobsApplicationCondition>;
  filter?: InputMaybe<JobsApplicationFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<JobsApplicationsOrderBy>>;
};


export type PipelineStageScorecardsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<ScorecardCondition>;
  filter?: InputMaybe<ScorecardFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<ScorecardsOrderBy>>;
};


export type PipelineStageStageScorecardsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<PipelineStageScorecardCondition>;
  filter?: InputMaybe<PipelineStageScorecardFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<PipelineStageScorecardsOrderBy>>;
};


export type PipelineStageStageUsersArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<PipelineStageUserCondition>;
  filter?: InputMaybe<PipelineStageUserFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<PipelineStageUsersOrderBy>>;
};


export type PipelineStageTranslationsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<PipelineStageTranslationCondition>;
  filter?: InputMaybe<PipelineStageTranslationFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<PipelineStageTranslationsOrderBy>>;
};


export type PipelineStageUsersArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<UserCondition>;
  filter?: InputMaybe<UserFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<UsersOrderBy>>;
};

/** A connection to a list of `Candidate` values, with data from `JobsApplication`. */
export type PipelineStageCandidatesByJobsApplicationPipelineStageIdAndCandidateIdManyToManyConnection = {
  __typename?: 'PipelineStageCandidatesByJobsApplicationPipelineStageIdAndCandidateIdManyToManyConnection';
  /** A list of edges which contains the `Candidate`, info from the `JobsApplication`, and the cursor to aid in pagination. */
  edges: Array<PipelineStageCandidatesByJobsApplicationPipelineStageIdAndCandidateIdManyToManyEdge>;
  /** A list of `Candidate` objects. */
  nodes: Array<Candidate>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Candidate` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `Candidate` edge in the connection, with data from `JobsApplication`. */
export type PipelineStageCandidatesByJobsApplicationPipelineStageIdAndCandidateIdManyToManyEdge = {
  __typename?: 'PipelineStageCandidatesByJobsApplicationPipelineStageIdAndCandidateIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** Reads and enables pagination through a set of `JobsApplication`. */
  jobsApplications: JobsApplicationsConnection;
  /** The `Candidate` at the end of the edge. */
  node: Candidate;
};


/** A `Candidate` edge in the connection, with data from `JobsApplication`. */
export type PipelineStageCandidatesByJobsApplicationPipelineStageIdAndCandidateIdManyToManyEdgeJobsApplicationsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<JobsApplicationCondition>;
  filter?: InputMaybe<JobsApplicationFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<JobsApplicationsOrderBy>>;
};

/** A condition to be used against `PipelineStage` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type PipelineStageCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `pipelineId` field. */
  pipelineId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `position` field. */
  position?: InputMaybe<Scalars['Int']['input']>;
};

/** A connection to a list of `DisqualifyReason` values, with data from `JobsApplication`. */
export type PipelineStageDisqualifyReasonsByJobsApplicationPipelineStageIdAndDisqualifyReasonIdManyToManyConnection = {
  __typename?: 'PipelineStageDisqualifyReasonsByJobsApplicationPipelineStageIdAndDisqualifyReasonIdManyToManyConnection';
  /** A list of edges which contains the `DisqualifyReason`, info from the `JobsApplication`, and the cursor to aid in pagination. */
  edges: Array<PipelineStageDisqualifyReasonsByJobsApplicationPipelineStageIdAndDisqualifyReasonIdManyToManyEdge>;
  /** A list of `DisqualifyReason` objects. */
  nodes: Array<DisqualifyReason>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `DisqualifyReason` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `DisqualifyReason` edge in the connection, with data from `JobsApplication`. */
export type PipelineStageDisqualifyReasonsByJobsApplicationPipelineStageIdAndDisqualifyReasonIdManyToManyEdge = {
  __typename?: 'PipelineStageDisqualifyReasonsByJobsApplicationPipelineStageIdAndDisqualifyReasonIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** Reads and enables pagination through a set of `JobsApplication`. */
  jobsApplications: JobsApplicationsConnection;
  /** The `DisqualifyReason` at the end of the edge. */
  node: DisqualifyReason;
};


/** A `DisqualifyReason` edge in the connection, with data from `JobsApplication`. */
export type PipelineStageDisqualifyReasonsByJobsApplicationPipelineStageIdAndDisqualifyReasonIdManyToManyEdgeJobsApplicationsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<JobsApplicationCondition>;
  filter?: InputMaybe<JobsApplicationFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<JobsApplicationsOrderBy>>;
};

/** A filter to be used against `PipelineStage` object types. All fields are combined with a logical ‘and.’ */
export type PipelineStageFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<PipelineStageFilter>>;
  /** Filter by the object’s `draftEvaluations` relation. */
  draftEvaluations?: InputMaybe<PipelineStageToManyDraftEvaluationFilter>;
  /** Some related `draftEvaluations` exist. */
  draftEvaluationsExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<IntFilter>;
  /** Filter by the object’s `jobsApplications` relation. */
  jobsApplications?: InputMaybe<PipelineStageToManyJobsApplicationFilter>;
  /** Some related `jobsApplications` exist. */
  jobsApplicationsExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Negates the expression. */
  not?: InputMaybe<PipelineStageFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<PipelineStageFilter>>;
  /** Filter by the object’s `pipeline` relation. */
  pipeline?: InputMaybe<PipelineFilter>;
  /** Filter by the object’s `pipelineId` field. */
  pipelineId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `position` field. */
  position?: InputMaybe<IntFilter>;
  /** Filter by the object’s `stageScorecards` relation. */
  stageScorecards?: InputMaybe<PipelineStageToManyPipelineStageScorecardFilter>;
  /** Some related `stageScorecards` exist. */
  stageScorecardsExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `stageUsers` relation. */
  stageUsers?: InputMaybe<PipelineStageToManyPipelineStageUserFilter>;
  /** Some related `stageUsers` exist. */
  stageUsersExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `translations` relation. */
  translations?: InputMaybe<PipelineStageToManyPipelineStageTranslationFilter>;
  /** Some related `translations` exist. */
  translationsExist?: InputMaybe<Scalars['Boolean']['input']>;
};

/** An input for mutations affecting `PipelineStage` */
export type PipelineStageInput = {
  draftEvaluations?: InputMaybe<DraftEvaluationsPipelineStageIdFkeyInverseInput>;
  jobsApplications?: InputMaybe<JobsApplicationsPipelineStageIdFkeyInverseInput>;
  pipeline?: InputMaybe<PipelineStagesPipelineIdFkeyInput>;
  pipelineId?: InputMaybe<Scalars['Int']['input']>;
  position: Scalars['Int']['input'];
  stageScorecards?: InputMaybe<PipelineStageScorecardsPipelineStageIdFkeyInverseInput>;
  stageUsers?: InputMaybe<PipelineStageUsersPipelineStageIdFkeyInverseInput>;
  translations?: InputMaybe<PipelineStageTranslationsPipelineStageIdFkeyInverseInput>;
  type: PipelineStageType;
};

export type PipelineStageInput__ = {
  id: Scalars['Int']['input'];
  patch: PipelineStagePatch__;
};

/** A connection to a list of `Job` values, with data from `JobsApplication`. */
export type PipelineStageJobsByJobsApplicationPipelineStageIdAndJobIdManyToManyConnection = {
  __typename?: 'PipelineStageJobsByJobsApplicationPipelineStageIdAndJobIdManyToManyConnection';
  /** A list of edges which contains the `Job`, info from the `JobsApplication`, and the cursor to aid in pagination. */
  edges: Array<PipelineStageJobsByJobsApplicationPipelineStageIdAndJobIdManyToManyEdge>;
  /** A list of `Job` objects. */
  nodes: Array<Job>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Job` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `Job` edge in the connection, with data from `JobsApplication`. */
export type PipelineStageJobsByJobsApplicationPipelineStageIdAndJobIdManyToManyEdge = {
  __typename?: 'PipelineStageJobsByJobsApplicationPipelineStageIdAndJobIdManyToManyEdge';
  /** Reads and enables pagination through a set of `JobsApplication`. */
  applications: JobsApplicationsConnection;
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Job` at the end of the edge. */
  node: Job;
};


/** A `Job` edge in the connection, with data from `JobsApplication`. */
export type PipelineStageJobsByJobsApplicationPipelineStageIdAndJobIdManyToManyEdgeApplicationsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<JobsApplicationCondition>;
  filter?: InputMaybe<JobsApplicationFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<JobsApplicationsOrderBy>>;
};

/** The globally unique `ID` look up for the row to connect. */
export type PipelineStageNodeIdConnect = {
  /** The globally unique `ID` which identifies a single `pipelineStage` to be connected. */
  nodeId: Scalars['ID']['input'];
};

/** The globally unique `ID` look up for the row to delete. */
export type PipelineStageNodeIdDelete = {
  /** The globally unique `ID` which identifies a single `pipelineStage` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** The globally unique `ID` look up for the row to update. */
export type PipelineStageOnDraftEvaluationForDraftEvaluationsPipelineStageIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `draftEvaluation` to be connected. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `draftEvaluation` being updated. */
  patch: DraftEvaluationPatch;
};

/** The fields on `pipelineStage` to look up the row to update. */
export type PipelineStageOnDraftEvaluationForDraftEvaluationsPipelineStageIdFkeyUsingPipelineStagesPkeyUpdate = {
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `pipelineStage` being updated. */
  patch: UpdatePipelineStageOnDraftEvaluationForDraftEvaluationsPipelineStageIdFkeyPatch;
};

/** The globally unique `ID` look up for the row to update. */
export type PipelineStageOnJobsApplicationForJobsApplicationsPipelineStageIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `jobsApplication` to be connected. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `jobsApplication` being updated. */
  patch: JobsApplicationPatch;
};

/** The fields on `pipelineStage` to look up the row to update. */
export type PipelineStageOnJobsApplicationForJobsApplicationsPipelineStageIdFkeyUsingPipelineStagesPkeyUpdate = {
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `pipelineStage` being updated. */
  patch: UpdatePipelineStageOnJobsApplicationForJobsApplicationsPipelineStageIdFkeyPatch;
};

/** The globally unique `ID` look up for the row to update. */
export type PipelineStageOnPipelineStageForPipelineStagesPipelineIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `pipeline` to be connected. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `pipeline` being updated. */
  patch: PipelinePatch;
};

/** The fields on `pipelineStage` to look up the row to update. */
export type PipelineStageOnPipelineStageForPipelineStagesPipelineIdFkeyUsingPipelineStagesPkeyUpdate = {
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `pipelineStage` being updated. */
  patch: UpdatePipelineStageOnPipelineStageForPipelineStagesPipelineIdFkeyPatch;
};

/** The globally unique `ID` look up for the row to update. */
export type PipelineStageOnPipelineStageScorecardForPipelineStageScorecardsPipelineStageIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `pipelineStageScorecard` to be connected. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `pipelineStageScorecard` being updated. */
  patch: PipelineStageScorecardPatch;
};

/** The fields on `pipelineStage` to look up the row to update. */
export type PipelineStageOnPipelineStageScorecardForPipelineStageScorecardsPipelineStageIdFkeyUsingPipelineStagesPkeyUpdate = {
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `pipelineStage` being updated. */
  patch: UpdatePipelineStageOnPipelineStageScorecardForPipelineStageScorecardsPipelineStageIdFkeyPatch;
};

/** The globally unique `ID` look up for the row to update. */
export type PipelineStageOnPipelineStageTranslationForPipelineStageTranslationsPipelineStageIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `pipelineStageTranslation` to be connected. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `pipelineStageTranslation` being updated. */
  patch: PipelineStageTranslationPatch;
};

/** The fields on `pipelineStage` to look up the row to update. */
export type PipelineStageOnPipelineStageTranslationForPipelineStageTranslationsPipelineStageIdFkeyUsingPipelineStagesPkeyUpdate = {
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `pipelineStage` being updated. */
  patch: UpdatePipelineStageOnPipelineStageTranslationForPipelineStageTranslationsPipelineStageIdFkeyPatch;
};

/** The globally unique `ID` look up for the row to update. */
export type PipelineStageOnPipelineStageUserForPipelineStageUsersPipelineStageIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `pipelineStageUser` to be connected. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `pipelineStageUser` being updated. */
  patch: PipelineStageUserPatch;
};

/** The fields on `pipelineStage` to look up the row to update. */
export type PipelineStageOnPipelineStageUserForPipelineStageUsersPipelineStageIdFkeyUsingPipelineStagesPkeyUpdate = {
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `pipelineStage` being updated. */
  patch: UpdatePipelineStageOnPipelineStageUserForPipelineStageUsersPipelineStageIdFkeyPatch;
};

/** Represents an update to a `PipelineStage`. Fields that are set will be updated. */
export type PipelineStagePatch = {
  draftEvaluations?: InputMaybe<DraftEvaluationsPipelineStageIdFkeyInverseInput>;
  jobsApplications?: InputMaybe<JobsApplicationsPipelineStageIdFkeyInverseInput>;
  pipeline?: InputMaybe<PipelineStagesPipelineIdFkeyInput>;
  pipelineId?: InputMaybe<Scalars['Int']['input']>;
  position?: InputMaybe<Scalars['Int']['input']>;
  stageScorecards?: InputMaybe<PipelineStageScorecardsPipelineStageIdFkeyInverseInput>;
  stageUsers?: InputMaybe<PipelineStageUsersPipelineStageIdFkeyInverseInput>;
  translations?: InputMaybe<PipelineStageTranslationsPipelineStageIdFkeyInverseInput>;
  type?: InputMaybe<PipelineStageType>;
};

export type PipelineStagePatch__ = {
  scorecardIds?: InputMaybe<Array<Scalars['Int']['input']>>;
  translations?: InputMaybe<Array<PipelineStageTranslationsInput>>;
  type?: InputMaybe<PipelineStageType>;
  userIds?: InputMaybe<Array<Scalars['Int']['input']>>;
};

/** The fields on `pipelineStage` to look up the row to connect. */
export type PipelineStagePipelineStagesPkeyConnect = {
  id: Scalars['Int']['input'];
};

/** The fields on `pipelineStage` to look up the row to delete. */
export type PipelineStagePipelineStagesPkeyDelete = {
  id: Scalars['Int']['input'];
};

export type PipelineStageScorecard = Node & {
  __typename?: 'PipelineStageScorecard';
  createdAt: Scalars['Datetime']['output'];
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  /** Reads a single `PipelineStage` that is related to this `PipelineStageScorecard`. */
  pipelineStage?: Maybe<PipelineStage>;
  pipelineStageId: Scalars['Int']['output'];
  /** Reads a single `Scorecard` that is related to this `PipelineStageScorecard`. */
  scorecard?: Maybe<Scorecard>;
  scorecardId: Scalars['Int']['output'];
};

/** A condition to be used against `PipelineStageScorecard` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type PipelineStageScorecardCondition = {
  /** Checks for equality with the object’s `pipelineStageId` field. */
  pipelineStageId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `scorecardId` field. */
  scorecardId?: InputMaybe<Scalars['Int']['input']>;
};

/** A filter to be used against `PipelineStageScorecard` object types. All fields are combined with a logical ‘and.’ */
export type PipelineStageScorecardFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<PipelineStageScorecardFilter>>;
  /** Negates the expression. */
  not?: InputMaybe<PipelineStageScorecardFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<PipelineStageScorecardFilter>>;
  /** Filter by the object’s `pipelineStage` relation. */
  pipelineStage?: InputMaybe<PipelineStageFilter>;
  /** Filter by the object’s `pipelineStageId` field. */
  pipelineStageId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `scorecard` relation. */
  scorecard?: InputMaybe<ScorecardFilter>;
  /** Filter by the object’s `scorecardId` field. */
  scorecardId?: InputMaybe<IntFilter>;
};

/** An input for mutations affecting `PipelineStageScorecard` */
export type PipelineStageScorecardInput = {
  pipelineStage?: InputMaybe<PipelineStageScorecardsPipelineStageIdFkeyInput>;
  pipelineStageId?: InputMaybe<Scalars['Int']['input']>;
  scorecard?: InputMaybe<PipelineStageScorecardsScorecardIdFkeyInput>;
  scorecardId?: InputMaybe<Scalars['Int']['input']>;
};

/** The globally unique `ID` look up for the row to connect. */
export type PipelineStageScorecardNodeIdConnect = {
  /** The globally unique `ID` which identifies a single `pipelineStageScorecard` to be connected. */
  nodeId: Scalars['ID']['input'];
};

/** The globally unique `ID` look up for the row to delete. */
export type PipelineStageScorecardNodeIdDelete = {
  /** The globally unique `ID` which identifies a single `pipelineStageScorecard` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** The globally unique `ID` look up for the row to update. */
export type PipelineStageScorecardOnPipelineStageScorecardForPipelineStageScorecardsPipelineStageIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `pipelineStage` to be connected. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `pipelineStage` being updated. */
  patch: PipelineStagePatch;
};

/** The fields on `pipelineStageScorecard` to look up the row to update. */
export type PipelineStageScorecardOnPipelineStageScorecardForPipelineStageScorecardsPipelineStageIdFkeyUsingPipelineStageScorecardsPkeyUpdate = {
  /** An object where the defined keys will be set on the `pipelineStageScorecard` being updated. */
  patch: UpdatePipelineStageScorecardOnPipelineStageScorecardForPipelineStageScorecardsPipelineStageIdFkeyPatch;
  pipelineStageId: Scalars['Int']['input'];
  scorecardId: Scalars['Int']['input'];
};

/** The globally unique `ID` look up for the row to update. */
export type PipelineStageScorecardOnPipelineStageScorecardForPipelineStageScorecardsScorecardIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `scorecard` to be connected. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `scorecard` being updated. */
  patch: ScorecardPatch;
};

/** The fields on `pipelineStageScorecard` to look up the row to update. */
export type PipelineStageScorecardOnPipelineStageScorecardForPipelineStageScorecardsScorecardIdFkeyUsingPipelineStageScorecardsPkeyUpdate = {
  /** An object where the defined keys will be set on the `pipelineStageScorecard` being updated. */
  patch: UpdatePipelineStageScorecardOnPipelineStageScorecardForPipelineStageScorecardsScorecardIdFkeyPatch;
  pipelineStageId: Scalars['Int']['input'];
  scorecardId: Scalars['Int']['input'];
};

/** Represents an update to a `PipelineStageScorecard`. Fields that are set will be updated. */
export type PipelineStageScorecardPatch = {
  pipelineStage?: InputMaybe<PipelineStageScorecardsPipelineStageIdFkeyInput>;
  pipelineStageId?: InputMaybe<Scalars['Int']['input']>;
  scorecard?: InputMaybe<PipelineStageScorecardsScorecardIdFkeyInput>;
  scorecardId?: InputMaybe<Scalars['Int']['input']>;
};

/** The fields on `pipelineStageScorecard` to look up the row to connect. */
export type PipelineStageScorecardPipelineStageScorecardsPkeyConnect = {
  pipelineStageId: Scalars['Int']['input'];
  scorecardId: Scalars['Int']['input'];
};

/** The fields on `pipelineStageScorecard` to look up the row to delete. */
export type PipelineStageScorecardPipelineStageScorecardsPkeyDelete = {
  pipelineStageId: Scalars['Int']['input'];
  scorecardId: Scalars['Int']['input'];
};

/** A connection to a list of `Scorecard` values, with data from `PipelineStageScorecard`. */
export type PipelineStageScorecardsByPipelineStageScorecardPipelineStageIdAndScorecardIdManyToManyConnection = {
  __typename?: 'PipelineStageScorecardsByPipelineStageScorecardPipelineStageIdAndScorecardIdManyToManyConnection';
  /** A list of edges which contains the `Scorecard`, info from the `PipelineStageScorecard`, and the cursor to aid in pagination. */
  edges: Array<PipelineStageScorecardsByPipelineStageScorecardPipelineStageIdAndScorecardIdManyToManyEdge>;
  /** A list of `Scorecard` objects. */
  nodes: Array<Scorecard>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Scorecard` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `Scorecard` edge in the connection, with data from `PipelineStageScorecard`. */
export type PipelineStageScorecardsByPipelineStageScorecardPipelineStageIdAndScorecardIdManyToManyEdge = {
  __typename?: 'PipelineStageScorecardsByPipelineStageScorecardPipelineStageIdAndScorecardIdManyToManyEdge';
  createdAt: Scalars['Datetime']['output'];
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Scorecard` at the end of the edge. */
  node: Scorecard;
};

/** A connection to a list of `PipelineStageScorecard` values. */
export type PipelineStageScorecardsConnection = {
  __typename?: 'PipelineStageScorecardsConnection';
  /** A list of edges which contains the `PipelineStageScorecard` and cursor to aid in pagination. */
  edges: Array<PipelineStageScorecardsEdge>;
  /** A list of `PipelineStageScorecard` objects. */
  nodes: Array<PipelineStageScorecard>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `PipelineStageScorecard` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `PipelineStageScorecard` edge in the connection. */
export type PipelineStageScorecardsEdge = {
  __typename?: 'PipelineStageScorecardsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `PipelineStageScorecard` at the end of the edge. */
  node: PipelineStageScorecard;
};

/** Methods to use when ordering `PipelineStageScorecard`. */
export enum PipelineStageScorecardsOrderBy {
  Natural = 'NATURAL',
  PipelineStageIdAsc = 'PIPELINE_STAGE_ID_ASC',
  PipelineStageIdDesc = 'PIPELINE_STAGE_ID_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  ScorecardIdAsc = 'SCORECARD_ID_ASC',
  ScorecardIdDesc = 'SCORECARD_ID_DESC'
}

/** Input for the nested mutation of `pipelineStage` in the `PipelineStageScorecardInput` mutation. */
export type PipelineStageScorecardsPipelineStageIdFkeyInput = {
  /** The primary key(s) for `pipelineStage` for the far side of the relationship. */
  connectById?: InputMaybe<PipelineStagePipelineStagesPkeyConnect>;
  /** The primary key(s) for `pipelineStage` for the far side of the relationship. */
  connectByNodeId?: InputMaybe<PipelineStageNodeIdConnect>;
  /** A `PipelineStageInput` object that will be created and connected to this object. */
  create?: InputMaybe<PipelineStageScorecardsPipelineStageIdFkeyPipelineStagesCreateInput>;
  /** The primary key(s) for `pipelineStage` for the far side of the relationship. */
  deleteById?: InputMaybe<PipelineStagePipelineStagesPkeyDelete>;
  /** The primary key(s) for `pipelineStage` for the far side of the relationship. */
  deleteByNodeId?: InputMaybe<PipelineStageNodeIdDelete>;
  /** The primary key(s) and patch data for `pipelineStage` for the far side of the relationship. */
  updateById?: InputMaybe<PipelineStageOnPipelineStageScorecardForPipelineStageScorecardsPipelineStageIdFkeyUsingPipelineStagesPkeyUpdate>;
  /** The primary key(s) and patch data for `pipelineStage` for the far side of the relationship. */
  updateByNodeId?: InputMaybe<PipelineStageScorecardOnPipelineStageScorecardForPipelineStageScorecardsPipelineStageIdFkeyNodeIdUpdate>;
};

/** Input for the nested mutation of `pipelineStageScorecard` in the `PipelineStageInput` mutation. */
export type PipelineStageScorecardsPipelineStageIdFkeyInverseInput = {
  /** The primary key(s) for `pipelineStageScorecard` for the far side of the relationship. */
  connectByNodeId?: InputMaybe<Array<PipelineStageScorecardNodeIdConnect>>;
  /** The primary key(s) for `pipelineStageScorecard` for the far side of the relationship. */
  connectByScorecardIdAndPipelineStageId?: InputMaybe<Array<PipelineStageScorecardPipelineStageScorecardsPkeyConnect>>;
  /** A `PipelineStageScorecardInput` object that will be created and connected to this object. */
  create?: InputMaybe<Array<PipelineStageScorecardsPipelineStageIdFkeyPipelineStageScorecardsCreateInput>>;
  /** The primary key(s) for `pipelineStageScorecard` for the far side of the relationship. */
  deleteByNodeId?: InputMaybe<Array<PipelineStageScorecardNodeIdDelete>>;
  /** The primary key(s) for `pipelineStageScorecard` for the far side of the relationship. */
  deleteByScorecardIdAndPipelineStageId?: InputMaybe<Array<PipelineStageScorecardPipelineStageScorecardsPkeyDelete>>;
  /** Flag indicating whether all other `pipelineStageScorecard` records that match this relationship should be removed. */
  deleteOthers?: InputMaybe<Scalars['Boolean']['input']>;
  /** The primary key(s) and patch data for `pipelineStageScorecard` for the far side of the relationship. */
  updateByNodeId?: InputMaybe<Array<PipelineStageOnPipelineStageScorecardForPipelineStageScorecardsPipelineStageIdFkeyNodeIdUpdate>>;
  /** The primary key(s) and patch data for `pipelineStageScorecard` for the far side of the relationship. */
  updateByScorecardIdAndPipelineStageId?: InputMaybe<Array<PipelineStageScorecardOnPipelineStageScorecardForPipelineStageScorecardsPipelineStageIdFkeyUsingPipelineStageScorecardsPkeyUpdate>>;
};

/** The `pipelineStageScorecard` to be created by this mutation. */
export type PipelineStageScorecardsPipelineStageIdFkeyPipelineStageScorecardsCreateInput = {
  pipelineStage?: InputMaybe<PipelineStageScorecardsPipelineStageIdFkeyInput>;
  scorecard?: InputMaybe<PipelineStageScorecardsScorecardIdFkeyInput>;
  scorecardId?: InputMaybe<Scalars['Int']['input']>;
};

/** The `pipelineStage` to be created by this mutation. */
export type PipelineStageScorecardsPipelineStageIdFkeyPipelineStagesCreateInput = {
  draftEvaluations?: InputMaybe<DraftEvaluationsPipelineStageIdFkeyInverseInput>;
  jobsApplications?: InputMaybe<JobsApplicationsPipelineStageIdFkeyInverseInput>;
  pipeline?: InputMaybe<PipelineStagesPipelineIdFkeyInput>;
  pipelineId?: InputMaybe<Scalars['Int']['input']>;
  position: Scalars['Int']['input'];
  stageScorecards?: InputMaybe<PipelineStageScorecardsPipelineStageIdFkeyInverseInput>;
  stageUsers?: InputMaybe<PipelineStageUsersPipelineStageIdFkeyInverseInput>;
  translations?: InputMaybe<PipelineStageTranslationsPipelineStageIdFkeyInverseInput>;
  type: PipelineStageType;
};

/** Input for the nested mutation of `scorecard` in the `PipelineStageScorecardInput` mutation. */
export type PipelineStageScorecardsScorecardIdFkeyInput = {
  /** The primary key(s) for `scorecard` for the far side of the relationship. */
  connectById?: InputMaybe<ScorecardScorecardsPkeyConnect>;
  /** The primary key(s) for `scorecard` for the far side of the relationship. */
  connectByNodeId?: InputMaybe<ScorecardNodeIdConnect>;
  /** A `ScorecardInput` object that will be created and connected to this object. */
  create?: InputMaybe<PipelineStageScorecardsScorecardIdFkeyScorecardsCreateInput>;
  /** The primary key(s) and patch data for `scorecard` for the far side of the relationship. */
  updateById?: InputMaybe<ScorecardOnPipelineStageScorecardForPipelineStageScorecardsScorecardIdFkeyUsingScorecardsPkeyUpdate>;
  /** The primary key(s) and patch data for `scorecard` for the far side of the relationship. */
  updateByNodeId?: InputMaybe<PipelineStageScorecardOnPipelineStageScorecardForPipelineStageScorecardsScorecardIdFkeyNodeIdUpdate>;
};

/** Input for the nested mutation of `pipelineStageScorecard` in the `ScorecardInput` mutation. */
export type PipelineStageScorecardsScorecardIdFkeyInverseInput = {
  /** The primary key(s) for `pipelineStageScorecard` for the far side of the relationship. */
  connectByNodeId?: InputMaybe<Array<PipelineStageScorecardNodeIdConnect>>;
  /** The primary key(s) for `pipelineStageScorecard` for the far side of the relationship. */
  connectByScorecardIdAndPipelineStageId?: InputMaybe<Array<PipelineStageScorecardPipelineStageScorecardsPkeyConnect>>;
  /** A `PipelineStageScorecardInput` object that will be created and connected to this object. */
  create?: InputMaybe<Array<PipelineStageScorecardsScorecardIdFkeyPipelineStageScorecardsCreateInput>>;
  /** The primary key(s) for `pipelineStageScorecard` for the far side of the relationship. */
  deleteByNodeId?: InputMaybe<Array<PipelineStageScorecardNodeIdDelete>>;
  /** The primary key(s) for `pipelineStageScorecard` for the far side of the relationship. */
  deleteByScorecardIdAndPipelineStageId?: InputMaybe<Array<PipelineStageScorecardPipelineStageScorecardsPkeyDelete>>;
  /** Flag indicating whether all other `pipelineStageScorecard` records that match this relationship should be removed. */
  deleteOthers?: InputMaybe<Scalars['Boolean']['input']>;
  /** The primary key(s) and patch data for `pipelineStageScorecard` for the far side of the relationship. */
  updateByNodeId?: InputMaybe<Array<ScorecardOnPipelineStageScorecardForPipelineStageScorecardsScorecardIdFkeyNodeIdUpdate>>;
  /** The primary key(s) and patch data for `pipelineStageScorecard` for the far side of the relationship. */
  updateByScorecardIdAndPipelineStageId?: InputMaybe<Array<PipelineStageScorecardOnPipelineStageScorecardForPipelineStageScorecardsScorecardIdFkeyUsingPipelineStageScorecardsPkeyUpdate>>;
};

/** The `pipelineStageScorecard` to be created by this mutation. */
export type PipelineStageScorecardsScorecardIdFkeyPipelineStageScorecardsCreateInput = {
  pipelineStage?: InputMaybe<PipelineStageScorecardsPipelineStageIdFkeyInput>;
  pipelineStageId?: InputMaybe<Scalars['Int']['input']>;
  scorecard?: InputMaybe<PipelineStageScorecardsScorecardIdFkeyInput>;
};

/** The `scorecard` to be created by this mutation. */
export type PipelineStageScorecardsScorecardIdFkeyScorecardsCreateInput = {
  criterias?: InputMaybe<ScorecardCriteriasScorecardIdFkeyInverseInput>;
  evaluationScorecards?: InputMaybe<EvaluationScorecardsScorecardIdFkeyInverseInput>;
  eventScorecards?: InputMaybe<EventScorecardsScorecardIdFkeyInverseInput>;
  pipelineStageScorecards?: InputMaybe<PipelineStageScorecardsScorecardIdFkeyInverseInput>;
  translations?: InputMaybe<ScorecardTranslationsScorecardIdFkeyInverseInput>;
};

/** A filter to be used against many `DraftEvaluation` object types. All fields are combined with a logical ‘and.’ */
export type PipelineStageToManyDraftEvaluationFilter = {
  /** Every related `DraftEvaluation` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<DraftEvaluationFilter>;
  /** No related `DraftEvaluation` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<DraftEvaluationFilter>;
  /** Some related `DraftEvaluation` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<DraftEvaluationFilter>;
};

/** A filter to be used against many `JobsApplication` object types. All fields are combined with a logical ‘and.’ */
export type PipelineStageToManyJobsApplicationFilter = {
  /** Every related `JobsApplication` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<JobsApplicationFilter>;
  /** No related `JobsApplication` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<JobsApplicationFilter>;
  /** Some related `JobsApplication` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<JobsApplicationFilter>;
};

/** A filter to be used against many `PipelineStageScorecard` object types. All fields are combined with a logical ‘and.’ */
export type PipelineStageToManyPipelineStageScorecardFilter = {
  /** Every related `PipelineStageScorecard` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<PipelineStageScorecardFilter>;
  /** No related `PipelineStageScorecard` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<PipelineStageScorecardFilter>;
  /** Some related `PipelineStageScorecard` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<PipelineStageScorecardFilter>;
};

/** A filter to be used against many `PipelineStageTranslation` object types. All fields are combined with a logical ‘and.’ */
export type PipelineStageToManyPipelineStageTranslationFilter = {
  /** Every related `PipelineStageTranslation` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<PipelineStageTranslationFilter>;
  /** No related `PipelineStageTranslation` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<PipelineStageTranslationFilter>;
  /** Some related `PipelineStageTranslation` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<PipelineStageTranslationFilter>;
};

/** A filter to be used against many `PipelineStageUser` object types. All fields are combined with a logical ‘and.’ */
export type PipelineStageToManyPipelineStageUserFilter = {
  /** Every related `PipelineStageUser` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<PipelineStageUserFilter>;
  /** No related `PipelineStageUser` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<PipelineStageUserFilter>;
  /** Some related `PipelineStageUser` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<PipelineStageUserFilter>;
};

export type PipelineStageTranslation = Node & {
  __typename?: 'PipelineStageTranslation';
  lang: Language;
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  /** Reads a single `PipelineStage` that is related to this `PipelineStageTranslation`. */
  pipelineStage?: Maybe<PipelineStage>;
  pipelineStageId: Scalars['Int']['output'];
  title: Scalars['String']['output'];
};

/** A condition to be used against `PipelineStageTranslation` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type PipelineStageTranslationCondition = {
  /** Checks for equality with the object’s `pipelineStageId` field. */
  pipelineStageId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `title` field. */
  title?: InputMaybe<Scalars['String']['input']>;
};

/** A filter to be used against `PipelineStageTranslation` object types. All fields are combined with a logical ‘and.’ */
export type PipelineStageTranslationFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<PipelineStageTranslationFilter>>;
  /** Negates the expression. */
  not?: InputMaybe<PipelineStageTranslationFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<PipelineStageTranslationFilter>>;
  /** Filter by the object’s `pipelineStage` relation. */
  pipelineStage?: InputMaybe<PipelineStageFilter>;
  /** Filter by the object’s `pipelineStageId` field. */
  pipelineStageId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `title` field. */
  title?: InputMaybe<StringFilter>;
};

/** An input for mutations affecting `PipelineStageTranslation` */
export type PipelineStageTranslationInput = {
  lang: Language;
  pipelineStage?: InputMaybe<PipelineStageTranslationsPipelineStageIdFkeyInput>;
  pipelineStageId?: InputMaybe<Scalars['Int']['input']>;
  title: Scalars['String']['input'];
};

/** The globally unique `ID` look up for the row to connect. */
export type PipelineStageTranslationNodeIdConnect = {
  /** The globally unique `ID` which identifies a single `pipelineStageTranslation` to be connected. */
  nodeId: Scalars['ID']['input'];
};

/** The globally unique `ID` look up for the row to delete. */
export type PipelineStageTranslationNodeIdDelete = {
  /** The globally unique `ID` which identifies a single `pipelineStageTranslation` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** The globally unique `ID` look up for the row to update. */
export type PipelineStageTranslationOnPipelineStageTranslationForPipelineStageTranslationsPipelineStageIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `pipelineStage` to be connected. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `pipelineStage` being updated. */
  patch: PipelineStagePatch;
};

/** The fields on `pipelineStageTranslation` to look up the row to update. */
export type PipelineStageTranslationOnPipelineStageTranslationForPipelineStageTranslationsPipelineStageIdFkeyUsingPipelineStageTranslationsPkeyUpdate = {
  lang: Language;
  /** An object where the defined keys will be set on the `pipelineStageTranslation` being updated. */
  patch: UpdatePipelineStageTranslationOnPipelineStageTranslationForPipelineStageTranslationsPipelineStageIdFkeyPatch;
  pipelineStageId: Scalars['Int']['input'];
};

/** Represents an update to a `PipelineStageTranslation`. Fields that are set will be updated. */
export type PipelineStageTranslationPatch = {
  pipelineStage?: InputMaybe<PipelineStageTranslationsPipelineStageIdFkeyInput>;
  pipelineStageId?: InputMaybe<Scalars['Int']['input']>;
  title?: InputMaybe<Scalars['String']['input']>;
};

/** The fields on `pipelineStageTranslation` to look up the row to connect. */
export type PipelineStageTranslationPipelineStageTranslationsPkeyConnect = {
  lang: Language;
  pipelineStageId: Scalars['Int']['input'];
};

/** The fields on `pipelineStageTranslation` to look up the row to delete. */
export type PipelineStageTranslationPipelineStageTranslationsPkeyDelete = {
  lang: Language;
  pipelineStageId: Scalars['Int']['input'];
};

/** A connection to a list of `PipelineStageTranslation` values. */
export type PipelineStageTranslationsConnection = {
  __typename?: 'PipelineStageTranslationsConnection';
  /** A list of edges which contains the `PipelineStageTranslation` and cursor to aid in pagination. */
  edges: Array<PipelineStageTranslationsEdge>;
  /** A list of `PipelineStageTranslation` objects. */
  nodes: Array<PipelineStageTranslation>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `PipelineStageTranslation` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `PipelineStageTranslation` edge in the connection. */
export type PipelineStageTranslationsEdge = {
  __typename?: 'PipelineStageTranslationsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `PipelineStageTranslation` at the end of the edge. */
  node: PipelineStageTranslation;
};

export type PipelineStageTranslationsInput = {
  lang: Language;
  title: Scalars['String']['input'];
};

/** Methods to use when ordering `PipelineStageTranslation`. */
export enum PipelineStageTranslationsOrderBy {
  Natural = 'NATURAL',
  PipelineStageIdAsc = 'PIPELINE_STAGE_ID_ASC',
  PipelineStageIdDesc = 'PIPELINE_STAGE_ID_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  TitleAsc = 'TITLE_ASC',
  TitleDesc = 'TITLE_DESC'
}

/** Input for the nested mutation of `pipelineStage` in the `PipelineStageTranslationInput` mutation. */
export type PipelineStageTranslationsPipelineStageIdFkeyInput = {
  /** The primary key(s) for `pipelineStage` for the far side of the relationship. */
  connectById?: InputMaybe<PipelineStagePipelineStagesPkeyConnect>;
  /** The primary key(s) for `pipelineStage` for the far side of the relationship. */
  connectByNodeId?: InputMaybe<PipelineStageNodeIdConnect>;
  /** A `PipelineStageInput` object that will be created and connected to this object. */
  create?: InputMaybe<PipelineStageTranslationsPipelineStageIdFkeyPipelineStagesCreateInput>;
  /** The primary key(s) for `pipelineStage` for the far side of the relationship. */
  deleteById?: InputMaybe<PipelineStagePipelineStagesPkeyDelete>;
  /** The primary key(s) for `pipelineStage` for the far side of the relationship. */
  deleteByNodeId?: InputMaybe<PipelineStageNodeIdDelete>;
  /** The primary key(s) and patch data for `pipelineStage` for the far side of the relationship. */
  updateById?: InputMaybe<PipelineStageOnPipelineStageTranslationForPipelineStageTranslationsPipelineStageIdFkeyUsingPipelineStagesPkeyUpdate>;
  /** The primary key(s) and patch data for `pipelineStage` for the far side of the relationship. */
  updateByNodeId?: InputMaybe<PipelineStageTranslationOnPipelineStageTranslationForPipelineStageTranslationsPipelineStageIdFkeyNodeIdUpdate>;
};

/** Input for the nested mutation of `pipelineStageTranslation` in the `PipelineStageInput` mutation. */
export type PipelineStageTranslationsPipelineStageIdFkeyInverseInput = {
  /** The primary key(s) for `pipelineStageTranslation` for the far side of the relationship. */
  connectByNodeId?: InputMaybe<Array<PipelineStageTranslationNodeIdConnect>>;
  /** The primary key(s) for `pipelineStageTranslation` for the far side of the relationship. */
  connectByPipelineStageIdAndLang?: InputMaybe<Array<PipelineStageTranslationPipelineStageTranslationsPkeyConnect>>;
  /** A `PipelineStageTranslationInput` object that will be created and connected to this object. */
  create?: InputMaybe<Array<PipelineStageTranslationsPipelineStageIdFkeyPipelineStageTranslationsCreateInput>>;
  /** The primary key(s) for `pipelineStageTranslation` for the far side of the relationship. */
  deleteByNodeId?: InputMaybe<Array<PipelineStageTranslationNodeIdDelete>>;
  /** The primary key(s) for `pipelineStageTranslation` for the far side of the relationship. */
  deleteByPipelineStageIdAndLang?: InputMaybe<Array<PipelineStageTranslationPipelineStageTranslationsPkeyDelete>>;
  /** Flag indicating whether all other `pipelineStageTranslation` records that match this relationship should be removed. */
  deleteOthers?: InputMaybe<Scalars['Boolean']['input']>;
  /** The primary key(s) and patch data for `pipelineStageTranslation` for the far side of the relationship. */
  updateByNodeId?: InputMaybe<Array<PipelineStageOnPipelineStageTranslationForPipelineStageTranslationsPipelineStageIdFkeyNodeIdUpdate>>;
  /** The primary key(s) and patch data for `pipelineStageTranslation` for the far side of the relationship. */
  updateByPipelineStageIdAndLang?: InputMaybe<Array<PipelineStageTranslationOnPipelineStageTranslationForPipelineStageTranslationsPipelineStageIdFkeyUsingPipelineStageTranslationsPkeyUpdate>>;
};

/** The `pipelineStageTranslation` to be created by this mutation. */
export type PipelineStageTranslationsPipelineStageIdFkeyPipelineStageTranslationsCreateInput = {
  lang: Language;
  pipelineStage?: InputMaybe<PipelineStageTranslationsPipelineStageIdFkeyInput>;
  title: Scalars['String']['input'];
};

/** The `pipelineStage` to be created by this mutation. */
export type PipelineStageTranslationsPipelineStageIdFkeyPipelineStagesCreateInput = {
  draftEvaluations?: InputMaybe<DraftEvaluationsPipelineStageIdFkeyInverseInput>;
  jobsApplications?: InputMaybe<JobsApplicationsPipelineStageIdFkeyInverseInput>;
  pipeline?: InputMaybe<PipelineStagesPipelineIdFkeyInput>;
  pipelineId?: InputMaybe<Scalars['Int']['input']>;
  position: Scalars['Int']['input'];
  stageScorecards?: InputMaybe<PipelineStageScorecardsPipelineStageIdFkeyInverseInput>;
  stageUsers?: InputMaybe<PipelineStageUsersPipelineStageIdFkeyInverseInput>;
  translations?: InputMaybe<PipelineStageTranslationsPipelineStageIdFkeyInverseInput>;
  type: PipelineStageType;
};

export enum PipelineStageType {
  Apply = 'APPLY',
  Evaluation = 'EVALUATION',
  Hire = 'HIRE',
  Interview = 'INTERVIEW',
  None = 'NONE',
  Offer = 'OFFER',
  PhoneScreen = 'PHONE_SCREEN'
}

export type PipelineStageUser = Node & {
  __typename?: 'PipelineStageUser';
  createdAt: Scalars['Datetime']['output'];
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  /** Reads a single `PipelineStage` that is related to this `PipelineStageUser`. */
  pipelineStage?: Maybe<PipelineStage>;
  pipelineStageId: Scalars['Int']['output'];
  /** Reads a single `User` that is related to this `PipelineStageUser`. */
  user?: Maybe<User>;
  userId: Scalars['Int']['output'];
};

/** A condition to be used against `PipelineStageUser` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type PipelineStageUserCondition = {
  /** Checks for equality with the object’s `pipelineStageId` field. */
  pipelineStageId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `userId` field. */
  userId?: InputMaybe<Scalars['Int']['input']>;
};

/** A filter to be used against `PipelineStageUser` object types. All fields are combined with a logical ‘and.’ */
export type PipelineStageUserFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<PipelineStageUserFilter>>;
  /** Negates the expression. */
  not?: InputMaybe<PipelineStageUserFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<PipelineStageUserFilter>>;
  /** Filter by the object’s `pipelineStage` relation. */
  pipelineStage?: InputMaybe<PipelineStageFilter>;
  /** Filter by the object’s `pipelineStageId` field. */
  pipelineStageId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `user` relation. */
  user?: InputMaybe<UserFilter>;
  /** Filter by the object’s `userId` field. */
  userId?: InputMaybe<IntFilter>;
};

/** An input for mutations affecting `PipelineStageUser` */
export type PipelineStageUserInput = {
  pipelineStage?: InputMaybe<PipelineStageUsersPipelineStageIdFkeyInput>;
  pipelineStageId?: InputMaybe<Scalars['Int']['input']>;
  user?: InputMaybe<PipelineStageUsersUserIdFkeyInput>;
  userId?: InputMaybe<Scalars['Int']['input']>;
};

/** The globally unique `ID` look up for the row to connect. */
export type PipelineStageUserNodeIdConnect = {
  /** The globally unique `ID` which identifies a single `pipelineStageUser` to be connected. */
  nodeId: Scalars['ID']['input'];
};

/** The globally unique `ID` look up for the row to delete. */
export type PipelineStageUserNodeIdDelete = {
  /** The globally unique `ID` which identifies a single `pipelineStageUser` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** The globally unique `ID` look up for the row to update. */
export type PipelineStageUserOnPipelineStageUserForPipelineStageUsersPipelineStageIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `pipelineStage` to be connected. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `pipelineStage` being updated. */
  patch: PipelineStagePatch;
};

/** The fields on `pipelineStageUser` to look up the row to update. */
export type PipelineStageUserOnPipelineStageUserForPipelineStageUsersPipelineStageIdFkeyUsingPipelineStageUsersPkeyUpdate = {
  /** An object where the defined keys will be set on the `pipelineStageUser` being updated. */
  patch: UpdatePipelineStageUserOnPipelineStageUserForPipelineStageUsersPipelineStageIdFkeyPatch;
  pipelineStageId: Scalars['Int']['input'];
  userId: Scalars['Int']['input'];
};

/** The globally unique `ID` look up for the row to update. */
export type PipelineStageUserOnPipelineStageUserForPipelineStageUsersUserIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `user` to be connected. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `user` being updated. */
  patch: UserPatch;
};

/** The fields on `pipelineStageUser` to look up the row to update. */
export type PipelineStageUserOnPipelineStageUserForPipelineStageUsersUserIdFkeyUsingPipelineStageUsersPkeyUpdate = {
  /** An object where the defined keys will be set on the `pipelineStageUser` being updated. */
  patch: UpdatePipelineStageUserOnPipelineStageUserForPipelineStageUsersUserIdFkeyPatch;
  pipelineStageId: Scalars['Int']['input'];
  userId: Scalars['Int']['input'];
};

/** Represents an update to a `PipelineStageUser`. Fields that are set will be updated. */
export type PipelineStageUserPatch = {
  pipelineStage?: InputMaybe<PipelineStageUsersPipelineStageIdFkeyInput>;
  pipelineStageId?: InputMaybe<Scalars['Int']['input']>;
  user?: InputMaybe<PipelineStageUsersUserIdFkeyInput>;
  userId?: InputMaybe<Scalars['Int']['input']>;
};

/** The fields on `pipelineStageUser` to look up the row to connect. */
export type PipelineStageUserPipelineStageUsersPkeyConnect = {
  pipelineStageId: Scalars['Int']['input'];
  userId: Scalars['Int']['input'];
};

/** The fields on `pipelineStageUser` to look up the row to delete. */
export type PipelineStageUserPipelineStageUsersPkeyDelete = {
  pipelineStageId: Scalars['Int']['input'];
  userId: Scalars['Int']['input'];
};

/** A connection to a list of `User` values, with data from `PipelineStageUser`. */
export type PipelineStageUsersByPipelineStageUserPipelineStageIdAndUserIdManyToManyConnection = {
  __typename?: 'PipelineStageUsersByPipelineStageUserPipelineStageIdAndUserIdManyToManyConnection';
  /** A list of edges which contains the `User`, info from the `PipelineStageUser`, and the cursor to aid in pagination. */
  edges: Array<PipelineStageUsersByPipelineStageUserPipelineStageIdAndUserIdManyToManyEdge>;
  /** A list of `User` objects. */
  nodes: Array<User>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `User` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `User` edge in the connection, with data from `PipelineStageUser`. */
export type PipelineStageUsersByPipelineStageUserPipelineStageIdAndUserIdManyToManyEdge = {
  __typename?: 'PipelineStageUsersByPipelineStageUserPipelineStageIdAndUserIdManyToManyEdge';
  createdAt: Scalars['Datetime']['output'];
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `User` at the end of the edge. */
  node: User;
};

/** A connection to a list of `PipelineStageUser` values. */
export type PipelineStageUsersConnection = {
  __typename?: 'PipelineStageUsersConnection';
  /** A list of edges which contains the `PipelineStageUser` and cursor to aid in pagination. */
  edges: Array<PipelineStageUsersEdge>;
  /** A list of `PipelineStageUser` objects. */
  nodes: Array<PipelineStageUser>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `PipelineStageUser` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `PipelineStageUser` edge in the connection. */
export type PipelineStageUsersEdge = {
  __typename?: 'PipelineStageUsersEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `PipelineStageUser` at the end of the edge. */
  node: PipelineStageUser;
};

/** Methods to use when ordering `PipelineStageUser`. */
export enum PipelineStageUsersOrderBy {
  Natural = 'NATURAL',
  PipelineStageIdAsc = 'PIPELINE_STAGE_ID_ASC',
  PipelineStageIdDesc = 'PIPELINE_STAGE_ID_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  UserIdAsc = 'USER_ID_ASC',
  UserIdDesc = 'USER_ID_DESC'
}

/** Input for the nested mutation of `pipelineStage` in the `PipelineStageUserInput` mutation. */
export type PipelineStageUsersPipelineStageIdFkeyInput = {
  /** The primary key(s) for `pipelineStage` for the far side of the relationship. */
  connectById?: InputMaybe<PipelineStagePipelineStagesPkeyConnect>;
  /** The primary key(s) for `pipelineStage` for the far side of the relationship. */
  connectByNodeId?: InputMaybe<PipelineStageNodeIdConnect>;
  /** A `PipelineStageInput` object that will be created and connected to this object. */
  create?: InputMaybe<PipelineStageUsersPipelineStageIdFkeyPipelineStagesCreateInput>;
  /** The primary key(s) for `pipelineStage` for the far side of the relationship. */
  deleteById?: InputMaybe<PipelineStagePipelineStagesPkeyDelete>;
  /** The primary key(s) for `pipelineStage` for the far side of the relationship. */
  deleteByNodeId?: InputMaybe<PipelineStageNodeIdDelete>;
  /** The primary key(s) and patch data for `pipelineStage` for the far side of the relationship. */
  updateById?: InputMaybe<PipelineStageOnPipelineStageUserForPipelineStageUsersPipelineStageIdFkeyUsingPipelineStagesPkeyUpdate>;
  /** The primary key(s) and patch data for `pipelineStage` for the far side of the relationship. */
  updateByNodeId?: InputMaybe<PipelineStageUserOnPipelineStageUserForPipelineStageUsersPipelineStageIdFkeyNodeIdUpdate>;
};

/** Input for the nested mutation of `pipelineStageUser` in the `PipelineStageInput` mutation. */
export type PipelineStageUsersPipelineStageIdFkeyInverseInput = {
  /** The primary key(s) for `pipelineStageUser` for the far side of the relationship. */
  connectByNodeId?: InputMaybe<Array<PipelineStageUserNodeIdConnect>>;
  /** The primary key(s) for `pipelineStageUser` for the far side of the relationship. */
  connectByUserIdAndPipelineStageId?: InputMaybe<Array<PipelineStageUserPipelineStageUsersPkeyConnect>>;
  /** A `PipelineStageUserInput` object that will be created and connected to this object. */
  create?: InputMaybe<Array<PipelineStageUsersPipelineStageIdFkeyPipelineStageUsersCreateInput>>;
  /** The primary key(s) for `pipelineStageUser` for the far side of the relationship. */
  deleteByNodeId?: InputMaybe<Array<PipelineStageUserNodeIdDelete>>;
  /** The primary key(s) for `pipelineStageUser` for the far side of the relationship. */
  deleteByUserIdAndPipelineStageId?: InputMaybe<Array<PipelineStageUserPipelineStageUsersPkeyDelete>>;
  /** Flag indicating whether all other `pipelineStageUser` records that match this relationship should be removed. */
  deleteOthers?: InputMaybe<Scalars['Boolean']['input']>;
  /** The primary key(s) and patch data for `pipelineStageUser` for the far side of the relationship. */
  updateByNodeId?: InputMaybe<Array<PipelineStageOnPipelineStageUserForPipelineStageUsersPipelineStageIdFkeyNodeIdUpdate>>;
  /** The primary key(s) and patch data for `pipelineStageUser` for the far side of the relationship. */
  updateByUserIdAndPipelineStageId?: InputMaybe<Array<PipelineStageUserOnPipelineStageUserForPipelineStageUsersPipelineStageIdFkeyUsingPipelineStageUsersPkeyUpdate>>;
};

/** The `pipelineStageUser` to be created by this mutation. */
export type PipelineStageUsersPipelineStageIdFkeyPipelineStageUsersCreateInput = {
  pipelineStage?: InputMaybe<PipelineStageUsersPipelineStageIdFkeyInput>;
  user?: InputMaybe<PipelineStageUsersUserIdFkeyInput>;
  userId?: InputMaybe<Scalars['Int']['input']>;
};

/** The `pipelineStage` to be created by this mutation. */
export type PipelineStageUsersPipelineStageIdFkeyPipelineStagesCreateInput = {
  draftEvaluations?: InputMaybe<DraftEvaluationsPipelineStageIdFkeyInverseInput>;
  jobsApplications?: InputMaybe<JobsApplicationsPipelineStageIdFkeyInverseInput>;
  pipeline?: InputMaybe<PipelineStagesPipelineIdFkeyInput>;
  pipelineId?: InputMaybe<Scalars['Int']['input']>;
  position: Scalars['Int']['input'];
  stageScorecards?: InputMaybe<PipelineStageScorecardsPipelineStageIdFkeyInverseInput>;
  stageUsers?: InputMaybe<PipelineStageUsersPipelineStageIdFkeyInverseInput>;
  translations?: InputMaybe<PipelineStageTranslationsPipelineStageIdFkeyInverseInput>;
  type: PipelineStageType;
};

/** Input for the nested mutation of `user` in the `PipelineStageUserInput` mutation. */
export type PipelineStageUsersUserIdFkeyInput = {
  /** The primary key(s) for `user` for the far side of the relationship. */
  connectByEmail?: InputMaybe<UserUsersEmailKeyConnect>;
  /** The primary key(s) for `user` for the far side of the relationship. */
  connectById?: InputMaybe<UserUsersPkeyConnect>;
  /** The primary key(s) for `user` for the far side of the relationship. */
  connectByNodeId?: InputMaybe<UserNodeIdConnect>;
  /** The primary key(s) and patch data for `user` for the far side of the relationship. */
  updateByEmail?: InputMaybe<UserOnPipelineStageUserForPipelineStageUsersUserIdFkeyUsingUsersEmailKeyUpdate>;
  /** The primary key(s) and patch data for `user` for the far side of the relationship. */
  updateById?: InputMaybe<UserOnPipelineStageUserForPipelineStageUsersUserIdFkeyUsingUsersPkeyUpdate>;
  /** The primary key(s) and patch data for `user` for the far side of the relationship. */
  updateByNodeId?: InputMaybe<PipelineStageUserOnPipelineStageUserForPipelineStageUsersUserIdFkeyNodeIdUpdate>;
};

/** Input for the nested mutation of `pipelineStageUser` in the `UserInput` mutation. */
export type PipelineStageUsersUserIdFkeyInverseInput = {
  /** The primary key(s) for `pipelineStageUser` for the far side of the relationship. */
  connectByNodeId?: InputMaybe<Array<PipelineStageUserNodeIdConnect>>;
  /** The primary key(s) for `pipelineStageUser` for the far side of the relationship. */
  connectByUserIdAndPipelineStageId?: InputMaybe<Array<PipelineStageUserPipelineStageUsersPkeyConnect>>;
  /** A `PipelineStageUserInput` object that will be created and connected to this object. */
  create?: InputMaybe<Array<PipelineStageUsersUserIdFkeyPipelineStageUsersCreateInput>>;
  /** The primary key(s) for `pipelineStageUser` for the far side of the relationship. */
  deleteByNodeId?: InputMaybe<Array<PipelineStageUserNodeIdDelete>>;
  /** The primary key(s) for `pipelineStageUser` for the far side of the relationship. */
  deleteByUserIdAndPipelineStageId?: InputMaybe<Array<PipelineStageUserPipelineStageUsersPkeyDelete>>;
  /** Flag indicating whether all other `pipelineStageUser` records that match this relationship should be removed. */
  deleteOthers?: InputMaybe<Scalars['Boolean']['input']>;
  /** The primary key(s) and patch data for `pipelineStageUser` for the far side of the relationship. */
  updateByNodeId?: InputMaybe<Array<UserOnPipelineStageUserForPipelineStageUsersUserIdFkeyNodeIdUpdate>>;
  /** The primary key(s) and patch data for `pipelineStageUser` for the far side of the relationship. */
  updateByUserIdAndPipelineStageId?: InputMaybe<Array<PipelineStageUserOnPipelineStageUserForPipelineStageUsersUserIdFkeyUsingPipelineStageUsersPkeyUpdate>>;
};

/** The `pipelineStageUser` to be created by this mutation. */
export type PipelineStageUsersUserIdFkeyPipelineStageUsersCreateInput = {
  pipelineStage?: InputMaybe<PipelineStageUsersPipelineStageIdFkeyInput>;
  pipelineStageId?: InputMaybe<Scalars['Int']['input']>;
  user?: InputMaybe<PipelineStageUsersUserIdFkeyInput>;
};

/** A connection to a list of `PipelineStage` values. */
export type PipelineStagesConnection = {
  __typename?: 'PipelineStagesConnection';
  /** A list of edges which contains the `PipelineStage` and cursor to aid in pagination. */
  edges: Array<PipelineStagesEdge>;
  /** A list of `PipelineStage` objects. */
  nodes: Array<PipelineStage>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `PipelineStage` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `PipelineStage` edge in the connection. */
export type PipelineStagesEdge = {
  __typename?: 'PipelineStagesEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `PipelineStage` at the end of the edge. */
  node: PipelineStage;
};

/** Methods to use when ordering `PipelineStage`. */
export enum PipelineStagesOrderBy {
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  Natural = 'NATURAL',
  PipelineIdAsc = 'PIPELINE_ID_ASC',
  PipelineIdDesc = 'PIPELINE_ID_DESC',
  PositionAsc = 'POSITION_ASC',
  PositionDesc = 'POSITION_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC'
}

/** Input for the nested mutation of `pipeline` in the `PipelineStageInput` mutation. */
export type PipelineStagesPipelineIdFkeyInput = {
  /** The primary key(s) for `pipeline` for the far side of the relationship. */
  connectById?: InputMaybe<PipelinePipelinesPkeyConnect>;
  /** The primary key(s) for `pipeline` for the far side of the relationship. */
  connectByNodeId?: InputMaybe<PipelineNodeIdConnect>;
  /** A `PipelineInput` object that will be created and connected to this object. */
  create?: InputMaybe<PipelineStagesPipelineIdFkeyPipelinesCreateInput>;
  /** The primary key(s) and patch data for `pipeline` for the far side of the relationship. */
  updateById?: InputMaybe<PipelineOnPipelineStageForPipelineStagesPipelineIdFkeyUsingPipelinesPkeyUpdate>;
  /** The primary key(s) and patch data for `pipeline` for the far side of the relationship. */
  updateByNodeId?: InputMaybe<PipelineStageOnPipelineStageForPipelineStagesPipelineIdFkeyNodeIdUpdate>;
};

/** Input for the nested mutation of `pipelineStage` in the `PipelineInput` mutation. */
export type PipelineStagesPipelineIdFkeyInverseInput = {
  /** The primary key(s) for `pipelineStage` for the far side of the relationship. */
  connectById?: InputMaybe<Array<PipelineStagePipelineStagesPkeyConnect>>;
  /** The primary key(s) for `pipelineStage` for the far side of the relationship. */
  connectByNodeId?: InputMaybe<Array<PipelineStageNodeIdConnect>>;
  /** A `PipelineStageInput` object that will be created and connected to this object. */
  create?: InputMaybe<Array<PipelineStagesPipelineIdFkeyPipelineStagesCreateInput>>;
  /** The primary key(s) for `pipelineStage` for the far side of the relationship. */
  deleteById?: InputMaybe<Array<PipelineStagePipelineStagesPkeyDelete>>;
  /** The primary key(s) for `pipelineStage` for the far side of the relationship. */
  deleteByNodeId?: InputMaybe<Array<PipelineStageNodeIdDelete>>;
  /** Flag indicating whether all other `pipelineStage` records that match this relationship should be removed. */
  deleteOthers?: InputMaybe<Scalars['Boolean']['input']>;
  /** The primary key(s) and patch data for `pipelineStage` for the far side of the relationship. */
  updateById?: InputMaybe<Array<PipelineStageOnPipelineStageForPipelineStagesPipelineIdFkeyUsingPipelineStagesPkeyUpdate>>;
  /** The primary key(s) and patch data for `pipelineStage` for the far side of the relationship. */
  updateByNodeId?: InputMaybe<Array<PipelineOnPipelineStageForPipelineStagesPipelineIdFkeyNodeIdUpdate>>;
};

/** The `pipelineStage` to be created by this mutation. */
export type PipelineStagesPipelineIdFkeyPipelineStagesCreateInput = {
  draftEvaluations?: InputMaybe<DraftEvaluationsPipelineStageIdFkeyInverseInput>;
  jobsApplications?: InputMaybe<JobsApplicationsPipelineStageIdFkeyInverseInput>;
  pipeline?: InputMaybe<PipelineStagesPipelineIdFkeyInput>;
  position: Scalars['Int']['input'];
  stageScorecards?: InputMaybe<PipelineStageScorecardsPipelineStageIdFkeyInverseInput>;
  stageUsers?: InputMaybe<PipelineStageUsersPipelineStageIdFkeyInverseInput>;
  translations?: InputMaybe<PipelineStageTranslationsPipelineStageIdFkeyInverseInput>;
  type: PipelineStageType;
};

/** The `pipeline` to be created by this mutation. */
export type PipelineStagesPipelineIdFkeyPipelinesCreateInput = {
  jobs?: InputMaybe<JobsPipelineIdFkeyInverseInput>;
  stages?: InputMaybe<PipelineStagesPipelineIdFkeyInverseInput>;
  translations?: InputMaybe<PipelineTranslationsPipelineIdFkeyInverseInput>;
};

/** A filter to be used against many `Job` object types. All fields are combined with a logical ‘and.’ */
export type PipelineToManyJobFilter = {
  /** Every related `Job` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<JobFilter>;
  /** No related `Job` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<JobFilter>;
  /** Some related `Job` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<JobFilter>;
};

/** A filter to be used against many `PipelineStage` object types. All fields are combined with a logical ‘and.’ */
export type PipelineToManyPipelineStageFilter = {
  /** Every related `PipelineStage` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<PipelineStageFilter>;
  /** No related `PipelineStage` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<PipelineStageFilter>;
  /** Some related `PipelineStage` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<PipelineStageFilter>;
};

/** A filter to be used against many `PipelineTranslation` object types. All fields are combined with a logical ‘and.’ */
export type PipelineToManyPipelineTranslationFilter = {
  /** Every related `PipelineTranslation` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<PipelineTranslationFilter>;
  /** No related `PipelineTranslation` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<PipelineTranslationFilter>;
  /** Some related `PipelineTranslation` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<PipelineTranslationFilter>;
};

export type PipelineTranslation = Node & {
  __typename?: 'PipelineTranslation';
  lang: Language;
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  /** Reads a single `Pipeline` that is related to this `PipelineTranslation`. */
  pipeline?: Maybe<Pipeline>;
  pipelineId: Scalars['Int']['output'];
  title: Scalars['String']['output'];
};

/** A condition to be used against `PipelineTranslation` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type PipelineTranslationCondition = {
  /** Checks for equality with the object’s `pipelineId` field. */
  pipelineId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `title` field. */
  title?: InputMaybe<Scalars['String']['input']>;
};

/** A filter to be used against `PipelineTranslation` object types. All fields are combined with a logical ‘and.’ */
export type PipelineTranslationFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<PipelineTranslationFilter>>;
  /** Negates the expression. */
  not?: InputMaybe<PipelineTranslationFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<PipelineTranslationFilter>>;
  /** Filter by the object’s `pipeline` relation. */
  pipeline?: InputMaybe<PipelineFilter>;
  /** Filter by the object’s `pipelineId` field. */
  pipelineId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `title` field. */
  title?: InputMaybe<StringFilter>;
};

/** An input for mutations affecting `PipelineTranslation` */
export type PipelineTranslationInput = {
  lang: Language;
  pipeline?: InputMaybe<PipelineTranslationsPipelineIdFkeyInput>;
  pipelineId?: InputMaybe<Scalars['Int']['input']>;
  title: Scalars['String']['input'];
};

/** The globally unique `ID` look up for the row to connect. */
export type PipelineTranslationNodeIdConnect = {
  /** The globally unique `ID` which identifies a single `pipelineTranslation` to be connected. */
  nodeId: Scalars['ID']['input'];
};

/** The globally unique `ID` look up for the row to delete. */
export type PipelineTranslationNodeIdDelete = {
  /** The globally unique `ID` which identifies a single `pipelineTranslation` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** The globally unique `ID` look up for the row to update. */
export type PipelineTranslationOnPipelineTranslationForPipelineTranslationsPipelineIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `pipeline` to be connected. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `pipeline` being updated. */
  patch: PipelinePatch;
};

/** The fields on `pipelineTranslation` to look up the row to update. */
export type PipelineTranslationOnPipelineTranslationForPipelineTranslationsPipelineIdFkeyUsingPipelineTranslationsPkeyUpdate = {
  lang: Language;
  /** An object where the defined keys will be set on the `pipelineTranslation` being updated. */
  patch: UpdatePipelineTranslationOnPipelineTranslationForPipelineTranslationsPipelineIdFkeyPatch;
  pipelineId: Scalars['Int']['input'];
};

/** Represents an update to a `PipelineTranslation`. Fields that are set will be updated. */
export type PipelineTranslationPatch = {
  pipeline?: InputMaybe<PipelineTranslationsPipelineIdFkeyInput>;
  pipelineId?: InputMaybe<Scalars['Int']['input']>;
  title?: InputMaybe<Scalars['String']['input']>;
};

/** The fields on `pipelineTranslation` to look up the row to connect. */
export type PipelineTranslationPipelineTranslationsPkeyConnect = {
  lang: Language;
  pipelineId: Scalars['Int']['input'];
};

/** The fields on `pipelineTranslation` to look up the row to delete. */
export type PipelineTranslationPipelineTranslationsPkeyDelete = {
  lang: Language;
  pipelineId: Scalars['Int']['input'];
};

/** A connection to a list of `PipelineTranslation` values. */
export type PipelineTranslationsConnection = {
  __typename?: 'PipelineTranslationsConnection';
  /** A list of edges which contains the `PipelineTranslation` and cursor to aid in pagination. */
  edges: Array<PipelineTranslationsEdge>;
  /** A list of `PipelineTranslation` objects. */
  nodes: Array<PipelineTranslation>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `PipelineTranslation` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `PipelineTranslation` edge in the connection. */
export type PipelineTranslationsEdge = {
  __typename?: 'PipelineTranslationsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `PipelineTranslation` at the end of the edge. */
  node: PipelineTranslation;
};

export type PipelineTranslationsInput = {
  lang: Language;
  title: Scalars['String']['input'];
};

/** Methods to use when ordering `PipelineTranslation`. */
export enum PipelineTranslationsOrderBy {
  Natural = 'NATURAL',
  PipelineIdAsc = 'PIPELINE_ID_ASC',
  PipelineIdDesc = 'PIPELINE_ID_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  TitleAsc = 'TITLE_ASC',
  TitleDesc = 'TITLE_DESC'
}

/** Input for the nested mutation of `pipeline` in the `PipelineTranslationInput` mutation. */
export type PipelineTranslationsPipelineIdFkeyInput = {
  /** The primary key(s) for `pipeline` for the far side of the relationship. */
  connectById?: InputMaybe<PipelinePipelinesPkeyConnect>;
  /** The primary key(s) for `pipeline` for the far side of the relationship. */
  connectByNodeId?: InputMaybe<PipelineNodeIdConnect>;
  /** A `PipelineInput` object that will be created and connected to this object. */
  create?: InputMaybe<PipelineTranslationsPipelineIdFkeyPipelinesCreateInput>;
  /** The primary key(s) and patch data for `pipeline` for the far side of the relationship. */
  updateById?: InputMaybe<PipelineOnPipelineTranslationForPipelineTranslationsPipelineIdFkeyUsingPipelinesPkeyUpdate>;
  /** The primary key(s) and patch data for `pipeline` for the far side of the relationship. */
  updateByNodeId?: InputMaybe<PipelineTranslationOnPipelineTranslationForPipelineTranslationsPipelineIdFkeyNodeIdUpdate>;
};

/** Input for the nested mutation of `pipelineTranslation` in the `PipelineInput` mutation. */
export type PipelineTranslationsPipelineIdFkeyInverseInput = {
  /** The primary key(s) for `pipelineTranslation` for the far side of the relationship. */
  connectByNodeId?: InputMaybe<Array<PipelineTranslationNodeIdConnect>>;
  /** The primary key(s) for `pipelineTranslation` for the far side of the relationship. */
  connectByPipelineIdAndLang?: InputMaybe<Array<PipelineTranslationPipelineTranslationsPkeyConnect>>;
  /** A `PipelineTranslationInput` object that will be created and connected to this object. */
  create?: InputMaybe<Array<PipelineTranslationsPipelineIdFkeyPipelineTranslationsCreateInput>>;
  /** The primary key(s) for `pipelineTranslation` for the far side of the relationship. */
  deleteByNodeId?: InputMaybe<Array<PipelineTranslationNodeIdDelete>>;
  /** The primary key(s) for `pipelineTranslation` for the far side of the relationship. */
  deleteByPipelineIdAndLang?: InputMaybe<Array<PipelineTranslationPipelineTranslationsPkeyDelete>>;
  /** Flag indicating whether all other `pipelineTranslation` records that match this relationship should be removed. */
  deleteOthers?: InputMaybe<Scalars['Boolean']['input']>;
  /** The primary key(s) and patch data for `pipelineTranslation` for the far side of the relationship. */
  updateByNodeId?: InputMaybe<Array<PipelineOnPipelineTranslationForPipelineTranslationsPipelineIdFkeyNodeIdUpdate>>;
  /** The primary key(s) and patch data for `pipelineTranslation` for the far side of the relationship. */
  updateByPipelineIdAndLang?: InputMaybe<Array<PipelineTranslationOnPipelineTranslationForPipelineTranslationsPipelineIdFkeyUsingPipelineTranslationsPkeyUpdate>>;
};

/** The `pipelineTranslation` to be created by this mutation. */
export type PipelineTranslationsPipelineIdFkeyPipelineTranslationsCreateInput = {
  lang: Language;
  pipeline?: InputMaybe<PipelineTranslationsPipelineIdFkeyInput>;
  title: Scalars['String']['input'];
};

/** The `pipeline` to be created by this mutation. */
export type PipelineTranslationsPipelineIdFkeyPipelinesCreateInput = {
  jobs?: InputMaybe<JobsPipelineIdFkeyInverseInput>;
  stages?: InputMaybe<PipelineStagesPipelineIdFkeyInverseInput>;
  translations?: InputMaybe<PipelineTranslationsPipelineIdFkeyInverseInput>;
};

/** A connection to a list of `Pipeline` values. */
export type PipelinesConnection = {
  __typename?: 'PipelinesConnection';
  /** A list of edges which contains the `Pipeline` and cursor to aid in pagination. */
  edges: Array<PipelinesEdge>;
  /** A list of `Pipeline` objects. */
  nodes: Array<Pipeline>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Pipeline` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `Pipeline` edge in the connection. */
export type PipelinesEdge = {
  __typename?: 'PipelinesEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Pipeline` at the end of the edge. */
  node: Pipeline;
};

/** Methods to use when ordering `Pipeline`. */
export enum PipelinesOrderBy {
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  Natural = 'NATURAL',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC'
}

/** The root query type which gives access points into the data universe. */
export type Query = Node & {
  __typename?: 'Query';
  allTags?: Maybe<AllTagsPayload>;
  candidate?: Maybe<Candidate>;
  /** Reads a single `Candidate` using its globally unique `ID`. */
  candidateByNodeId?: Maybe<Candidate>;
  candidateFile?: Maybe<CandidateFile>;
  /** Reads a single `CandidateFile` using its globally unique `ID`. */
  candidateFileByNodeId?: Maybe<CandidateFile>;
  candidateImport?: Maybe<CandidateImport>;
  /** Reads a single `CandidateImport` using its globally unique `ID`. */
  candidateImportByNodeId?: Maybe<CandidateImport>;
  candidateImportCandidate?: Maybe<CandidateImportCandidate>;
  /** Reads a single `CandidateImportCandidate` using its globally unique `ID`. */
  candidateImportCandidateByNodeId?: Maybe<CandidateImportCandidate>;
  /** Reads and enables pagination through a set of `CandidateImportCandidate`. */
  candidateImportCandidates?: Maybe<CandidateImportCandidatesConnection>;
  candidateImportFile?: Maybe<CandidateImportFile>;
  /** Reads a single `CandidateImportFile` using its globally unique `ID`. */
  candidateImportFileByNodeId?: Maybe<CandidateImportFile>;
  /** Reads and enables pagination through a set of `CandidateImportFile`. */
  candidateImportFiles?: Maybe<CandidateImportFilesConnection>;
  /** Reads and enables pagination through a set of `CandidateImport`. */
  candidateImports?: Maybe<CandidateImportsConnection>;
  candidatePerDayReport: Array<CandidatePerDayReport>;
  candidateQuestion?: Maybe<CandidateQuestion>;
  /** Reads a single `CandidateQuestion` using its globally unique `ID`. */
  candidateQuestionByNodeId?: Maybe<CandidateQuestion>;
  candidateQuestionnaire?: Maybe<CandidateQuestionnaire>;
  /** Reads a single `CandidateQuestionnaire` using its globally unique `ID`. */
  candidateQuestionnaireByNodeId?: Maybe<CandidateQuestionnaire>;
  /** Reads and enables pagination through a set of `CandidateQuestionnaire`. */
  candidateQuestionnaires?: Maybe<CandidateQuestionnairesConnection>;
  candidateTag?: Maybe<CandidateTag>;
  /** Reads a single `CandidateTag` using its globally unique `ID`. */
  candidateTagByNodeId?: Maybe<CandidateTag>;
  /** Reads and enables pagination through a set of `CandidateTag`. */
  candidateTags?: Maybe<CandidateTagsConnection>;
  candidateTranslation?: Maybe<CandidateTranslation>;
  /** Reads a single `CandidateTranslation` using its globally unique `ID`. */
  candidateTranslationByNodeId?: Maybe<CandidateTranslation>;
  /** Reads and enables pagination through a set of `Candidate`. */
  candidates?: Maybe<CandidatesConnection>;
  candidatesPerDepartment: Array<CandidatesPerDepartment>;
  candidatesPerPipelineStage: Array<CandidatesPerPipelineStage>;
  /** Reads and enables pagination through a set of `Company`. */
  companies?: Maybe<CompaniesConnection>;
  companiesByTagIdsAndJobSearch?: Maybe<CompaniesByTagIdsAndJobSearchPayload>;
  company?: Maybe<Company>;
  /** Reads a single `Company` using its globally unique `ID`. */
  companyByNodeId?: Maybe<Company>;
  companyBySlug?: Maybe<Company>;
  companyTranslation?: Maybe<CompanyTranslation>;
  /** Reads a single `CompanyTranslation` using its globally unique `ID`. */
  companyTranslationByNodeId?: Maybe<CompanyTranslation>;
  /** Reads a single `CompanyUser` using its globally unique `ID`. */
  companyUserByNodeId?: Maybe<CompanyUser>;
  /** Reads and enables pagination through a set of `CompanyUser`. */
  companyUsers?: Maybe<CompanyUsersConnection>;
  /** Reads and enables pagination through a set of `Competency`. */
  competencies?: Maybe<CompetenciesConnection>;
  competency?: Maybe<Competency>;
  /** Reads a single `Competency` using its globally unique `ID`. */
  competencyByNodeId?: Maybe<Competency>;
  currentCompany?: Maybe<Company>;
  currentUser?: Maybe<User>;
  currentWebsite?: Maybe<Website>;
  department?: Maybe<Department>;
  /** Reads a single `Department` using its globally unique `ID`. */
  departmentByNodeId?: Maybe<Department>;
  departmentTranslation?: Maybe<DepartmentTranslation>;
  /** Reads a single `DepartmentTranslation` using its globally unique `ID`. */
  departmentTranslationByNodeId?: Maybe<DepartmentTranslation>;
  /** Reads and enables pagination through a set of `Department`. */
  departments?: Maybe<DepartmentsConnection>;
  disqualifyReason?: Maybe<DisqualifyReason>;
  /** Reads a single `DisqualifyReason` using its globally unique `ID`. */
  disqualifyReasonByNodeId?: Maybe<DisqualifyReason>;
  disqualifyReasonTranslation?: Maybe<DisqualifyReasonTranslation>;
  /** Reads a single `DisqualifyReasonTranslation` using its globally unique `ID`. */
  disqualifyReasonTranslationByNodeId?: Maybe<DisqualifyReasonTranslation>;
  /** Reads and enables pagination through a set of `DisqualifyReason`. */
  disqualifyReasons?: Maybe<DisqualifyReasonsConnection>;
  draftEvaluation?: Maybe<DraftEvaluation>;
  /** Reads a single `DraftEvaluation` using its globally unique `ID`. */
  draftEvaluationByNodeId?: Maybe<DraftEvaluation>;
  draftEvaluationByPipelineStageIdAndJobIdAndCandidateId?: Maybe<DraftEvaluation>;
  /** Reads and enables pagination through a set of `DraftEvaluation`. */
  draftEvaluations?: Maybe<DraftEvaluationsConnection>;
  evaluation?: Maybe<Evaluation>;
  /** Reads a single `Evaluation` using its globally unique `ID`. */
  evaluationByNodeId?: Maybe<Evaluation>;
  evaluationScorecard?: Maybe<EvaluationScorecard>;
  /** Reads a single `EvaluationScorecard` using its globally unique `ID`. */
  evaluationScorecardByNodeId?: Maybe<EvaluationScorecard>;
  evaluationScorecardCriteria?: Maybe<EvaluationScorecardCriteria>;
  /** Reads a single `EvaluationScorecardCriteria` using its globally unique `ID`. */
  evaluationScorecardCriteriaByNodeId?: Maybe<EvaluationScorecardCriteria>;
  /** Reads and enables pagination through a set of `Evaluation`. */
  evaluations?: Maybe<EvaluationsConnection>;
  event?: Maybe<Event>;
  /** Reads a single `Event` using its globally unique `ID`. */
  eventByNodeId?: Maybe<Event>;
  /** Reads a single `EventCandidate` using its globally unique `ID`. */
  eventCandidateByNodeId?: Maybe<EventCandidate>;
  /** Reads and enables pagination through a set of `EventCandidate`. */
  eventCandidates?: Maybe<EventCandidatesConnection>;
  eventDraftEvaluation?: Maybe<EventDraftEvaluation>;
  eventDraftEvaluationByEventIdAndCandidateId?: Maybe<EventDraftEvaluation>;
  /** Reads a single `EventDraftEvaluation` using its globally unique `ID`. */
  eventDraftEvaluationByNodeId?: Maybe<EventDraftEvaluation>;
  /** Reads and enables pagination through a set of `EventDraftEvaluation`. */
  eventDraftEvaluations?: Maybe<EventDraftEvaluationsConnection>;
  /** Reads a single `EventScorecard` using its globally unique `ID`. */
  eventScorecardByNodeId?: Maybe<EventScorecard>;
  /** Reads and enables pagination through a set of `EventScorecard`. */
  eventScorecards?: Maybe<EventScorecardsConnection>;
  /** Reads a single `EventUser` using its globally unique `ID`. */
  eventUserByNodeId?: Maybe<EventUser>;
  /** Reads and enables pagination through a set of `EventUser`. */
  eventUsers?: Maybe<EventUsersConnection>;
  /** Reads and enables pagination through a set of `Event`. */
  events?: Maybe<EventsConnection>;
  field?: Maybe<Field>;
  /** Reads a single `Field` using its globally unique `ID`. */
  fieldByNodeId?: Maybe<Field>;
  invoice?: Maybe<Invoice>;
  /** Reads a single `Invoice` using its globally unique `ID`. */
  invoiceByNodeId?: Maybe<Invoice>;
  /** Reads and enables pagination through a set of `Invoice`. */
  invoices?: Maybe<InvoicesConnection>;
  job?: Maybe<Job>;
  /** Reads a single `Job` using its globally unique `ID`. */
  jobByNodeId?: Maybe<Job>;
  /** Reads and enables pagination through a set of `JobCompetency`. */
  jobCompetencies?: Maybe<JobCompetenciesConnection>;
  jobCompetency?: Maybe<JobCompetency>;
  /** Reads a single `JobCompetency` using its globally unique `ID`. */
  jobCompetencyByNodeId?: Maybe<JobCompetency>;
  jobKnowledge?: Maybe<JobKnowledge>;
  /** Reads a single `JobKnowledge` using its globally unique `ID`. */
  jobKnowledgeByNodeId?: Maybe<JobKnowledge>;
  /** Reads and enables pagination through a set of `JobKnowledge`. */
  jobKnowledges?: Maybe<JobKnowledgesConnection>;
  jobOwner?: Maybe<JobOwner>;
  /** Reads a single `JobOwner` using its globally unique `ID`. */
  jobOwnerByNodeId?: Maybe<JobOwner>;
  /** Reads and enables pagination through a set of `JobOwner`. */
  jobOwners?: Maybe<JobOwnersConnection>;
  jobQuestionnaire?: Maybe<JobQuestionnaire>;
  /** Reads a single `JobQuestionnaire` using its globally unique `ID`. */
  jobQuestionnaireByNodeId?: Maybe<JobQuestionnaire>;
  /** Reads and enables pagination through a set of `JobQuestionnaire`. */
  jobQuestionnaires?: Maybe<JobQuestionnairesConnection>;
  jobSkill?: Maybe<JobSkill>;
  /** Reads a single `JobSkill` using its globally unique `ID`. */
  jobSkillByNodeId?: Maybe<JobSkill>;
  /** Reads and enables pagination through a set of `JobSkill`. */
  jobSkills?: Maybe<JobSkillsConnection>;
  jobTag?: Maybe<JobTag>;
  /** Reads a single `JobTag` using its globally unique `ID`. */
  jobTagByNodeId?: Maybe<JobTag>;
  /** Reads and enables pagination through a set of `JobTag`. */
  jobTags?: Maybe<JobTagsConnection>;
  jobTranslation?: Maybe<JobTranslation>;
  /** Reads a single `JobTranslation` using its globally unique `ID`. */
  jobTranslationByNodeId?: Maybe<JobTranslation>;
  /** Reads and enables pagination through a set of `Job`. */
  jobs?: Maybe<JobsConnection>;
  jobsApplication?: Maybe<JobsApplication>;
  jobsApplicationByCandidateIdAndJobId?: Maybe<JobsApplication>;
  /** Reads a single `JobsApplication` using its globally unique `ID`. */
  jobsApplicationByNodeId?: Maybe<JobsApplication>;
  /** Reads and enables pagination through a set of `JobsApplication`. */
  jobsApplications?: Maybe<JobsApplicationsConnection>;
  jobsWithCompanyDetails?: Maybe<JobsWithCompanyDetailsPayload>;
  knowledge?: Maybe<Knowledge>;
  /** Reads a single `Knowledge` using its globally unique `ID`. */
  knowledgeByNodeId?: Maybe<Knowledge>;
  /** Reads and enables pagination through a set of `Knowledge`. */
  knowledges?: Maybe<KnowledgesConnection>;
  message?: Maybe<Message>;
  messageByExternalId?: Maybe<Message>;
  messageByExternalMessageId?: Maybe<Message>;
  /** Reads a single `Message` using its globally unique `ID`. */
  messageByNodeId?: Maybe<Message>;
  messageFile?: Maybe<MessageFile>;
  /** Reads a single `MessageFile` using its globally unique `ID`. */
  messageFileByNodeId?: Maybe<MessageFile>;
  /** Reads and enables pagination through a set of `MessageFile`. */
  messageFiles?: Maybe<MessageFilesConnection>;
  /** Reads and enables pagination through a set of `Message`. */
  messages?: Maybe<MessagesConnection>;
  /** Fetches an object given its globally unique `ID`. */
  node?: Maybe<Node>;
  /** The root query type must be a `Node` to work well with Relay 1 mutations. This just resolves to `query`. */
  nodeId: Scalars['ID']['output'];
  pipeline?: Maybe<Pipeline>;
  /** Reads a single `Pipeline` using its globally unique `ID`. */
  pipelineByNodeId?: Maybe<Pipeline>;
  pipelineSpeedByJobsReport: Array<PipelineSpeedByJobsReport>;
  pipelineStage?: Maybe<PipelineStage>;
  /** Reads a single `PipelineStage` using its globally unique `ID`. */
  pipelineStageByNodeId?: Maybe<PipelineStage>;
  pipelineStageScorecard?: Maybe<PipelineStageScorecard>;
  /** Reads a single `PipelineStageScorecard` using its globally unique `ID`. */
  pipelineStageScorecardByNodeId?: Maybe<PipelineStageScorecard>;
  /** Reads and enables pagination through a set of `PipelineStageScorecard`. */
  pipelineStageScorecards?: Maybe<PipelineStageScorecardsConnection>;
  pipelineStageTranslation?: Maybe<PipelineStageTranslation>;
  /** Reads a single `PipelineStageTranslation` using its globally unique `ID`. */
  pipelineStageTranslationByNodeId?: Maybe<PipelineStageTranslation>;
  pipelineStageUser?: Maybe<PipelineStageUser>;
  /** Reads a single `PipelineStageUser` using its globally unique `ID`. */
  pipelineStageUserByNodeId?: Maybe<PipelineStageUser>;
  /** Reads and enables pagination through a set of `PipelineStageUser`. */
  pipelineStageUsers?: Maybe<PipelineStageUsersConnection>;
  /** Reads and enables pagination through a set of `PipelineStage`. */
  pipelineStages?: Maybe<PipelineStagesConnection>;
  pipelineTranslation?: Maybe<PipelineTranslation>;
  /** Reads a single `PipelineTranslation` using its globally unique `ID`. */
  pipelineTranslationByNodeId?: Maybe<PipelineTranslation>;
  /** Reads and enables pagination through a set of `Pipeline`. */
  pipelines?: Maybe<PipelinesConnection>;
  /** Exposes the root query type nested one level down. This is helpful for Relay 1 which can only query top level fields if they are in a particular form. */
  query: Query;
  question?: Maybe<Question>;
  /** Reads a single `Question` using its globally unique `ID`. */
  questionByNodeId?: Maybe<Question>;
  questionOption?: Maybe<QuestionOption>;
  /** Reads a single `QuestionOption` using its globally unique `ID`. */
  questionOptionByNodeId?: Maybe<QuestionOption>;
  questionOptionTranslation?: Maybe<QuestionOptionTranslation>;
  /** Reads a single `QuestionOptionTranslation` using its globally unique `ID`. */
  questionOptionTranslationByNodeId?: Maybe<QuestionOptionTranslation>;
  questionTranslation?: Maybe<QuestionTranslation>;
  /** Reads a single `QuestionTranslation` using its globally unique `ID`. */
  questionTranslationByNodeId?: Maybe<QuestionTranslation>;
  questionnaire?: Maybe<Questionnaire>;
  /** Reads a single `Questionnaire` using its globally unique `ID`. */
  questionnaireByNodeId?: Maybe<Questionnaire>;
  questionnaireQuestion?: Maybe<QuestionnaireQuestion>;
  /** Reads a single `QuestionnaireQuestion` using its globally unique `ID`. */
  questionnaireQuestionByNodeId?: Maybe<QuestionnaireQuestion>;
  questionnaireTranslation?: Maybe<QuestionnaireTranslation>;
  /** Reads a single `QuestionnaireTranslation` using its globally unique `ID`. */
  questionnaireTranslationByNodeId?: Maybe<QuestionnaireTranslation>;
  /** Reads and enables pagination through a set of `Questionnaire`. */
  questionnaires?: Maybe<QuestionnairesConnection>;
  /** Reads and enables pagination through a set of `Question`. */
  questions?: Maybe<QuestionsConnection>;
  role?: Maybe<Role>;
  /** Reads a single `Role` using its globally unique `ID`. */
  roleByNodeId?: Maybe<Role>;
  roleTranslation?: Maybe<RoleTranslation>;
  /** Reads a single `RoleTranslation` using its globally unique `ID`. */
  roleTranslationByNodeId?: Maybe<RoleTranslation>;
  /** Reads and enables pagination through a set of `Role`. */
  roles?: Maybe<RolesConnection>;
  scorecard?: Maybe<Scorecard>;
  /** Reads a single `Scorecard` using its globally unique `ID`. */
  scorecardByNodeId?: Maybe<Scorecard>;
  scorecardCriteria?: Maybe<ScorecardCriteria>;
  /** Reads a single `ScorecardCriteria` using its globally unique `ID`. */
  scorecardCriteriaByNodeId?: Maybe<ScorecardCriteria>;
  scorecardCriteriaTranslation?: Maybe<ScorecardCriteriaTranslation>;
  /** Reads a single `ScorecardCriteriaTranslation` using its globally unique `ID`. */
  scorecardCriteriaTranslationByNodeId?: Maybe<ScorecardCriteriaTranslation>;
  scorecardTranslation?: Maybe<ScorecardTranslation>;
  /** Reads a single `ScorecardTranslation` using its globally unique `ID`. */
  scorecardTranslationByNodeId?: Maybe<ScorecardTranslation>;
  /** Reads and enables pagination through a set of `Scorecard`. */
  scorecards?: Maybe<ScorecardsConnection>;
  skill?: Maybe<Skill>;
  /** Reads a single `Skill` using its globally unique `ID`. */
  skillByNodeId?: Maybe<Skill>;
  /** Reads and enables pagination through a set of `Skill`. */
  skills?: Maybe<SkillsConnection>;
  subscription?: Maybe<Subscription>;
  /** Reads a single `Subscription` using its globally unique `ID`. */
  subscriptionByNodeId?: Maybe<Subscription>;
  /** Reads and enables pagination through a set of `Subscription`. */
  subscriptions?: Maybe<SubscriptionsConnection>;
  tag?: Maybe<Tag>;
  /** Reads a single `Tag` using its globally unique `ID`. */
  tagByNodeId?: Maybe<Tag>;
  /** Reads and enables pagination through a set of `Tag`. */
  tags?: Maybe<TagsConnection>;
  thread?: Maybe<Thread>;
  /** Reads a single `Thread` using its globally unique `ID`. */
  threadByNodeId?: Maybe<Thread>;
  threadUser?: Maybe<ThreadUser>;
  /** Reads a single `ThreadUser` using its globally unique `ID`. */
  threadUserByNodeId?: Maybe<ThreadUser>;
  /** Reads and enables pagination through a set of `Thread`. */
  threads?: Maybe<ThreadsConnection>;
  timeToHireByJobReport: Array<TimeToHireByJobReport>;
  totalDisqualifiedCandidates: TotalDisqualifiedCandidates;
  totalHiredCandidates: TotalHiredCandidates;
  user?: Maybe<User>;
  userByEmail?: Maybe<User>;
  /** Reads a single `User` using its globally unique `ID`. */
  userByNodeId?: Maybe<User>;
  userInvitation?: Maybe<UserInvitation>;
  /** Reads a single `UserInvitation` using its globally unique `ID`. */
  userInvitationByNodeId?: Maybe<UserInvitation>;
  userInvitationByToken?: Maybe<UserInvitation>;
  userInvitationValidation?: Maybe<UserInvitation>;
  /** Reads and enables pagination through a set of `UserInvitation`. */
  userInvitations?: Maybe<UserInvitationsConnection>;
  userTranslation?: Maybe<UserTranslation>;
  /** Reads a single `UserTranslation` using its globally unique `ID`. */
  userTranslationByNodeId?: Maybe<UserTranslation>;
  userUsingCredential?: Maybe<User>;
  /** Reads and enables pagination through a set of `User`. */
  users?: Maybe<UsersConnection>;
  website?: Maybe<Website>;
  websiteByHost?: Maybe<Website>;
  /** Reads a single `Website` using its globally unique `ID`. */
  websiteByNodeId?: Maybe<Website>;
  websiteFile?: Maybe<WebsiteFile>;
  /** Reads a single `WebsiteFile` using its globally unique `ID`. */
  websiteFileByNodeId?: Maybe<WebsiteFile>;
};


/** The root query type which gives access points into the data universe. */
export type QueryAllTagsArgs = {
  input: AllTagsInput;
};


/** The root query type which gives access points into the data universe. */
export type QueryCandidateArgs = {
  id: Scalars['Int']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryCandidateByNodeIdArgs = {
  nodeId: Scalars['ID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryCandidateFileArgs = {
  externalId: Scalars['UUID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryCandidateFileByNodeIdArgs = {
  nodeId: Scalars['ID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryCandidateImportArgs = {
  id: Scalars['Int']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryCandidateImportByNodeIdArgs = {
  nodeId: Scalars['ID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryCandidateImportCandidateArgs = {
  candidateId: Scalars['Int']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryCandidateImportCandidateByNodeIdArgs = {
  nodeId: Scalars['ID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryCandidateImportCandidatesArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<CandidateImportCandidateCondition>;
  filter?: InputMaybe<CandidateImportCandidateFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<CandidateImportCandidatesOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryCandidateImportFileArgs = {
  externalId: Scalars['UUID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryCandidateImportFileByNodeIdArgs = {
  nodeId: Scalars['ID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryCandidateImportFilesArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<CandidateImportFileCondition>;
  filter?: InputMaybe<CandidateImportFileFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<CandidateImportFilesOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryCandidateImportsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<CandidateImportCondition>;
  filter?: InputMaybe<CandidateImportFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<CandidateImportsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryCandidateQuestionArgs = {
  id: Scalars['Int']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryCandidateQuestionByNodeIdArgs = {
  nodeId: Scalars['ID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryCandidateQuestionnaireArgs = {
  id: Scalars['Int']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryCandidateQuestionnaireByNodeIdArgs = {
  nodeId: Scalars['ID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryCandidateQuestionnairesArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<CandidateQuestionnaireCondition>;
  filter?: InputMaybe<CandidateQuestionnaireFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<CandidateQuestionnairesOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryCandidateTagArgs = {
  candidateId: Scalars['Int']['input'];
  tagId: Scalars['Int']['input'];
  type: CandidateTagType;
};


/** The root query type which gives access points into the data universe. */
export type QueryCandidateTagByNodeIdArgs = {
  nodeId: Scalars['ID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryCandidateTagsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<CandidateTagCondition>;
  filter?: InputMaybe<CandidateTagFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<CandidateTagsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryCandidateTranslationArgs = {
  candidateId: Scalars['Int']['input'];
  lang: Language;
};


/** The root query type which gives access points into the data universe. */
export type QueryCandidateTranslationByNodeIdArgs = {
  nodeId: Scalars['ID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryCandidatesArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<CandidateCondition>;
  filter?: InputMaybe<CandidateFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<CandidatesOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryCompaniesArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<CompanyCondition>;
  filter?: InputMaybe<CompanyFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<CompaniesOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryCompaniesByTagIdsAndJobSearchArgs = {
  input: CompaniesByTagIdsAndJobSearchInput;
};


/** The root query type which gives access points into the data universe. */
export type QueryCompanyArgs = {
  id: Scalars['Int']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryCompanyByNodeIdArgs = {
  nodeId: Scalars['ID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryCompanyBySlugArgs = {
  slug: Scalars['String']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryCompanyTranslationArgs = {
  companyId: Scalars['Int']['input'];
  lang: Language;
};


/** The root query type which gives access points into the data universe. */
export type QueryCompanyTranslationByNodeIdArgs = {
  nodeId: Scalars['ID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryCompanyUserByNodeIdArgs = {
  nodeId: Scalars['ID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryCompanyUsersArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<CompanyUserCondition>;
  filter?: InputMaybe<CompanyUserFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<CompanyUsersOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryCompetenciesArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<CompetencyCondition>;
  filter?: InputMaybe<CompetencyFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<CompetenciesOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryCompetencyArgs = {
  id: Scalars['Int']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryCompetencyByNodeIdArgs = {
  nodeId: Scalars['ID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryDepartmentArgs = {
  id: Scalars['Int']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryDepartmentByNodeIdArgs = {
  nodeId: Scalars['ID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryDepartmentTranslationArgs = {
  departmentId: Scalars['Int']['input'];
  lang: Language;
};


/** The root query type which gives access points into the data universe. */
export type QueryDepartmentTranslationByNodeIdArgs = {
  nodeId: Scalars['ID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryDepartmentsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<DepartmentCondition>;
  filter?: InputMaybe<DepartmentFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<DepartmentsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryDisqualifyReasonArgs = {
  id: Scalars['Int']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryDisqualifyReasonByNodeIdArgs = {
  nodeId: Scalars['ID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryDisqualifyReasonTranslationArgs = {
  disqualifyReasonId: Scalars['Int']['input'];
  lang: Language;
};


/** The root query type which gives access points into the data universe. */
export type QueryDisqualifyReasonTranslationByNodeIdArgs = {
  nodeId: Scalars['ID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryDisqualifyReasonsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<DisqualifyReasonCondition>;
  filter?: InputMaybe<DisqualifyReasonFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<DisqualifyReasonsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryDraftEvaluationArgs = {
  id: Scalars['Int']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryDraftEvaluationByNodeIdArgs = {
  nodeId: Scalars['ID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryDraftEvaluationByPipelineStageIdAndJobIdAndCandidateIdArgs = {
  candidateId: Scalars['Int']['input'];
  jobId: Scalars['Int']['input'];
  pipelineStageId: Scalars['Int']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryDraftEvaluationsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<DraftEvaluationCondition>;
  filter?: InputMaybe<DraftEvaluationFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<DraftEvaluationsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryEvaluationArgs = {
  id: Scalars['Int']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryEvaluationByNodeIdArgs = {
  nodeId: Scalars['ID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryEvaluationScorecardArgs = {
  id: Scalars['Int']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryEvaluationScorecardByNodeIdArgs = {
  nodeId: Scalars['ID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryEvaluationScorecardCriteriaArgs = {
  id: Scalars['Int']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryEvaluationScorecardCriteriaByNodeIdArgs = {
  nodeId: Scalars['ID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryEvaluationsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<EvaluationCondition>;
  filter?: InputMaybe<EvaluationFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<EvaluationsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryEventArgs = {
  id: Scalars['Int']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryEventByNodeIdArgs = {
  nodeId: Scalars['ID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryEventCandidateByNodeIdArgs = {
  nodeId: Scalars['ID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryEventCandidatesArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<EventCandidateCondition>;
  filter?: InputMaybe<EventCandidateFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<EventCandidatesOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryEventDraftEvaluationArgs = {
  id: Scalars['Int']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryEventDraftEvaluationByEventIdAndCandidateIdArgs = {
  candidateId: Scalars['Int']['input'];
  eventId: Scalars['Int']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryEventDraftEvaluationByNodeIdArgs = {
  nodeId: Scalars['ID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryEventDraftEvaluationsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<EventDraftEvaluationCondition>;
  filter?: InputMaybe<EventDraftEvaluationFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<EventDraftEvaluationsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryEventScorecardByNodeIdArgs = {
  nodeId: Scalars['ID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryEventScorecardsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<EventScorecardCondition>;
  filter?: InputMaybe<EventScorecardFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<EventScorecardsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryEventUserByNodeIdArgs = {
  nodeId: Scalars['ID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryEventUsersArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<EventUserCondition>;
  filter?: InputMaybe<EventUserFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<EventUsersOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryEventsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<EventCondition>;
  filter?: InputMaybe<EventFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<EventsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryFieldArgs = {
  id: Scalars['Int']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryFieldByNodeIdArgs = {
  nodeId: Scalars['ID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryInvoiceArgs = {
  id: Scalars['Int']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryInvoiceByNodeIdArgs = {
  nodeId: Scalars['ID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryInvoicesArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<InvoiceCondition>;
  filter?: InputMaybe<InvoiceFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<InvoicesOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryJobArgs = {
  id: Scalars['Int']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryJobByNodeIdArgs = {
  nodeId: Scalars['ID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryJobCompetenciesArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<JobCompetencyCondition>;
  filter?: InputMaybe<JobCompetencyFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<JobCompetenciesOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryJobCompetencyArgs = {
  competenceId: Scalars['Int']['input'];
  jobId: Scalars['Int']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryJobCompetencyByNodeIdArgs = {
  nodeId: Scalars['ID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryJobKnowledgeArgs = {
  jobId: Scalars['Int']['input'];
  knowledgeId: Scalars['Int']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryJobKnowledgeByNodeIdArgs = {
  nodeId: Scalars['ID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryJobKnowledgesArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<JobKnowledgeCondition>;
  filter?: InputMaybe<JobKnowledgeFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<JobKnowledgesOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryJobOwnerArgs = {
  jobId: Scalars['Int']['input'];
  userId: Scalars['Int']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryJobOwnerByNodeIdArgs = {
  nodeId: Scalars['ID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryJobOwnersArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<JobOwnerCondition>;
  filter?: InputMaybe<JobOwnerFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<JobOwnersOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryJobQuestionnaireArgs = {
  jobId: Scalars['Int']['input'];
  questionnaireId: Scalars['Int']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryJobQuestionnaireByNodeIdArgs = {
  nodeId: Scalars['ID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryJobQuestionnairesArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<JobQuestionnaireCondition>;
  filter?: InputMaybe<JobQuestionnaireFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<JobQuestionnairesOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryJobSkillArgs = {
  jobId: Scalars['Int']['input'];
  skillId: Scalars['Int']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryJobSkillByNodeIdArgs = {
  nodeId: Scalars['ID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryJobSkillsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<JobSkillCondition>;
  filter?: InputMaybe<JobSkillFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<JobSkillsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryJobTagArgs = {
  jobId: Scalars['Int']['input'];
  tagId: Scalars['Int']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryJobTagByNodeIdArgs = {
  nodeId: Scalars['ID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryJobTagsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<JobTagCondition>;
  filter?: InputMaybe<JobTagFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<JobTagsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryJobTranslationArgs = {
  jobId: Scalars['Int']['input'];
  lang: Language;
};


/** The root query type which gives access points into the data universe. */
export type QueryJobTranslationByNodeIdArgs = {
  nodeId: Scalars['ID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryJobsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<JobCondition>;
  filter?: InputMaybe<JobFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<JobsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryJobsApplicationArgs = {
  id: Scalars['Int']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryJobsApplicationByCandidateIdAndJobIdArgs = {
  candidateId: Scalars['Int']['input'];
  jobId: Scalars['Int']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryJobsApplicationByNodeIdArgs = {
  nodeId: Scalars['ID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryJobsApplicationsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<JobsApplicationCondition>;
  filter?: InputMaybe<JobsApplicationFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<JobsApplicationsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryJobsWithCompanyDetailsArgs = {
  input: JobsWithCompanyDetailsInput;
};


/** The root query type which gives access points into the data universe. */
export type QueryKnowledgeArgs = {
  id: Scalars['Int']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryKnowledgeByNodeIdArgs = {
  nodeId: Scalars['ID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryKnowledgesArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<KnowledgeCondition>;
  filter?: InputMaybe<KnowledgeFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<KnowledgesOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryMessageArgs = {
  id: Scalars['Int']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryMessageByExternalIdArgs = {
  externalId: Scalars['UUID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryMessageByExternalMessageIdArgs = {
  externalMessageId: Scalars['String']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryMessageByNodeIdArgs = {
  nodeId: Scalars['ID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryMessageFileArgs = {
  externalId: Scalars['UUID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryMessageFileByNodeIdArgs = {
  nodeId: Scalars['ID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryMessageFilesArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<MessageFileCondition>;
  filter?: InputMaybe<MessageFileFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<MessageFilesOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryMessagesArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<MessageCondition>;
  filter?: InputMaybe<MessageFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<MessagesOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryNodeArgs = {
  nodeId: Scalars['ID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryPipelineArgs = {
  id: Scalars['Int']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryPipelineByNodeIdArgs = {
  nodeId: Scalars['ID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryPipelineStageArgs = {
  id: Scalars['Int']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryPipelineStageByNodeIdArgs = {
  nodeId: Scalars['ID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryPipelineStageScorecardArgs = {
  pipelineStageId: Scalars['Int']['input'];
  scorecardId: Scalars['Int']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryPipelineStageScorecardByNodeIdArgs = {
  nodeId: Scalars['ID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryPipelineStageScorecardsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<PipelineStageScorecardCondition>;
  filter?: InputMaybe<PipelineStageScorecardFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<PipelineStageScorecardsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryPipelineStageTranslationArgs = {
  lang: Language;
  pipelineStageId: Scalars['Int']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryPipelineStageTranslationByNodeIdArgs = {
  nodeId: Scalars['ID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryPipelineStageUserArgs = {
  pipelineStageId: Scalars['Int']['input'];
  userId: Scalars['Int']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryPipelineStageUserByNodeIdArgs = {
  nodeId: Scalars['ID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryPipelineStageUsersArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<PipelineStageUserCondition>;
  filter?: InputMaybe<PipelineStageUserFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<PipelineStageUsersOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryPipelineStagesArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<PipelineStageCondition>;
  filter?: InputMaybe<PipelineStageFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<PipelineStagesOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryPipelineTranslationArgs = {
  lang: Language;
  pipelineId: Scalars['Int']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryPipelineTranslationByNodeIdArgs = {
  nodeId: Scalars['ID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryPipelinesArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<PipelineCondition>;
  filter?: InputMaybe<PipelineFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<PipelinesOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryQuestionArgs = {
  id: Scalars['Int']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryQuestionByNodeIdArgs = {
  nodeId: Scalars['ID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryQuestionOptionArgs = {
  id: Scalars['Int']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryQuestionOptionByNodeIdArgs = {
  nodeId: Scalars['ID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryQuestionOptionTranslationArgs = {
  lang: Language;
  questionOptionId: Scalars['Int']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryQuestionOptionTranslationByNodeIdArgs = {
  nodeId: Scalars['ID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryQuestionTranslationArgs = {
  lang: Language;
  questionId: Scalars['Int']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryQuestionTranslationByNodeIdArgs = {
  nodeId: Scalars['ID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryQuestionnaireArgs = {
  id: Scalars['Int']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryQuestionnaireByNodeIdArgs = {
  nodeId: Scalars['ID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryQuestionnaireQuestionArgs = {
  questionId: Scalars['Int']['input'];
  questionnaireId: Scalars['Int']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryQuestionnaireQuestionByNodeIdArgs = {
  nodeId: Scalars['ID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryQuestionnaireTranslationArgs = {
  lang: Language;
  questionnaireId: Scalars['Int']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryQuestionnaireTranslationByNodeIdArgs = {
  nodeId: Scalars['ID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryQuestionnairesArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<QuestionnaireCondition>;
  filter?: InputMaybe<QuestionnaireFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<QuestionnairesOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryQuestionsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<QuestionCondition>;
  filter?: InputMaybe<QuestionFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<QuestionsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryRoleArgs = {
  id: Scalars['Int']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryRoleByNodeIdArgs = {
  nodeId: Scalars['ID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryRoleTranslationArgs = {
  lang: Language;
  roleId: Scalars['Int']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryRoleTranslationByNodeIdArgs = {
  nodeId: Scalars['ID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryRolesArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<RoleCondition>;
  filter?: InputMaybe<RoleFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<RolesOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryScorecardArgs = {
  id: Scalars['Int']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryScorecardByNodeIdArgs = {
  nodeId: Scalars['ID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryScorecardCriteriaArgs = {
  id: Scalars['Int']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryScorecardCriteriaByNodeIdArgs = {
  nodeId: Scalars['ID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryScorecardCriteriaTranslationArgs = {
  lang: Language;
  scorecardCriteriaId: Scalars['Int']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryScorecardCriteriaTranslationByNodeIdArgs = {
  nodeId: Scalars['ID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryScorecardTranslationArgs = {
  lang: Language;
  scorecardId: Scalars['Int']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryScorecardTranslationByNodeIdArgs = {
  nodeId: Scalars['ID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryScorecardsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<ScorecardCondition>;
  filter?: InputMaybe<ScorecardFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<ScorecardsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QuerySkillArgs = {
  id: Scalars['Int']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QuerySkillByNodeIdArgs = {
  nodeId: Scalars['ID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QuerySkillsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<SkillCondition>;
  filter?: InputMaybe<SkillFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<SkillsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QuerySubscriptionArgs = {
  id: Scalars['Int']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QuerySubscriptionByNodeIdArgs = {
  nodeId: Scalars['ID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QuerySubscriptionsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<SubscriptionCondition>;
  filter?: InputMaybe<SubscriptionFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<SubscriptionsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryTagArgs = {
  id: Scalars['Int']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryTagByNodeIdArgs = {
  nodeId: Scalars['ID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryTagsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<TagCondition>;
  filter?: InputMaybe<TagFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<TagsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryThreadArgs = {
  id: Scalars['Int']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryThreadByNodeIdArgs = {
  nodeId: Scalars['ID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryThreadUserArgs = {
  threadId: Scalars['Int']['input'];
  userId: Scalars['Int']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryThreadUserByNodeIdArgs = {
  nodeId: Scalars['ID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryThreadsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<ThreadCondition>;
  filter?: InputMaybe<ThreadFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<ThreadsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryUserArgs = {
  id: Scalars['Int']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryUserByEmailArgs = {
  email: Scalars['String']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryUserByNodeIdArgs = {
  nodeId: Scalars['ID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryUserInvitationArgs = {
  id: Scalars['Int']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryUserInvitationByNodeIdArgs = {
  nodeId: Scalars['ID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryUserInvitationByTokenArgs = {
  token: Scalars['UUID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryUserInvitationValidationArgs = {
  token: Scalars['UUID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryUserInvitationsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<UserInvitationCondition>;
  filter?: InputMaybe<UserInvitationFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<UserInvitationsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryUserTranslationArgs = {
  lang: Language;
  userId: Scalars['Int']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryUserTranslationByNodeIdArgs = {
  nodeId: Scalars['ID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryUserUsingCredentialArgs = {
  email: Scalars['String']['input'];
  password: Scalars['String']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryUsersArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<UserCondition>;
  filter?: InputMaybe<UserFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<UsersOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryWebsiteArgs = {
  id: Scalars['Int']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryWebsiteByHostArgs = {
  host: Scalars['String']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryWebsiteByNodeIdArgs = {
  nodeId: Scalars['ID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryWebsiteFileArgs = {
  externalId: Scalars['UUID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryWebsiteFileByNodeIdArgs = {
  nodeId: Scalars['ID']['input'];
};

export type Question = Node & {
  __typename?: 'Question';
  /** Reads and enables pagination through a set of `CandidateQuestion`. */
  candidateQuestions: CandidateQuestionsConnection;
  /** Reads and enables pagination through a set of `Candidate`. */
  candidates: QuestionCandidatesByCandidateQuestionQuestionIdAndCandidateIdManyToManyConnection;
  createdAt: Scalars['Datetime']['output'];
  id: Scalars['Int']['output'];
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  /** Reads and enables pagination through a set of `QuestionOption`. */
  options: QuestionOptionsConnection;
  /** Reads and enables pagination through a set of `QuestionOption`. */
  questionOptions: QuestionQuestionOptionsByCandidateQuestionQuestionIdAndQuestionOptionIdManyToManyConnection;
  /** Reads and enables pagination through a set of `QuestionnaireQuestion`. */
  questionnaireQuestions: QuestionnaireQuestionsConnection;
  /** Reads and enables pagination through a set of `Questionnaire`. */
  questionnaires: QuestionQuestionnairesByQuestionnaireQuestionQuestionIdAndQuestionnaireIdManyToManyConnection;
  required: Scalars['Boolean']['output'];
  /** Reads and enables pagination through a set of `QuestionTranslation`. */
  translations: QuestionTranslationsConnection;
  type: QuestionType;
  updatedAt: Scalars['Datetime']['output'];
};


export type QuestionCandidateQuestionsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<CandidateQuestionCondition>;
  filter?: InputMaybe<CandidateQuestionFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<CandidateQuestionsOrderBy>>;
};


export type QuestionCandidatesArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<CandidateCondition>;
  filter?: InputMaybe<CandidateFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<CandidatesOrderBy>>;
};


export type QuestionOptionsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<QuestionOptionCondition>;
  filter?: InputMaybe<QuestionOptionFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<QuestionOptionsOrderBy>>;
};


export type QuestionQuestionOptionsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<QuestionOptionCondition>;
  filter?: InputMaybe<QuestionOptionFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<QuestionOptionsOrderBy>>;
};


export type QuestionQuestionnaireQuestionsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<QuestionnaireQuestionCondition>;
  filter?: InputMaybe<QuestionnaireQuestionFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<QuestionnaireQuestionsOrderBy>>;
};


export type QuestionQuestionnairesArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<QuestionnaireCondition>;
  filter?: InputMaybe<QuestionnaireFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<QuestionnairesOrderBy>>;
};


export type QuestionTranslationsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<QuestionTranslationCondition>;
  filter?: InputMaybe<QuestionTranslationFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<QuestionTranslationsOrderBy>>;
};

/** A connection to a list of `Candidate` values, with data from `CandidateQuestion`. */
export type QuestionCandidatesByCandidateQuestionQuestionIdAndCandidateIdManyToManyConnection = {
  __typename?: 'QuestionCandidatesByCandidateQuestionQuestionIdAndCandidateIdManyToManyConnection';
  /** A list of edges which contains the `Candidate`, info from the `CandidateQuestion`, and the cursor to aid in pagination. */
  edges: Array<QuestionCandidatesByCandidateQuestionQuestionIdAndCandidateIdManyToManyEdge>;
  /** A list of `Candidate` objects. */
  nodes: Array<Candidate>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Candidate` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `Candidate` edge in the connection, with data from `CandidateQuestion`. */
export type QuestionCandidatesByCandidateQuestionQuestionIdAndCandidateIdManyToManyEdge = {
  __typename?: 'QuestionCandidatesByCandidateQuestionQuestionIdAndCandidateIdManyToManyEdge';
  /** Reads and enables pagination through a set of `CandidateQuestion`. */
  candidateQuestions: CandidateQuestionsConnection;
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Candidate` at the end of the edge. */
  node: Candidate;
};


/** A `Candidate` edge in the connection, with data from `CandidateQuestion`. */
export type QuestionCandidatesByCandidateQuestionQuestionIdAndCandidateIdManyToManyEdgeCandidateQuestionsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<CandidateQuestionCondition>;
  filter?: InputMaybe<CandidateQuestionFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<CandidateQuestionsOrderBy>>;
};

/** A condition to be used against `Question` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type QuestionCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['Int']['input']>;
};

/** A filter to be used against `Question` object types. All fields are combined with a logical ‘and.’ */
export type QuestionFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<QuestionFilter>>;
  /** Filter by the object’s `candidateQuestions` relation. */
  candidateQuestions?: InputMaybe<QuestionToManyCandidateQuestionFilter>;
  /** Some related `candidateQuestions` exist. */
  candidateQuestionsExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<IntFilter>;
  /** Negates the expression. */
  not?: InputMaybe<QuestionFilter>;
  /** Filter by the object’s `options` relation. */
  options?: InputMaybe<QuestionToManyQuestionOptionFilter>;
  /** Some related `options` exist. */
  optionsExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<QuestionFilter>>;
  /** Filter by the object’s `questionnaireQuestions` relation. */
  questionnaireQuestions?: InputMaybe<QuestionToManyQuestionnaireQuestionFilter>;
  /** Some related `questionnaireQuestions` exist. */
  questionnaireQuestionsExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `translations` relation. */
  translations?: InputMaybe<QuestionToManyQuestionTranslationFilter>;
  /** Some related `translations` exist. */
  translationsExist?: InputMaybe<Scalars['Boolean']['input']>;
};

/** An input for mutations affecting `Question` */
export type QuestionInput = {
  candidateQuestions?: InputMaybe<CandidateQuestionsQuestionIdFkeyInverseInput>;
  options?: InputMaybe<QuestionOptionsQuestionIdFkeyInverseInput>;
  questionnaireQuestions?: InputMaybe<QuestionnaireQuestionsQuestionIdFkeyInverseInput>;
  required: Scalars['Boolean']['input'];
  translations?: InputMaybe<QuestionTranslationsQuestionIdFkeyInverseInput>;
  type: QuestionType;
};

/** The globally unique `ID` look up for the row to connect. */
export type QuestionNodeIdConnect = {
  /** The globally unique `ID` which identifies a single `question` to be connected. */
  nodeId: Scalars['ID']['input'];
};

/** The globally unique `ID` look up for the row to update. */
export type QuestionOnCandidateQuestionForCandidateQuestionsQuestionIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `candidateQuestion` to be connected. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `candidateQuestion` being updated. */
  patch: CandidateQuestionPatch;
};

/** The fields on `question` to look up the row to update. */
export type QuestionOnCandidateQuestionForCandidateQuestionsQuestionIdFkeyUsingQuestionsPkeyUpdate = {
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `question` being updated. */
  patch: UpdateQuestionOnCandidateQuestionForCandidateQuestionsQuestionIdFkeyPatch;
};

/** The globally unique `ID` look up for the row to update. */
export type QuestionOnQuestionOptionForQuestionOptionsQuestionIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `questionOption` to be connected. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `questionOption` being updated. */
  patch: QuestionOptionPatch;
};

/** The fields on `question` to look up the row to update. */
export type QuestionOnQuestionOptionForQuestionOptionsQuestionIdFkeyUsingQuestionsPkeyUpdate = {
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `question` being updated. */
  patch: UpdateQuestionOnQuestionOptionForQuestionOptionsQuestionIdFkeyPatch;
};

/** The globally unique `ID` look up for the row to update. */
export type QuestionOnQuestionTranslationForQuestionTranslationsQuestionIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `questionTranslation` to be connected. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `questionTranslation` being updated. */
  patch: QuestionTranslationPatch;
};

/** The fields on `question` to look up the row to update. */
export type QuestionOnQuestionTranslationForQuestionTranslationsQuestionIdFkeyUsingQuestionsPkeyUpdate = {
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `question` being updated. */
  patch: UpdateQuestionOnQuestionTranslationForQuestionTranslationsQuestionIdFkeyPatch;
};

/** The globally unique `ID` look up for the row to update. */
export type QuestionOnQuestionnaireQuestionForQuestionnaireQuestionsQuestionIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `questionnaireQuestion` to be connected. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `questionnaireQuestion` being updated. */
  patch: QuestionnaireQuestionPatch;
};

/** The fields on `question` to look up the row to update. */
export type QuestionOnQuestionnaireQuestionForQuestionnaireQuestionsQuestionIdFkeyUsingQuestionsPkeyUpdate = {
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `question` being updated. */
  patch: UpdateQuestionOnQuestionnaireQuestionForQuestionnaireQuestionsQuestionIdFkeyPatch;
};

export type QuestionOption = Node & {
  __typename?: 'QuestionOption';
  /** Reads and enables pagination through a set of `CandidateQuestion`. */
  candidateQuestions: CandidateQuestionsConnection;
  /** Reads and enables pagination through a set of `Candidate`. */
  candidates: QuestionOptionCandidatesByCandidateQuestionQuestionOptionIdAndCandidateIdManyToManyConnection;
  id: Scalars['Int']['output'];
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  position: Scalars['Int']['output'];
  /** Reads a single `Question` that is related to this `QuestionOption`. */
  question?: Maybe<Question>;
  questionId: Scalars['Int']['output'];
  /** Reads and enables pagination through a set of `Question`. */
  questions: QuestionOptionQuestionsByCandidateQuestionQuestionOptionIdAndQuestionIdManyToManyConnection;
  /** Reads and enables pagination through a set of `QuestionOptionTranslation`. */
  translations: QuestionOptionTranslationsConnection;
};


export type QuestionOptionCandidateQuestionsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<CandidateQuestionCondition>;
  filter?: InputMaybe<CandidateQuestionFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<CandidateQuestionsOrderBy>>;
};


export type QuestionOptionCandidatesArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<CandidateCondition>;
  filter?: InputMaybe<CandidateFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<CandidatesOrderBy>>;
};


export type QuestionOptionQuestionsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<QuestionCondition>;
  filter?: InputMaybe<QuestionFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<QuestionsOrderBy>>;
};


export type QuestionOptionTranslationsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<QuestionOptionTranslationCondition>;
  filter?: InputMaybe<QuestionOptionTranslationFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<QuestionOptionTranslationsOrderBy>>;
};

/** A connection to a list of `Candidate` values, with data from `CandidateQuestion`. */
export type QuestionOptionCandidatesByCandidateQuestionQuestionOptionIdAndCandidateIdManyToManyConnection = {
  __typename?: 'QuestionOptionCandidatesByCandidateQuestionQuestionOptionIdAndCandidateIdManyToManyConnection';
  /** A list of edges which contains the `Candidate`, info from the `CandidateQuestion`, and the cursor to aid in pagination. */
  edges: Array<QuestionOptionCandidatesByCandidateQuestionQuestionOptionIdAndCandidateIdManyToManyEdge>;
  /** A list of `Candidate` objects. */
  nodes: Array<Candidate>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Candidate` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `Candidate` edge in the connection, with data from `CandidateQuestion`. */
export type QuestionOptionCandidatesByCandidateQuestionQuestionOptionIdAndCandidateIdManyToManyEdge = {
  __typename?: 'QuestionOptionCandidatesByCandidateQuestionQuestionOptionIdAndCandidateIdManyToManyEdge';
  /** Reads and enables pagination through a set of `CandidateQuestion`. */
  candidateQuestions: CandidateQuestionsConnection;
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Candidate` at the end of the edge. */
  node: Candidate;
};


/** A `Candidate` edge in the connection, with data from `CandidateQuestion`. */
export type QuestionOptionCandidatesByCandidateQuestionQuestionOptionIdAndCandidateIdManyToManyEdgeCandidateQuestionsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<CandidateQuestionCondition>;
  filter?: InputMaybe<CandidateQuestionFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<CandidateQuestionsOrderBy>>;
};

/** A condition to be used against `QuestionOption` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type QuestionOptionCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `questionId` field. */
  questionId?: InputMaybe<Scalars['Int']['input']>;
};

/** A filter to be used against `QuestionOption` object types. All fields are combined with a logical ‘and.’ */
export type QuestionOptionFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<QuestionOptionFilter>>;
  /** Filter by the object’s `candidateQuestions` relation. */
  candidateQuestions?: InputMaybe<QuestionOptionToManyCandidateQuestionFilter>;
  /** Some related `candidateQuestions` exist. */
  candidateQuestionsExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<IntFilter>;
  /** Negates the expression. */
  not?: InputMaybe<QuestionOptionFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<QuestionOptionFilter>>;
  /** Filter by the object’s `question` relation. */
  question?: InputMaybe<QuestionFilter>;
  /** Filter by the object’s `questionId` field. */
  questionId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `translations` relation. */
  translations?: InputMaybe<QuestionOptionToManyQuestionOptionTranslationFilter>;
  /** Some related `translations` exist. */
  translationsExist?: InputMaybe<Scalars['Boolean']['input']>;
};

/** An input for mutations affecting `QuestionOption` */
export type QuestionOptionInput = {
  candidateQuestions?: InputMaybe<CandidateQuestionsQuestionValueIdFkeyInverseInput>;
  position: Scalars['Int']['input'];
  question?: InputMaybe<QuestionOptionsQuestionIdFkeyInput>;
  questionId?: InputMaybe<Scalars['Int']['input']>;
  translations?: InputMaybe<QuestionOptionTranslationsQuestionOptionIdFkeyInverseInput>;
};

/** The globally unique `ID` look up for the row to connect. */
export type QuestionOptionNodeIdConnect = {
  /** The globally unique `ID` which identifies a single `questionOption` to be connected. */
  nodeId: Scalars['ID']['input'];
};

/** The globally unique `ID` look up for the row to delete. */
export type QuestionOptionNodeIdDelete = {
  /** The globally unique `ID` which identifies a single `questionOption` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** The globally unique `ID` look up for the row to update. */
export type QuestionOptionOnCandidateQuestionForCandidateQuestionsQuestionValueIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `candidateQuestion` to be connected. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `candidateQuestion` being updated. */
  patch: CandidateQuestionPatch;
};

/** The fields on `questionOption` to look up the row to update. */
export type QuestionOptionOnCandidateQuestionForCandidateQuestionsQuestionValueIdFkeyUsingQuestionOptionsPkeyUpdate = {
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `questionOption` being updated. */
  patch: UpdateQuestionOptionOnCandidateQuestionForCandidateQuestionsQuestionValueIdFkeyPatch;
};

/** The globally unique `ID` look up for the row to update. */
export type QuestionOptionOnQuestionOptionForQuestionOptionsQuestionIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `question` to be connected. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `question` being updated. */
  patch: QuestionPatch;
};

/** The fields on `questionOption` to look up the row to update. */
export type QuestionOptionOnQuestionOptionForQuestionOptionsQuestionIdFkeyUsingQuestionOptionsPkeyUpdate = {
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `questionOption` being updated. */
  patch: UpdateQuestionOptionOnQuestionOptionForQuestionOptionsQuestionIdFkeyPatch;
};

/** The globally unique `ID` look up for the row to update. */
export type QuestionOptionOnQuestionOptionTranslationForQuestionOptionTranslationsQuestionOptionIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `questionOptionTranslation` to be connected. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `questionOptionTranslation` being updated. */
  patch: QuestionOptionTranslationPatch;
};

/** The fields on `questionOption` to look up the row to update. */
export type QuestionOptionOnQuestionOptionTranslationForQuestionOptionTranslationsQuestionOptionIdFkeyUsingQuestionOptionsPkeyUpdate = {
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `questionOption` being updated. */
  patch: UpdateQuestionOptionOnQuestionOptionTranslationForQuestionOptionTranslationsQuestionOptionIdFkeyPatch;
};

/** Represents an update to a `QuestionOption`. Fields that are set will be updated. */
export type QuestionOptionPatch = {
  candidateQuestions?: InputMaybe<CandidateQuestionsQuestionValueIdFkeyInverseInput>;
  position?: InputMaybe<Scalars['Int']['input']>;
  question?: InputMaybe<QuestionOptionsQuestionIdFkeyInput>;
  questionId?: InputMaybe<Scalars['Int']['input']>;
  translations?: InputMaybe<QuestionOptionTranslationsQuestionOptionIdFkeyInverseInput>;
};

/** The fields on `questionOption` to look up the row to connect. */
export type QuestionOptionQuestionOptionsPkeyConnect = {
  id: Scalars['Int']['input'];
};

/** The fields on `questionOption` to look up the row to delete. */
export type QuestionOptionQuestionOptionsPkeyDelete = {
  id: Scalars['Int']['input'];
};

/** A connection to a list of `Question` values, with data from `CandidateQuestion`. */
export type QuestionOptionQuestionsByCandidateQuestionQuestionOptionIdAndQuestionIdManyToManyConnection = {
  __typename?: 'QuestionOptionQuestionsByCandidateQuestionQuestionOptionIdAndQuestionIdManyToManyConnection';
  /** A list of edges which contains the `Question`, info from the `CandidateQuestion`, and the cursor to aid in pagination. */
  edges: Array<QuestionOptionQuestionsByCandidateQuestionQuestionOptionIdAndQuestionIdManyToManyEdge>;
  /** A list of `Question` objects. */
  nodes: Array<Question>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Question` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `Question` edge in the connection, with data from `CandidateQuestion`. */
export type QuestionOptionQuestionsByCandidateQuestionQuestionOptionIdAndQuestionIdManyToManyEdge = {
  __typename?: 'QuestionOptionQuestionsByCandidateQuestionQuestionOptionIdAndQuestionIdManyToManyEdge';
  /** Reads and enables pagination through a set of `CandidateQuestion`. */
  candidateQuestions: CandidateQuestionsConnection;
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Question` at the end of the edge. */
  node: Question;
};


/** A `Question` edge in the connection, with data from `CandidateQuestion`. */
export type QuestionOptionQuestionsByCandidateQuestionQuestionOptionIdAndQuestionIdManyToManyEdgeCandidateQuestionsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<CandidateQuestionCondition>;
  filter?: InputMaybe<CandidateQuestionFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<CandidateQuestionsOrderBy>>;
};

/** A filter to be used against many `CandidateQuestion` object types. All fields are combined with a logical ‘and.’ */
export type QuestionOptionToManyCandidateQuestionFilter = {
  /** Every related `CandidateQuestion` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<CandidateQuestionFilter>;
  /** No related `CandidateQuestion` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<CandidateQuestionFilter>;
  /** Some related `CandidateQuestion` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<CandidateQuestionFilter>;
};

/** A filter to be used against many `QuestionOptionTranslation` object types. All fields are combined with a logical ‘and.’ */
export type QuestionOptionToManyQuestionOptionTranslationFilter = {
  /** Every related `QuestionOptionTranslation` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<QuestionOptionTranslationFilter>;
  /** No related `QuestionOptionTranslation` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<QuestionOptionTranslationFilter>;
  /** Some related `QuestionOptionTranslation` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<QuestionOptionTranslationFilter>;
};

export type QuestionOptionTranslation = Node & {
  __typename?: 'QuestionOptionTranslation';
  lang: Language;
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  /** Reads a single `QuestionOption` that is related to this `QuestionOptionTranslation`. */
  questionOption?: Maybe<QuestionOption>;
  questionOptionId: Scalars['Int']['output'];
  value: Scalars['String']['output'];
};

/** A condition to be used against `QuestionOptionTranslation` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type QuestionOptionTranslationCondition = {
  /** Checks for equality with the object’s `questionOptionId` field. */
  questionOptionId?: InputMaybe<Scalars['Int']['input']>;
};

/** A filter to be used against `QuestionOptionTranslation` object types. All fields are combined with a logical ‘and.’ */
export type QuestionOptionTranslationFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<QuestionOptionTranslationFilter>>;
  /** Negates the expression. */
  not?: InputMaybe<QuestionOptionTranslationFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<QuestionOptionTranslationFilter>>;
  /** Filter by the object’s `questionOption` relation. */
  questionOption?: InputMaybe<QuestionOptionFilter>;
  /** Filter by the object’s `questionOptionId` field. */
  questionOptionId?: InputMaybe<IntFilter>;
};

/** An input for mutations affecting `QuestionOptionTranslation` */
export type QuestionOptionTranslationInput = {
  lang: Language;
  questionOption?: InputMaybe<QuestionOptionTranslationsQuestionOptionIdFkeyInput>;
  questionOptionId?: InputMaybe<Scalars['Int']['input']>;
  value: Scalars['String']['input'];
};

/** The globally unique `ID` look up for the row to connect. */
export type QuestionOptionTranslationNodeIdConnect = {
  /** The globally unique `ID` which identifies a single `questionOptionTranslation` to be connected. */
  nodeId: Scalars['ID']['input'];
};

/** The globally unique `ID` look up for the row to delete. */
export type QuestionOptionTranslationNodeIdDelete = {
  /** The globally unique `ID` which identifies a single `questionOptionTranslation` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** The globally unique `ID` look up for the row to update. */
export type QuestionOptionTranslationOnQuestionOptionTranslationForQuestionOptionTranslationsQuestionOptionIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `questionOption` to be connected. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `questionOption` being updated. */
  patch: QuestionOptionPatch;
};

/** The fields on `questionOptionTranslation` to look up the row to update. */
export type QuestionOptionTranslationOnQuestionOptionTranslationForQuestionOptionTranslationsQuestionOptionIdFkeyUsingQuestionOptionTranslationsPkeyUpdate = {
  lang: Language;
  /** An object where the defined keys will be set on the `questionOptionTranslation` being updated. */
  patch: UpdateQuestionOptionTranslationOnQuestionOptionTranslationForQuestionOptionTranslationsQuestionOptionIdFkeyPatch;
  questionOptionId: Scalars['Int']['input'];
};

/** Represents an update to a `QuestionOptionTranslation`. Fields that are set will be updated. */
export type QuestionOptionTranslationPatch = {
  questionOption?: InputMaybe<QuestionOptionTranslationsQuestionOptionIdFkeyInput>;
  questionOptionId?: InputMaybe<Scalars['Int']['input']>;
  value?: InputMaybe<Scalars['String']['input']>;
};

/** The fields on `questionOptionTranslation` to look up the row to connect. */
export type QuestionOptionTranslationQuestionOptionTranslationsPkeyConnect = {
  lang: Language;
  questionOptionId: Scalars['Int']['input'];
};

/** The fields on `questionOptionTranslation` to look up the row to delete. */
export type QuestionOptionTranslationQuestionOptionTranslationsPkeyDelete = {
  lang: Language;
  questionOptionId: Scalars['Int']['input'];
};

/** A connection to a list of `QuestionOptionTranslation` values. */
export type QuestionOptionTranslationsConnection = {
  __typename?: 'QuestionOptionTranslationsConnection';
  /** A list of edges which contains the `QuestionOptionTranslation` and cursor to aid in pagination. */
  edges: Array<QuestionOptionTranslationsEdge>;
  /** A list of `QuestionOptionTranslation` objects. */
  nodes: Array<QuestionOptionTranslation>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `QuestionOptionTranslation` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `QuestionOptionTranslation` edge in the connection. */
export type QuestionOptionTranslationsEdge = {
  __typename?: 'QuestionOptionTranslationsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `QuestionOptionTranslation` at the end of the edge. */
  node: QuestionOptionTranslation;
};

/** Methods to use when ordering `QuestionOptionTranslation`. */
export enum QuestionOptionTranslationsOrderBy {
  Natural = 'NATURAL',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  QuestionOptionIdAsc = 'QUESTION_OPTION_ID_ASC',
  QuestionOptionIdDesc = 'QUESTION_OPTION_ID_DESC'
}

/** Input for the nested mutation of `questionOption` in the `QuestionOptionTranslationInput` mutation. */
export type QuestionOptionTranslationsQuestionOptionIdFkeyInput = {
  /** The primary key(s) for `questionOption` for the far side of the relationship. */
  connectById?: InputMaybe<QuestionOptionQuestionOptionsPkeyConnect>;
  /** The primary key(s) for `questionOption` for the far side of the relationship. */
  connectByNodeId?: InputMaybe<QuestionOptionNodeIdConnect>;
  /** A `QuestionOptionInput` object that will be created and connected to this object. */
  create?: InputMaybe<QuestionOptionTranslationsQuestionOptionIdFkeyQuestionOptionsCreateInput>;
  /** The primary key(s) for `questionOption` for the far side of the relationship. */
  deleteById?: InputMaybe<QuestionOptionQuestionOptionsPkeyDelete>;
  /** The primary key(s) for `questionOption` for the far side of the relationship. */
  deleteByNodeId?: InputMaybe<QuestionOptionNodeIdDelete>;
  /** The primary key(s) and patch data for `questionOption` for the far side of the relationship. */
  updateById?: InputMaybe<QuestionOptionOnQuestionOptionTranslationForQuestionOptionTranslationsQuestionOptionIdFkeyUsingQuestionOptionsPkeyUpdate>;
  /** The primary key(s) and patch data for `questionOption` for the far side of the relationship. */
  updateByNodeId?: InputMaybe<QuestionOptionTranslationOnQuestionOptionTranslationForQuestionOptionTranslationsQuestionOptionIdFkeyNodeIdUpdate>;
};

/** Input for the nested mutation of `questionOptionTranslation` in the `QuestionOptionInput` mutation. */
export type QuestionOptionTranslationsQuestionOptionIdFkeyInverseInput = {
  /** The primary key(s) for `questionOptionTranslation` for the far side of the relationship. */
  connectByNodeId?: InputMaybe<Array<QuestionOptionTranslationNodeIdConnect>>;
  /** The primary key(s) for `questionOptionTranslation` for the far side of the relationship. */
  connectByQuestionOptionIdAndLang?: InputMaybe<Array<QuestionOptionTranslationQuestionOptionTranslationsPkeyConnect>>;
  /** A `QuestionOptionTranslationInput` object that will be created and connected to this object. */
  create?: InputMaybe<Array<QuestionOptionTranslationsQuestionOptionIdFkeyQuestionOptionTranslationsCreateInput>>;
  /** The primary key(s) for `questionOptionTranslation` for the far side of the relationship. */
  deleteByNodeId?: InputMaybe<Array<QuestionOptionTranslationNodeIdDelete>>;
  /** The primary key(s) for `questionOptionTranslation` for the far side of the relationship. */
  deleteByQuestionOptionIdAndLang?: InputMaybe<Array<QuestionOptionTranslationQuestionOptionTranslationsPkeyDelete>>;
  /** Flag indicating whether all other `questionOptionTranslation` records that match this relationship should be removed. */
  deleteOthers?: InputMaybe<Scalars['Boolean']['input']>;
  /** The primary key(s) and patch data for `questionOptionTranslation` for the far side of the relationship. */
  updateByNodeId?: InputMaybe<Array<QuestionOptionOnQuestionOptionTranslationForQuestionOptionTranslationsQuestionOptionIdFkeyNodeIdUpdate>>;
  /** The primary key(s) and patch data for `questionOptionTranslation` for the far side of the relationship. */
  updateByQuestionOptionIdAndLang?: InputMaybe<Array<QuestionOptionTranslationOnQuestionOptionTranslationForQuestionOptionTranslationsQuestionOptionIdFkeyUsingQuestionOptionTranslationsPkeyUpdate>>;
};

/** The `questionOptionTranslation` to be created by this mutation. */
export type QuestionOptionTranslationsQuestionOptionIdFkeyQuestionOptionTranslationsCreateInput = {
  lang: Language;
  questionOption?: InputMaybe<QuestionOptionTranslationsQuestionOptionIdFkeyInput>;
  value: Scalars['String']['input'];
};

/** The `questionOption` to be created by this mutation. */
export type QuestionOptionTranslationsQuestionOptionIdFkeyQuestionOptionsCreateInput = {
  candidateQuestions?: InputMaybe<CandidateQuestionsQuestionValueIdFkeyInverseInput>;
  position: Scalars['Int']['input'];
  question?: InputMaybe<QuestionOptionsQuestionIdFkeyInput>;
  questionId?: InputMaybe<Scalars['Int']['input']>;
  translations?: InputMaybe<QuestionOptionTranslationsQuestionOptionIdFkeyInverseInput>;
};

/** A connection to a list of `QuestionOption` values. */
export type QuestionOptionsConnection = {
  __typename?: 'QuestionOptionsConnection';
  /** A list of edges which contains the `QuestionOption` and cursor to aid in pagination. */
  edges: Array<QuestionOptionsEdge>;
  /** A list of `QuestionOption` objects. */
  nodes: Array<QuestionOption>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `QuestionOption` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `QuestionOption` edge in the connection. */
export type QuestionOptionsEdge = {
  __typename?: 'QuestionOptionsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `QuestionOption` at the end of the edge. */
  node: QuestionOption;
};

/** Methods to use when ordering `QuestionOption`. */
export enum QuestionOptionsOrderBy {
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  Natural = 'NATURAL',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  QuestionIdAsc = 'QUESTION_ID_ASC',
  QuestionIdDesc = 'QUESTION_ID_DESC'
}

/** Input for the nested mutation of `question` in the `QuestionOptionInput` mutation. */
export type QuestionOptionsQuestionIdFkeyInput = {
  /** The primary key(s) for `question` for the far side of the relationship. */
  connectById?: InputMaybe<QuestionQuestionsPkeyConnect>;
  /** The primary key(s) for `question` for the far side of the relationship. */
  connectByNodeId?: InputMaybe<QuestionNodeIdConnect>;
  /** A `QuestionInput` object that will be created and connected to this object. */
  create?: InputMaybe<QuestionOptionsQuestionIdFkeyQuestionsCreateInput>;
  /** The primary key(s) and patch data for `question` for the far side of the relationship. */
  updateById?: InputMaybe<QuestionOnQuestionOptionForQuestionOptionsQuestionIdFkeyUsingQuestionsPkeyUpdate>;
  /** The primary key(s) and patch data for `question` for the far side of the relationship. */
  updateByNodeId?: InputMaybe<QuestionOptionOnQuestionOptionForQuestionOptionsQuestionIdFkeyNodeIdUpdate>;
};

/** Input for the nested mutation of `questionOption` in the `QuestionInput` mutation. */
export type QuestionOptionsQuestionIdFkeyInverseInput = {
  /** The primary key(s) for `questionOption` for the far side of the relationship. */
  connectById?: InputMaybe<Array<QuestionOptionQuestionOptionsPkeyConnect>>;
  /** The primary key(s) for `questionOption` for the far side of the relationship. */
  connectByNodeId?: InputMaybe<Array<QuestionOptionNodeIdConnect>>;
  /** A `QuestionOptionInput` object that will be created and connected to this object. */
  create?: InputMaybe<Array<QuestionOptionsQuestionIdFkeyQuestionOptionsCreateInput>>;
  /** The primary key(s) for `questionOption` for the far side of the relationship. */
  deleteById?: InputMaybe<Array<QuestionOptionQuestionOptionsPkeyDelete>>;
  /** The primary key(s) for `questionOption` for the far side of the relationship. */
  deleteByNodeId?: InputMaybe<Array<QuestionOptionNodeIdDelete>>;
  /** Flag indicating whether all other `questionOption` records that match this relationship should be removed. */
  deleteOthers?: InputMaybe<Scalars['Boolean']['input']>;
  /** The primary key(s) and patch data for `questionOption` for the far side of the relationship. */
  updateById?: InputMaybe<Array<QuestionOptionOnQuestionOptionForQuestionOptionsQuestionIdFkeyUsingQuestionOptionsPkeyUpdate>>;
  /** The primary key(s) and patch data for `questionOption` for the far side of the relationship. */
  updateByNodeId?: InputMaybe<Array<QuestionOnQuestionOptionForQuestionOptionsQuestionIdFkeyNodeIdUpdate>>;
};

/** The `questionOption` to be created by this mutation. */
export type QuestionOptionsQuestionIdFkeyQuestionOptionsCreateInput = {
  candidateQuestions?: InputMaybe<CandidateQuestionsQuestionValueIdFkeyInverseInput>;
  position: Scalars['Int']['input'];
  question?: InputMaybe<QuestionOptionsQuestionIdFkeyInput>;
  translations?: InputMaybe<QuestionOptionTranslationsQuestionOptionIdFkeyInverseInput>;
};

/** The `question` to be created by this mutation. */
export type QuestionOptionsQuestionIdFkeyQuestionsCreateInput = {
  candidateQuestions?: InputMaybe<CandidateQuestionsQuestionIdFkeyInverseInput>;
  options?: InputMaybe<QuestionOptionsQuestionIdFkeyInverseInput>;
  questionnaireQuestions?: InputMaybe<QuestionnaireQuestionsQuestionIdFkeyInverseInput>;
  required: Scalars['Boolean']['input'];
  translations?: InputMaybe<QuestionTranslationsQuestionIdFkeyInverseInput>;
  type: QuestionType;
};

/** Represents an update to a `Question`. Fields that are set will be updated. */
export type QuestionPatch = {
  candidateQuestions?: InputMaybe<CandidateQuestionsQuestionIdFkeyInverseInput>;
  options?: InputMaybe<QuestionOptionsQuestionIdFkeyInverseInput>;
  questionnaireQuestions?: InputMaybe<QuestionnaireQuestionsQuestionIdFkeyInverseInput>;
  required?: InputMaybe<Scalars['Boolean']['input']>;
  translations?: InputMaybe<QuestionTranslationsQuestionIdFkeyInverseInput>;
  type?: InputMaybe<QuestionType>;
};

/** A connection to a list of `QuestionOption` values, with data from `CandidateQuestion`. */
export type QuestionQuestionOptionsByCandidateQuestionQuestionIdAndQuestionOptionIdManyToManyConnection = {
  __typename?: 'QuestionQuestionOptionsByCandidateQuestionQuestionIdAndQuestionOptionIdManyToManyConnection';
  /** A list of edges which contains the `QuestionOption`, info from the `CandidateQuestion`, and the cursor to aid in pagination. */
  edges: Array<QuestionQuestionOptionsByCandidateQuestionQuestionIdAndQuestionOptionIdManyToManyEdge>;
  /** A list of `QuestionOption` objects. */
  nodes: Array<QuestionOption>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `QuestionOption` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `QuestionOption` edge in the connection, with data from `CandidateQuestion`. */
export type QuestionQuestionOptionsByCandidateQuestionQuestionIdAndQuestionOptionIdManyToManyEdge = {
  __typename?: 'QuestionQuestionOptionsByCandidateQuestionQuestionIdAndQuestionOptionIdManyToManyEdge';
  /** Reads and enables pagination through a set of `CandidateQuestion`. */
  candidateQuestions: CandidateQuestionsConnection;
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `QuestionOption` at the end of the edge. */
  node: QuestionOption;
};


/** A `QuestionOption` edge in the connection, with data from `CandidateQuestion`. */
export type QuestionQuestionOptionsByCandidateQuestionQuestionIdAndQuestionOptionIdManyToManyEdgeCandidateQuestionsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<CandidateQuestionCondition>;
  filter?: InputMaybe<CandidateQuestionFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<CandidateQuestionsOrderBy>>;
};

/** A connection to a list of `Questionnaire` values, with data from `QuestionnaireQuestion`. */
export type QuestionQuestionnairesByQuestionnaireQuestionQuestionIdAndQuestionnaireIdManyToManyConnection = {
  __typename?: 'QuestionQuestionnairesByQuestionnaireQuestionQuestionIdAndQuestionnaireIdManyToManyConnection';
  /** A list of edges which contains the `Questionnaire`, info from the `QuestionnaireQuestion`, and the cursor to aid in pagination. */
  edges: Array<QuestionQuestionnairesByQuestionnaireQuestionQuestionIdAndQuestionnaireIdManyToManyEdge>;
  /** A list of `Questionnaire` objects. */
  nodes: Array<Questionnaire>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Questionnaire` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `Questionnaire` edge in the connection, with data from `QuestionnaireQuestion`. */
export type QuestionQuestionnairesByQuestionnaireQuestionQuestionIdAndQuestionnaireIdManyToManyEdge = {
  __typename?: 'QuestionQuestionnairesByQuestionnaireQuestionQuestionIdAndQuestionnaireIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Questionnaire` at the end of the edge. */
  node: Questionnaire;
  position: Scalars['Int']['output'];
};

/** The fields on `question` to look up the row to connect. */
export type QuestionQuestionsPkeyConnect = {
  id: Scalars['Int']['input'];
};

/** A filter to be used against many `CandidateQuestion` object types. All fields are combined with a logical ‘and.’ */
export type QuestionToManyCandidateQuestionFilter = {
  /** Every related `CandidateQuestion` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<CandidateQuestionFilter>;
  /** No related `CandidateQuestion` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<CandidateQuestionFilter>;
  /** Some related `CandidateQuestion` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<CandidateQuestionFilter>;
};

/** A filter to be used against many `QuestionOption` object types. All fields are combined with a logical ‘and.’ */
export type QuestionToManyQuestionOptionFilter = {
  /** Every related `QuestionOption` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<QuestionOptionFilter>;
  /** No related `QuestionOption` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<QuestionOptionFilter>;
  /** Some related `QuestionOption` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<QuestionOptionFilter>;
};

/** A filter to be used against many `QuestionTranslation` object types. All fields are combined with a logical ‘and.’ */
export type QuestionToManyQuestionTranslationFilter = {
  /** Every related `QuestionTranslation` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<QuestionTranslationFilter>;
  /** No related `QuestionTranslation` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<QuestionTranslationFilter>;
  /** Some related `QuestionTranslation` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<QuestionTranslationFilter>;
};

/** A filter to be used against many `QuestionnaireQuestion` object types. All fields are combined with a logical ‘and.’ */
export type QuestionToManyQuestionnaireQuestionFilter = {
  /** Every related `QuestionnaireQuestion` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<QuestionnaireQuestionFilter>;
  /** No related `QuestionnaireQuestion` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<QuestionnaireQuestionFilter>;
  /** Some related `QuestionnaireQuestion` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<QuestionnaireQuestionFilter>;
};

export type QuestionTranslation = Node & {
  __typename?: 'QuestionTranslation';
  description?: Maybe<Scalars['Html']['output']>;
  hint?: Maybe<Scalars['String']['output']>;
  lang: Language;
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  /** Reads a single `Question` that is related to this `QuestionTranslation`. */
  question?: Maybe<Question>;
  questionId: Scalars['Int']['output'];
  title: Scalars['String']['output'];
};

/** A condition to be used against `QuestionTranslation` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type QuestionTranslationCondition = {
  /** Checks for equality with the object’s `questionId` field. */
  questionId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `title` field. */
  title?: InputMaybe<Scalars['String']['input']>;
};

/** A filter to be used against `QuestionTranslation` object types. All fields are combined with a logical ‘and.’ */
export type QuestionTranslationFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<QuestionTranslationFilter>>;
  /** Negates the expression. */
  not?: InputMaybe<QuestionTranslationFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<QuestionTranslationFilter>>;
  /** Filter by the object’s `question` relation. */
  question?: InputMaybe<QuestionFilter>;
  /** Filter by the object’s `questionId` field. */
  questionId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `title` field. */
  title?: InputMaybe<StringFilter>;
};

/** An input for mutations affecting `QuestionTranslation` */
export type QuestionTranslationInput = {
  description?: InputMaybe<Scalars['Html']['input']>;
  hint?: InputMaybe<Scalars['String']['input']>;
  lang: Language;
  question?: InputMaybe<QuestionTranslationsQuestionIdFkeyInput>;
  questionId?: InputMaybe<Scalars['Int']['input']>;
  title: Scalars['String']['input'];
};

/** The globally unique `ID` look up for the row to connect. */
export type QuestionTranslationNodeIdConnect = {
  /** The globally unique `ID` which identifies a single `questionTranslation` to be connected. */
  nodeId: Scalars['ID']['input'];
};

/** The globally unique `ID` look up for the row to delete. */
export type QuestionTranslationNodeIdDelete = {
  /** The globally unique `ID` which identifies a single `questionTranslation` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** The globally unique `ID` look up for the row to update. */
export type QuestionTranslationOnQuestionTranslationForQuestionTranslationsQuestionIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `question` to be connected. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `question` being updated. */
  patch: QuestionPatch;
};

/** The fields on `questionTranslation` to look up the row to update. */
export type QuestionTranslationOnQuestionTranslationForQuestionTranslationsQuestionIdFkeyUsingQuestionTranslationsPkeyUpdate = {
  lang: Language;
  /** An object where the defined keys will be set on the `questionTranslation` being updated. */
  patch: UpdateQuestionTranslationOnQuestionTranslationForQuestionTranslationsQuestionIdFkeyPatch;
  questionId: Scalars['Int']['input'];
};

/** Represents an update to a `QuestionTranslation`. Fields that are set will be updated. */
export type QuestionTranslationPatch = {
  description?: InputMaybe<Scalars['Html']['input']>;
  hint?: InputMaybe<Scalars['String']['input']>;
  question?: InputMaybe<QuestionTranslationsQuestionIdFkeyInput>;
  questionId?: InputMaybe<Scalars['Int']['input']>;
  title?: InputMaybe<Scalars['String']['input']>;
};

/** The fields on `questionTranslation` to look up the row to connect. */
export type QuestionTranslationQuestionTranslationsPkeyConnect = {
  lang: Language;
  questionId: Scalars['Int']['input'];
};

/** The fields on `questionTranslation` to look up the row to delete. */
export type QuestionTranslationQuestionTranslationsPkeyDelete = {
  lang: Language;
  questionId: Scalars['Int']['input'];
};

/** A connection to a list of `QuestionTranslation` values. */
export type QuestionTranslationsConnection = {
  __typename?: 'QuestionTranslationsConnection';
  /** A list of edges which contains the `QuestionTranslation` and cursor to aid in pagination. */
  edges: Array<QuestionTranslationsEdge>;
  /** A list of `QuestionTranslation` objects. */
  nodes: Array<QuestionTranslation>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `QuestionTranslation` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `QuestionTranslation` edge in the connection. */
export type QuestionTranslationsEdge = {
  __typename?: 'QuestionTranslationsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `QuestionTranslation` at the end of the edge. */
  node: QuestionTranslation;
};

/** Methods to use when ordering `QuestionTranslation`. */
export enum QuestionTranslationsOrderBy {
  Natural = 'NATURAL',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  QuestionIdAsc = 'QUESTION_ID_ASC',
  QuestionIdDesc = 'QUESTION_ID_DESC',
  TitleAsc = 'TITLE_ASC',
  TitleDesc = 'TITLE_DESC'
}

/** Input for the nested mutation of `question` in the `QuestionTranslationInput` mutation. */
export type QuestionTranslationsQuestionIdFkeyInput = {
  /** The primary key(s) for `question` for the far side of the relationship. */
  connectById?: InputMaybe<QuestionQuestionsPkeyConnect>;
  /** The primary key(s) for `question` for the far side of the relationship. */
  connectByNodeId?: InputMaybe<QuestionNodeIdConnect>;
  /** A `QuestionInput` object that will be created and connected to this object. */
  create?: InputMaybe<QuestionTranslationsQuestionIdFkeyQuestionsCreateInput>;
  /** The primary key(s) and patch data for `question` for the far side of the relationship. */
  updateById?: InputMaybe<QuestionOnQuestionTranslationForQuestionTranslationsQuestionIdFkeyUsingQuestionsPkeyUpdate>;
  /** The primary key(s) and patch data for `question` for the far side of the relationship. */
  updateByNodeId?: InputMaybe<QuestionTranslationOnQuestionTranslationForQuestionTranslationsQuestionIdFkeyNodeIdUpdate>;
};

/** Input for the nested mutation of `questionTranslation` in the `QuestionInput` mutation. */
export type QuestionTranslationsQuestionIdFkeyInverseInput = {
  /** The primary key(s) for `questionTranslation` for the far side of the relationship. */
  connectByNodeId?: InputMaybe<Array<QuestionTranslationNodeIdConnect>>;
  /** The primary key(s) for `questionTranslation` for the far side of the relationship. */
  connectByQuestionIdAndLang?: InputMaybe<Array<QuestionTranslationQuestionTranslationsPkeyConnect>>;
  /** A `QuestionTranslationInput` object that will be created and connected to this object. */
  create?: InputMaybe<Array<QuestionTranslationsQuestionIdFkeyQuestionTranslationsCreateInput>>;
  /** The primary key(s) for `questionTranslation` for the far side of the relationship. */
  deleteByNodeId?: InputMaybe<Array<QuestionTranslationNodeIdDelete>>;
  /** The primary key(s) for `questionTranslation` for the far side of the relationship. */
  deleteByQuestionIdAndLang?: InputMaybe<Array<QuestionTranslationQuestionTranslationsPkeyDelete>>;
  /** Flag indicating whether all other `questionTranslation` records that match this relationship should be removed. */
  deleteOthers?: InputMaybe<Scalars['Boolean']['input']>;
  /** The primary key(s) and patch data for `questionTranslation` for the far side of the relationship. */
  updateByNodeId?: InputMaybe<Array<QuestionOnQuestionTranslationForQuestionTranslationsQuestionIdFkeyNodeIdUpdate>>;
  /** The primary key(s) and patch data for `questionTranslation` for the far side of the relationship. */
  updateByQuestionIdAndLang?: InputMaybe<Array<QuestionTranslationOnQuestionTranslationForQuestionTranslationsQuestionIdFkeyUsingQuestionTranslationsPkeyUpdate>>;
};

/** The `questionTranslation` to be created by this mutation. */
export type QuestionTranslationsQuestionIdFkeyQuestionTranslationsCreateInput = {
  description?: InputMaybe<Scalars['Html']['input']>;
  hint?: InputMaybe<Scalars['String']['input']>;
  lang: Language;
  question?: InputMaybe<QuestionTranslationsQuestionIdFkeyInput>;
  title: Scalars['String']['input'];
};

/** The `question` to be created by this mutation. */
export type QuestionTranslationsQuestionIdFkeyQuestionsCreateInput = {
  candidateQuestions?: InputMaybe<CandidateQuestionsQuestionIdFkeyInverseInput>;
  options?: InputMaybe<QuestionOptionsQuestionIdFkeyInverseInput>;
  questionnaireQuestions?: InputMaybe<QuestionnaireQuestionsQuestionIdFkeyInverseInput>;
  required: Scalars['Boolean']['input'];
  translations?: InputMaybe<QuestionTranslationsQuestionIdFkeyInverseInput>;
  type: QuestionType;
};

export enum QuestionType {
  Date = 'DATE',
  DateTime = 'DATE_TIME',
  DropDown = 'DROP_DOWN',
  File = 'FILE',
  Files = 'FILES',
  Info = 'INFO',
  MultipleChoice = 'MULTIPLE_CHOICE',
  Number = 'NUMBER',
  RatingToFive = 'RATING_TO_FIVE',
  RatingToTen = 'RATING_TO_TEN',
  SingleChoice = 'SINGLE_CHOICE',
  Text = 'TEXT',
  TextMultiline = 'TEXT_MULTILINE',
  Time = 'TIME',
  Video_1Min = 'VIDEO_1MIN',
  Video_2Min = 'VIDEO_2MIN',
  Video_5Min = 'VIDEO_5MIN',
  Video_10Min = 'VIDEO_10MIN',
  Video_30Sec = 'VIDEO_30SEC'
}

export type Questionnaire = Node & {
  __typename?: 'Questionnaire';
  /** Reads and enables pagination through a set of `CandidateQuestionnaire`. */
  candidateQuestionnaires: CandidateQuestionnairesConnection;
  /** Reads and enables pagination through a set of `CandidateQuestion`. */
  candidateQuestions: CandidateQuestionsConnection;
  /** Reads and enables pagination through a set of `Candidate`. */
  candidates: QuestionnaireCandidatesByCandidateQuestionnaireQuestionnaireIdAndCandidateIdManyToManyConnection;
  category: Scalars['String']['output'];
  createdAt: Scalars['Datetime']['output'];
  deletedAt?: Maybe<Scalars['Datetime']['output']>;
  id: Scalars['Int']['output'];
  /** Reads and enables pagination through a set of `JobQuestionnaire`. */
  jobQuestionnaires: JobQuestionnairesConnection;
  /** Reads and enables pagination through a set of `Job`. */
  jobs: QuestionnaireJobsByJobQuestionnaireQuestionnaireIdAndJobIdManyToManyConnection;
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  /** Reads and enables pagination through a set of `QuestionnaireQuestion`. */
  questionnaireQuestions: QuestionnaireQuestionsConnection;
  /** Reads and enables pagination through a set of `Question`. */
  questions: QuestionnaireQuestionsByQuestionnaireQuestionQuestionnaireIdAndQuestionIdManyToManyConnection;
  /** Reads and enables pagination through a set of `QuestionnaireTranslation`. */
  translations: QuestionnaireTranslationsConnection;
  updatedAt: Scalars['Datetime']['output'];
};


export type QuestionnaireCandidateQuestionnairesArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<CandidateQuestionnaireCondition>;
  filter?: InputMaybe<CandidateQuestionnaireFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<CandidateQuestionnairesOrderBy>>;
};


export type QuestionnaireCandidateQuestionsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<CandidateQuestionCondition>;
  filter?: InputMaybe<CandidateQuestionFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<CandidateQuestionsOrderBy>>;
};


export type QuestionnaireCandidatesArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<CandidateCondition>;
  filter?: InputMaybe<CandidateFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<CandidatesOrderBy>>;
};


export type QuestionnaireJobQuestionnairesArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<JobQuestionnaireCondition>;
  filter?: InputMaybe<JobQuestionnaireFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<JobQuestionnairesOrderBy>>;
};


export type QuestionnaireJobsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<JobCondition>;
  filter?: InputMaybe<JobFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<JobsOrderBy>>;
};


export type QuestionnaireQuestionnaireQuestionsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<QuestionnaireQuestionCondition>;
  filter?: InputMaybe<QuestionnaireQuestionFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<QuestionnaireQuestionsOrderBy>>;
};


export type QuestionnaireQuestionsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<QuestionCondition>;
  filter?: InputMaybe<QuestionFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<QuestionsOrderBy>>;
};


export type QuestionnaireTranslationsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<QuestionnaireTranslationCondition>;
  filter?: InputMaybe<QuestionnaireTranslationFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<QuestionnaireTranslationsOrderBy>>;
};

/** A connection to a list of `Candidate` values, with data from `CandidateQuestionnaire`. */
export type QuestionnaireCandidatesByCandidateQuestionnaireQuestionnaireIdAndCandidateIdManyToManyConnection = {
  __typename?: 'QuestionnaireCandidatesByCandidateQuestionnaireQuestionnaireIdAndCandidateIdManyToManyConnection';
  /** A list of edges which contains the `Candidate`, info from the `CandidateQuestionnaire`, and the cursor to aid in pagination. */
  edges: Array<QuestionnaireCandidatesByCandidateQuestionnaireQuestionnaireIdAndCandidateIdManyToManyEdge>;
  /** A list of `Candidate` objects. */
  nodes: Array<Candidate>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Candidate` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `Candidate` edge in the connection, with data from `CandidateQuestionnaire`. */
export type QuestionnaireCandidatesByCandidateQuestionnaireQuestionnaireIdAndCandidateIdManyToManyEdge = {
  __typename?: 'QuestionnaireCandidatesByCandidateQuestionnaireQuestionnaireIdAndCandidateIdManyToManyEdge';
  /** Reads and enables pagination through a set of `CandidateQuestionnaire`. */
  candidateQuestionnaires: CandidateQuestionnairesConnection;
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Candidate` at the end of the edge. */
  node: Candidate;
};


/** A `Candidate` edge in the connection, with data from `CandidateQuestionnaire`. */
export type QuestionnaireCandidatesByCandidateQuestionnaireQuestionnaireIdAndCandidateIdManyToManyEdgeCandidateQuestionnairesArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<CandidateQuestionnaireCondition>;
  filter?: InputMaybe<CandidateQuestionnaireFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<CandidateQuestionnairesOrderBy>>;
};

/** A condition to be used against `Questionnaire` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type QuestionnaireCondition = {
  /** Checks for equality with the object’s `deletedAt` field. */
  deletedAt?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['Int']['input']>;
};

/** A filter to be used against `Questionnaire` object types. All fields are combined with a logical ‘and.’ */
export type QuestionnaireFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<QuestionnaireFilter>>;
  /** Filter by the object’s `candidateQuestionnaires` relation. */
  candidateQuestionnaires?: InputMaybe<QuestionnaireToManyCandidateQuestionnaireFilter>;
  /** Some related `candidateQuestionnaires` exist. */
  candidateQuestionnairesExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `candidateQuestions` relation. */
  candidateQuestions?: InputMaybe<QuestionnaireToManyCandidateQuestionFilter>;
  /** Some related `candidateQuestions` exist. */
  candidateQuestionsExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `deletedAt` field. */
  deletedAt?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<IntFilter>;
  /** Filter by the object’s `jobQuestionnaires` relation. */
  jobQuestionnaires?: InputMaybe<QuestionnaireToManyJobQuestionnaireFilter>;
  /** Some related `jobQuestionnaires` exist. */
  jobQuestionnairesExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Negates the expression. */
  not?: InputMaybe<QuestionnaireFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<QuestionnaireFilter>>;
  /** Filter by the object’s `questionnaireQuestions` relation. */
  questionnaireQuestions?: InputMaybe<QuestionnaireToManyQuestionnaireQuestionFilter>;
  /** Some related `questionnaireQuestions` exist. */
  questionnaireQuestionsExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `translations` relation. */
  translations?: InputMaybe<QuestionnaireToManyQuestionnaireTranslationFilter>;
  /** Some related `translations` exist. */
  translationsExist?: InputMaybe<Scalars['Boolean']['input']>;
};

/** An input for mutations affecting `Questionnaire` */
export type QuestionnaireInput = {
  candidateQuestionnaires?: InputMaybe<CandidateQuestionnairesQuestionnaireIdFkeyInverseInput>;
  candidateQuestions?: InputMaybe<CandidateQuestionsQuestionnaireIdFkeyInverseInput>;
  category: Scalars['String']['input'];
  deletedAt?: InputMaybe<Scalars['Datetime']['input']>;
  jobQuestionnaires?: InputMaybe<JobQuestionnairesQuestionnaireIdFkeyInverseInput>;
  questionnaireQuestions?: InputMaybe<QuestionnaireQuestionsQuestionnaireIdFkeyInverseInput>;
  translations?: InputMaybe<QuestionnaireTranslationsQuestionnaireIdFkeyInverseInput>;
};

/** A connection to a list of `Job` values, with data from `JobQuestionnaire`. */
export type QuestionnaireJobsByJobQuestionnaireQuestionnaireIdAndJobIdManyToManyConnection = {
  __typename?: 'QuestionnaireJobsByJobQuestionnaireQuestionnaireIdAndJobIdManyToManyConnection';
  /** A list of edges which contains the `Job`, info from the `JobQuestionnaire`, and the cursor to aid in pagination. */
  edges: Array<QuestionnaireJobsByJobQuestionnaireQuestionnaireIdAndJobIdManyToManyEdge>;
  /** A list of `Job` objects. */
  nodes: Array<Job>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Job` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `Job` edge in the connection, with data from `JobQuestionnaire`. */
export type QuestionnaireJobsByJobQuestionnaireQuestionnaireIdAndJobIdManyToManyEdge = {
  __typename?: 'QuestionnaireJobsByJobQuestionnaireQuestionnaireIdAndJobIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Job` at the end of the edge. */
  node: Job;
};

/** The globally unique `ID` look up for the row to connect. */
export type QuestionnaireNodeIdConnect = {
  /** The globally unique `ID` which identifies a single `questionnaire` to be connected. */
  nodeId: Scalars['ID']['input'];
};

/** The globally unique `ID` look up for the row to update. */
export type QuestionnaireOnCandidateQuestionForCandidateQuestionsQuestionnaireIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `candidateQuestion` to be connected. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `candidateQuestion` being updated. */
  patch: CandidateQuestionPatch;
};

/** The fields on `questionnaire` to look up the row to update. */
export type QuestionnaireOnCandidateQuestionForCandidateQuestionsQuestionnaireIdFkeyUsingQuestionnairesPkeyUpdate = {
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `questionnaire` being updated. */
  patch: UpdateQuestionnaireOnCandidateQuestionForCandidateQuestionsQuestionnaireIdFkeyPatch;
};

/** The globally unique `ID` look up for the row to update. */
export type QuestionnaireOnCandidateQuestionnaireForCandidateQuestionnairesQuestionnaireIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `candidateQuestionnaire` to be connected. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `candidateQuestionnaire` being updated. */
  patch: CandidateQuestionnairePatch;
};

/** The fields on `questionnaire` to look up the row to update. */
export type QuestionnaireOnCandidateQuestionnaireForCandidateQuestionnairesQuestionnaireIdFkeyUsingQuestionnairesPkeyUpdate = {
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `questionnaire` being updated. */
  patch: UpdateQuestionnaireOnCandidateQuestionnaireForCandidateQuestionnairesQuestionnaireIdFkeyPatch;
};

/** The globally unique `ID` look up for the row to update. */
export type QuestionnaireOnJobQuestionnaireForJobQuestionnairesQuestionnaireIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `jobQuestionnaire` to be connected. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `jobQuestionnaire` being updated. */
  patch: JobQuestionnairePatch;
};

/** The fields on `questionnaire` to look up the row to update. */
export type QuestionnaireOnJobQuestionnaireForJobQuestionnairesQuestionnaireIdFkeyUsingQuestionnairesPkeyUpdate = {
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `questionnaire` being updated. */
  patch: UpdateQuestionnaireOnJobQuestionnaireForJobQuestionnairesQuestionnaireIdFkeyPatch;
};

/** The globally unique `ID` look up for the row to update. */
export type QuestionnaireOnQuestionnaireQuestionForQuestionnaireQuestionsQuestionnaireIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `questionnaireQuestion` to be connected. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `questionnaireQuestion` being updated. */
  patch: QuestionnaireQuestionPatch;
};

/** The fields on `questionnaire` to look up the row to update. */
export type QuestionnaireOnQuestionnaireQuestionForQuestionnaireQuestionsQuestionnaireIdFkeyUsingQuestionnairesPkeyUpdate = {
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `questionnaire` being updated. */
  patch: UpdateQuestionnaireOnQuestionnaireQuestionForQuestionnaireQuestionsQuestionnaireIdFkeyPatch;
};

/** The globally unique `ID` look up for the row to update. */
export type QuestionnaireOnQuestionnaireTranslationForQuestionnaireTranslationsQuestionnaireIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `questionnaireTranslation` to be connected. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `questionnaireTranslation` being updated. */
  patch: QuestionnaireTranslationPatch;
};

/** The fields on `questionnaire` to look up the row to update. */
export type QuestionnaireOnQuestionnaireTranslationForQuestionnaireTranslationsQuestionnaireIdFkeyUsingQuestionnairesPkeyUpdate = {
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `questionnaire` being updated. */
  patch: UpdateQuestionnaireOnQuestionnaireTranslationForQuestionnaireTranslationsQuestionnaireIdFkeyPatch;
};

/** Represents an update to a `Questionnaire`. Fields that are set will be updated. */
export type QuestionnairePatch = {
  candidateQuestionnaires?: InputMaybe<CandidateQuestionnairesQuestionnaireIdFkeyInverseInput>;
  candidateQuestions?: InputMaybe<CandidateQuestionsQuestionnaireIdFkeyInverseInput>;
  category?: InputMaybe<Scalars['String']['input']>;
  deletedAt?: InputMaybe<Scalars['Datetime']['input']>;
  jobQuestionnaires?: InputMaybe<JobQuestionnairesQuestionnaireIdFkeyInverseInput>;
  questionnaireQuestions?: InputMaybe<QuestionnaireQuestionsQuestionnaireIdFkeyInverseInput>;
  translations?: InputMaybe<QuestionnaireTranslationsQuestionnaireIdFkeyInverseInput>;
};

export type QuestionnaireQuestion = Node & {
  __typename?: 'QuestionnaireQuestion';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  position: Scalars['Int']['output'];
  /** Reads a single `Question` that is related to this `QuestionnaireQuestion`. */
  question?: Maybe<Question>;
  questionId: Scalars['Int']['output'];
  /** Reads a single `Questionnaire` that is related to this `QuestionnaireQuestion`. */
  questionnaire?: Maybe<Questionnaire>;
  questionnaireId: Scalars['Int']['output'];
};

/** A condition to be used against `QuestionnaireQuestion` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type QuestionnaireQuestionCondition = {
  /** Checks for equality with the object’s `questionId` field. */
  questionId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `questionnaireId` field. */
  questionnaireId?: InputMaybe<Scalars['Int']['input']>;
};

/** A filter to be used against `QuestionnaireQuestion` object types. All fields are combined with a logical ‘and.’ */
export type QuestionnaireQuestionFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<QuestionnaireQuestionFilter>>;
  /** Negates the expression. */
  not?: InputMaybe<QuestionnaireQuestionFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<QuestionnaireQuestionFilter>>;
  /** Filter by the object’s `question` relation. */
  question?: InputMaybe<QuestionFilter>;
  /** Filter by the object’s `questionId` field. */
  questionId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `questionnaire` relation. */
  questionnaire?: InputMaybe<QuestionnaireFilter>;
  /** Filter by the object’s `questionnaireId` field. */
  questionnaireId?: InputMaybe<IntFilter>;
};

/** An input for mutations affecting `QuestionnaireQuestion` */
export type QuestionnaireQuestionInput = {
  position: Scalars['Int']['input'];
  question?: InputMaybe<QuestionnaireQuestionsQuestionIdFkeyInput>;
  questionId?: InputMaybe<Scalars['Int']['input']>;
  questionnaire?: InputMaybe<QuestionnaireQuestionsQuestionnaireIdFkeyInput>;
  questionnaireId?: InputMaybe<Scalars['Int']['input']>;
};

/** The globally unique `ID` look up for the row to connect. */
export type QuestionnaireQuestionNodeIdConnect = {
  /** The globally unique `ID` which identifies a single `questionnaireQuestion` to be connected. */
  nodeId: Scalars['ID']['input'];
};

/** The globally unique `ID` look up for the row to delete. */
export type QuestionnaireQuestionNodeIdDelete = {
  /** The globally unique `ID` which identifies a single `questionnaireQuestion` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** The globally unique `ID` look up for the row to update. */
export type QuestionnaireQuestionOnQuestionnaireQuestionForQuestionnaireQuestionsQuestionIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `question` to be connected. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `question` being updated. */
  patch: QuestionPatch;
};

/** The fields on `questionnaireQuestion` to look up the row to update. */
export type QuestionnaireQuestionOnQuestionnaireQuestionForQuestionnaireQuestionsQuestionIdFkeyUsingQuestionnaireQuestionsPkeyUpdate = {
  /** An object where the defined keys will be set on the `questionnaireQuestion` being updated. */
  patch: UpdateQuestionnaireQuestionOnQuestionnaireQuestionForQuestionnaireQuestionsQuestionIdFkeyPatch;
  questionId: Scalars['Int']['input'];
  questionnaireId: Scalars['Int']['input'];
};

/** The globally unique `ID` look up for the row to update. */
export type QuestionnaireQuestionOnQuestionnaireQuestionForQuestionnaireQuestionsQuestionnaireIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `questionnaire` to be connected. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `questionnaire` being updated. */
  patch: QuestionnairePatch;
};

/** The fields on `questionnaireQuestion` to look up the row to update. */
export type QuestionnaireQuestionOnQuestionnaireQuestionForQuestionnaireQuestionsQuestionnaireIdFkeyUsingQuestionnaireQuestionsPkeyUpdate = {
  /** An object where the defined keys will be set on the `questionnaireQuestion` being updated. */
  patch: UpdateQuestionnaireQuestionOnQuestionnaireQuestionForQuestionnaireQuestionsQuestionnaireIdFkeyPatch;
  questionId: Scalars['Int']['input'];
  questionnaireId: Scalars['Int']['input'];
};

/** Represents an update to a `QuestionnaireQuestion`. Fields that are set will be updated. */
export type QuestionnaireQuestionPatch = {
  position?: InputMaybe<Scalars['Int']['input']>;
  question?: InputMaybe<QuestionnaireQuestionsQuestionIdFkeyInput>;
  questionId?: InputMaybe<Scalars['Int']['input']>;
  questionnaire?: InputMaybe<QuestionnaireQuestionsQuestionnaireIdFkeyInput>;
  questionnaireId?: InputMaybe<Scalars['Int']['input']>;
};

/** The fields on `questionnaireQuestion` to look up the row to connect. */
export type QuestionnaireQuestionQuestionnaireQuestionsPkeyConnect = {
  questionId: Scalars['Int']['input'];
  questionnaireId: Scalars['Int']['input'];
};

/** The fields on `questionnaireQuestion` to look up the row to delete. */
export type QuestionnaireQuestionQuestionnaireQuestionsPkeyDelete = {
  questionId: Scalars['Int']['input'];
  questionnaireId: Scalars['Int']['input'];
};

/** The fields on `questionnaire` to look up the row to connect. */
export type QuestionnaireQuestionnairesPkeyConnect = {
  id: Scalars['Int']['input'];
};

/** A connection to a list of `Question` values, with data from `QuestionnaireQuestion`. */
export type QuestionnaireQuestionsByQuestionnaireQuestionQuestionnaireIdAndQuestionIdManyToManyConnection = {
  __typename?: 'QuestionnaireQuestionsByQuestionnaireQuestionQuestionnaireIdAndQuestionIdManyToManyConnection';
  /** A list of edges which contains the `Question`, info from the `QuestionnaireQuestion`, and the cursor to aid in pagination. */
  edges: Array<QuestionnaireQuestionsByQuestionnaireQuestionQuestionnaireIdAndQuestionIdManyToManyEdge>;
  /** A list of `Question` objects. */
  nodes: Array<Question>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Question` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `Question` edge in the connection, with data from `QuestionnaireQuestion`. */
export type QuestionnaireQuestionsByQuestionnaireQuestionQuestionnaireIdAndQuestionIdManyToManyEdge = {
  __typename?: 'QuestionnaireQuestionsByQuestionnaireQuestionQuestionnaireIdAndQuestionIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Question` at the end of the edge. */
  node: Question;
  position: Scalars['Int']['output'];
};

/** A connection to a list of `QuestionnaireQuestion` values. */
export type QuestionnaireQuestionsConnection = {
  __typename?: 'QuestionnaireQuestionsConnection';
  /** A list of edges which contains the `QuestionnaireQuestion` and cursor to aid in pagination. */
  edges: Array<QuestionnaireQuestionsEdge>;
  /** A list of `QuestionnaireQuestion` objects. */
  nodes: Array<QuestionnaireQuestion>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `QuestionnaireQuestion` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `QuestionnaireQuestion` edge in the connection. */
export type QuestionnaireQuestionsEdge = {
  __typename?: 'QuestionnaireQuestionsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `QuestionnaireQuestion` at the end of the edge. */
  node: QuestionnaireQuestion;
};

/** Methods to use when ordering `QuestionnaireQuestion`. */
export enum QuestionnaireQuestionsOrderBy {
  Natural = 'NATURAL',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  QuestionnaireIdAsc = 'QUESTIONNAIRE_ID_ASC',
  QuestionnaireIdDesc = 'QUESTIONNAIRE_ID_DESC',
  QuestionIdAsc = 'QUESTION_ID_ASC',
  QuestionIdDesc = 'QUESTION_ID_DESC'
}

/** Input for the nested mutation of `question` in the `QuestionnaireQuestionInput` mutation. */
export type QuestionnaireQuestionsQuestionIdFkeyInput = {
  /** The primary key(s) for `question` for the far side of the relationship. */
  connectById?: InputMaybe<QuestionQuestionsPkeyConnect>;
  /** The primary key(s) for `question` for the far side of the relationship. */
  connectByNodeId?: InputMaybe<QuestionNodeIdConnect>;
  /** A `QuestionInput` object that will be created and connected to this object. */
  create?: InputMaybe<QuestionnaireQuestionsQuestionIdFkeyQuestionsCreateInput>;
  /** The primary key(s) and patch data for `question` for the far side of the relationship. */
  updateById?: InputMaybe<QuestionOnQuestionnaireQuestionForQuestionnaireQuestionsQuestionIdFkeyUsingQuestionsPkeyUpdate>;
  /** The primary key(s) and patch data for `question` for the far side of the relationship. */
  updateByNodeId?: InputMaybe<QuestionnaireQuestionOnQuestionnaireQuestionForQuestionnaireQuestionsQuestionIdFkeyNodeIdUpdate>;
};

/** Input for the nested mutation of `questionnaireQuestion` in the `QuestionInput` mutation. */
export type QuestionnaireQuestionsQuestionIdFkeyInverseInput = {
  /** The primary key(s) for `questionnaireQuestion` for the far side of the relationship. */
  connectByNodeId?: InputMaybe<Array<QuestionnaireQuestionNodeIdConnect>>;
  /** The primary key(s) for `questionnaireQuestion` for the far side of the relationship. */
  connectByQuestionnaireIdAndQuestionId?: InputMaybe<Array<QuestionnaireQuestionQuestionnaireQuestionsPkeyConnect>>;
  /** A `QuestionnaireQuestionInput` object that will be created and connected to this object. */
  create?: InputMaybe<Array<QuestionnaireQuestionsQuestionIdFkeyQuestionnaireQuestionsCreateInput>>;
  /** The primary key(s) for `questionnaireQuestion` for the far side of the relationship. */
  deleteByNodeId?: InputMaybe<Array<QuestionnaireQuestionNodeIdDelete>>;
  /** The primary key(s) for `questionnaireQuestion` for the far side of the relationship. */
  deleteByQuestionnaireIdAndQuestionId?: InputMaybe<Array<QuestionnaireQuestionQuestionnaireQuestionsPkeyDelete>>;
  /** Flag indicating whether all other `questionnaireQuestion` records that match this relationship should be removed. */
  deleteOthers?: InputMaybe<Scalars['Boolean']['input']>;
  /** The primary key(s) and patch data for `questionnaireQuestion` for the far side of the relationship. */
  updateByNodeId?: InputMaybe<Array<QuestionOnQuestionnaireQuestionForQuestionnaireQuestionsQuestionIdFkeyNodeIdUpdate>>;
  /** The primary key(s) and patch data for `questionnaireQuestion` for the far side of the relationship. */
  updateByQuestionnaireIdAndQuestionId?: InputMaybe<Array<QuestionnaireQuestionOnQuestionnaireQuestionForQuestionnaireQuestionsQuestionIdFkeyUsingQuestionnaireQuestionsPkeyUpdate>>;
};

/** The `questionnaireQuestion` to be created by this mutation. */
export type QuestionnaireQuestionsQuestionIdFkeyQuestionnaireQuestionsCreateInput = {
  position: Scalars['Int']['input'];
  question?: InputMaybe<QuestionnaireQuestionsQuestionIdFkeyInput>;
  questionnaire?: InputMaybe<QuestionnaireQuestionsQuestionnaireIdFkeyInput>;
  questionnaireId?: InputMaybe<Scalars['Int']['input']>;
};

/** The `question` to be created by this mutation. */
export type QuestionnaireQuestionsQuestionIdFkeyQuestionsCreateInput = {
  candidateQuestions?: InputMaybe<CandidateQuestionsQuestionIdFkeyInverseInput>;
  options?: InputMaybe<QuestionOptionsQuestionIdFkeyInverseInput>;
  questionnaireQuestions?: InputMaybe<QuestionnaireQuestionsQuestionIdFkeyInverseInput>;
  required: Scalars['Boolean']['input'];
  translations?: InputMaybe<QuestionTranslationsQuestionIdFkeyInverseInput>;
  type: QuestionType;
};

/** Input for the nested mutation of `questionnaire` in the `QuestionnaireQuestionInput` mutation. */
export type QuestionnaireQuestionsQuestionnaireIdFkeyInput = {
  /** The primary key(s) for `questionnaire` for the far side of the relationship. */
  connectById?: InputMaybe<QuestionnaireQuestionnairesPkeyConnect>;
  /** The primary key(s) for `questionnaire` for the far side of the relationship. */
  connectByNodeId?: InputMaybe<QuestionnaireNodeIdConnect>;
  /** A `QuestionnaireInput` object that will be created and connected to this object. */
  create?: InputMaybe<QuestionnaireQuestionsQuestionnaireIdFkeyQuestionnairesCreateInput>;
  /** The primary key(s) and patch data for `questionnaire` for the far side of the relationship. */
  updateById?: InputMaybe<QuestionnaireOnQuestionnaireQuestionForQuestionnaireQuestionsQuestionnaireIdFkeyUsingQuestionnairesPkeyUpdate>;
  /** The primary key(s) and patch data for `questionnaire` for the far side of the relationship. */
  updateByNodeId?: InputMaybe<QuestionnaireQuestionOnQuestionnaireQuestionForQuestionnaireQuestionsQuestionnaireIdFkeyNodeIdUpdate>;
};

/** Input for the nested mutation of `questionnaireQuestion` in the `QuestionnaireInput` mutation. */
export type QuestionnaireQuestionsQuestionnaireIdFkeyInverseInput = {
  /** The primary key(s) for `questionnaireQuestion` for the far side of the relationship. */
  connectByNodeId?: InputMaybe<Array<QuestionnaireQuestionNodeIdConnect>>;
  /** The primary key(s) for `questionnaireQuestion` for the far side of the relationship. */
  connectByQuestionnaireIdAndQuestionId?: InputMaybe<Array<QuestionnaireQuestionQuestionnaireQuestionsPkeyConnect>>;
  /** A `QuestionnaireQuestionInput` object that will be created and connected to this object. */
  create?: InputMaybe<Array<QuestionnaireQuestionsQuestionnaireIdFkeyQuestionnaireQuestionsCreateInput>>;
  /** The primary key(s) for `questionnaireQuestion` for the far side of the relationship. */
  deleteByNodeId?: InputMaybe<Array<QuestionnaireQuestionNodeIdDelete>>;
  /** The primary key(s) for `questionnaireQuestion` for the far side of the relationship. */
  deleteByQuestionnaireIdAndQuestionId?: InputMaybe<Array<QuestionnaireQuestionQuestionnaireQuestionsPkeyDelete>>;
  /** Flag indicating whether all other `questionnaireQuestion` records that match this relationship should be removed. */
  deleteOthers?: InputMaybe<Scalars['Boolean']['input']>;
  /** The primary key(s) and patch data for `questionnaireQuestion` for the far side of the relationship. */
  updateByNodeId?: InputMaybe<Array<QuestionnaireOnQuestionnaireQuestionForQuestionnaireQuestionsQuestionnaireIdFkeyNodeIdUpdate>>;
  /** The primary key(s) and patch data for `questionnaireQuestion` for the far side of the relationship. */
  updateByQuestionnaireIdAndQuestionId?: InputMaybe<Array<QuestionnaireQuestionOnQuestionnaireQuestionForQuestionnaireQuestionsQuestionnaireIdFkeyUsingQuestionnaireQuestionsPkeyUpdate>>;
};

/** The `questionnaireQuestion` to be created by this mutation. */
export type QuestionnaireQuestionsQuestionnaireIdFkeyQuestionnaireQuestionsCreateInput = {
  position: Scalars['Int']['input'];
  question?: InputMaybe<QuestionnaireQuestionsQuestionIdFkeyInput>;
  questionId?: InputMaybe<Scalars['Int']['input']>;
  questionnaire?: InputMaybe<QuestionnaireQuestionsQuestionnaireIdFkeyInput>;
};

/** The `questionnaire` to be created by this mutation. */
export type QuestionnaireQuestionsQuestionnaireIdFkeyQuestionnairesCreateInput = {
  candidateQuestionnaires?: InputMaybe<CandidateQuestionnairesQuestionnaireIdFkeyInverseInput>;
  candidateQuestions?: InputMaybe<CandidateQuestionsQuestionnaireIdFkeyInverseInput>;
  category: Scalars['String']['input'];
  deletedAt?: InputMaybe<Scalars['Datetime']['input']>;
  jobQuestionnaires?: InputMaybe<JobQuestionnairesQuestionnaireIdFkeyInverseInput>;
  questionnaireQuestions?: InputMaybe<QuestionnaireQuestionsQuestionnaireIdFkeyInverseInput>;
  translations?: InputMaybe<QuestionnaireTranslationsQuestionnaireIdFkeyInverseInput>;
};

/** A filter to be used against many `CandidateQuestion` object types. All fields are combined with a logical ‘and.’ */
export type QuestionnaireToManyCandidateQuestionFilter = {
  /** Every related `CandidateQuestion` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<CandidateQuestionFilter>;
  /** No related `CandidateQuestion` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<CandidateQuestionFilter>;
  /** Some related `CandidateQuestion` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<CandidateQuestionFilter>;
};

/** A filter to be used against many `CandidateQuestionnaire` object types. All fields are combined with a logical ‘and.’ */
export type QuestionnaireToManyCandidateQuestionnaireFilter = {
  /** Every related `CandidateQuestionnaire` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<CandidateQuestionnaireFilter>;
  /** No related `CandidateQuestionnaire` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<CandidateQuestionnaireFilter>;
  /** Some related `CandidateQuestionnaire` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<CandidateQuestionnaireFilter>;
};

/** A filter to be used against many `JobQuestionnaire` object types. All fields are combined with a logical ‘and.’ */
export type QuestionnaireToManyJobQuestionnaireFilter = {
  /** Every related `JobQuestionnaire` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<JobQuestionnaireFilter>;
  /** No related `JobQuestionnaire` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<JobQuestionnaireFilter>;
  /** Some related `JobQuestionnaire` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<JobQuestionnaireFilter>;
};

/** A filter to be used against many `QuestionnaireQuestion` object types. All fields are combined with a logical ‘and.’ */
export type QuestionnaireToManyQuestionnaireQuestionFilter = {
  /** Every related `QuestionnaireQuestion` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<QuestionnaireQuestionFilter>;
  /** No related `QuestionnaireQuestion` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<QuestionnaireQuestionFilter>;
  /** Some related `QuestionnaireQuestion` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<QuestionnaireQuestionFilter>;
};

/** A filter to be used against many `QuestionnaireTranslation` object types. All fields are combined with a logical ‘and.’ */
export type QuestionnaireToManyQuestionnaireTranslationFilter = {
  /** Every related `QuestionnaireTranslation` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<QuestionnaireTranslationFilter>;
  /** No related `QuestionnaireTranslation` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<QuestionnaireTranslationFilter>;
  /** Some related `QuestionnaireTranslation` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<QuestionnaireTranslationFilter>;
};

export type QuestionnaireTranslation = Node & {
  __typename?: 'QuestionnaireTranslation';
  lang: Language;
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  /** Reads a single `Questionnaire` that is related to this `QuestionnaireTranslation`. */
  questionnaire?: Maybe<Questionnaire>;
  questionnaireId: Scalars['Int']['output'];
  title: Scalars['String']['output'];
};

/** A condition to be used against `QuestionnaireTranslation` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type QuestionnaireTranslationCondition = {
  /** Checks for equality with the object’s `questionnaireId` field. */
  questionnaireId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `title` field. */
  title?: InputMaybe<Scalars['String']['input']>;
};

/** A filter to be used against `QuestionnaireTranslation` object types. All fields are combined with a logical ‘and.’ */
export type QuestionnaireTranslationFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<QuestionnaireTranslationFilter>>;
  /** Negates the expression. */
  not?: InputMaybe<QuestionnaireTranslationFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<QuestionnaireTranslationFilter>>;
  /** Filter by the object’s `questionnaire` relation. */
  questionnaire?: InputMaybe<QuestionnaireFilter>;
  /** Filter by the object’s `questionnaireId` field. */
  questionnaireId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `title` field. */
  title?: InputMaybe<StringFilter>;
};

/** An input for mutations affecting `QuestionnaireTranslation` */
export type QuestionnaireTranslationInput = {
  lang: Language;
  questionnaire?: InputMaybe<QuestionnaireTranslationsQuestionnaireIdFkeyInput>;
  questionnaireId?: InputMaybe<Scalars['Int']['input']>;
  title: Scalars['String']['input'];
};

/** The globally unique `ID` look up for the row to connect. */
export type QuestionnaireTranslationNodeIdConnect = {
  /** The globally unique `ID` which identifies a single `questionnaireTranslation` to be connected. */
  nodeId: Scalars['ID']['input'];
};

/** The globally unique `ID` look up for the row to delete. */
export type QuestionnaireTranslationNodeIdDelete = {
  /** The globally unique `ID` which identifies a single `questionnaireTranslation` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** The globally unique `ID` look up for the row to update. */
export type QuestionnaireTranslationOnQuestionnaireTranslationForQuestionnaireTranslationsQuestionnaireIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `questionnaire` to be connected. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `questionnaire` being updated. */
  patch: QuestionnairePatch;
};

/** The fields on `questionnaireTranslation` to look up the row to update. */
export type QuestionnaireTranslationOnQuestionnaireTranslationForQuestionnaireTranslationsQuestionnaireIdFkeyUsingQuestionnaireTranslationsPkeyUpdate = {
  lang: Language;
  /** An object where the defined keys will be set on the `questionnaireTranslation` being updated. */
  patch: UpdateQuestionnaireTranslationOnQuestionnaireTranslationForQuestionnaireTranslationsQuestionnaireIdFkeyPatch;
  questionnaireId: Scalars['Int']['input'];
};

/** Represents an update to a `QuestionnaireTranslation`. Fields that are set will be updated. */
export type QuestionnaireTranslationPatch = {
  questionnaire?: InputMaybe<QuestionnaireTranslationsQuestionnaireIdFkeyInput>;
  questionnaireId?: InputMaybe<Scalars['Int']['input']>;
  title?: InputMaybe<Scalars['String']['input']>;
};

/** The fields on `questionnaireTranslation` to look up the row to connect. */
export type QuestionnaireTranslationQuestionnaireTranslationsPkeyConnect = {
  lang: Language;
  questionnaireId: Scalars['Int']['input'];
};

/** The fields on `questionnaireTranslation` to look up the row to delete. */
export type QuestionnaireTranslationQuestionnaireTranslationsPkeyDelete = {
  lang: Language;
  questionnaireId: Scalars['Int']['input'];
};

/** A connection to a list of `QuestionnaireTranslation` values. */
export type QuestionnaireTranslationsConnection = {
  __typename?: 'QuestionnaireTranslationsConnection';
  /** A list of edges which contains the `QuestionnaireTranslation` and cursor to aid in pagination. */
  edges: Array<QuestionnaireTranslationsEdge>;
  /** A list of `QuestionnaireTranslation` objects. */
  nodes: Array<QuestionnaireTranslation>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `QuestionnaireTranslation` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `QuestionnaireTranslation` edge in the connection. */
export type QuestionnaireTranslationsEdge = {
  __typename?: 'QuestionnaireTranslationsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `QuestionnaireTranslation` at the end of the edge. */
  node: QuestionnaireTranslation;
};

/** Methods to use when ordering `QuestionnaireTranslation`. */
export enum QuestionnaireTranslationsOrderBy {
  Natural = 'NATURAL',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  QuestionnaireIdAsc = 'QUESTIONNAIRE_ID_ASC',
  QuestionnaireIdDesc = 'QUESTIONNAIRE_ID_DESC',
  TitleAsc = 'TITLE_ASC',
  TitleDesc = 'TITLE_DESC'
}

/** Input for the nested mutation of `questionnaire` in the `QuestionnaireTranslationInput` mutation. */
export type QuestionnaireTranslationsQuestionnaireIdFkeyInput = {
  /** The primary key(s) for `questionnaire` for the far side of the relationship. */
  connectById?: InputMaybe<QuestionnaireQuestionnairesPkeyConnect>;
  /** The primary key(s) for `questionnaire` for the far side of the relationship. */
  connectByNodeId?: InputMaybe<QuestionnaireNodeIdConnect>;
  /** A `QuestionnaireInput` object that will be created and connected to this object. */
  create?: InputMaybe<QuestionnaireTranslationsQuestionnaireIdFkeyQuestionnairesCreateInput>;
  /** The primary key(s) and patch data for `questionnaire` for the far side of the relationship. */
  updateById?: InputMaybe<QuestionnaireOnQuestionnaireTranslationForQuestionnaireTranslationsQuestionnaireIdFkeyUsingQuestionnairesPkeyUpdate>;
  /** The primary key(s) and patch data for `questionnaire` for the far side of the relationship. */
  updateByNodeId?: InputMaybe<QuestionnaireTranslationOnQuestionnaireTranslationForQuestionnaireTranslationsQuestionnaireIdFkeyNodeIdUpdate>;
};

/** Input for the nested mutation of `questionnaireTranslation` in the `QuestionnaireInput` mutation. */
export type QuestionnaireTranslationsQuestionnaireIdFkeyInverseInput = {
  /** The primary key(s) for `questionnaireTranslation` for the far side of the relationship. */
  connectByNodeId?: InputMaybe<Array<QuestionnaireTranslationNodeIdConnect>>;
  /** The primary key(s) for `questionnaireTranslation` for the far side of the relationship. */
  connectByQuestionnaireIdAndLang?: InputMaybe<Array<QuestionnaireTranslationQuestionnaireTranslationsPkeyConnect>>;
  /** A `QuestionnaireTranslationInput` object that will be created and connected to this object. */
  create?: InputMaybe<Array<QuestionnaireTranslationsQuestionnaireIdFkeyQuestionnaireTranslationsCreateInput>>;
  /** The primary key(s) for `questionnaireTranslation` for the far side of the relationship. */
  deleteByNodeId?: InputMaybe<Array<QuestionnaireTranslationNodeIdDelete>>;
  /** The primary key(s) for `questionnaireTranslation` for the far side of the relationship. */
  deleteByQuestionnaireIdAndLang?: InputMaybe<Array<QuestionnaireTranslationQuestionnaireTranslationsPkeyDelete>>;
  /** Flag indicating whether all other `questionnaireTranslation` records that match this relationship should be removed. */
  deleteOthers?: InputMaybe<Scalars['Boolean']['input']>;
  /** The primary key(s) and patch data for `questionnaireTranslation` for the far side of the relationship. */
  updateByNodeId?: InputMaybe<Array<QuestionnaireOnQuestionnaireTranslationForQuestionnaireTranslationsQuestionnaireIdFkeyNodeIdUpdate>>;
  /** The primary key(s) and patch data for `questionnaireTranslation` for the far side of the relationship. */
  updateByQuestionnaireIdAndLang?: InputMaybe<Array<QuestionnaireTranslationOnQuestionnaireTranslationForQuestionnaireTranslationsQuestionnaireIdFkeyUsingQuestionnaireTranslationsPkeyUpdate>>;
};

/** The `questionnaireTranslation` to be created by this mutation. */
export type QuestionnaireTranslationsQuestionnaireIdFkeyQuestionnaireTranslationsCreateInput = {
  lang: Language;
  questionnaire?: InputMaybe<QuestionnaireTranslationsQuestionnaireIdFkeyInput>;
  title: Scalars['String']['input'];
};

/** The `questionnaire` to be created by this mutation. */
export type QuestionnaireTranslationsQuestionnaireIdFkeyQuestionnairesCreateInput = {
  candidateQuestionnaires?: InputMaybe<CandidateQuestionnairesQuestionnaireIdFkeyInverseInput>;
  candidateQuestions?: InputMaybe<CandidateQuestionsQuestionnaireIdFkeyInverseInput>;
  category: Scalars['String']['input'];
  deletedAt?: InputMaybe<Scalars['Datetime']['input']>;
  jobQuestionnaires?: InputMaybe<JobQuestionnairesQuestionnaireIdFkeyInverseInput>;
  questionnaireQuestions?: InputMaybe<QuestionnaireQuestionsQuestionnaireIdFkeyInverseInput>;
  translations?: InputMaybe<QuestionnaireTranslationsQuestionnaireIdFkeyInverseInput>;
};

/** A connection to a list of `Questionnaire` values. */
export type QuestionnairesConnection = {
  __typename?: 'QuestionnairesConnection';
  /** A list of edges which contains the `Questionnaire` and cursor to aid in pagination. */
  edges: Array<QuestionnairesEdge>;
  /** A list of `Questionnaire` objects. */
  nodes: Array<Questionnaire>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Questionnaire` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `Questionnaire` edge in the connection. */
export type QuestionnairesEdge = {
  __typename?: 'QuestionnairesEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Questionnaire` at the end of the edge. */
  node: Questionnaire;
};

/** Methods to use when ordering `Questionnaire`. */
export enum QuestionnairesOrderBy {
  DeletedAtAsc = 'DELETED_AT_ASC',
  DeletedAtDesc = 'DELETED_AT_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  Natural = 'NATURAL',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC'
}

/** A connection to a list of `Question` values. */
export type QuestionsConnection = {
  __typename?: 'QuestionsConnection';
  /** A list of edges which contains the `Question` and cursor to aid in pagination. */
  edges: Array<QuestionsEdge>;
  /** A list of `Question` objects. */
  nodes: Array<Question>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Question` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `Question` edge in the connection. */
export type QuestionsEdge = {
  __typename?: 'QuestionsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Question` at the end of the edge. */
  node: Question;
};

/** Methods to use when ordering `Question`. */
export enum QuestionsOrderBy {
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  Natural = 'NATURAL',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC'
}

/** All input for the `registerInvitationUser` mutation. */
export type RegisterInvitationUserInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  email: Scalars['String']['input'];
  invitationToken: Scalars['UUID']['input'];
  password: Scalars['String']['input'];
  translations: Array<InputMaybe<UserTranslationInput>>;
};

/** The output of our `registerInvitationUser` mutation. */
export type RegisterInvitationUserPayload = {
  __typename?: 'RegisterInvitationUserPayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  user?: Maybe<User>;
  /** An edge for our `User`. May be used by Relay 1. */
  userEdge?: Maybe<UsersEdge>;
};


/** The output of our `registerInvitationUser` mutation. */
export type RegisterInvitationUserPayloadUserEdgeArgs = {
  orderBy?: InputMaybe<Array<UsersOrderBy>>;
};

/** All input for the `registerUser` mutation. */
export type RegisterUserInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  email: Scalars['String']['input'];
  password: Scalars['String']['input'];
  translations: Array<InputMaybe<UserTranslationInput>>;
};

/** The output of our `registerUser` mutation. */
export type RegisterUserPayload = {
  __typename?: 'RegisterUserPayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  user?: Maybe<User>;
  /** An edge for our `User`. May be used by Relay 1. */
  userEdge?: Maybe<UsersEdge>;
};


/** The output of our `registerUser` mutation. */
export type RegisterUserPayloadUserEdgeArgs = {
  orderBy?: InputMaybe<Array<UsersOrderBy>>;
};

/** All input for the `revokeInvitation` mutation. */
export type RevokeInvitationInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
};

/** The output of our `revokeInvitation` mutation. */
export type RevokeInvitationPayload = {
  __typename?: 'RevokeInvitationPayload';
  boolean?: Maybe<Scalars['Boolean']['output']>;
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};

export type Role = Node & {
  __typename?: 'Role';
  abilities: Array<Maybe<Roleability>>;
  /** Reads and enables pagination through a set of `CompanyUser`. */
  companyUsers: CompanyUsersConnection;
  createdAt: Scalars['Datetime']['output'];
  id: Scalars['Int']['output'];
  isAdmin: Scalars['Boolean']['output'];
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  /** Reads and enables pagination through a set of `RoleTranslation`. */
  translations: RoleTranslationsConnection;
  updatedAt: Scalars['Datetime']['output'];
  /** Reads and enables pagination through a set of `UserInvitation`. */
  userInvitations: UserInvitationsConnection;
  /** Reads and enables pagination through a set of `User`. */
  users: RoleUsersByCompanyUserRoleIdAndUserIdManyToManyConnection;
};


export type RoleCompanyUsersArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<CompanyUserCondition>;
  filter?: InputMaybe<CompanyUserFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<CompanyUsersOrderBy>>;
};


export type RoleTranslationsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<RoleTranslationCondition>;
  filter?: InputMaybe<RoleTranslationFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<RoleTranslationsOrderBy>>;
};


export type RoleUserInvitationsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<UserInvitationCondition>;
  filter?: InputMaybe<UserInvitationFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<UserInvitationsOrderBy>>;
};


export type RoleUsersArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<UserCondition>;
  filter?: InputMaybe<UserFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<UsersOrderBy>>;
};

/** A condition to be used against `Role` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type RoleCondition = {
  /** Checks for equality with the object’s `abilities` field. */
  abilities?: InputMaybe<Array<InputMaybe<Roleability>>>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['Int']['input']>;
};

/** A filter to be used against `Role` object types. All fields are combined with a logical ‘and.’ */
export type RoleFilter = {
  /** Filter by the object’s `abilities` field. */
  abilities?: InputMaybe<RoleabilityListFilter>;
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<RoleFilter>>;
  /** Filter by the object’s `companyUsers` relation. */
  companyUsers?: InputMaybe<RoleToManyCompanyUserFilter>;
  /** Some related `companyUsers` exist. */
  companyUsersExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<IntFilter>;
  /** Negates the expression. */
  not?: InputMaybe<RoleFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<RoleFilter>>;
  /** Filter by the object’s `translations` relation. */
  translations?: InputMaybe<RoleToManyRoleTranslationFilter>;
  /** Some related `translations` exist. */
  translationsExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `userInvitations` relation. */
  userInvitations?: InputMaybe<RoleToManyUserInvitationFilter>;
  /** Some related `userInvitations` exist. */
  userInvitationsExist?: InputMaybe<Scalars['Boolean']['input']>;
};

/** An input for mutations affecting `Role` */
export type RoleInput = {
  abilities: Array<InputMaybe<Roleability>>;
  companyUsers?: InputMaybe<CompanyUsersRoleIdFkeyInverseInput>;
  translations?: InputMaybe<RoleTranslationsRoleIdFkeyInverseInput>;
  userInvitations?: InputMaybe<UserInvitationsRoleIdFkeyInverseInput>;
};

/** The globally unique `ID` look up for the row to connect. */
export type RoleNodeIdConnect = {
  /** The globally unique `ID` which identifies a single `role` to be connected. */
  nodeId: Scalars['ID']['input'];
};

/** The globally unique `ID` look up for the row to update. */
export type RoleOnCompanyUserForCompanyUsersRoleIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `companyUser` to be connected. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `companyUser` being updated. */
  patch: CompanyUserPatch;
};

/** The fields on `role` to look up the row to update. */
export type RoleOnCompanyUserForCompanyUsersRoleIdFkeyUsingRolesPkeyUpdate = {
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `role` being updated. */
  patch: UpdateRoleOnCompanyUserForCompanyUsersRoleIdFkeyPatch;
};

/** The globally unique `ID` look up for the row to update. */
export type RoleOnRoleTranslationForRoleTranslationsRoleIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `roleTranslation` to be connected. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `roleTranslation` being updated. */
  patch: RoleTranslationPatch;
};

/** The fields on `role` to look up the row to update. */
export type RoleOnRoleTranslationForRoleTranslationsRoleIdFkeyUsingRolesPkeyUpdate = {
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `role` being updated. */
  patch: UpdateRoleOnRoleTranslationForRoleTranslationsRoleIdFkeyPatch;
};

/** The globally unique `ID` look up for the row to update. */
export type RoleOnUserInvitationForUserInvitationsRoleIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `userInvitation` to be connected. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `userInvitation` being updated. */
  patch: UserInvitationPatch;
};

/** The fields on `role` to look up the row to update. */
export type RoleOnUserInvitationForUserInvitationsRoleIdFkeyUsingRolesPkeyUpdate = {
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `role` being updated. */
  patch: UpdateRoleOnUserInvitationForUserInvitationsRoleIdFkeyPatch;
};

/** Represents an update to a `Role`. Fields that are set will be updated. */
export type RolePatch = {
  abilities?: InputMaybe<Array<InputMaybe<Roleability>>>;
  companyUsers?: InputMaybe<CompanyUsersRoleIdFkeyInverseInput>;
  translations?: InputMaybe<RoleTranslationsRoleIdFkeyInverseInput>;
  userInvitations?: InputMaybe<UserInvitationsRoleIdFkeyInverseInput>;
};

/** The fields on `role` to look up the row to connect. */
export type RoleRolesPkeyConnect = {
  id: Scalars['Int']['input'];
};

/** A filter to be used against many `CompanyUser` object types. All fields are combined with a logical ‘and.’ */
export type RoleToManyCompanyUserFilter = {
  /** Every related `CompanyUser` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<CompanyUserFilter>;
  /** No related `CompanyUser` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<CompanyUserFilter>;
  /** Some related `CompanyUser` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<CompanyUserFilter>;
};

/** A filter to be used against many `RoleTranslation` object types. All fields are combined with a logical ‘and.’ */
export type RoleToManyRoleTranslationFilter = {
  /** Every related `RoleTranslation` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<RoleTranslationFilter>;
  /** No related `RoleTranslation` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<RoleTranslationFilter>;
  /** Some related `RoleTranslation` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<RoleTranslationFilter>;
};

/** A filter to be used against many `UserInvitation` object types. All fields are combined with a logical ‘and.’ */
export type RoleToManyUserInvitationFilter = {
  /** Every related `UserInvitation` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<UserInvitationFilter>;
  /** No related `UserInvitation` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<UserInvitationFilter>;
  /** Some related `UserInvitation` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<UserInvitationFilter>;
};

export type RoleTranslation = Node & {
  __typename?: 'RoleTranslation';
  lang: Language;
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  /** Reads a single `Role` that is related to this `RoleTranslation`. */
  role?: Maybe<Role>;
  roleId: Scalars['Int']['output'];
  title: Scalars['String']['output'];
};

/** A condition to be used against `RoleTranslation` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type RoleTranslationCondition = {
  /** Checks for equality with the object’s `roleId` field. */
  roleId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `title` field. */
  title?: InputMaybe<Scalars['String']['input']>;
};

/** A filter to be used against `RoleTranslation` object types. All fields are combined with a logical ‘and.’ */
export type RoleTranslationFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<RoleTranslationFilter>>;
  /** Negates the expression. */
  not?: InputMaybe<RoleTranslationFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<RoleTranslationFilter>>;
  /** Filter by the object’s `role` relation. */
  role?: InputMaybe<RoleFilter>;
  /** Filter by the object’s `roleId` field. */
  roleId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `title` field. */
  title?: InputMaybe<StringFilter>;
};

/** An input for mutations affecting `RoleTranslation` */
export type RoleTranslationInput = {
  lang: Language;
  role?: InputMaybe<RoleTranslationsRoleIdFkeyInput>;
  roleId?: InputMaybe<Scalars['Int']['input']>;
  title: Scalars['String']['input'];
};

/** The globally unique `ID` look up for the row to connect. */
export type RoleTranslationNodeIdConnect = {
  /** The globally unique `ID` which identifies a single `roleTranslation` to be connected. */
  nodeId: Scalars['ID']['input'];
};

/** The globally unique `ID` look up for the row to delete. */
export type RoleTranslationNodeIdDelete = {
  /** The globally unique `ID` which identifies a single `roleTranslation` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** The globally unique `ID` look up for the row to update. */
export type RoleTranslationOnRoleTranslationForRoleTranslationsRoleIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `role` to be connected. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `role` being updated. */
  patch: RolePatch;
};

/** The fields on `roleTranslation` to look up the row to update. */
export type RoleTranslationOnRoleTranslationForRoleTranslationsRoleIdFkeyUsingRoleTranslationsPkeyUpdate = {
  lang: Language;
  /** An object where the defined keys will be set on the `roleTranslation` being updated. */
  patch: UpdateRoleTranslationOnRoleTranslationForRoleTranslationsRoleIdFkeyPatch;
  roleId: Scalars['Int']['input'];
};

/** Represents an update to a `RoleTranslation`. Fields that are set will be updated. */
export type RoleTranslationPatch = {
  role?: InputMaybe<RoleTranslationsRoleIdFkeyInput>;
  roleId?: InputMaybe<Scalars['Int']['input']>;
  title?: InputMaybe<Scalars['String']['input']>;
};

/** The fields on `roleTranslation` to look up the row to connect. */
export type RoleTranslationRoleTranslationsPkeyConnect = {
  lang: Language;
  roleId: Scalars['Int']['input'];
};

/** The fields on `roleTranslation` to look up the row to delete. */
export type RoleTranslationRoleTranslationsPkeyDelete = {
  lang: Language;
  roleId: Scalars['Int']['input'];
};

/** A connection to a list of `RoleTranslation` values. */
export type RoleTranslationsConnection = {
  __typename?: 'RoleTranslationsConnection';
  /** A list of edges which contains the `RoleTranslation` and cursor to aid in pagination. */
  edges: Array<RoleTranslationsEdge>;
  /** A list of `RoleTranslation` objects. */
  nodes: Array<RoleTranslation>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `RoleTranslation` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `RoleTranslation` edge in the connection. */
export type RoleTranslationsEdge = {
  __typename?: 'RoleTranslationsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `RoleTranslation` at the end of the edge. */
  node: RoleTranslation;
};

/** Methods to use when ordering `RoleTranslation`. */
export enum RoleTranslationsOrderBy {
  Natural = 'NATURAL',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  RoleIdAsc = 'ROLE_ID_ASC',
  RoleIdDesc = 'ROLE_ID_DESC',
  TitleAsc = 'TITLE_ASC',
  TitleDesc = 'TITLE_DESC'
}

/** Input for the nested mutation of `role` in the `RoleTranslationInput` mutation. */
export type RoleTranslationsRoleIdFkeyInput = {
  /** The primary key(s) for `role` for the far side of the relationship. */
  connectById?: InputMaybe<RoleRolesPkeyConnect>;
  /** The primary key(s) for `role` for the far side of the relationship. */
  connectByNodeId?: InputMaybe<RoleNodeIdConnect>;
  /** A `RoleInput` object that will be created and connected to this object. */
  create?: InputMaybe<RoleTranslationsRoleIdFkeyRolesCreateInput>;
  /** The primary key(s) and patch data for `role` for the far side of the relationship. */
  updateById?: InputMaybe<RoleOnRoleTranslationForRoleTranslationsRoleIdFkeyUsingRolesPkeyUpdate>;
  /** The primary key(s) and patch data for `role` for the far side of the relationship. */
  updateByNodeId?: InputMaybe<RoleTranslationOnRoleTranslationForRoleTranslationsRoleIdFkeyNodeIdUpdate>;
};

/** Input for the nested mutation of `roleTranslation` in the `RoleInput` mutation. */
export type RoleTranslationsRoleIdFkeyInverseInput = {
  /** The primary key(s) for `roleTranslation` for the far side of the relationship. */
  connectByNodeId?: InputMaybe<Array<RoleTranslationNodeIdConnect>>;
  /** The primary key(s) for `roleTranslation` for the far side of the relationship. */
  connectByRoleIdAndLang?: InputMaybe<Array<RoleTranslationRoleTranslationsPkeyConnect>>;
  /** A `RoleTranslationInput` object that will be created and connected to this object. */
  create?: InputMaybe<Array<RoleTranslationsRoleIdFkeyRoleTranslationsCreateInput>>;
  /** The primary key(s) for `roleTranslation` for the far side of the relationship. */
  deleteByNodeId?: InputMaybe<Array<RoleTranslationNodeIdDelete>>;
  /** The primary key(s) for `roleTranslation` for the far side of the relationship. */
  deleteByRoleIdAndLang?: InputMaybe<Array<RoleTranslationRoleTranslationsPkeyDelete>>;
  /** Flag indicating whether all other `roleTranslation` records that match this relationship should be removed. */
  deleteOthers?: InputMaybe<Scalars['Boolean']['input']>;
  /** The primary key(s) and patch data for `roleTranslation` for the far side of the relationship. */
  updateByNodeId?: InputMaybe<Array<RoleOnRoleTranslationForRoleTranslationsRoleIdFkeyNodeIdUpdate>>;
  /** The primary key(s) and patch data for `roleTranslation` for the far side of the relationship. */
  updateByRoleIdAndLang?: InputMaybe<Array<RoleTranslationOnRoleTranslationForRoleTranslationsRoleIdFkeyUsingRoleTranslationsPkeyUpdate>>;
};

/** The `roleTranslation` to be created by this mutation. */
export type RoleTranslationsRoleIdFkeyRoleTranslationsCreateInput = {
  lang: Language;
  role?: InputMaybe<RoleTranslationsRoleIdFkeyInput>;
  title: Scalars['String']['input'];
};

/** The `role` to be created by this mutation. */
export type RoleTranslationsRoleIdFkeyRolesCreateInput = {
  abilities: Array<InputMaybe<Roleability>>;
  companyUsers?: InputMaybe<CompanyUsersRoleIdFkeyInverseInput>;
  translations?: InputMaybe<RoleTranslationsRoleIdFkeyInverseInput>;
  userInvitations?: InputMaybe<UserInvitationsRoleIdFkeyInverseInput>;
};

/** A connection to a list of `User` values, with data from `CompanyUser`. */
export type RoleUsersByCompanyUserRoleIdAndUserIdManyToManyConnection = {
  __typename?: 'RoleUsersByCompanyUserRoleIdAndUserIdManyToManyConnection';
  /** A list of edges which contains the `User`, info from the `CompanyUser`, and the cursor to aid in pagination. */
  edges: Array<RoleUsersByCompanyUserRoleIdAndUserIdManyToManyEdge>;
  /** A list of `User` objects. */
  nodes: Array<User>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `User` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `User` edge in the connection, with data from `CompanyUser`. */
export type RoleUsersByCompanyUserRoleIdAndUserIdManyToManyEdge = {
  __typename?: 'RoleUsersByCompanyUserRoleIdAndUserIdManyToManyEdge';
  /** Reads and enables pagination through a set of `CompanyUser`. */
  companyUsers: CompanyUsersConnection;
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `User` at the end of the edge. */
  node: User;
};


/** A `User` edge in the connection, with data from `CompanyUser`. */
export type RoleUsersByCompanyUserRoleIdAndUserIdManyToManyEdgeCompanyUsersArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<CompanyUserCondition>;
  filter?: InputMaybe<CompanyUserFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<CompanyUsersOrderBy>>;
};

export enum Roleability {
  Candidates = 'CANDIDATES',
  CandidatesCreateNew = 'CANDIDATES_CREATE_NEW',
  CandidatesEditAll = 'CANDIDATES_EDIT_ALL',
  CandidatesImport = 'CANDIDATES_IMPORT',
  CandidatesViewAll = 'CANDIDATES_VIEW_ALL',
  CandidatesViewContacts = 'CANDIDATES_VIEW_CONTACTS',
  CompanyManageAttributes = 'COMPANY_MANAGE_ATTRIBUTES',
  CreateEvents = 'CREATE_EVENTS',
  FetchInvoice = 'FETCH_INVOICE',
  Jobs = 'JOBS',
  JobsCreateApplications = 'JOBS_CREATE_APPLICATIONS',
  JobsCreateNew = 'JOBS_CREATE_NEW',
  JobsEditAll = 'JOBS_EDIT_ALL',
  JobsEditApplications = 'JOBS_EDIT_APPLICATIONS',
  JobsEditOwned = 'JOBS_EDIT_OWNED',
  JobsManageTeam = 'JOBS_MANAGE_TEAM',
  JobsViewAll = 'JOBS_VIEW_ALL',
  ManageWebsite = 'MANAGE_WEBSITE',
  Messages = 'MESSAGES',
  MessagesAccessAll = 'MESSAGES_ACCESS_ALL',
  MessagesAccessOwned = 'MESSAGES_ACCESS_OWNED',
  MessagesSend = 'MESSAGES_SEND',
  PaymentInvoice = 'PAYMENT_INVOICE',
  Reports = 'REPORTS'
}

/** A filter to be used against Roleability List fields. All fields are combined with a logical ‘and.’ */
export type RoleabilityListFilter = {
  /** Any array item is equal to the specified value. */
  anyEqualTo?: InputMaybe<Roleability>;
  /** Any array item is greater than the specified value. */
  anyGreaterThan?: InputMaybe<Roleability>;
  /** Any array item is greater than or equal to the specified value. */
  anyGreaterThanOrEqualTo?: InputMaybe<Roleability>;
  /** Any array item is less than the specified value. */
  anyLessThan?: InputMaybe<Roleability>;
  /** Any array item is less than or equal to the specified value. */
  anyLessThanOrEqualTo?: InputMaybe<Roleability>;
  /** Any array item is not equal to the specified value. */
  anyNotEqualTo?: InputMaybe<Roleability>;
  /** Contained by the specified list of values. */
  containedBy?: InputMaybe<Array<InputMaybe<Roleability>>>;
  /** Contains the specified list of values. */
  contains?: InputMaybe<Array<InputMaybe<Roleability>>>;
  /** Not equal to the specified value, treating null like an ordinary value. */
  distinctFrom?: InputMaybe<Array<InputMaybe<Roleability>>>;
  /** Equal to the specified value. */
  equalTo?: InputMaybe<Array<InputMaybe<Roleability>>>;
  /** Greater than the specified value. */
  greaterThan?: InputMaybe<Array<InputMaybe<Roleability>>>;
  /** Greater than or equal to the specified value. */
  greaterThanOrEqualTo?: InputMaybe<Array<InputMaybe<Roleability>>>;
  /** Is null (if `true` is specified) or is not null (if `false` is specified). */
  isNull?: InputMaybe<Scalars['Boolean']['input']>;
  /** Less than the specified value. */
  lessThan?: InputMaybe<Array<InputMaybe<Roleability>>>;
  /** Less than or equal to the specified value. */
  lessThanOrEqualTo?: InputMaybe<Array<InputMaybe<Roleability>>>;
  /** Equal to the specified value, treating null like an ordinary value. */
  notDistinctFrom?: InputMaybe<Array<InputMaybe<Roleability>>>;
  /** Not equal to the specified value. */
  notEqualTo?: InputMaybe<Array<InputMaybe<Roleability>>>;
  /** Overlaps the specified list of values. */
  overlaps?: InputMaybe<Array<InputMaybe<Roleability>>>;
};

/** A connection to a list of `Role` values. */
export type RolesConnection = {
  __typename?: 'RolesConnection';
  /** A list of edges which contains the `Role` and cursor to aid in pagination. */
  edges: Array<RolesEdge>;
  /** A list of `Role` objects. */
  nodes: Array<Role>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Role` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `Role` edge in the connection. */
export type RolesEdge = {
  __typename?: 'RolesEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Role` at the end of the edge. */
  node: Role;
};

/** Methods to use when ordering `Role`. */
export enum RolesOrderBy {
  AbilitiesAsc = 'ABILITIES_ASC',
  AbilitiesDesc = 'ABILITIES_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  Natural = 'NATURAL',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC'
}

export type Scorecard = Node & {
  __typename?: 'Scorecard';
  /** Reads and enables pagination through a set of `ScorecardCriteria`. */
  criterias: ScorecardCriteriaConnection;
  /** Reads and enables pagination through a set of `EvaluationScorecard`. */
  evaluationScorecards: EvaluationScorecardsConnection;
  /** Reads and enables pagination through a set of `Evaluation`. */
  evaluations: ScorecardEvaluationsByEvaluationScorecardScorecardIdAndEvaluationIdManyToManyConnection;
  /** Reads and enables pagination through a set of `EventScorecard`. */
  eventScorecards: EventScorecardsConnection;
  /** Reads and enables pagination through a set of `Event`. */
  events: ScorecardEventsByEventScorecardScorecardIdAndEventIdManyToManyConnection;
  id: Scalars['Int']['output'];
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  /** Reads and enables pagination through a set of `PipelineStageScorecard`. */
  pipelineStageScorecards: PipelineStageScorecardsConnection;
  /** Reads and enables pagination through a set of `PipelineStage`. */
  pipelineStages: ScorecardPipelineStagesByPipelineStageScorecardScorecardIdAndPipelineStageIdManyToManyConnection;
  /** Reads and enables pagination through a set of `ScorecardTranslation`. */
  translations: ScorecardTranslationsConnection;
};


export type ScorecardCriteriasArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<ScorecardCriteriaCondition>;
  filter?: InputMaybe<ScorecardCriteriaFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<ScorecardCriteriaOrderBy>>;
};


export type ScorecardEvaluationScorecardsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<EvaluationScorecardCondition>;
  filter?: InputMaybe<EvaluationScorecardFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<EvaluationScorecardsOrderBy>>;
};


export type ScorecardEvaluationsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<EvaluationCondition>;
  filter?: InputMaybe<EvaluationFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<EvaluationsOrderBy>>;
};


export type ScorecardEventScorecardsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<EventScorecardCondition>;
  filter?: InputMaybe<EventScorecardFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<EventScorecardsOrderBy>>;
};


export type ScorecardEventsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<EventCondition>;
  filter?: InputMaybe<EventFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<EventsOrderBy>>;
};


export type ScorecardPipelineStageScorecardsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<PipelineStageScorecardCondition>;
  filter?: InputMaybe<PipelineStageScorecardFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<PipelineStageScorecardsOrderBy>>;
};


export type ScorecardPipelineStagesArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<PipelineStageCondition>;
  filter?: InputMaybe<PipelineStageFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<PipelineStagesOrderBy>>;
};


export type ScorecardTranslationsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<ScorecardTranslationCondition>;
  filter?: InputMaybe<ScorecardTranslationFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<ScorecardTranslationsOrderBy>>;
};

/** A condition to be used against `Scorecard` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type ScorecardCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['Int']['input']>;
};

export type ScorecardCriteria = Node & {
  __typename?: 'ScorecardCriteria';
  commentable: Scalars['Boolean']['output'];
  /** Reads and enables pagination through a set of `EvaluationScorecardCriteria`. */
  evaluationScorecardCriteriaByCriteriaId: EvaluationScorecardCriteriaConnection;
  /** Reads and enables pagination through a set of `EvaluationScorecard`. */
  evaluationScorecards: ScorecardCriteriaEvaluationScorecardsByEvaluationScorecardCriteriaCriteriaIdAndEvaluationScorecardIdManyToManyConnection;
  id: Scalars['Int']['output'];
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  required: Scalars['Boolean']['output'];
  /** Reads a single `Scorecard` that is related to this `ScorecardCriteria`. */
  scorecard?: Maybe<Scorecard>;
  scorecardId: Scalars['Int']['output'];
  /** Reads and enables pagination through a set of `ScorecardCriteriaTranslation`. */
  translations: ScorecardCriteriaTranslationsConnection;
};


export type ScorecardCriteriaEvaluationScorecardCriteriaByCriteriaIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<EvaluationScorecardCriteriaCondition>;
  filter?: InputMaybe<EvaluationScorecardCriteriaFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<EvaluationScorecardCriteriaOrderBy>>;
};


export type ScorecardCriteriaEvaluationScorecardsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<EvaluationScorecardCondition>;
  filter?: InputMaybe<EvaluationScorecardFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<EvaluationScorecardsOrderBy>>;
};


export type ScorecardCriteriaTranslationsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<ScorecardCriteriaTranslationCondition>;
  filter?: InputMaybe<ScorecardCriteriaTranslationFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<ScorecardCriteriaTranslationsOrderBy>>;
};

/** A condition to be used against `ScorecardCriteria` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type ScorecardCriteriaCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `scorecardId` field. */
  scorecardId?: InputMaybe<Scalars['Int']['input']>;
};

/** A connection to a list of `ScorecardCriteria` values. */
export type ScorecardCriteriaConnection = {
  __typename?: 'ScorecardCriteriaConnection';
  /** A list of edges which contains the `ScorecardCriteria` and cursor to aid in pagination. */
  edges: Array<ScorecardCriteriaEdge>;
  /** A list of `ScorecardCriteria` objects. */
  nodes: Array<ScorecardCriteria>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `ScorecardCriteria` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `ScorecardCriteria` edge in the connection. */
export type ScorecardCriteriaEdge = {
  __typename?: 'ScorecardCriteriaEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `ScorecardCriteria` at the end of the edge. */
  node: ScorecardCriteria;
};

/** A connection to a list of `EvaluationScorecard` values, with data from `EvaluationScorecardCriteria`. */
export type ScorecardCriteriaEvaluationScorecardsByEvaluationScorecardCriteriaCriteriaIdAndEvaluationScorecardIdManyToManyConnection = {
  __typename?: 'ScorecardCriteriaEvaluationScorecardsByEvaluationScorecardCriteriaCriteriaIdAndEvaluationScorecardIdManyToManyConnection';
  /** A list of edges which contains the `EvaluationScorecard`, info from the `EvaluationScorecardCriteria`, and the cursor to aid in pagination. */
  edges: Array<ScorecardCriteriaEvaluationScorecardsByEvaluationScorecardCriteriaCriteriaIdAndEvaluationScorecardIdManyToManyEdge>;
  /** A list of `EvaluationScorecard` objects. */
  nodes: Array<EvaluationScorecard>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `EvaluationScorecard` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `EvaluationScorecard` edge in the connection, with data from `EvaluationScorecardCriteria`. */
export type ScorecardCriteriaEvaluationScorecardsByEvaluationScorecardCriteriaCriteriaIdAndEvaluationScorecardIdManyToManyEdge = {
  __typename?: 'ScorecardCriteriaEvaluationScorecardsByEvaluationScorecardCriteriaCriteriaIdAndEvaluationScorecardIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `EvaluationScorecard` at the end of the edge. */
  node: EvaluationScorecard;
  /** Reads and enables pagination through a set of `EvaluationScorecardCriteria`. */
  scorecardCriterias: EvaluationScorecardCriteriaConnection;
};


/** A `EvaluationScorecard` edge in the connection, with data from `EvaluationScorecardCriteria`. */
export type ScorecardCriteriaEvaluationScorecardsByEvaluationScorecardCriteriaCriteriaIdAndEvaluationScorecardIdManyToManyEdgeScorecardCriteriasArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<EvaluationScorecardCriteriaCondition>;
  filter?: InputMaybe<EvaluationScorecardCriteriaFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<EvaluationScorecardCriteriaOrderBy>>;
};

/** A filter to be used against `ScorecardCriteria` object types. All fields are combined with a logical ‘and.’ */
export type ScorecardCriteriaFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<ScorecardCriteriaFilter>>;
  /** Filter by the object’s `evaluationScorecardCriteriaByCriteriaId` relation. */
  evaluationScorecardCriteriaByCriteriaId?: InputMaybe<ScorecardCriteriaToManyEvaluationScorecardCriteriaFilter>;
  /** Some related `evaluationScorecardCriteriaByCriteriaId` exist. */
  evaluationScorecardCriteriaByCriteriaIdExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<IntFilter>;
  /** Negates the expression. */
  not?: InputMaybe<ScorecardCriteriaFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<ScorecardCriteriaFilter>>;
  /** Filter by the object’s `scorecard` relation. */
  scorecard?: InputMaybe<ScorecardFilter>;
  /** Filter by the object’s `scorecardId` field. */
  scorecardId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `translations` relation. */
  translations?: InputMaybe<ScorecardCriteriaToManyScorecardCriteriaTranslationFilter>;
  /** Some related `translations` exist. */
  translationsExist?: InputMaybe<Scalars['Boolean']['input']>;
};

/** An input for mutations affecting `ScorecardCriteria` */
export type ScorecardCriteriaInput = {
  commentable: Scalars['Boolean']['input'];
  evaluationScorecardCriteria?: InputMaybe<EvaluationScorecardCriteriasCriteriaIdFkeyInverseInput>;
  required: Scalars['Boolean']['input'];
  scorecard?: InputMaybe<ScorecardCriteriasScorecardIdFkeyInput>;
  scorecardId?: InputMaybe<Scalars['Int']['input']>;
  translations?: InputMaybe<ScorecardCriteriaTranslationsScorecardCriteriaIdFkeyInverseInput>;
};

/** The globally unique `ID` look up for the row to connect. */
export type ScorecardCriteriaNodeIdConnect = {
  /** The globally unique `ID` which identifies a single `scorecardCriteria` to be connected. */
  nodeId: Scalars['ID']['input'];
};

/** The globally unique `ID` look up for the row to update. */
export type ScorecardCriteriaOnEvaluationScorecardCriteriaForEvaluationScorecardCriteriasCriteriaIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `evaluationScorecardCriteria` to be connected. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `evaluationScorecardCriteria` being updated. */
  patch: EvaluationScorecardCriteriaPatch;
};

/** The fields on `scorecardCriteria` to look up the row to update. */
export type ScorecardCriteriaOnEvaluationScorecardCriteriaForEvaluationScorecardCriteriasCriteriaIdFkeyUsingScorecardCriteriasPkeyUpdate = {
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `scorecardCriteria` being updated. */
  patch: UpdateScorecardCriteriaOnEvaluationScorecardCriteriaForEvaluationScorecardCriteriasCriteriaIdFkeyPatch;
};

/** The globally unique `ID` look up for the row to update. */
export type ScorecardCriteriaOnScorecardCriteriaForScorecardCriteriasScorecardIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `scorecard` to be connected. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `scorecard` being updated. */
  patch: ScorecardPatch;
};

/** The fields on `scorecardCriteria` to look up the row to update. */
export type ScorecardCriteriaOnScorecardCriteriaForScorecardCriteriasScorecardIdFkeyUsingScorecardCriteriasPkeyUpdate = {
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `scorecardCriteria` being updated. */
  patch: UpdateScorecardCriteriaOnScorecardCriteriaForScorecardCriteriasScorecardIdFkeyPatch;
};

/** The globally unique `ID` look up for the row to update. */
export type ScorecardCriteriaOnScorecardCriteriaTranslationForScorecardCriteriaTranslationsScorecardCriteriaIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `scorecardCriteriaTranslation` to be connected. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `scorecardCriteriaTranslation` being updated. */
  patch: ScorecardCriteriaTranslationPatch;
};

/** The fields on `scorecardCriteria` to look up the row to update. */
export type ScorecardCriteriaOnScorecardCriteriaTranslationForScorecardCriteriaTranslationsScorecardCriteriaIdFkeyUsingScorecardCriteriasPkeyUpdate = {
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `scorecardCriteria` being updated. */
  patch: UpdateScorecardCriteriaOnScorecardCriteriaTranslationForScorecardCriteriaTranslationsScorecardCriteriaIdFkeyPatch;
};

/** Methods to use when ordering `ScorecardCriteria`. */
export enum ScorecardCriteriaOrderBy {
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  Natural = 'NATURAL',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  ScorecardIdAsc = 'SCORECARD_ID_ASC',
  ScorecardIdDesc = 'SCORECARD_ID_DESC'
}

/** Represents an update to a `ScorecardCriteria`. Fields that are set will be updated. */
export type ScorecardCriteriaPatch = {
  commentable?: InputMaybe<Scalars['Boolean']['input']>;
  evaluationScorecardCriteria?: InputMaybe<EvaluationScorecardCriteriasCriteriaIdFkeyInverseInput>;
  required?: InputMaybe<Scalars['Boolean']['input']>;
  scorecard?: InputMaybe<ScorecardCriteriasScorecardIdFkeyInput>;
  scorecardId?: InputMaybe<Scalars['Int']['input']>;
  translations?: InputMaybe<ScorecardCriteriaTranslationsScorecardCriteriaIdFkeyInverseInput>;
};

/** The fields on `scorecardCriteria` to look up the row to connect. */
export type ScorecardCriteriaScorecardCriteriasPkeyConnect = {
  id: Scalars['Int']['input'];
};

/** A filter to be used against many `EvaluationScorecardCriteria` object types. All fields are combined with a logical ‘and.’ */
export type ScorecardCriteriaToManyEvaluationScorecardCriteriaFilter = {
  /** Every related `EvaluationScorecardCriteria` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<EvaluationScorecardCriteriaFilter>;
  /** No related `EvaluationScorecardCriteria` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<EvaluationScorecardCriteriaFilter>;
  /** Some related `EvaluationScorecardCriteria` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<EvaluationScorecardCriteriaFilter>;
};

/** A filter to be used against many `ScorecardCriteriaTranslation` object types. All fields are combined with a logical ‘and.’ */
export type ScorecardCriteriaToManyScorecardCriteriaTranslationFilter = {
  /** Every related `ScorecardCriteriaTranslation` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<ScorecardCriteriaTranslationFilter>;
  /** No related `ScorecardCriteriaTranslation` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<ScorecardCriteriaTranslationFilter>;
  /** Some related `ScorecardCriteriaTranslation` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<ScorecardCriteriaTranslationFilter>;
};

export type ScorecardCriteriaTranslation = Node & {
  __typename?: 'ScorecardCriteriaTranslation';
  lang: Language;
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  /** Reads a single `ScorecardCriteria` that is related to this `ScorecardCriteriaTranslation`. */
  scorecardCriteria?: Maybe<ScorecardCriteria>;
  scorecardCriteriaId: Scalars['Int']['output'];
  title: Scalars['String']['output'];
};

/** A condition to be used against `ScorecardCriteriaTranslation` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type ScorecardCriteriaTranslationCondition = {
  /** Checks for equality with the object’s `scorecardCriteriaId` field. */
  scorecardCriteriaId?: InputMaybe<Scalars['Int']['input']>;
};

/** A filter to be used against `ScorecardCriteriaTranslation` object types. All fields are combined with a logical ‘and.’ */
export type ScorecardCriteriaTranslationFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<ScorecardCriteriaTranslationFilter>>;
  /** Negates the expression. */
  not?: InputMaybe<ScorecardCriteriaTranslationFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<ScorecardCriteriaTranslationFilter>>;
  /** Filter by the object’s `scorecardCriteria` relation. */
  scorecardCriteria?: InputMaybe<ScorecardCriteriaFilter>;
  /** Filter by the object’s `scorecardCriteriaId` field. */
  scorecardCriteriaId?: InputMaybe<IntFilter>;
};

/** An input for mutations affecting `ScorecardCriteriaTranslation` */
export type ScorecardCriteriaTranslationInput = {
  lang: Language;
  scorecardCriteria?: InputMaybe<ScorecardCriteriaTranslationsScorecardCriteriaIdFkeyInput>;
  scorecardCriteriaId?: InputMaybe<Scalars['Int']['input']>;
  title: Scalars['String']['input'];
};

/** The globally unique `ID` look up for the row to connect. */
export type ScorecardCriteriaTranslationNodeIdConnect = {
  /** The globally unique `ID` which identifies a single `scorecardCriteriaTranslation` to be connected. */
  nodeId: Scalars['ID']['input'];
};

/** The globally unique `ID` look up for the row to delete. */
export type ScorecardCriteriaTranslationNodeIdDelete = {
  /** The globally unique `ID` which identifies a single `scorecardCriteriaTranslation` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** The globally unique `ID` look up for the row to update. */
export type ScorecardCriteriaTranslationOnScorecardCriteriaTranslationForScorecardCriteriaTranslationsScorecardCriteriaIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `scorecardCriteria` to be connected. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `scorecardCriteria` being updated. */
  patch: ScorecardCriteriaPatch;
};

/** The fields on `scorecardCriteriaTranslation` to look up the row to update. */
export type ScorecardCriteriaTranslationOnScorecardCriteriaTranslationForScorecardCriteriaTranslationsScorecardCriteriaIdFkeyUsingScorecardCriteriaTranslationsPkeyUpdate = {
  lang: Language;
  /** An object where the defined keys will be set on the `scorecardCriteriaTranslation` being updated. */
  patch: UpdateScorecardCriteriaTranslationOnScorecardCriteriaTranslationForScorecardCriteriaTranslationsScorecardCriteriaIdFkeyPatch;
  scorecardCriteriaId: Scalars['Int']['input'];
};

/** Represents an update to a `ScorecardCriteriaTranslation`. Fields that are set will be updated. */
export type ScorecardCriteriaTranslationPatch = {
  scorecardCriteria?: InputMaybe<ScorecardCriteriaTranslationsScorecardCriteriaIdFkeyInput>;
  scorecardCriteriaId?: InputMaybe<Scalars['Int']['input']>;
  title?: InputMaybe<Scalars['String']['input']>;
};

/** The fields on `scorecardCriteriaTranslation` to look up the row to connect. */
export type ScorecardCriteriaTranslationScorecardCriteriaTranslationsPkeyConnect = {
  lang: Language;
  scorecardCriteriaId: Scalars['Int']['input'];
};

/** The fields on `scorecardCriteriaTranslation` to look up the row to delete. */
export type ScorecardCriteriaTranslationScorecardCriteriaTranslationsPkeyDelete = {
  lang: Language;
  scorecardCriteriaId: Scalars['Int']['input'];
};

/** A connection to a list of `ScorecardCriteriaTranslation` values. */
export type ScorecardCriteriaTranslationsConnection = {
  __typename?: 'ScorecardCriteriaTranslationsConnection';
  /** A list of edges which contains the `ScorecardCriteriaTranslation` and cursor to aid in pagination. */
  edges: Array<ScorecardCriteriaTranslationsEdge>;
  /** A list of `ScorecardCriteriaTranslation` objects. */
  nodes: Array<ScorecardCriteriaTranslation>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `ScorecardCriteriaTranslation` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `ScorecardCriteriaTranslation` edge in the connection. */
export type ScorecardCriteriaTranslationsEdge = {
  __typename?: 'ScorecardCriteriaTranslationsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `ScorecardCriteriaTranslation` at the end of the edge. */
  node: ScorecardCriteriaTranslation;
};

/** Methods to use when ordering `ScorecardCriteriaTranslation`. */
export enum ScorecardCriteriaTranslationsOrderBy {
  Natural = 'NATURAL',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  ScorecardCriteriaIdAsc = 'SCORECARD_CRITERIA_ID_ASC',
  ScorecardCriteriaIdDesc = 'SCORECARD_CRITERIA_ID_DESC'
}

/** Input for the nested mutation of `scorecardCriteria` in the `ScorecardCriteriaTranslationInput` mutation. */
export type ScorecardCriteriaTranslationsScorecardCriteriaIdFkeyInput = {
  /** The primary key(s) for `scorecardCriteria` for the far side of the relationship. */
  connectById?: InputMaybe<ScorecardCriteriaScorecardCriteriasPkeyConnect>;
  /** The primary key(s) for `scorecardCriteria` for the far side of the relationship. */
  connectByNodeId?: InputMaybe<ScorecardCriteriaNodeIdConnect>;
  /** A `ScorecardCriteriaInput` object that will be created and connected to this object. */
  create?: InputMaybe<ScorecardCriteriaTranslationsScorecardCriteriaIdFkeyScorecardCriteriasCreateInput>;
  /** The primary key(s) and patch data for `scorecardCriteria` for the far side of the relationship. */
  updateById?: InputMaybe<ScorecardCriteriaOnScorecardCriteriaTranslationForScorecardCriteriaTranslationsScorecardCriteriaIdFkeyUsingScorecardCriteriasPkeyUpdate>;
  /** The primary key(s) and patch data for `scorecardCriteria` for the far side of the relationship. */
  updateByNodeId?: InputMaybe<ScorecardCriteriaTranslationOnScorecardCriteriaTranslationForScorecardCriteriaTranslationsScorecardCriteriaIdFkeyNodeIdUpdate>;
};

/** Input for the nested mutation of `scorecardCriteriaTranslation` in the `ScorecardCriteriaInput` mutation. */
export type ScorecardCriteriaTranslationsScorecardCriteriaIdFkeyInverseInput = {
  /** The primary key(s) for `scorecardCriteriaTranslation` for the far side of the relationship. */
  connectByNodeId?: InputMaybe<Array<ScorecardCriteriaTranslationNodeIdConnect>>;
  /** The primary key(s) for `scorecardCriteriaTranslation` for the far side of the relationship. */
  connectByScorecardCriteriaIdAndLang?: InputMaybe<Array<ScorecardCriteriaTranslationScorecardCriteriaTranslationsPkeyConnect>>;
  /** A `ScorecardCriteriaTranslationInput` object that will be created and connected to this object. */
  create?: InputMaybe<Array<ScorecardCriteriaTranslationsScorecardCriteriaIdFkeyScorecardCriteriaTranslationsCreateInput>>;
  /** The primary key(s) for `scorecardCriteriaTranslation` for the far side of the relationship. */
  deleteByNodeId?: InputMaybe<Array<ScorecardCriteriaTranslationNodeIdDelete>>;
  /** The primary key(s) for `scorecardCriteriaTranslation` for the far side of the relationship. */
  deleteByScorecardCriteriaIdAndLang?: InputMaybe<Array<ScorecardCriteriaTranslationScorecardCriteriaTranslationsPkeyDelete>>;
  /** Flag indicating whether all other `scorecardCriteriaTranslation` records that match this relationship should be removed. */
  deleteOthers?: InputMaybe<Scalars['Boolean']['input']>;
  /** The primary key(s) and patch data for `scorecardCriteriaTranslation` for the far side of the relationship. */
  updateByNodeId?: InputMaybe<Array<ScorecardCriteriaOnScorecardCriteriaTranslationForScorecardCriteriaTranslationsScorecardCriteriaIdFkeyNodeIdUpdate>>;
  /** The primary key(s) and patch data for `scorecardCriteriaTranslation` for the far side of the relationship. */
  updateByScorecardCriteriaIdAndLang?: InputMaybe<Array<ScorecardCriteriaTranslationOnScorecardCriteriaTranslationForScorecardCriteriaTranslationsScorecardCriteriaIdFkeyUsingScorecardCriteriaTranslationsPkeyUpdate>>;
};

/** The `scorecardCriteriaTranslation` to be created by this mutation. */
export type ScorecardCriteriaTranslationsScorecardCriteriaIdFkeyScorecardCriteriaTranslationsCreateInput = {
  lang: Language;
  scorecardCriteria?: InputMaybe<ScorecardCriteriaTranslationsScorecardCriteriaIdFkeyInput>;
  title: Scalars['String']['input'];
};

/** The `scorecardCriteria` to be created by this mutation. */
export type ScorecardCriteriaTranslationsScorecardCriteriaIdFkeyScorecardCriteriasCreateInput = {
  commentable: Scalars['Boolean']['input'];
  evaluationScorecardCriteria?: InputMaybe<EvaluationScorecardCriteriasCriteriaIdFkeyInverseInput>;
  required: Scalars['Boolean']['input'];
  scorecard?: InputMaybe<ScorecardCriteriasScorecardIdFkeyInput>;
  scorecardId?: InputMaybe<Scalars['Int']['input']>;
  translations?: InputMaybe<ScorecardCriteriaTranslationsScorecardCriteriaIdFkeyInverseInput>;
};

/** Input for the nested mutation of `scorecard` in the `ScorecardCriteriaInput` mutation. */
export type ScorecardCriteriasScorecardIdFkeyInput = {
  /** The primary key(s) for `scorecard` for the far side of the relationship. */
  connectById?: InputMaybe<ScorecardScorecardsPkeyConnect>;
  /** The primary key(s) for `scorecard` for the far side of the relationship. */
  connectByNodeId?: InputMaybe<ScorecardNodeIdConnect>;
  /** A `ScorecardInput` object that will be created and connected to this object. */
  create?: InputMaybe<ScorecardCriteriasScorecardIdFkeyScorecardsCreateInput>;
  /** The primary key(s) and patch data for `scorecard` for the far side of the relationship. */
  updateById?: InputMaybe<ScorecardOnScorecardCriteriaForScorecardCriteriasScorecardIdFkeyUsingScorecardsPkeyUpdate>;
  /** The primary key(s) and patch data for `scorecard` for the far side of the relationship. */
  updateByNodeId?: InputMaybe<ScorecardCriteriaOnScorecardCriteriaForScorecardCriteriasScorecardIdFkeyNodeIdUpdate>;
};

/** Input for the nested mutation of `scorecardCriteria` in the `ScorecardInput` mutation. */
export type ScorecardCriteriasScorecardIdFkeyInverseInput = {
  /** The primary key(s) for `scorecardCriteria` for the far side of the relationship. */
  connectById?: InputMaybe<Array<ScorecardCriteriaScorecardCriteriasPkeyConnect>>;
  /** The primary key(s) for `scorecardCriteria` for the far side of the relationship. */
  connectByNodeId?: InputMaybe<Array<ScorecardCriteriaNodeIdConnect>>;
  /** A `ScorecardCriteriaInput` object that will be created and connected to this object. */
  create?: InputMaybe<Array<ScorecardCriteriasScorecardIdFkeyScorecardCriteriasCreateInput>>;
  /** The primary key(s) and patch data for `scorecardCriteria` for the far side of the relationship. */
  updateById?: InputMaybe<Array<ScorecardCriteriaOnScorecardCriteriaForScorecardCriteriasScorecardIdFkeyUsingScorecardCriteriasPkeyUpdate>>;
  /** The primary key(s) and patch data for `scorecardCriteria` for the far side of the relationship. */
  updateByNodeId?: InputMaybe<Array<ScorecardOnScorecardCriteriaForScorecardCriteriasScorecardIdFkeyNodeIdUpdate>>;
};

/** The `scorecardCriteria` to be created by this mutation. */
export type ScorecardCriteriasScorecardIdFkeyScorecardCriteriasCreateInput = {
  commentable: Scalars['Boolean']['input'];
  evaluationScorecardCriteria?: InputMaybe<EvaluationScorecardCriteriasCriteriaIdFkeyInverseInput>;
  required: Scalars['Boolean']['input'];
  scorecard?: InputMaybe<ScorecardCriteriasScorecardIdFkeyInput>;
  translations?: InputMaybe<ScorecardCriteriaTranslationsScorecardCriteriaIdFkeyInverseInput>;
};

/** The `scorecard` to be created by this mutation. */
export type ScorecardCriteriasScorecardIdFkeyScorecardsCreateInput = {
  criterias?: InputMaybe<ScorecardCriteriasScorecardIdFkeyInverseInput>;
  evaluationScorecards?: InputMaybe<EvaluationScorecardsScorecardIdFkeyInverseInput>;
  eventScorecards?: InputMaybe<EventScorecardsScorecardIdFkeyInverseInput>;
  pipelineStageScorecards?: InputMaybe<PipelineStageScorecardsScorecardIdFkeyInverseInput>;
  translations?: InputMaybe<ScorecardTranslationsScorecardIdFkeyInverseInput>;
};

/** A connection to a list of `Evaluation` values, with data from `EvaluationScorecard`. */
export type ScorecardEvaluationsByEvaluationScorecardScorecardIdAndEvaluationIdManyToManyConnection = {
  __typename?: 'ScorecardEvaluationsByEvaluationScorecardScorecardIdAndEvaluationIdManyToManyConnection';
  /** A list of edges which contains the `Evaluation`, info from the `EvaluationScorecard`, and the cursor to aid in pagination. */
  edges: Array<ScorecardEvaluationsByEvaluationScorecardScorecardIdAndEvaluationIdManyToManyEdge>;
  /** A list of `Evaluation` objects. */
  nodes: Array<Evaluation>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Evaluation` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `Evaluation` edge in the connection, with data from `EvaluationScorecard`. */
export type ScorecardEvaluationsByEvaluationScorecardScorecardIdAndEvaluationIdManyToManyEdge = {
  __typename?: 'ScorecardEvaluationsByEvaluationScorecardScorecardIdAndEvaluationIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** Reads and enables pagination through a set of `EvaluationScorecard`. */
  evaluationScorecards: EvaluationScorecardsConnection;
  /** The `Evaluation` at the end of the edge. */
  node: Evaluation;
};


/** A `Evaluation` edge in the connection, with data from `EvaluationScorecard`. */
export type ScorecardEvaluationsByEvaluationScorecardScorecardIdAndEvaluationIdManyToManyEdgeEvaluationScorecardsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<EvaluationScorecardCondition>;
  filter?: InputMaybe<EvaluationScorecardFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<EvaluationScorecardsOrderBy>>;
};

/** A connection to a list of `Event` values, with data from `EventScorecard`. */
export type ScorecardEventsByEventScorecardScorecardIdAndEventIdManyToManyConnection = {
  __typename?: 'ScorecardEventsByEventScorecardScorecardIdAndEventIdManyToManyConnection';
  /** A list of edges which contains the `Event`, info from the `EventScorecard`, and the cursor to aid in pagination. */
  edges: Array<ScorecardEventsByEventScorecardScorecardIdAndEventIdManyToManyEdge>;
  /** A list of `Event` objects. */
  nodes: Array<Event>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Event` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `Event` edge in the connection, with data from `EventScorecard`. */
export type ScorecardEventsByEventScorecardScorecardIdAndEventIdManyToManyEdge = {
  __typename?: 'ScorecardEventsByEventScorecardScorecardIdAndEventIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** Reads and enables pagination through a set of `EventScorecard`. */
  eventScorecards: EventScorecardsConnection;
  /** The `Event` at the end of the edge. */
  node: Event;
};


/** A `Event` edge in the connection, with data from `EventScorecard`. */
export type ScorecardEventsByEventScorecardScorecardIdAndEventIdManyToManyEdgeEventScorecardsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<EventScorecardCondition>;
  filter?: InputMaybe<EventScorecardFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<EventScorecardsOrderBy>>;
};

/** A filter to be used against `Scorecard` object types. All fields are combined with a logical ‘and.’ */
export type ScorecardFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<ScorecardFilter>>;
  /** Filter by the object’s `criterias` relation. */
  criterias?: InputMaybe<ScorecardToManyScorecardCriteriaFilter>;
  /** Some related `criterias` exist. */
  criteriasExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `evaluationScorecards` relation. */
  evaluationScorecards?: InputMaybe<ScorecardToManyEvaluationScorecardFilter>;
  /** Some related `evaluationScorecards` exist. */
  evaluationScorecardsExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `eventScorecards` relation. */
  eventScorecards?: InputMaybe<ScorecardToManyEventScorecardFilter>;
  /** Some related `eventScorecards` exist. */
  eventScorecardsExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<IntFilter>;
  /** Negates the expression. */
  not?: InputMaybe<ScorecardFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<ScorecardFilter>>;
  /** Filter by the object’s `pipelineStageScorecards` relation. */
  pipelineStageScorecards?: InputMaybe<ScorecardToManyPipelineStageScorecardFilter>;
  /** Some related `pipelineStageScorecards` exist. */
  pipelineStageScorecardsExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `translations` relation. */
  translations?: InputMaybe<ScorecardToManyScorecardTranslationFilter>;
  /** Some related `translations` exist. */
  translationsExist?: InputMaybe<Scalars['Boolean']['input']>;
};

/** An input for mutations affecting `Scorecard` */
export type ScorecardInput = {
  criterias?: InputMaybe<ScorecardCriteriasScorecardIdFkeyInverseInput>;
  evaluationScorecards?: InputMaybe<EvaluationScorecardsScorecardIdFkeyInverseInput>;
  eventScorecards?: InputMaybe<EventScorecardsScorecardIdFkeyInverseInput>;
  pipelineStageScorecards?: InputMaybe<PipelineStageScorecardsScorecardIdFkeyInverseInput>;
  translations?: InputMaybe<ScorecardTranslationsScorecardIdFkeyInverseInput>;
};

/** The globally unique `ID` look up for the row to connect. */
export type ScorecardNodeIdConnect = {
  /** The globally unique `ID` which identifies a single `scorecard` to be connected. */
  nodeId: Scalars['ID']['input'];
};

/** The globally unique `ID` look up for the row to update. */
export type ScorecardOnEvaluationScorecardForEvaluationScorecardsScorecardIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `evaluationScorecard` to be connected. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `evaluationScorecard` being updated. */
  patch: EvaluationScorecardPatch;
};

/** The fields on `scorecard` to look up the row to update. */
export type ScorecardOnEvaluationScorecardForEvaluationScorecardsScorecardIdFkeyUsingScorecardsPkeyUpdate = {
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `scorecard` being updated. */
  patch: UpdateScorecardOnEvaluationScorecardForEvaluationScorecardsScorecardIdFkeyPatch;
};

/** The globally unique `ID` look up for the row to update. */
export type ScorecardOnEventScorecardForEventScorecardsScorecardIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `eventScorecard` to be connected. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `eventScorecard` being updated. */
  patch: EventScorecardPatch;
};

/** The fields on `scorecard` to look up the row to update. */
export type ScorecardOnEventScorecardForEventScorecardsScorecardIdFkeyUsingScorecardsPkeyUpdate = {
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `scorecard` being updated. */
  patch: UpdateScorecardOnEventScorecardForEventScorecardsScorecardIdFkeyPatch;
};

/** The globally unique `ID` look up for the row to update. */
export type ScorecardOnPipelineStageScorecardForPipelineStageScorecardsScorecardIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `pipelineStageScorecard` to be connected. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `pipelineStageScorecard` being updated. */
  patch: PipelineStageScorecardPatch;
};

/** The fields on `scorecard` to look up the row to update. */
export type ScorecardOnPipelineStageScorecardForPipelineStageScorecardsScorecardIdFkeyUsingScorecardsPkeyUpdate = {
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `scorecard` being updated. */
  patch: UpdateScorecardOnPipelineStageScorecardForPipelineStageScorecardsScorecardIdFkeyPatch;
};

/** The globally unique `ID` look up for the row to update. */
export type ScorecardOnScorecardCriteriaForScorecardCriteriasScorecardIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `scorecardCriteria` to be connected. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `scorecardCriteria` being updated. */
  patch: ScorecardCriteriaPatch;
};

/** The fields on `scorecard` to look up the row to update. */
export type ScorecardOnScorecardCriteriaForScorecardCriteriasScorecardIdFkeyUsingScorecardsPkeyUpdate = {
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `scorecard` being updated. */
  patch: UpdateScorecardOnScorecardCriteriaForScorecardCriteriasScorecardIdFkeyPatch;
};

/** The globally unique `ID` look up for the row to update. */
export type ScorecardOnScorecardTranslationForScorecardTranslationsScorecardIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `scorecardTranslation` to be connected. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `scorecardTranslation` being updated. */
  patch: ScorecardTranslationPatch;
};

/** The fields on `scorecard` to look up the row to update. */
export type ScorecardOnScorecardTranslationForScorecardTranslationsScorecardIdFkeyUsingScorecardsPkeyUpdate = {
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `scorecard` being updated. */
  patch: UpdateScorecardOnScorecardTranslationForScorecardTranslationsScorecardIdFkeyPatch;
};

/** Represents an update to a `Scorecard`. Fields that are set will be updated. */
export type ScorecardPatch = {
  criterias?: InputMaybe<ScorecardCriteriasScorecardIdFkeyInverseInput>;
  evaluationScorecards?: InputMaybe<EvaluationScorecardsScorecardIdFkeyInverseInput>;
  eventScorecards?: InputMaybe<EventScorecardsScorecardIdFkeyInverseInput>;
  pipelineStageScorecards?: InputMaybe<PipelineStageScorecardsScorecardIdFkeyInverseInput>;
  translations?: InputMaybe<ScorecardTranslationsScorecardIdFkeyInverseInput>;
};

/** A connection to a list of `PipelineStage` values, with data from `PipelineStageScorecard`. */
export type ScorecardPipelineStagesByPipelineStageScorecardScorecardIdAndPipelineStageIdManyToManyConnection = {
  __typename?: 'ScorecardPipelineStagesByPipelineStageScorecardScorecardIdAndPipelineStageIdManyToManyConnection';
  /** A list of edges which contains the `PipelineStage`, info from the `PipelineStageScorecard`, and the cursor to aid in pagination. */
  edges: Array<ScorecardPipelineStagesByPipelineStageScorecardScorecardIdAndPipelineStageIdManyToManyEdge>;
  /** A list of `PipelineStage` objects. */
  nodes: Array<PipelineStage>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `PipelineStage` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `PipelineStage` edge in the connection, with data from `PipelineStageScorecard`. */
export type ScorecardPipelineStagesByPipelineStageScorecardScorecardIdAndPipelineStageIdManyToManyEdge = {
  __typename?: 'ScorecardPipelineStagesByPipelineStageScorecardScorecardIdAndPipelineStageIdManyToManyEdge';
  createdAt: Scalars['Datetime']['output'];
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `PipelineStage` at the end of the edge. */
  node: PipelineStage;
};

/** The fields on `scorecard` to look up the row to connect. */
export type ScorecardScorecardsPkeyConnect = {
  id: Scalars['Int']['input'];
};

/** A filter to be used against many `EvaluationScorecard` object types. All fields are combined with a logical ‘and.’ */
export type ScorecardToManyEvaluationScorecardFilter = {
  /** Every related `EvaluationScorecard` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<EvaluationScorecardFilter>;
  /** No related `EvaluationScorecard` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<EvaluationScorecardFilter>;
  /** Some related `EvaluationScorecard` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<EvaluationScorecardFilter>;
};

/** A filter to be used against many `EventScorecard` object types. All fields are combined with a logical ‘and.’ */
export type ScorecardToManyEventScorecardFilter = {
  /** Every related `EventScorecard` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<EventScorecardFilter>;
  /** No related `EventScorecard` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<EventScorecardFilter>;
  /** Some related `EventScorecard` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<EventScorecardFilter>;
};

/** A filter to be used against many `PipelineStageScorecard` object types. All fields are combined with a logical ‘and.’ */
export type ScorecardToManyPipelineStageScorecardFilter = {
  /** Every related `PipelineStageScorecard` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<PipelineStageScorecardFilter>;
  /** No related `PipelineStageScorecard` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<PipelineStageScorecardFilter>;
  /** Some related `PipelineStageScorecard` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<PipelineStageScorecardFilter>;
};

/** A filter to be used against many `ScorecardCriteria` object types. All fields are combined with a logical ‘and.’ */
export type ScorecardToManyScorecardCriteriaFilter = {
  /** Every related `ScorecardCriteria` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<ScorecardCriteriaFilter>;
  /** No related `ScorecardCriteria` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<ScorecardCriteriaFilter>;
  /** Some related `ScorecardCriteria` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<ScorecardCriteriaFilter>;
};

/** A filter to be used against many `ScorecardTranslation` object types. All fields are combined with a logical ‘and.’ */
export type ScorecardToManyScorecardTranslationFilter = {
  /** Every related `ScorecardTranslation` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<ScorecardTranslationFilter>;
  /** No related `ScorecardTranslation` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<ScorecardTranslationFilter>;
  /** Some related `ScorecardTranslation` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<ScorecardTranslationFilter>;
};

export type ScorecardTranslation = Node & {
  __typename?: 'ScorecardTranslation';
  lang: Language;
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  /** Reads a single `Scorecard` that is related to this `ScorecardTranslation`. */
  scorecard?: Maybe<Scorecard>;
  scorecardId: Scalars['Int']['output'];
  title: Scalars['String']['output'];
};

/** A condition to be used against `ScorecardTranslation` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type ScorecardTranslationCondition = {
  /** Checks for equality with the object’s `scorecardId` field. */
  scorecardId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `title` field. */
  title?: InputMaybe<Scalars['String']['input']>;
};

/** A filter to be used against `ScorecardTranslation` object types. All fields are combined with a logical ‘and.’ */
export type ScorecardTranslationFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<ScorecardTranslationFilter>>;
  /** Negates the expression. */
  not?: InputMaybe<ScorecardTranslationFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<ScorecardTranslationFilter>>;
  /** Filter by the object’s `scorecard` relation. */
  scorecard?: InputMaybe<ScorecardFilter>;
  /** Filter by the object’s `scorecardId` field. */
  scorecardId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `title` field. */
  title?: InputMaybe<StringFilter>;
};

/** An input for mutations affecting `ScorecardTranslation` */
export type ScorecardTranslationInput = {
  lang: Language;
  scorecard?: InputMaybe<ScorecardTranslationsScorecardIdFkeyInput>;
  scorecardId?: InputMaybe<Scalars['Int']['input']>;
  title: Scalars['String']['input'];
};

/** The globally unique `ID` look up for the row to connect. */
export type ScorecardTranslationNodeIdConnect = {
  /** The globally unique `ID` which identifies a single `scorecardTranslation` to be connected. */
  nodeId: Scalars['ID']['input'];
};

/** The globally unique `ID` look up for the row to delete. */
export type ScorecardTranslationNodeIdDelete = {
  /** The globally unique `ID` which identifies a single `scorecardTranslation` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** The globally unique `ID` look up for the row to update. */
export type ScorecardTranslationOnScorecardTranslationForScorecardTranslationsScorecardIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `scorecard` to be connected. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `scorecard` being updated. */
  patch: ScorecardPatch;
};

/** The fields on `scorecardTranslation` to look up the row to update. */
export type ScorecardTranslationOnScorecardTranslationForScorecardTranslationsScorecardIdFkeyUsingScorecardTranslationsPkeyUpdate = {
  lang: Language;
  /** An object where the defined keys will be set on the `scorecardTranslation` being updated. */
  patch: UpdateScorecardTranslationOnScorecardTranslationForScorecardTranslationsScorecardIdFkeyPatch;
  scorecardId: Scalars['Int']['input'];
};

/** Represents an update to a `ScorecardTranslation`. Fields that are set will be updated. */
export type ScorecardTranslationPatch = {
  scorecard?: InputMaybe<ScorecardTranslationsScorecardIdFkeyInput>;
  scorecardId?: InputMaybe<Scalars['Int']['input']>;
  title?: InputMaybe<Scalars['String']['input']>;
};

/** The fields on `scorecardTranslation` to look up the row to connect. */
export type ScorecardTranslationScorecardTranslationsPkeyConnect = {
  lang: Language;
  scorecardId: Scalars['Int']['input'];
};

/** The fields on `scorecardTranslation` to look up the row to delete. */
export type ScorecardTranslationScorecardTranslationsPkeyDelete = {
  lang: Language;
  scorecardId: Scalars['Int']['input'];
};

/** A connection to a list of `ScorecardTranslation` values. */
export type ScorecardTranslationsConnection = {
  __typename?: 'ScorecardTranslationsConnection';
  /** A list of edges which contains the `ScorecardTranslation` and cursor to aid in pagination. */
  edges: Array<ScorecardTranslationsEdge>;
  /** A list of `ScorecardTranslation` objects. */
  nodes: Array<ScorecardTranslation>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `ScorecardTranslation` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `ScorecardTranslation` edge in the connection. */
export type ScorecardTranslationsEdge = {
  __typename?: 'ScorecardTranslationsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `ScorecardTranslation` at the end of the edge. */
  node: ScorecardTranslation;
};

/** Methods to use when ordering `ScorecardTranslation`. */
export enum ScorecardTranslationsOrderBy {
  Natural = 'NATURAL',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  ScorecardIdAsc = 'SCORECARD_ID_ASC',
  ScorecardIdDesc = 'SCORECARD_ID_DESC',
  TitleAsc = 'TITLE_ASC',
  TitleDesc = 'TITLE_DESC'
}

/** Input for the nested mutation of `scorecard` in the `ScorecardTranslationInput` mutation. */
export type ScorecardTranslationsScorecardIdFkeyInput = {
  /** The primary key(s) for `scorecard` for the far side of the relationship. */
  connectById?: InputMaybe<ScorecardScorecardsPkeyConnect>;
  /** The primary key(s) for `scorecard` for the far side of the relationship. */
  connectByNodeId?: InputMaybe<ScorecardNodeIdConnect>;
  /** A `ScorecardInput` object that will be created and connected to this object. */
  create?: InputMaybe<ScorecardTranslationsScorecardIdFkeyScorecardsCreateInput>;
  /** The primary key(s) and patch data for `scorecard` for the far side of the relationship. */
  updateById?: InputMaybe<ScorecardOnScorecardTranslationForScorecardTranslationsScorecardIdFkeyUsingScorecardsPkeyUpdate>;
  /** The primary key(s) and patch data for `scorecard` for the far side of the relationship. */
  updateByNodeId?: InputMaybe<ScorecardTranslationOnScorecardTranslationForScorecardTranslationsScorecardIdFkeyNodeIdUpdate>;
};

/** Input for the nested mutation of `scorecardTranslation` in the `ScorecardInput` mutation. */
export type ScorecardTranslationsScorecardIdFkeyInverseInput = {
  /** The primary key(s) for `scorecardTranslation` for the far side of the relationship. */
  connectByNodeId?: InputMaybe<Array<ScorecardTranslationNodeIdConnect>>;
  /** The primary key(s) for `scorecardTranslation` for the far side of the relationship. */
  connectByScorecardIdAndLang?: InputMaybe<Array<ScorecardTranslationScorecardTranslationsPkeyConnect>>;
  /** A `ScorecardTranslationInput` object that will be created and connected to this object. */
  create?: InputMaybe<Array<ScorecardTranslationsScorecardIdFkeyScorecardTranslationsCreateInput>>;
  /** The primary key(s) for `scorecardTranslation` for the far side of the relationship. */
  deleteByNodeId?: InputMaybe<Array<ScorecardTranslationNodeIdDelete>>;
  /** The primary key(s) for `scorecardTranslation` for the far side of the relationship. */
  deleteByScorecardIdAndLang?: InputMaybe<Array<ScorecardTranslationScorecardTranslationsPkeyDelete>>;
  /** Flag indicating whether all other `scorecardTranslation` records that match this relationship should be removed. */
  deleteOthers?: InputMaybe<Scalars['Boolean']['input']>;
  /** The primary key(s) and patch data for `scorecardTranslation` for the far side of the relationship. */
  updateByNodeId?: InputMaybe<Array<ScorecardOnScorecardTranslationForScorecardTranslationsScorecardIdFkeyNodeIdUpdate>>;
  /** The primary key(s) and patch data for `scorecardTranslation` for the far side of the relationship. */
  updateByScorecardIdAndLang?: InputMaybe<Array<ScorecardTranslationOnScorecardTranslationForScorecardTranslationsScorecardIdFkeyUsingScorecardTranslationsPkeyUpdate>>;
};

/** The `scorecardTranslation` to be created by this mutation. */
export type ScorecardTranslationsScorecardIdFkeyScorecardTranslationsCreateInput = {
  lang: Language;
  scorecard?: InputMaybe<ScorecardTranslationsScorecardIdFkeyInput>;
  title: Scalars['String']['input'];
};

/** The `scorecard` to be created by this mutation. */
export type ScorecardTranslationsScorecardIdFkeyScorecardsCreateInput = {
  criterias?: InputMaybe<ScorecardCriteriasScorecardIdFkeyInverseInput>;
  evaluationScorecards?: InputMaybe<EvaluationScorecardsScorecardIdFkeyInverseInput>;
  eventScorecards?: InputMaybe<EventScorecardsScorecardIdFkeyInverseInput>;
  pipelineStageScorecards?: InputMaybe<PipelineStageScorecardsScorecardIdFkeyInverseInput>;
  translations?: InputMaybe<ScorecardTranslationsScorecardIdFkeyInverseInput>;
};

/** A connection to a list of `Scorecard` values. */
export type ScorecardsConnection = {
  __typename?: 'ScorecardsConnection';
  /** A list of edges which contains the `Scorecard` and cursor to aid in pagination. */
  edges: Array<ScorecardsEdge>;
  /** A list of `Scorecard` objects. */
  nodes: Array<Scorecard>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Scorecard` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `Scorecard` edge in the connection. */
export type ScorecardsEdge = {
  __typename?: 'ScorecardsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Scorecard` at the end of the edge. */
  node: Scorecard;
};

/** Methods to use when ordering `Scorecard`. */
export enum ScorecardsOrderBy {
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  Natural = 'NATURAL',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC'
}

export type Skill = Node & {
  __typename?: 'Skill';
  createdAt: Scalars['Datetime']['output'];
  id: Scalars['Int']['output'];
  /** Reads and enables pagination through a set of `JobSkill`. */
  jobSkills: JobSkillsConnection;
  /** Reads and enables pagination through a set of `Job`. */
  jobs: SkillJobsByJobSkillSkillIdAndJobIdManyToManyConnection;
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  title: Scalars['String']['output'];
};


export type SkillJobSkillsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<JobSkillCondition>;
  filter?: InputMaybe<JobSkillFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<JobSkillsOrderBy>>;
};


export type SkillJobsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<JobCondition>;
  filter?: InputMaybe<JobFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<JobsOrderBy>>;
};

/** A condition to be used against `Skill` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type SkillCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `title` field. */
  title?: InputMaybe<Scalars['String']['input']>;
};

/** A filter to be used against `Skill` object types. All fields are combined with a logical ‘and.’ */
export type SkillFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<SkillFilter>>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<IntFilter>;
  /** Filter by the object’s `jobSkills` relation. */
  jobSkills?: InputMaybe<SkillToManyJobSkillFilter>;
  /** Some related `jobSkills` exist. */
  jobSkillsExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Negates the expression. */
  not?: InputMaybe<SkillFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<SkillFilter>>;
  /** Filter by the object’s `title` field. */
  title?: InputMaybe<StringFilter>;
};

/** An input for mutations affecting `Skill` */
export type SkillInput = {
  jobSkills?: InputMaybe<JobSkillsSkillIdFkeyInverseInput>;
  title: Scalars['String']['input'];
};

/** A connection to a list of `Job` values, with data from `JobSkill`. */
export type SkillJobsByJobSkillSkillIdAndJobIdManyToManyConnection = {
  __typename?: 'SkillJobsByJobSkillSkillIdAndJobIdManyToManyConnection';
  /** A list of edges which contains the `Job`, info from the `JobSkill`, and the cursor to aid in pagination. */
  edges: Array<SkillJobsByJobSkillSkillIdAndJobIdManyToManyEdge>;
  /** A list of `Job` objects. */
  nodes: Array<Job>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Job` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `Job` edge in the connection, with data from `JobSkill`. */
export type SkillJobsByJobSkillSkillIdAndJobIdManyToManyEdge = {
  __typename?: 'SkillJobsByJobSkillSkillIdAndJobIdManyToManyEdge';
  createdAt: Scalars['Datetime']['output'];
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Job` at the end of the edge. */
  node: Job;
};

/** The globally unique `ID` look up for the row to connect. */
export type SkillNodeIdConnect = {
  /** The globally unique `ID` which identifies a single `skill` to be connected. */
  nodeId: Scalars['ID']['input'];
};

/** The globally unique `ID` look up for the row to update. */
export type SkillOnJobSkillForJobSkillsSkillIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `jobSkill` to be connected. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `jobSkill` being updated. */
  patch: JobSkillPatch;
};

/** The fields on `skill` to look up the row to update. */
export type SkillOnJobSkillForJobSkillsSkillIdFkeyUsingSkillsPkeyUpdate = {
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `skill` being updated. */
  patch: UpdateSkillOnJobSkillForJobSkillsSkillIdFkeyPatch;
};

/** Represents an update to a `Skill`. Fields that are set will be updated. */
export type SkillPatch = {
  jobSkills?: InputMaybe<JobSkillsSkillIdFkeyInverseInput>;
  title?: InputMaybe<Scalars['String']['input']>;
};

/** The fields on `skill` to look up the row to connect. */
export type SkillSkillsPkeyConnect = {
  id: Scalars['Int']['input'];
};

/** A filter to be used against many `JobSkill` object types. All fields are combined with a logical ‘and.’ */
export type SkillToManyJobSkillFilter = {
  /** Every related `JobSkill` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<JobSkillFilter>;
  /** No related `JobSkill` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<JobSkillFilter>;
  /** Some related `JobSkill` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<JobSkillFilter>;
};

/** A connection to a list of `Skill` values. */
export type SkillsConnection = {
  __typename?: 'SkillsConnection';
  /** A list of edges which contains the `Skill` and cursor to aid in pagination. */
  edges: Array<SkillsEdge>;
  /** A list of `Skill` objects. */
  nodes: Array<Skill>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Skill` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `Skill` edge in the connection. */
export type SkillsEdge = {
  __typename?: 'SkillsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Skill` at the end of the edge. */
  node: Skill;
};

/** Methods to use when ordering `Skill`. */
export enum SkillsOrderBy {
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  Natural = 'NATURAL',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  TitleAsc = 'TITLE_ASC',
  TitleDesc = 'TITLE_DESC'
}

/** A filter to be used against String fields. All fields are combined with a logical ‘and.’ */
export type StringFilter = {
  /** Not equal to the specified value, treating null like an ordinary value. */
  distinctFrom?: InputMaybe<Scalars['String']['input']>;
  /** Ends with the specified string (case-sensitive). */
  endsWith?: InputMaybe<Scalars['String']['input']>;
  /** Ends with the specified string (case-insensitive). */
  endsWithInsensitive?: InputMaybe<Scalars['String']['input']>;
  /** Equal to the specified value. */
  equalTo?: InputMaybe<Scalars['String']['input']>;
  /** Greater than the specified value. */
  greaterThan?: InputMaybe<Scalars['String']['input']>;
  /** Greater than or equal to the specified value. */
  greaterThanOrEqualTo?: InputMaybe<Scalars['String']['input']>;
  /** Included in the specified list. */
  in?: InputMaybe<Array<Scalars['String']['input']>>;
  /** Contains the specified string (case-sensitive). */
  includes?: InputMaybe<Scalars['String']['input']>;
  /** Contains the specified string (case-insensitive). */
  includesInsensitive?: InputMaybe<Scalars['String']['input']>;
  /** Is null (if `true` is specified) or is not null (if `false` is specified). */
  isNull?: InputMaybe<Scalars['Boolean']['input']>;
  /** Less than the specified value. */
  lessThan?: InputMaybe<Scalars['String']['input']>;
  /** Less than or equal to the specified value. */
  lessThanOrEqualTo?: InputMaybe<Scalars['String']['input']>;
  /** Matches the specified pattern (case-sensitive). An underscore (_) matches any single character; a percent sign (%) matches any sequence of zero or more characters. */
  like?: InputMaybe<Scalars['String']['input']>;
  /** Matches the specified pattern (case-insensitive). An underscore (_) matches any single character; a percent sign (%) matches any sequence of zero or more characters. */
  likeInsensitive?: InputMaybe<Scalars['String']['input']>;
  /** Equal to the specified value, treating null like an ordinary value. */
  notDistinctFrom?: InputMaybe<Scalars['String']['input']>;
  /** Does not end with the specified string (case-sensitive). */
  notEndsWith?: InputMaybe<Scalars['String']['input']>;
  /** Does not end with the specified string (case-insensitive). */
  notEndsWithInsensitive?: InputMaybe<Scalars['String']['input']>;
  /** Not equal to the specified value. */
  notEqualTo?: InputMaybe<Scalars['String']['input']>;
  /** Not included in the specified list. */
  notIn?: InputMaybe<Array<Scalars['String']['input']>>;
  /** Does not contain the specified string (case-sensitive). */
  notIncludes?: InputMaybe<Scalars['String']['input']>;
  /** Does not contain the specified string (case-insensitive). */
  notIncludesInsensitive?: InputMaybe<Scalars['String']['input']>;
  /** Does not match the specified pattern (case-sensitive). An underscore (_) matches any single character; a percent sign (%) matches any sequence of zero or more characters. */
  notLike?: InputMaybe<Scalars['String']['input']>;
  /** Does not match the specified pattern (case-insensitive). An underscore (_) matches any single character; a percent sign (%) matches any sequence of zero or more characters. */
  notLikeInsensitive?: InputMaybe<Scalars['String']['input']>;
  /** Does not match the specified pattern using the SQL standard's definition of a regular expression. */
  notSimilarTo?: InputMaybe<Scalars['String']['input']>;
  /** Does not start with the specified string (case-sensitive). */
  notStartsWith?: InputMaybe<Scalars['String']['input']>;
  /** Does not start with the specified string (case-insensitive). */
  notStartsWithInsensitive?: InputMaybe<Scalars['String']['input']>;
  /** Matches the specified pattern using the SQL standard's definition of a regular expression. */
  similarTo?: InputMaybe<Scalars['String']['input']>;
  /** Starts with the specified string (case-sensitive). */
  startsWith?: InputMaybe<Scalars['String']['input']>;
  /** Starts with the specified string (case-insensitive). */
  startsWithInsensitive?: InputMaybe<Scalars['String']['input']>;
};

/** A filter to be used against String List fields. All fields are combined with a logical ‘and.’ */
export type StringListFilter = {
  /** Any array item is equal to the specified value. */
  anyEqualTo?: InputMaybe<Scalars['String']['input']>;
  /** Any array item is greater than the specified value. */
  anyGreaterThan?: InputMaybe<Scalars['String']['input']>;
  /** Any array item is greater than or equal to the specified value. */
  anyGreaterThanOrEqualTo?: InputMaybe<Scalars['String']['input']>;
  /** Any array item is less than the specified value. */
  anyLessThan?: InputMaybe<Scalars['String']['input']>;
  /** Any array item is less than or equal to the specified value. */
  anyLessThanOrEqualTo?: InputMaybe<Scalars['String']['input']>;
  /** Any array item is not equal to the specified value. */
  anyNotEqualTo?: InputMaybe<Scalars['String']['input']>;
  /** Contained by the specified list of values. */
  containedBy?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  /** Contains the specified list of values. */
  contains?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  /** Not equal to the specified value, treating null like an ordinary value. */
  distinctFrom?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  /** Equal to the specified value. */
  equalTo?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  /** Greater than the specified value. */
  greaterThan?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  /** Greater than or equal to the specified value. */
  greaterThanOrEqualTo?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  /** Is null (if `true` is specified) or is not null (if `false` is specified). */
  isNull?: InputMaybe<Scalars['Boolean']['input']>;
  /** Less than the specified value. */
  lessThan?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  /** Less than or equal to the specified value. */
  lessThanOrEqualTo?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  /** Equal to the specified value, treating null like an ordinary value. */
  notDistinctFrom?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  /** Not equal to the specified value. */
  notEqualTo?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  /** Overlaps the specified list of values. */
  overlaps?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
};

export type Subscription = Node & {
  __typename?: 'Subscription';
  /** Reads and enables pagination through a set of `Company`. */
  companies: SubscriptionCompaniesByInvoiceSubscriptionIdAndCompanyIdManyToManyConnection;
  description?: Maybe<Scalars['String']['output']>;
  duration?: Maybe<Scalars['Int']['output']>;
  durationType?: Maybe<DurationType>;
  grade?: Maybe<Scalars['Int']['output']>;
  id: Scalars['Int']['output'];
  /** Reads and enables pagination through a set of `Invoice`. */
  invoices: InvoicesConnection;
  maxCandidates?: Maybe<Scalars['Int']['output']>;
  maxJobs?: Maybe<Scalars['Int']['output']>;
  maxUser?: Maybe<Scalars['Int']['output']>;
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  price?: Maybe<Scalars['Int']['output']>;
  title?: Maybe<Scalars['String']['output']>;
};


export type SubscriptionCompaniesArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<CompanyCondition>;
  filter?: InputMaybe<CompanyFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<CompaniesOrderBy>>;
};


export type SubscriptionInvoicesArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<InvoiceCondition>;
  filter?: InputMaybe<InvoiceFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<InvoicesOrderBy>>;
};

/** A connection to a list of `Company` values, with data from `Invoice`. */
export type SubscriptionCompaniesByInvoiceSubscriptionIdAndCompanyIdManyToManyConnection = {
  __typename?: 'SubscriptionCompaniesByInvoiceSubscriptionIdAndCompanyIdManyToManyConnection';
  /** A list of edges which contains the `Company`, info from the `Invoice`, and the cursor to aid in pagination. */
  edges: Array<SubscriptionCompaniesByInvoiceSubscriptionIdAndCompanyIdManyToManyEdge>;
  /** A list of `Company` objects. */
  nodes: Array<Company>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Company` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `Company` edge in the connection, with data from `Invoice`. */
export type SubscriptionCompaniesByInvoiceSubscriptionIdAndCompanyIdManyToManyEdge = {
  __typename?: 'SubscriptionCompaniesByInvoiceSubscriptionIdAndCompanyIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** Reads and enables pagination through a set of `Invoice`. */
  invoices: InvoicesConnection;
  /** The `Company` at the end of the edge. */
  node: Company;
};


/** A `Company` edge in the connection, with data from `Invoice`. */
export type SubscriptionCompaniesByInvoiceSubscriptionIdAndCompanyIdManyToManyEdgeInvoicesArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<InvoiceCondition>;
  filter?: InputMaybe<InvoiceFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<InvoicesOrderBy>>;
};

/** A condition to be used against `Subscription` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type SubscriptionCondition = {
  /** Checks for equality with the object’s `durationType` field. */
  durationType?: InputMaybe<DurationType>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['Int']['input']>;
};

/** A filter to be used against `Subscription` object types. All fields are combined with a logical ‘and.’ */
export type SubscriptionFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<SubscriptionFilter>>;
  /** Filter by the object’s `durationType` field. */
  durationType?: InputMaybe<DurationTypeFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<IntFilter>;
  /** Filter by the object’s `invoices` relation. */
  invoices?: InputMaybe<SubscriptionToManyInvoiceFilter>;
  /** Some related `invoices` exist. */
  invoicesExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Negates the expression. */
  not?: InputMaybe<SubscriptionFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<SubscriptionFilter>>;
};

/** The globally unique `ID` look up for the row to connect. */
export type SubscriptionNodeIdConnect = {
  /** The globally unique `ID` which identifies a single `subscription` to be connected. */
  nodeId: Scalars['ID']['input'];
};

/** The globally unique `ID` look up for the row to update. */
export type SubscriptionOnInvoiceForInvoicesSubscriptionIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `invoice` to be connected. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `invoice` being updated. */
  patch: InvoicePatch;
};

/** The fields on `subscription` to look up the row to update. */
export type SubscriptionOnInvoiceForInvoicesSubscriptionIdFkeyUsingSubscriptionsPkeyUpdate = {
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `subscription` being updated. */
  patch: UpdateSubscriptionOnInvoiceForInvoicesSubscriptionIdFkeyPatch;
};

/** Represents an update to a `Subscription`. Fields that are set will be updated. */
export type SubscriptionPatch = {
  description?: InputMaybe<Scalars['String']['input']>;
  duration?: InputMaybe<Scalars['Int']['input']>;
  durationType?: InputMaybe<DurationType>;
  grade?: InputMaybe<Scalars['Int']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  invoices?: InputMaybe<InvoicesSubscriptionIdFkeyInverseInput>;
  maxCandidates?: InputMaybe<Scalars['Int']['input']>;
  maxJobs?: InputMaybe<Scalars['Int']['input']>;
  maxUser?: InputMaybe<Scalars['Int']['input']>;
  price?: InputMaybe<Scalars['Int']['input']>;
  title?: InputMaybe<Scalars['String']['input']>;
};

/** The fields on `subscription` to look up the row to connect. */
export type SubscriptionSubscriptionsPkeyConnect = {
  id: Scalars['Int']['input'];
};

/** A filter to be used against many `Invoice` object types. All fields are combined with a logical ‘and.’ */
export type SubscriptionToManyInvoiceFilter = {
  /** Every related `Invoice` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<InvoiceFilter>;
  /** No related `Invoice` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<InvoiceFilter>;
  /** Some related `Invoice` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<InvoiceFilter>;
};

/** A connection to a list of `Subscription` values. */
export type SubscriptionsConnection = {
  __typename?: 'SubscriptionsConnection';
  /** A list of edges which contains the `Subscription` and cursor to aid in pagination. */
  edges: Array<SubscriptionsEdge>;
  /** A list of `Subscription` objects. */
  nodes: Array<Subscription>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Subscription` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `Subscription` edge in the connection. */
export type SubscriptionsEdge = {
  __typename?: 'SubscriptionsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Subscription` at the end of the edge. */
  node: Subscription;
};

/** Methods to use when ordering `Subscription`. */
export enum SubscriptionsOrderBy {
  DurationTypeAsc = 'DURATION_TYPE_ASC',
  DurationTypeDesc = 'DURATION_TYPE_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  Natural = 'NATURAL',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC'
}

export type Tag = Node & {
  __typename?: 'Tag';
  /** Reads and enables pagination through a set of `CandidateTag`. */
  candidateTags: CandidateTagsConnection;
  /** Reads and enables pagination through a set of `Candidate`. */
  candidates: TagCandidatesByCandidateTagTagIdAndCandidateIdManyToManyConnection;
  createdAt: Scalars['Datetime']['output'];
  id: Scalars['Int']['output'];
  /** Reads and enables pagination through a set of `JobTag`. */
  jobTags: JobTagsConnection;
  /** Reads and enables pagination through a set of `Job`. */
  jobs: TagJobsByJobTagTagIdAndJobIdManyToManyConnection;
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  title: Scalars['String']['output'];
};


export type TagCandidateTagsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<CandidateTagCondition>;
  filter?: InputMaybe<CandidateTagFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<CandidateTagsOrderBy>>;
};


export type TagCandidatesArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<CandidateCondition>;
  filter?: InputMaybe<CandidateFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<CandidatesOrderBy>>;
};


export type TagJobTagsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<JobTagCondition>;
  filter?: InputMaybe<JobTagFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<JobTagsOrderBy>>;
};


export type TagJobsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<JobCondition>;
  filter?: InputMaybe<JobFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<JobsOrderBy>>;
};

/** A connection to a list of `Candidate` values, with data from `CandidateTag`. */
export type TagCandidatesByCandidateTagTagIdAndCandidateIdManyToManyConnection = {
  __typename?: 'TagCandidatesByCandidateTagTagIdAndCandidateIdManyToManyConnection';
  /** A list of edges which contains the `Candidate`, info from the `CandidateTag`, and the cursor to aid in pagination. */
  edges: Array<TagCandidatesByCandidateTagTagIdAndCandidateIdManyToManyEdge>;
  /** A list of `Candidate` objects. */
  nodes: Array<Candidate>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Candidate` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `Candidate` edge in the connection, with data from `CandidateTag`. */
export type TagCandidatesByCandidateTagTagIdAndCandidateIdManyToManyEdge = {
  __typename?: 'TagCandidatesByCandidateTagTagIdAndCandidateIdManyToManyEdge';
  /** Reads and enables pagination through a set of `CandidateTag`. */
  candidateTags: CandidateTagsConnection;
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Candidate` at the end of the edge. */
  node: Candidate;
};


/** A `Candidate` edge in the connection, with data from `CandidateTag`. */
export type TagCandidatesByCandidateTagTagIdAndCandidateIdManyToManyEdgeCandidateTagsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<CandidateTagCondition>;
  filter?: InputMaybe<CandidateTagFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<CandidateTagsOrderBy>>;
};

/** A condition to be used against `Tag` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type TagCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `title` field. */
  title?: InputMaybe<Scalars['String']['input']>;
};

/** A filter to be used against `Tag` object types. All fields are combined with a logical ‘and.’ */
export type TagFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<TagFilter>>;
  /** Filter by the object’s `candidateTags` relation. */
  candidateTags?: InputMaybe<TagToManyCandidateTagFilter>;
  /** Some related `candidateTags` exist. */
  candidateTagsExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<IntFilter>;
  /** Filter by the object’s `jobTags` relation. */
  jobTags?: InputMaybe<TagToManyJobTagFilter>;
  /** Some related `jobTags` exist. */
  jobTagsExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Negates the expression. */
  not?: InputMaybe<TagFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<TagFilter>>;
  /** Filter by the object’s `title` field. */
  title?: InputMaybe<StringFilter>;
};

/** An input for mutations affecting `Tag` */
export type TagInput = {
  candidateTags?: InputMaybe<CandidateTagsTagIdFkeyInverseInput>;
  jobTags?: InputMaybe<JobTagsTagIdFkeyInverseInput>;
  title: Scalars['String']['input'];
};

/** A connection to a list of `Job` values, with data from `JobTag`. */
export type TagJobsByJobTagTagIdAndJobIdManyToManyConnection = {
  __typename?: 'TagJobsByJobTagTagIdAndJobIdManyToManyConnection';
  /** A list of edges which contains the `Job`, info from the `JobTag`, and the cursor to aid in pagination. */
  edges: Array<TagJobsByJobTagTagIdAndJobIdManyToManyEdge>;
  /** A list of `Job` objects. */
  nodes: Array<Job>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Job` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `Job` edge in the connection, with data from `JobTag`. */
export type TagJobsByJobTagTagIdAndJobIdManyToManyEdge = {
  __typename?: 'TagJobsByJobTagTagIdAndJobIdManyToManyEdge';
  createdAt: Scalars['Datetime']['output'];
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Job` at the end of the edge. */
  node: Job;
};

/** The globally unique `ID` look up for the row to connect. */
export type TagNodeIdConnect = {
  /** The globally unique `ID` which identifies a single `tag` to be connected. */
  nodeId: Scalars['ID']['input'];
};

/** The globally unique `ID` look up for the row to update. */
export type TagOnCandidateTagForCandidateTagsTagIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `candidateTag` to be connected. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `candidateTag` being updated. */
  patch: CandidateTagPatch;
};

/** The fields on `tag` to look up the row to update. */
export type TagOnCandidateTagForCandidateTagsTagIdFkeyUsingTagsPkeyUpdate = {
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `tag` being updated. */
  patch: UpdateTagOnCandidateTagForCandidateTagsTagIdFkeyPatch;
};

/** The globally unique `ID` look up for the row to update. */
export type TagOnJobTagForJobTagsTagIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `jobTag` to be connected. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `jobTag` being updated. */
  patch: JobTagPatch;
};

/** The fields on `tag` to look up the row to update. */
export type TagOnJobTagForJobTagsTagIdFkeyUsingTagsPkeyUpdate = {
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `tag` being updated. */
  patch: UpdateTagOnJobTagForJobTagsTagIdFkeyPatch;
};

/** Represents an update to a `Tag`. Fields that are set will be updated. */
export type TagPatch = {
  candidateTags?: InputMaybe<CandidateTagsTagIdFkeyInverseInput>;
  jobTags?: InputMaybe<JobTagsTagIdFkeyInverseInput>;
  title?: InputMaybe<Scalars['String']['input']>;
};

/** The fields on `tag` to look up the row to connect. */
export type TagTagsPkeyConnect = {
  id: Scalars['Int']['input'];
};

/** A filter to be used against many `CandidateTag` object types. All fields are combined with a logical ‘and.’ */
export type TagToManyCandidateTagFilter = {
  /** Every related `CandidateTag` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<CandidateTagFilter>;
  /** No related `CandidateTag` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<CandidateTagFilter>;
  /** Some related `CandidateTag` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<CandidateTagFilter>;
};

/** A filter to be used against many `JobTag` object types. All fields are combined with a logical ‘and.’ */
export type TagToManyJobTagFilter = {
  /** Every related `JobTag` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<JobTagFilter>;
  /** No related `JobTag` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<JobTagFilter>;
  /** Some related `JobTag` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<JobTagFilter>;
};

/** A connection to a list of `Tag` values. */
export type TagsConnection = {
  __typename?: 'TagsConnection';
  /** A list of edges which contains the `Tag` and cursor to aid in pagination. */
  edges: Array<TagsEdge>;
  /** A list of `Tag` objects. */
  nodes: Array<Tag>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Tag` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `Tag` edge in the connection. */
export type TagsEdge = {
  __typename?: 'TagsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Tag` at the end of the edge. */
  node: Tag;
};

/** Methods to use when ordering `Tag`. */
export enum TagsOrderBy {
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  Natural = 'NATURAL',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  TitleAsc = 'TITLE_ASC',
  TitleDesc = 'TITLE_DESC'
}

export type Thread = Node & {
  __typename?: 'Thread';
  /** Reads a single `Candidate` that is related to this `Thread`. */
  candidate?: Maybe<Candidate>;
  candidateId?: Maybe<Scalars['Int']['output']>;
  createdAt: Scalars['Datetime']['output'];
  emails?: Maybe<Array<Maybe<Scalars['String']['output']>>>;
  id: Scalars['Int']['output'];
  /** Reads a single `Job` that is related to this `Thread`. */
  job?: Maybe<Job>;
  jobId?: Maybe<Scalars['Int']['output']>;
  /** Reads and enables pagination through a set of `Message`. */
  messages: MessagesConnection;
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  phones?: Maybe<Array<Maybe<Scalars['String']['output']>>>;
  senderName?: Maybe<Scalars['String']['output']>;
  subject: Scalars['String']['output'];
  /** Reads and enables pagination through a set of `ThreadUser`. */
  threadUsers: ThreadUsersConnection;
  /** Reads a single `User` that is related to this `Thread`. */
  user?: Maybe<User>;
  userId?: Maybe<Scalars['Int']['output']>;
};


export type ThreadMessagesArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<MessageCondition>;
  filter?: InputMaybe<MessageFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<MessagesOrderBy>>;
};


export type ThreadThreadUsersArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<ThreadUserCondition>;
  filter?: InputMaybe<ThreadUserFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<ThreadUsersOrderBy>>;
};

/** A condition to be used against `Thread` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type ThreadCondition = {
  /** Checks for equality with the object’s `candidateId` field. */
  candidateId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `createdAt` field. */
  createdAt?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `jobId` field. */
  jobId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `subject` field. */
  subject?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `userId` field. */
  userId?: InputMaybe<Scalars['Int']['input']>;
};

/** A filter to be used against `Thread` object types. All fields are combined with a logical ‘and.’ */
export type ThreadFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<ThreadFilter>>;
  /** Filter by the object’s `candidate` relation. */
  candidate?: InputMaybe<CandidateFilter>;
  /** A related `candidate` exists. */
  candidateExists?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `candidateId` field. */
  candidateId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `createdAt` field. */
  createdAt?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<IntFilter>;
  /** Filter by the object’s `job` relation. */
  job?: InputMaybe<JobFilter>;
  /** A related `job` exists. */
  jobExists?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `jobId` field. */
  jobId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `messages` relation. */
  messages?: InputMaybe<ThreadToManyMessageFilter>;
  /** Some related `messages` exist. */
  messagesExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Negates the expression. */
  not?: InputMaybe<ThreadFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<ThreadFilter>>;
  /** Filter by the object’s `subject` field. */
  subject?: InputMaybe<StringFilter>;
  /** Filter by the object’s `threadUsers` relation. */
  threadUsers?: InputMaybe<ThreadToManyThreadUserFilter>;
  /** Some related `threadUsers` exist. */
  threadUsersExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `user` relation. */
  user?: InputMaybe<UserFilter>;
  /** A related `user` exists. */
  userExists?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `userId` field. */
  userId?: InputMaybe<IntFilter>;
};

/** An input for mutations affecting `Thread` */
export type ThreadInput = {
  candidate?: InputMaybe<ThreadsCandidateIdFkeyInput>;
  candidateId?: InputMaybe<Scalars['Int']['input']>;
  emails?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  job?: InputMaybe<ThreadsJobIdFkeyInput>;
  jobId?: InputMaybe<Scalars['Int']['input']>;
  messages?: InputMaybe<MessagesThreadIdFkeyInverseInput>;
  phones?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  senderName?: InputMaybe<Scalars['String']['input']>;
  subject: Scalars['String']['input'];
  threadUsers?: InputMaybe<ThreadUsersThreadIdFkeyInverseInput>;
  user?: InputMaybe<ThreadsUserIdFkeyInput>;
  userId?: InputMaybe<Scalars['Int']['input']>;
};

/** The globally unique `ID` look up for the row to connect. */
export type ThreadNodeIdConnect = {
  /** The globally unique `ID` which identifies a single `thread` to be connected. */
  nodeId: Scalars['ID']['input'];
};

/** The globally unique `ID` look up for the row to update. */
export type ThreadOnMessageForMessagesThreadIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `message` to be connected. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `message` being updated. */
  patch: MessagePatch;
};

/** The fields on `thread` to look up the row to update. */
export type ThreadOnMessageForMessagesThreadIdFkeyUsingThreadsPkeyUpdate = {
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `thread` being updated. */
  patch: UpdateThreadOnMessageForMessagesThreadIdFkeyPatch;
};

/** The globally unique `ID` look up for the row to update. */
export type ThreadOnThreadForThreadsCandidateIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `candidate` to be connected. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `candidate` being updated. */
  patch: CandidatePatch;
};

/** The fields on `thread` to look up the row to update. */
export type ThreadOnThreadForThreadsCandidateIdFkeyUsingThreadsPkeyUpdate = {
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `thread` being updated. */
  patch: UpdateThreadOnThreadForThreadsCandidateIdFkeyPatch;
};

/** The globally unique `ID` look up for the row to update. */
export type ThreadOnThreadForThreadsJobIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `job` to be connected. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `job` being updated. */
  patch: JobPatch;
};

/** The fields on `thread` to look up the row to update. */
export type ThreadOnThreadForThreadsJobIdFkeyUsingThreadsPkeyUpdate = {
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `thread` being updated. */
  patch: UpdateThreadOnThreadForThreadsJobIdFkeyPatch;
};

/** The globally unique `ID` look up for the row to update. */
export type ThreadOnThreadForThreadsUserIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `user` to be connected. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `user` being updated. */
  patch: UserPatch;
};

/** The fields on `thread` to look up the row to update. */
export type ThreadOnThreadForThreadsUserIdFkeyUsingThreadsPkeyUpdate = {
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `thread` being updated. */
  patch: UpdateThreadOnThreadForThreadsUserIdFkeyPatch;
};

/** The globally unique `ID` look up for the row to update. */
export type ThreadOnThreadUserForThreadUsersThreadIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `threadUser` to be connected. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `threadUser` being updated. */
  patch: ThreadUserPatch;
};

/** The fields on `thread` to look up the row to update. */
export type ThreadOnThreadUserForThreadUsersThreadIdFkeyUsingThreadsPkeyUpdate = {
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `thread` being updated. */
  patch: UpdateThreadOnThreadUserForThreadUsersThreadIdFkeyPatch;
};

/** Represents an update to a `Thread`. Fields that are set will be updated. */
export type ThreadPatch = {
  candidate?: InputMaybe<ThreadsCandidateIdFkeyInput>;
  candidateId?: InputMaybe<Scalars['Int']['input']>;
  job?: InputMaybe<ThreadsJobIdFkeyInput>;
  jobId?: InputMaybe<Scalars['Int']['input']>;
  messages?: InputMaybe<MessagesThreadIdFkeyInverseInput>;
  threadUsers?: InputMaybe<ThreadUsersThreadIdFkeyInverseInput>;
  user?: InputMaybe<ThreadsUserIdFkeyInput>;
  userId?: InputMaybe<Scalars['Int']['input']>;
};

/** The fields on `thread` to look up the row to connect. */
export type ThreadThreadsPkeyConnect = {
  id: Scalars['Int']['input'];
};

/** A filter to be used against many `Message` object types. All fields are combined with a logical ‘and.’ */
export type ThreadToManyMessageFilter = {
  /** Every related `Message` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<MessageFilter>;
  /** No related `Message` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<MessageFilter>;
  /** Some related `Message` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<MessageFilter>;
};

/** A filter to be used against many `ThreadUser` object types. All fields are combined with a logical ‘and.’ */
export type ThreadToManyThreadUserFilter = {
  /** Every related `ThreadUser` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<ThreadUserFilter>;
  /** No related `ThreadUser` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<ThreadUserFilter>;
  /** Some related `ThreadUser` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<ThreadUserFilter>;
};

export type ThreadUser = Node & {
  __typename?: 'ThreadUser';
  lastReadAt: Scalars['Datetime']['output'];
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  /** Reads a single `Thread` that is related to this `ThreadUser`. */
  thread?: Maybe<Thread>;
  threadId: Scalars['Int']['output'];
  /** Reads a single `User` that is related to this `ThreadUser`. */
  user?: Maybe<User>;
  userId: Scalars['Int']['output'];
};

/** A condition to be used against `ThreadUser` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type ThreadUserCondition = {
  /** Checks for equality with the object’s `threadId` field. */
  threadId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `userId` field. */
  userId?: InputMaybe<Scalars['Int']['input']>;
};

/** A filter to be used against `ThreadUser` object types. All fields are combined with a logical ‘and.’ */
export type ThreadUserFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<ThreadUserFilter>>;
  /** Negates the expression. */
  not?: InputMaybe<ThreadUserFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<ThreadUserFilter>>;
  /** Filter by the object’s `thread` relation. */
  thread?: InputMaybe<ThreadFilter>;
  /** Filter by the object’s `threadId` field. */
  threadId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `user` relation. */
  user?: InputMaybe<UserFilter>;
  /** Filter by the object’s `userId` field. */
  userId?: InputMaybe<IntFilter>;
};

/** An input for mutations affecting `ThreadUser` */
export type ThreadUserInput = {
  lastReadAt?: InputMaybe<Scalars['Datetime']['input']>;
  thread?: InputMaybe<ThreadUsersThreadIdFkeyInput>;
  threadId?: InputMaybe<Scalars['Int']['input']>;
  user?: InputMaybe<ThreadUsersUserIdFkeyInput>;
  userId?: InputMaybe<Scalars['Int']['input']>;
};

/** The globally unique `ID` look up for the row to connect. */
export type ThreadUserNodeIdConnect = {
  /** The globally unique `ID` which identifies a single `threadUser` to be connected. */
  nodeId: Scalars['ID']['input'];
};

/** The globally unique `ID` look up for the row to update. */
export type ThreadUserOnThreadUserForThreadUsersThreadIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `thread` to be connected. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `thread` being updated. */
  patch: ThreadPatch;
};

/** The fields on `threadUser` to look up the row to update. */
export type ThreadUserOnThreadUserForThreadUsersThreadIdFkeyUsingThreadUsersPkeyUpdate = {
  /** An object where the defined keys will be set on the `threadUser` being updated. */
  patch: UpdateThreadUserOnThreadUserForThreadUsersThreadIdFkeyPatch;
  threadId: Scalars['Int']['input'];
  userId: Scalars['Int']['input'];
};

/** The globally unique `ID` look up for the row to update. */
export type ThreadUserOnThreadUserForThreadUsersUserIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `user` to be connected. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `user` being updated. */
  patch: UserPatch;
};

/** The fields on `threadUser` to look up the row to update. */
export type ThreadUserOnThreadUserForThreadUsersUserIdFkeyUsingThreadUsersPkeyUpdate = {
  /** An object where the defined keys will be set on the `threadUser` being updated. */
  patch: UpdateThreadUserOnThreadUserForThreadUsersUserIdFkeyPatch;
  threadId: Scalars['Int']['input'];
  userId: Scalars['Int']['input'];
};

/** Represents an update to a `ThreadUser`. Fields that are set will be updated. */
export type ThreadUserPatch = {
  lastReadAt?: InputMaybe<Scalars['Datetime']['input']>;
  thread?: InputMaybe<ThreadUsersThreadIdFkeyInput>;
  threadId?: InputMaybe<Scalars['Int']['input']>;
  user?: InputMaybe<ThreadUsersUserIdFkeyInput>;
  userId?: InputMaybe<Scalars['Int']['input']>;
};

/** The fields on `threadUser` to look up the row to connect. */
export type ThreadUserThreadUsersPkeyConnect = {
  threadId: Scalars['Int']['input'];
  userId: Scalars['Int']['input'];
};

/** A connection to a list of `ThreadUser` values. */
export type ThreadUsersConnection = {
  __typename?: 'ThreadUsersConnection';
  /** A list of edges which contains the `ThreadUser` and cursor to aid in pagination. */
  edges: Array<ThreadUsersEdge>;
  /** A list of `ThreadUser` objects. */
  nodes: Array<ThreadUser>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `ThreadUser` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `ThreadUser` edge in the connection. */
export type ThreadUsersEdge = {
  __typename?: 'ThreadUsersEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `ThreadUser` at the end of the edge. */
  node: ThreadUser;
};

/** Methods to use when ordering `ThreadUser`. */
export enum ThreadUsersOrderBy {
  Natural = 'NATURAL',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  ThreadIdAsc = 'THREAD_ID_ASC',
  ThreadIdDesc = 'THREAD_ID_DESC',
  UserIdAsc = 'USER_ID_ASC',
  UserIdDesc = 'USER_ID_DESC'
}

/** Input for the nested mutation of `thread` in the `ThreadUserInput` mutation. */
export type ThreadUsersThreadIdFkeyInput = {
  /** The primary key(s) for `thread` for the far side of the relationship. */
  connectById?: InputMaybe<ThreadThreadsPkeyConnect>;
  /** The primary key(s) for `thread` for the far side of the relationship. */
  connectByNodeId?: InputMaybe<ThreadNodeIdConnect>;
  /** A `ThreadInput` object that will be created and connected to this object. */
  create?: InputMaybe<ThreadUsersThreadIdFkeyThreadsCreateInput>;
  /** The primary key(s) and patch data for `thread` for the far side of the relationship. */
  updateById?: InputMaybe<ThreadOnThreadUserForThreadUsersThreadIdFkeyUsingThreadsPkeyUpdate>;
  /** The primary key(s) and patch data for `thread` for the far side of the relationship. */
  updateByNodeId?: InputMaybe<ThreadUserOnThreadUserForThreadUsersThreadIdFkeyNodeIdUpdate>;
};

/** Input for the nested mutation of `threadUser` in the `ThreadInput` mutation. */
export type ThreadUsersThreadIdFkeyInverseInput = {
  /** The primary key(s) for `threadUser` for the far side of the relationship. */
  connectByNodeId?: InputMaybe<Array<ThreadUserNodeIdConnect>>;
  /** The primary key(s) for `threadUser` for the far side of the relationship. */
  connectByUserIdAndThreadId?: InputMaybe<Array<ThreadUserThreadUsersPkeyConnect>>;
  /** A `ThreadUserInput` object that will be created and connected to this object. */
  create?: InputMaybe<Array<ThreadUsersThreadIdFkeyThreadUsersCreateInput>>;
  /** The primary key(s) and patch data for `threadUser` for the far side of the relationship. */
  updateByNodeId?: InputMaybe<Array<ThreadOnThreadUserForThreadUsersThreadIdFkeyNodeIdUpdate>>;
  /** The primary key(s) and patch data for `threadUser` for the far side of the relationship. */
  updateByUserIdAndThreadId?: InputMaybe<Array<ThreadUserOnThreadUserForThreadUsersThreadIdFkeyUsingThreadUsersPkeyUpdate>>;
};

/** The `threadUser` to be created by this mutation. */
export type ThreadUsersThreadIdFkeyThreadUsersCreateInput = {
  lastReadAt?: InputMaybe<Scalars['Datetime']['input']>;
  thread?: InputMaybe<ThreadUsersThreadIdFkeyInput>;
  user?: InputMaybe<ThreadUsersUserIdFkeyInput>;
  userId?: InputMaybe<Scalars['Int']['input']>;
};

/** The `thread` to be created by this mutation. */
export type ThreadUsersThreadIdFkeyThreadsCreateInput = {
  candidate?: InputMaybe<ThreadsCandidateIdFkeyInput>;
  candidateId?: InputMaybe<Scalars['Int']['input']>;
  emails?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  job?: InputMaybe<ThreadsJobIdFkeyInput>;
  jobId?: InputMaybe<Scalars['Int']['input']>;
  messages?: InputMaybe<MessagesThreadIdFkeyInverseInput>;
  phones?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  senderName?: InputMaybe<Scalars['String']['input']>;
  subject: Scalars['String']['input'];
  threadUsers?: InputMaybe<ThreadUsersThreadIdFkeyInverseInput>;
  user?: InputMaybe<ThreadsUserIdFkeyInput>;
  userId?: InputMaybe<Scalars['Int']['input']>;
};

/** Input for the nested mutation of `user` in the `ThreadUserInput` mutation. */
export type ThreadUsersUserIdFkeyInput = {
  /** The primary key(s) for `user` for the far side of the relationship. */
  connectByEmail?: InputMaybe<UserUsersEmailKeyConnect>;
  /** The primary key(s) for `user` for the far side of the relationship. */
  connectById?: InputMaybe<UserUsersPkeyConnect>;
  /** The primary key(s) for `user` for the far side of the relationship. */
  connectByNodeId?: InputMaybe<UserNodeIdConnect>;
  /** The primary key(s) and patch data for `user` for the far side of the relationship. */
  updateByEmail?: InputMaybe<UserOnThreadUserForThreadUsersUserIdFkeyUsingUsersEmailKeyUpdate>;
  /** The primary key(s) and patch data for `user` for the far side of the relationship. */
  updateById?: InputMaybe<UserOnThreadUserForThreadUsersUserIdFkeyUsingUsersPkeyUpdate>;
  /** The primary key(s) and patch data for `user` for the far side of the relationship. */
  updateByNodeId?: InputMaybe<ThreadUserOnThreadUserForThreadUsersUserIdFkeyNodeIdUpdate>;
};

/** Input for the nested mutation of `threadUser` in the `UserInput` mutation. */
export type ThreadUsersUserIdFkeyInverseInput = {
  /** The primary key(s) for `threadUser` for the far side of the relationship. */
  connectByNodeId?: InputMaybe<Array<ThreadUserNodeIdConnect>>;
  /** The primary key(s) for `threadUser` for the far side of the relationship. */
  connectByUserIdAndThreadId?: InputMaybe<Array<ThreadUserThreadUsersPkeyConnect>>;
  /** A `ThreadUserInput` object that will be created and connected to this object. */
  create?: InputMaybe<Array<ThreadUsersUserIdFkeyThreadUsersCreateInput>>;
  /** The primary key(s) and patch data for `threadUser` for the far side of the relationship. */
  updateByNodeId?: InputMaybe<Array<UserOnThreadUserForThreadUsersUserIdFkeyNodeIdUpdate>>;
  /** The primary key(s) and patch data for `threadUser` for the far side of the relationship. */
  updateByUserIdAndThreadId?: InputMaybe<Array<ThreadUserOnThreadUserForThreadUsersUserIdFkeyUsingThreadUsersPkeyUpdate>>;
};

/** The `threadUser` to be created by this mutation. */
export type ThreadUsersUserIdFkeyThreadUsersCreateInput = {
  lastReadAt?: InputMaybe<Scalars['Datetime']['input']>;
  thread?: InputMaybe<ThreadUsersThreadIdFkeyInput>;
  threadId?: InputMaybe<Scalars['Int']['input']>;
  user?: InputMaybe<ThreadUsersUserIdFkeyInput>;
};

/** The `candidate` to be created by this mutation. */
export type ThreadsCandidateIdFkeyCandidatesCreateInput = {
  birthday?: InputMaybe<Scalars['Date']['input']>;
  candidateDraftEvaluations?: InputMaybe<DraftEvaluationsCandidateIdFkeyInverseInput>;
  candidateEventDraftEvaluations?: InputMaybe<EventDraftEvaluationsCandidateIdFkeyInverseInput>;
  candidateImportCandidate?: InputMaybe<CandidateImportCandidatesCandidateIdFkeyInverseInput>;
  candidateQuestionnaires?: InputMaybe<CandidateQuestionnairesCandidateIdFkeyInverseInput>;
  candidateQuestions?: InputMaybe<CandidateQuestionsCandidateIdFkeyInverseInput>;
  candidateTags?: InputMaybe<CandidateTagsCandidateIdFkeyInverseInput>;
  cvText?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  emails?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  evaluations?: InputMaybe<EvaluationsCandidateIdFkeyInverseInput>;
  eventCandidates?: InputMaybe<EventCandidatesCandidateIdFkeyInverseInput>;
  files?: InputMaybe<CandidateFilesCandidateIdFkeyInverseInput>;
  gender?: InputMaybe<Gender>;
  jobsApplications?: InputMaybe<JobsApplicationsCandidateIdFkeyInverseInput>;
  language: Language;
  links?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  militaryStatus?: InputMaybe<MilitaryStatus>;
  phones?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  photoExternalId?: InputMaybe<Scalars['UUID']['input']>;
  resumeExternalId?: InputMaybe<Scalars['UUID']['input']>;
  socialLinks?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  sources?: InputMaybe<Array<Scalars['String']['input']>>;
  tags?: InputMaybe<Array<Scalars['String']['input']>>;
  threads?: InputMaybe<ThreadsCandidateIdFkeyInverseInput>;
  translations?: InputMaybe<CandidateTranslationsCandidateIdFkeyInverseInput>;
};

/** Input for the nested mutation of `candidate` in the `ThreadInput` mutation. */
export type ThreadsCandidateIdFkeyInput = {
  /** The primary key(s) for `candidate` for the far side of the relationship. */
  connectById?: InputMaybe<CandidateCandidatesPkeyConnect>;
  /** The primary key(s) for `candidate` for the far side of the relationship. */
  connectByNodeId?: InputMaybe<CandidateNodeIdConnect>;
  /** A `CandidateInput` object that will be created and connected to this object. */
  create?: InputMaybe<ThreadsCandidateIdFkeyCandidatesCreateInput>;
  /** The primary key(s) and patch data for `candidate` for the far side of the relationship. */
  updateById?: InputMaybe<CandidateOnThreadForThreadsCandidateIdFkeyUsingCandidatesPkeyUpdate>;
  /** The primary key(s) and patch data for `candidate` for the far side of the relationship. */
  updateByNodeId?: InputMaybe<ThreadOnThreadForThreadsCandidateIdFkeyNodeIdUpdate>;
};

/** Input for the nested mutation of `thread` in the `CandidateInput` mutation. */
export type ThreadsCandidateIdFkeyInverseInput = {
  /** The primary key(s) for `thread` for the far side of the relationship. */
  connectById?: InputMaybe<Array<ThreadThreadsPkeyConnect>>;
  /** The primary key(s) for `thread` for the far side of the relationship. */
  connectByNodeId?: InputMaybe<Array<ThreadNodeIdConnect>>;
  /** A `ThreadInput` object that will be created and connected to this object. */
  create?: InputMaybe<Array<ThreadsCandidateIdFkeyThreadsCreateInput>>;
  /** The primary key(s) and patch data for `thread` for the far side of the relationship. */
  updateById?: InputMaybe<Array<ThreadOnThreadForThreadsCandidateIdFkeyUsingThreadsPkeyUpdate>>;
  /** The primary key(s) and patch data for `thread` for the far side of the relationship. */
  updateByNodeId?: InputMaybe<Array<CandidateOnThreadForThreadsCandidateIdFkeyNodeIdUpdate>>;
};

/** The `thread` to be created by this mutation. */
export type ThreadsCandidateIdFkeyThreadsCreateInput = {
  candidate?: InputMaybe<ThreadsCandidateIdFkeyInput>;
  emails?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  job?: InputMaybe<ThreadsJobIdFkeyInput>;
  jobId?: InputMaybe<Scalars['Int']['input']>;
  messages?: InputMaybe<MessagesThreadIdFkeyInverseInput>;
  phones?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  senderName?: InputMaybe<Scalars['String']['input']>;
  subject: Scalars['String']['input'];
  threadUsers?: InputMaybe<ThreadUsersThreadIdFkeyInverseInput>;
  user?: InputMaybe<ThreadsUserIdFkeyInput>;
  userId?: InputMaybe<Scalars['Int']['input']>;
};

/** A connection to a list of `Thread` values. */
export type ThreadsConnection = {
  __typename?: 'ThreadsConnection';
  /** A list of edges which contains the `Thread` and cursor to aid in pagination. */
  edges: Array<ThreadsEdge>;
  /** A list of `Thread` objects. */
  nodes: Array<Thread>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Thread` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `Thread` edge in the connection. */
export type ThreadsEdge = {
  __typename?: 'ThreadsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Thread` at the end of the edge. */
  node: Thread;
};

/** Input for the nested mutation of `job` in the `ThreadInput` mutation. */
export type ThreadsJobIdFkeyInput = {
  /** The primary key(s) for `job` for the far side of the relationship. */
  connectById?: InputMaybe<JobJobsPkeyConnect>;
  /** The primary key(s) for `job` for the far side of the relationship. */
  connectByNodeId?: InputMaybe<JobNodeIdConnect>;
  /** A `JobInput` object that will be created and connected to this object. */
  create?: InputMaybe<ThreadsJobIdFkeyJobsCreateInput>;
  /** The primary key(s) and patch data for `job` for the far side of the relationship. */
  updateById?: InputMaybe<JobOnThreadForThreadsJobIdFkeyUsingJobsPkeyUpdate>;
  /** The primary key(s) and patch data for `job` for the far side of the relationship. */
  updateByNodeId?: InputMaybe<ThreadOnThreadForThreadsJobIdFkeyNodeIdUpdate>;
};

/** Input for the nested mutation of `thread` in the `JobInput` mutation. */
export type ThreadsJobIdFkeyInverseInput = {
  /** The primary key(s) for `thread` for the far side of the relationship. */
  connectById?: InputMaybe<Array<ThreadThreadsPkeyConnect>>;
  /** The primary key(s) for `thread` for the far side of the relationship. */
  connectByNodeId?: InputMaybe<Array<ThreadNodeIdConnect>>;
  /** A `ThreadInput` object that will be created and connected to this object. */
  create?: InputMaybe<Array<ThreadsJobIdFkeyThreadsCreateInput>>;
  /** The primary key(s) and patch data for `thread` for the far side of the relationship. */
  updateById?: InputMaybe<Array<ThreadOnThreadForThreadsJobIdFkeyUsingThreadsPkeyUpdate>>;
  /** The primary key(s) and patch data for `thread` for the far side of the relationship. */
  updateByNodeId?: InputMaybe<Array<JobOnThreadForThreadsJobIdFkeyNodeIdUpdate>>;
};

/** The `job` to be created by this mutation. */
export type ThreadsJobIdFkeyJobsCreateInput = {
  address?: InputMaybe<Scalars['String']['input']>;
  applications?: InputMaybe<JobsApplicationsJobIdFkeyInverseInput>;
  city?: InputMaybe<Scalars['String']['input']>;
  competencies?: InputMaybe<Array<Scalars['String']['input']>>;
  country?: InputMaybe<Scalars['Int']['input']>;
  department?: InputMaybe<JobsDepartmentIdFkeyInput>;
  departmentId?: InputMaybe<Scalars['Int']['input']>;
  draftEvaluations?: InputMaybe<DraftEvaluationsJobIdFkeyInverseInput>;
  education?: InputMaybe<JobEducation>;
  evaluations?: InputMaybe<EvaluationsJobIdFkeyInverseInput>;
  fields?: InputMaybe<JobFieldsJobIdFkeyInverseInput>;
  genders?: InputMaybe<Array<InputMaybe<Gender>>>;
  gradeConditions?: InputMaybe<Array<InputMaybe<GradeCondition>>>;
  hoursPerWeek?: InputMaybe<IntRangeInput>;
  isRemote?: InputMaybe<Scalars['Boolean']['input']>;
  jobCompetencies?: InputMaybe<JobCompetenciesJobIdFkeyInverseInput>;
  jobKnowledges?: InputMaybe<JobKnowledgesJobIdFkeyInverseInput>;
  jobQuestionnaires?: InputMaybe<JobQuestionnairesJobIdFkeyInverseInput>;
  jobSkills?: InputMaybe<JobSkillsJobIdFkeyInverseInput>;
  jobTags?: InputMaybe<JobTagsJobIdFkeyInverseInput>;
  knowledges?: InputMaybe<Array<Scalars['String']['input']>>;
  languages: Array<InputMaybe<Language>>;
  maxAgeCondition?: InputMaybe<Scalars['Int']['input']>;
  militaryStatus?: InputMaybe<Array<InputMaybe<MilitaryStatus>>>;
  minAgeCondition?: InputMaybe<Scalars['Int']['input']>;
  owners?: InputMaybe<JobOwnersJobIdFkeyInverseInput>;
  pipeline?: InputMaybe<JobsPipelineIdFkeyInput>;
  pipelineId?: InputMaybe<Scalars['Int']['input']>;
  position: Scalars['Int']['input'];
  publishedAt?: InputMaybe<Scalars['Datetime']['input']>;
  skills?: InputMaybe<Array<Scalars['String']['input']>>;
  state?: InputMaybe<Scalars['Int']['input']>;
  status: JobStatus;
  tags?: InputMaybe<Array<Scalars['String']['input']>>;
  threads?: InputMaybe<ThreadsJobIdFkeyInverseInput>;
  translations?: InputMaybe<JobTranslationsJobIdFkeyInverseInput>;
  workExperienceCondition?: InputMaybe<Scalars['Int']['input']>;
};

/** The `thread` to be created by this mutation. */
export type ThreadsJobIdFkeyThreadsCreateInput = {
  candidate?: InputMaybe<ThreadsCandidateIdFkeyInput>;
  candidateId?: InputMaybe<Scalars['Int']['input']>;
  emails?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  job?: InputMaybe<ThreadsJobIdFkeyInput>;
  messages?: InputMaybe<MessagesThreadIdFkeyInverseInput>;
  phones?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  senderName?: InputMaybe<Scalars['String']['input']>;
  subject: Scalars['String']['input'];
  threadUsers?: InputMaybe<ThreadUsersThreadIdFkeyInverseInput>;
  user?: InputMaybe<ThreadsUserIdFkeyInput>;
  userId?: InputMaybe<Scalars['Int']['input']>;
};

/** Methods to use when ordering `Thread`. */
export enum ThreadsOrderBy {
  CandidateIdAsc = 'CANDIDATE_ID_ASC',
  CandidateIdDesc = 'CANDIDATE_ID_DESC',
  CreatedAtAsc = 'CREATED_AT_ASC',
  CreatedAtDesc = 'CREATED_AT_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  JobIdAsc = 'JOB_ID_ASC',
  JobIdDesc = 'JOB_ID_DESC',
  Natural = 'NATURAL',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  SubjectAsc = 'SUBJECT_ASC',
  SubjectDesc = 'SUBJECT_DESC',
  UserIdAsc = 'USER_ID_ASC',
  UserIdDesc = 'USER_ID_DESC'
}

/** Input for the nested mutation of `user` in the `ThreadInput` mutation. */
export type ThreadsUserIdFkeyInput = {
  /** The primary key(s) for `user` for the far side of the relationship. */
  connectByEmail?: InputMaybe<UserUsersEmailKeyConnect>;
  /** The primary key(s) for `user` for the far side of the relationship. */
  connectById?: InputMaybe<UserUsersPkeyConnect>;
  /** The primary key(s) for `user` for the far side of the relationship. */
  connectByNodeId?: InputMaybe<UserNodeIdConnect>;
  /** The primary key(s) and patch data for `user` for the far side of the relationship. */
  updateByEmail?: InputMaybe<UserOnThreadForThreadsUserIdFkeyUsingUsersEmailKeyUpdate>;
  /** The primary key(s) and patch data for `user` for the far side of the relationship. */
  updateById?: InputMaybe<UserOnThreadForThreadsUserIdFkeyUsingUsersPkeyUpdate>;
  /** The primary key(s) and patch data for `user` for the far side of the relationship. */
  updateByNodeId?: InputMaybe<ThreadOnThreadForThreadsUserIdFkeyNodeIdUpdate>;
};

/** Input for the nested mutation of `thread` in the `UserInput` mutation. */
export type ThreadsUserIdFkeyInverseInput = {
  /** The primary key(s) for `thread` for the far side of the relationship. */
  connectById?: InputMaybe<Array<ThreadThreadsPkeyConnect>>;
  /** The primary key(s) for `thread` for the far side of the relationship. */
  connectByNodeId?: InputMaybe<Array<ThreadNodeIdConnect>>;
  /** The primary key(s) and patch data for `thread` for the far side of the relationship. */
  updateById?: InputMaybe<Array<ThreadOnThreadForThreadsUserIdFkeyUsingThreadsPkeyUpdate>>;
  /** The primary key(s) and patch data for `thread` for the far side of the relationship. */
  updateByNodeId?: InputMaybe<Array<UserOnThreadForThreadsUserIdFkeyNodeIdUpdate>>;
};

export type TimeToHireByJobReport = {
  __typename?: 'TimeToHireByJobReport';
  avgSeconds: Scalars['Int']['output'];
  hiredCount: Scalars['Int']['output'];
  jobId: Scalars['Int']['output'];
  maxSeconds: Scalars['Int']['output'];
  minSeconds: Scalars['Int']['output'];
};

export type TotalDisqualifiedCandidates = {
  __typename?: 'TotalDisqualifiedCandidates';
  count: Scalars['Int']['output'];
};

export type TotalHiredCandidates = {
  __typename?: 'TotalHiredCandidates';
  count: Scalars['Int']['output'];
};

/** A filter to be used against UUID fields. All fields are combined with a logical ‘and.’ */
export type UuidFilter = {
  /** Not equal to the specified value, treating null like an ordinary value. */
  distinctFrom?: InputMaybe<Scalars['UUID']['input']>;
  /** Equal to the specified value. */
  equalTo?: InputMaybe<Scalars['UUID']['input']>;
  /** Greater than the specified value. */
  greaterThan?: InputMaybe<Scalars['UUID']['input']>;
  /** Greater than or equal to the specified value. */
  greaterThanOrEqualTo?: InputMaybe<Scalars['UUID']['input']>;
  /** Included in the specified list. */
  in?: InputMaybe<Array<Scalars['UUID']['input']>>;
  /** Is null (if `true` is specified) or is not null (if `false` is specified). */
  isNull?: InputMaybe<Scalars['Boolean']['input']>;
  /** Less than the specified value. */
  lessThan?: InputMaybe<Scalars['UUID']['input']>;
  /** Less than or equal to the specified value. */
  lessThanOrEqualTo?: InputMaybe<Scalars['UUID']['input']>;
  /** Equal to the specified value, treating null like an ordinary value. */
  notDistinctFrom?: InputMaybe<Scalars['UUID']['input']>;
  /** Not equal to the specified value. */
  notEqualTo?: InputMaybe<Scalars['UUID']['input']>;
  /** Not included in the specified list. */
  notIn?: InputMaybe<Array<Scalars['UUID']['input']>>;
};

/** All input for the `updateCandidateByNodeId` mutation. */
export type UpdateCandidateByNodeIdInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `Candidate` to be updated. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `Candidate` being updated. */
  patch: CandidatePatch;
};

/** All input for the `updateCandidate` mutation. */
export type UpdateCandidateInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `Candidate` being updated. */
  patch: CandidatePatch;
};

/** The output of our update `Candidate` mutation. */
export type UpdateCandidatePayload = {
  __typename?: 'UpdateCandidatePayload';
  /** The `Candidate` that was updated by this mutation. */
  candidate?: Maybe<Candidate>;
  /** An edge for our `Candidate`. May be used by Relay 1. */
  candidateEdge?: Maybe<CandidatesEdge>;
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our update `Candidate` mutation. */
export type UpdateCandidatePayloadCandidateEdgeArgs = {
  orderBy?: InputMaybe<Array<CandidatesOrderBy>>;
};

/** All input for the `updateCandidateTranslationByNodeId` mutation. */
export type UpdateCandidateTranslationByNodeIdInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `CandidateTranslation` to be updated. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `CandidateTranslation` being updated. */
  patch: CandidateTranslationPatch;
};

/** All input for the `updateCandidateTranslation` mutation. */
export type UpdateCandidateTranslationInput = {
  candidateId: Scalars['Int']['input'];
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  lang: Language;
  /** An object where the defined keys will be set on the `CandidateTranslation` being updated. */
  patch: CandidateTranslationPatch;
};

/** The output of our update `CandidateTranslation` mutation. */
export type UpdateCandidateTranslationPayload = {
  __typename?: 'UpdateCandidateTranslationPayload';
  /** Reads a single `Candidate` that is related to this `CandidateTranslation`. */
  candidate?: Maybe<Candidate>;
  /** The `CandidateTranslation` that was updated by this mutation. */
  candidateTranslation?: Maybe<CandidateTranslation>;
  /** An edge for our `CandidateTranslation`. May be used by Relay 1. */
  candidateTranslationEdge?: Maybe<CandidateTranslationsEdge>;
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our update `CandidateTranslation` mutation. */
export type UpdateCandidateTranslationPayloadCandidateTranslationEdgeArgs = {
  orderBy?: InputMaybe<Array<CandidateTranslationsOrderBy>>;
};

/** All input for the `updateCompany` mutation. */
export type UpdateCompanyInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
  patch: CompanyPatchRecordInput;
};

/** The output of our `updateCompany` mutation. */
export type UpdateCompanyPayload = {
  __typename?: 'UpdateCompanyPayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  company?: Maybe<Company>;
  /** An edge for our `Company`. May be used by Relay 1. */
  companyEdge?: Maybe<CompaniesEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our `updateCompany` mutation. */
export type UpdateCompanyPayloadCompanyEdgeArgs = {
  orderBy?: InputMaybe<Array<CompaniesOrderBy>>;
};

/** All input for the `updateCompanyUserByNodeId` mutation. */
export type UpdateCompanyUserByNodeIdInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `CompanyUser` to be updated. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `CompanyUser` being updated. */
  patch: CompanyUserPatch;
};

/** The output of our update `CompanyUser` mutation. */
export type UpdateCompanyUserPayload = {
  __typename?: 'UpdateCompanyUserPayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The `CompanyUser` that was updated by this mutation. */
  companyUser?: Maybe<CompanyUser>;
  /** An edge for our `CompanyUser`. May be used by Relay 1. */
  companyUserEdge?: Maybe<CompanyUsersEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `Role` that is related to this `CompanyUser`. */
  role?: Maybe<Role>;
  /** Reads a single `User` that is related to this `CompanyUser`. */
  user?: Maybe<User>;
};


/** The output of our update `CompanyUser` mutation. */
export type UpdateCompanyUserPayloadCompanyUserEdgeArgs = {
  orderBy?: InputMaybe<Array<CompanyUsersOrderBy>>;
};

export type UpdateDepartmentInput__ = {
  departmentId: Scalars['Int']['input'];
  patch: DepartmentPatch__;
};

export type UpdateDepartmentPayload__ = {
  __typename?: 'UpdateDepartmentPayload__';
  department?: Maybe<Department>;
  query?: Maybe<Query>;
};

/** All input for the `updateDepartmentTranslationByNodeId` mutation. */
export type UpdateDepartmentTranslationByNodeIdInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `DepartmentTranslation` to be updated. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `DepartmentTranslation` being updated. */
  patch: DepartmentTranslationPatch;
};

/** All input for the `updateDepartmentTranslation` mutation. */
export type UpdateDepartmentTranslationInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  departmentId: Scalars['Int']['input'];
  lang: Language;
  /** An object where the defined keys will be set on the `DepartmentTranslation` being updated. */
  patch: DepartmentTranslationPatch;
};

/** The output of our update `DepartmentTranslation` mutation. */
export type UpdateDepartmentTranslationPayload = {
  __typename?: 'UpdateDepartmentTranslationPayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Reads a single `Department` that is related to this `DepartmentTranslation`. */
  department?: Maybe<Department>;
  /** The `DepartmentTranslation` that was updated by this mutation. */
  departmentTranslation?: Maybe<DepartmentTranslation>;
  /** An edge for our `DepartmentTranslation`. May be used by Relay 1. */
  departmentTranslationEdge?: Maybe<DepartmentTranslationsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our update `DepartmentTranslation` mutation. */
export type UpdateDepartmentTranslationPayloadDepartmentTranslationEdgeArgs = {
  orderBy?: InputMaybe<Array<DepartmentTranslationsOrderBy>>;
};

/** All input for the `updateDisqualifyReasonByNodeId` mutation. */
export type UpdateDisqualifyReasonByNodeIdInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `DisqualifyReason` to be updated. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `DisqualifyReason` being updated. */
  patch: DisqualifyReasonPatch;
};

/** All input for the `updateDisqualifyReason` mutation. */
export type UpdateDisqualifyReasonInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `DisqualifyReason` being updated. */
  patch: DisqualifyReasonPatch;
};

/** The output of our update `DisqualifyReason` mutation. */
export type UpdateDisqualifyReasonPayload = {
  __typename?: 'UpdateDisqualifyReasonPayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The `DisqualifyReason` that was updated by this mutation. */
  disqualifyReason?: Maybe<DisqualifyReason>;
  /** An edge for our `DisqualifyReason`. May be used by Relay 1. */
  disqualifyReasonEdge?: Maybe<DisqualifyReasonsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our update `DisqualifyReason` mutation. */
export type UpdateDisqualifyReasonPayloadDisqualifyReasonEdgeArgs = {
  orderBy?: InputMaybe<Array<DisqualifyReasonsOrderBy>>;
};

/** All input for the `updateDisqualifyReasonTranslationByNodeId` mutation. */
export type UpdateDisqualifyReasonTranslationByNodeIdInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `DisqualifyReasonTranslation` to be updated. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `DisqualifyReasonTranslation` being updated. */
  patch: DisqualifyReasonTranslationPatch;
};

/** All input for the `updateDisqualifyReasonTranslation` mutation. */
export type UpdateDisqualifyReasonTranslationInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  disqualifyReasonId: Scalars['Int']['input'];
  lang: Language;
  /** An object where the defined keys will be set on the `DisqualifyReasonTranslation` being updated. */
  patch: DisqualifyReasonTranslationPatch;
};

/** The output of our update `DisqualifyReasonTranslation` mutation. */
export type UpdateDisqualifyReasonTranslationPayload = {
  __typename?: 'UpdateDisqualifyReasonTranslationPayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Reads a single `DisqualifyReason` that is related to this `DisqualifyReasonTranslation`. */
  disqualifyReason?: Maybe<DisqualifyReason>;
  /** The `DisqualifyReasonTranslation` that was updated by this mutation. */
  disqualifyReasonTranslation?: Maybe<DisqualifyReasonTranslation>;
  /** An edge for our `DisqualifyReasonTranslation`. May be used by Relay 1. */
  disqualifyReasonTranslationEdge?: Maybe<DisqualifyReasonTranslationsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our update `DisqualifyReasonTranslation` mutation. */
export type UpdateDisqualifyReasonTranslationPayloadDisqualifyReasonTranslationEdgeArgs = {
  orderBy?: InputMaybe<Array<DisqualifyReasonTranslationsOrderBy>>;
};

/** All input for the `updateEventByNodeId` mutation. */
export type UpdateEventByNodeIdInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `Event` to be updated. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `Event` being updated. */
  patch: EventPatch;
};

/** All input for the `updateEventCandidateByNodeId` mutation. */
export type UpdateEventCandidateByNodeIdInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `EventCandidate` to be updated. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `EventCandidate` being updated. */
  patch: EventCandidatePatch;
};

/** The output of our update `EventCandidate` mutation. */
export type UpdateEventCandidatePayload = {
  __typename?: 'UpdateEventCandidatePayload';
  /** Reads a single `Candidate` that is related to this `EventCandidate`. */
  candidate?: Maybe<Candidate>;
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Reads a single `Event` that is related to this `EventCandidate`. */
  event?: Maybe<Event>;
  /** The `EventCandidate` that was updated by this mutation. */
  eventCandidate?: Maybe<EventCandidate>;
  /** An edge for our `EventCandidate`. May be used by Relay 1. */
  eventCandidateEdge?: Maybe<EventCandidatesEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our update `EventCandidate` mutation. */
export type UpdateEventCandidatePayloadEventCandidateEdgeArgs = {
  orderBy?: InputMaybe<Array<EventCandidatesOrderBy>>;
};

/** All input for the `updateEvent` mutation. */
export type UpdateEventInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `Event` being updated. */
  patch: EventPatch;
};

/** The output of our update `Event` mutation. */
export type UpdateEventPayload = {
  __typename?: 'UpdateEventPayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The `Event` that was updated by this mutation. */
  event?: Maybe<Event>;
  /** An edge for our `Event`. May be used by Relay 1. */
  eventEdge?: Maybe<EventsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our update `Event` mutation. */
export type UpdateEventPayloadEventEdgeArgs = {
  orderBy?: InputMaybe<Array<EventsOrderBy>>;
};

/** All input for the `updateFieldByNodeId` mutation. */
export type UpdateFieldByNodeIdInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `Field` to be updated. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `Field` being updated. */
  patch: FieldPatch;
};

/** All input for the `updateField` mutation. */
export type UpdateFieldInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `Field` being updated. */
  patch: FieldPatch;
};

/** The output of our update `Field` mutation. */
export type UpdateFieldPayload = {
  __typename?: 'UpdateFieldPayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The `Field` that was updated by this mutation. */
  field?: Maybe<Field>;
  /** An edge for our `Field`. May be used by Relay 1. */
  fieldEdge?: Maybe<FieldsEdge>;
  /** Reads a single `Job` that is related to this `Field`. */
  job?: Maybe<Job>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our update `Field` mutation. */
export type UpdateFieldPayloadFieldEdgeArgs = {
  orderBy?: InputMaybe<Array<FieldsOrderBy>>;
};

/** All input for the `updateInvoiceByNodeId` mutation. */
export type UpdateInvoiceByNodeIdInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `Invoice` to be updated. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `Invoice` being updated. */
  patch: InvoicePatch;
};

/** All input for the `updateInvoice` mutation. */
export type UpdateInvoiceInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `Invoice` being updated. */
  patch: InvoicePatch;
};

/** The output of our update `Invoice` mutation. */
export type UpdateInvoicePayload = {
  __typename?: 'UpdateInvoicePayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Reads a single `Company` that is related to this `Invoice`. */
  company?: Maybe<Company>;
  /** The `Invoice` that was updated by this mutation. */
  invoice?: Maybe<Invoice>;
  /** An edge for our `Invoice`. May be used by Relay 1. */
  invoiceEdge?: Maybe<InvoicesEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `Subscription` that is related to this `Invoice`. */
  subscription?: Maybe<Subscription>;
};


/** The output of our update `Invoice` mutation. */
export type UpdateInvoicePayloadInvoiceEdgeArgs = {
  orderBy?: InputMaybe<Array<InvoicesOrderBy>>;
};

/** All input for the `updateJobByNodeId` mutation. */
export type UpdateJobByNodeIdInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `Job` to be updated. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `Job` being updated. */
  patch: JobPatch;
};

/** All input for the `updateJob` mutation. */
export type UpdateJobInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `Job` being updated. */
  patch: JobPatch;
};

export type UpdateJobInput__ = {
  id: Scalars['Int']['input'];
  patch: JobPatch__;
};

/** The output of our update `Job` mutation. */
export type UpdateJobPayload = {
  __typename?: 'UpdateJobPayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Reads a single `Department` that is related to this `Job`. */
  department?: Maybe<Department>;
  /** The `Job` that was updated by this mutation. */
  job?: Maybe<Job>;
  /** An edge for our `Job`. May be used by Relay 1. */
  jobEdge?: Maybe<JobsEdge>;
  /** Reads a single `Pipeline` that is related to this `Job`. */
  pipeline?: Maybe<Pipeline>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our update `Job` mutation. */
export type UpdateJobPayloadJobEdgeArgs = {
  orderBy?: InputMaybe<Array<JobsOrderBy>>;
};

export type UpdateJobPayload__ = {
  __typename?: 'UpdateJobPayload__';
  job?: Maybe<Job>;
  query?: Maybe<Query>;
};

/** All input for the `updateJobTranslationByNodeId` mutation. */
export type UpdateJobTranslationByNodeIdInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `JobTranslation` to be updated. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `JobTranslation` being updated. */
  patch: JobTranslationPatch;
};

/** All input for the `updateJobTranslation` mutation. */
export type UpdateJobTranslationInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  jobId: Scalars['Int']['input'];
  lang: Language;
  /** An object where the defined keys will be set on the `JobTranslation` being updated. */
  patch: JobTranslationPatch;
};

/** The output of our update `JobTranslation` mutation. */
export type UpdateJobTranslationPayload = {
  __typename?: 'UpdateJobTranslationPayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Reads a single `Job` that is related to this `JobTranslation`. */
  job?: Maybe<Job>;
  /** The `JobTranslation` that was updated by this mutation. */
  jobTranslation?: Maybe<JobTranslation>;
  /** An edge for our `JobTranslation`. May be used by Relay 1. */
  jobTranslationEdge?: Maybe<JobTranslationsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our update `JobTranslation` mutation. */
export type UpdateJobTranslationPayloadJobTranslationEdgeArgs = {
  orderBy?: InputMaybe<Array<JobTranslationsOrderBy>>;
};

/** All input for the `updateJobsApplicationByCandidateIdAndJobId` mutation. */
export type UpdateJobsApplicationByCandidateIdAndJobIdInput = {
  candidateId: Scalars['Int']['input'];
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  jobId: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `JobsApplication` being updated. */
  patch: JobsApplicationPatch;
};

/** All input for the `updateJobsApplicationByNodeId` mutation. */
export type UpdateJobsApplicationByNodeIdInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `JobsApplication` to be updated. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `JobsApplication` being updated. */
  patch: JobsApplicationPatch;
};

/** All input for the `updateJobsApplication` mutation. */
export type UpdateJobsApplicationInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `JobsApplication` being updated. */
  patch: JobsApplicationPatch;
};

/** The output of our update `JobsApplication` mutation. */
export type UpdateJobsApplicationPayload = {
  __typename?: 'UpdateJobsApplicationPayload';
  /** Reads a single `Candidate` that is related to this `JobsApplication`. */
  candidate?: Maybe<Candidate>;
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Reads a single `DisqualifyReason` that is related to this `JobsApplication`. */
  disqualifyReason?: Maybe<DisqualifyReason>;
  /** Reads a single `Job` that is related to this `JobsApplication`. */
  job?: Maybe<Job>;
  /** The `JobsApplication` that was updated by this mutation. */
  jobsApplication?: Maybe<JobsApplication>;
  /** An edge for our `JobsApplication`. May be used by Relay 1. */
  jobsApplicationEdge?: Maybe<JobsApplicationsEdge>;
  /** Reads a single `PipelineStage` that is related to this `JobsApplication`. */
  pipelineStage?: Maybe<PipelineStage>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our update `JobsApplication` mutation. */
export type UpdateJobsApplicationPayloadJobsApplicationEdgeArgs = {
  orderBy?: InputMaybe<Array<JobsApplicationsOrderBy>>;
};

/** All input for the `updatePasswordByToken` mutation. */
export type UpdatePasswordByTokenInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  password: Scalars['String']['input'];
  token: Scalars['UUID']['input'];
};

/** The output of our `updatePasswordByToken` mutation. */
export type UpdatePasswordByTokenPayload = {
  __typename?: 'UpdatePasswordByTokenPayload';
  boolean?: Maybe<Scalars['Boolean']['output']>;
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};

export type UpdatePipelineInput = {
  id: Scalars['Int']['input'];
  patch: UpdatePipelinePatch;
};

export type UpdatePipelinePatch = {
  pipelineStages?: InputMaybe<Array<PipelineStageInput__>>;
  translations?: InputMaybe<Array<PipelineTranslationsInput>>;
};

export type UpdatePipelinePayload = {
  __typename?: 'UpdatePipelinePayload';
  pipeline?: Maybe<Pipeline>;
  query?: Maybe<Query>;
};

/** All input for the `updatePipelineStageByNodeId` mutation. */
export type UpdatePipelineStageByNodeIdInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `PipelineStage` to be updated. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `PipelineStage` being updated. */
  patch: PipelineStagePatch;
};

/** All input for the `updatePipelineStage` mutation. */
export type UpdatePipelineStageInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `PipelineStage` being updated. */
  patch: PipelineStagePatch;
};

/** The output of our update `PipelineStage` mutation. */
export type UpdatePipelineStagePayload = {
  __typename?: 'UpdatePipelineStagePayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Reads a single `Pipeline` that is related to this `PipelineStage`. */
  pipeline?: Maybe<Pipeline>;
  /** The `PipelineStage` that was updated by this mutation. */
  pipelineStage?: Maybe<PipelineStage>;
  /** An edge for our `PipelineStage`. May be used by Relay 1. */
  pipelineStageEdge?: Maybe<PipelineStagesEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our update `PipelineStage` mutation. */
export type UpdatePipelineStagePayloadPipelineStageEdgeArgs = {
  orderBy?: InputMaybe<Array<PipelineStagesOrderBy>>;
};

/** All input for the `updatePipelineStageScorecardByNodeId` mutation. */
export type UpdatePipelineStageScorecardByNodeIdInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `PipelineStageScorecard` to be updated. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `PipelineStageScorecard` being updated. */
  patch: PipelineStageScorecardPatch;
};

/** All input for the `updatePipelineStageScorecard` mutation. */
export type UpdatePipelineStageScorecardInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** An object where the defined keys will be set on the `PipelineStageScorecard` being updated. */
  patch: PipelineStageScorecardPatch;
  pipelineStageId: Scalars['Int']['input'];
  scorecardId: Scalars['Int']['input'];
};

/** The output of our update `PipelineStageScorecard` mutation. */
export type UpdatePipelineStageScorecardPayload = {
  __typename?: 'UpdatePipelineStageScorecardPayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Reads a single `PipelineStage` that is related to this `PipelineStageScorecard`. */
  pipelineStage?: Maybe<PipelineStage>;
  /** The `PipelineStageScorecard` that was updated by this mutation. */
  pipelineStageScorecard?: Maybe<PipelineStageScorecard>;
  /** An edge for our `PipelineStageScorecard`. May be used by Relay 1. */
  pipelineStageScorecardEdge?: Maybe<PipelineStageScorecardsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `Scorecard` that is related to this `PipelineStageScorecard`. */
  scorecard?: Maybe<Scorecard>;
};


/** The output of our update `PipelineStageScorecard` mutation. */
export type UpdatePipelineStageScorecardPayloadPipelineStageScorecardEdgeArgs = {
  orderBy?: InputMaybe<Array<PipelineStageScorecardsOrderBy>>;
};

/** All input for the `updatePipelineStageTranslationByNodeId` mutation. */
export type UpdatePipelineStageTranslationByNodeIdInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `PipelineStageTranslation` to be updated. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `PipelineStageTranslation` being updated. */
  patch: PipelineStageTranslationPatch;
};

/** All input for the `updatePipelineStageTranslation` mutation. */
export type UpdatePipelineStageTranslationInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  lang: Language;
  /** An object where the defined keys will be set on the `PipelineStageTranslation` being updated. */
  patch: PipelineStageTranslationPatch;
  pipelineStageId: Scalars['Int']['input'];
};

/** The output of our update `PipelineStageTranslation` mutation. */
export type UpdatePipelineStageTranslationPayload = {
  __typename?: 'UpdatePipelineStageTranslationPayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Reads a single `PipelineStage` that is related to this `PipelineStageTranslation`. */
  pipelineStage?: Maybe<PipelineStage>;
  /** The `PipelineStageTranslation` that was updated by this mutation. */
  pipelineStageTranslation?: Maybe<PipelineStageTranslation>;
  /** An edge for our `PipelineStageTranslation`. May be used by Relay 1. */
  pipelineStageTranslationEdge?: Maybe<PipelineStageTranslationsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our update `PipelineStageTranslation` mutation. */
export type UpdatePipelineStageTranslationPayloadPipelineStageTranslationEdgeArgs = {
  orderBy?: InputMaybe<Array<PipelineStageTranslationsOrderBy>>;
};

/** All input for the `updatePipelineStageUserByNodeId` mutation. */
export type UpdatePipelineStageUserByNodeIdInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `PipelineStageUser` to be updated. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `PipelineStageUser` being updated. */
  patch: PipelineStageUserPatch;
};

/** All input for the `updatePipelineStageUser` mutation. */
export type UpdatePipelineStageUserInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** An object where the defined keys will be set on the `PipelineStageUser` being updated. */
  patch: PipelineStageUserPatch;
  pipelineStageId: Scalars['Int']['input'];
  userId: Scalars['Int']['input'];
};

/** The output of our update `PipelineStageUser` mutation. */
export type UpdatePipelineStageUserPayload = {
  __typename?: 'UpdatePipelineStageUserPayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Reads a single `PipelineStage` that is related to this `PipelineStageUser`. */
  pipelineStage?: Maybe<PipelineStage>;
  /** The `PipelineStageUser` that was updated by this mutation. */
  pipelineStageUser?: Maybe<PipelineStageUser>;
  /** An edge for our `PipelineStageUser`. May be used by Relay 1. */
  pipelineStageUserEdge?: Maybe<PipelineStageUsersEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `User` that is related to this `PipelineStageUser`. */
  user?: Maybe<User>;
};


/** The output of our update `PipelineStageUser` mutation. */
export type UpdatePipelineStageUserPayloadPipelineStageUserEdgeArgs = {
  orderBy?: InputMaybe<Array<PipelineStageUsersOrderBy>>;
};

/** All input for the `updatePipelineTranslationByNodeId` mutation. */
export type UpdatePipelineTranslationByNodeIdInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `PipelineTranslation` to be updated. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `PipelineTranslation` being updated. */
  patch: PipelineTranslationPatch;
};

/** All input for the `updatePipelineTranslation` mutation. */
export type UpdatePipelineTranslationInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  lang: Language;
  /** An object where the defined keys will be set on the `PipelineTranslation` being updated. */
  patch: PipelineTranslationPatch;
  pipelineId: Scalars['Int']['input'];
};

/** The output of our update `PipelineTranslation` mutation. */
export type UpdatePipelineTranslationPayload = {
  __typename?: 'UpdatePipelineTranslationPayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Reads a single `Pipeline` that is related to this `PipelineTranslation`. */
  pipeline?: Maybe<Pipeline>;
  /** The `PipelineTranslation` that was updated by this mutation. */
  pipelineTranslation?: Maybe<PipelineTranslation>;
  /** An edge for our `PipelineTranslation`. May be used by Relay 1. */
  pipelineTranslationEdge?: Maybe<PipelineTranslationsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our update `PipelineTranslation` mutation. */
export type UpdatePipelineTranslationPayloadPipelineTranslationEdgeArgs = {
  orderBy?: InputMaybe<Array<PipelineTranslationsOrderBy>>;
};

/** All input for the `updateQuestionByNodeId` mutation. */
export type UpdateQuestionByNodeIdInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `Question` to be updated. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `Question` being updated. */
  patch: QuestionPatch;
};

/** All input for the `updateQuestion` mutation. */
export type UpdateQuestionInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `Question` being updated. */
  patch: QuestionPatch;
};

/** All input for the `updateQuestionOptionByNodeId` mutation. */
export type UpdateQuestionOptionByNodeIdInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `QuestionOption` to be updated. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `QuestionOption` being updated. */
  patch: QuestionOptionPatch;
};

/** All input for the `updateQuestionOption` mutation. */
export type UpdateQuestionOptionInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `QuestionOption` being updated. */
  patch: QuestionOptionPatch;
};

/** The output of our update `QuestionOption` mutation. */
export type UpdateQuestionOptionPayload = {
  __typename?: 'UpdateQuestionOptionPayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `Question` that is related to this `QuestionOption`. */
  question?: Maybe<Question>;
  /** The `QuestionOption` that was updated by this mutation. */
  questionOption?: Maybe<QuestionOption>;
  /** An edge for our `QuestionOption`. May be used by Relay 1. */
  questionOptionEdge?: Maybe<QuestionOptionsEdge>;
};


/** The output of our update `QuestionOption` mutation. */
export type UpdateQuestionOptionPayloadQuestionOptionEdgeArgs = {
  orderBy?: InputMaybe<Array<QuestionOptionsOrderBy>>;
};

/** All input for the `updateQuestionOptionTranslationByNodeId` mutation. */
export type UpdateQuestionOptionTranslationByNodeIdInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `QuestionOptionTranslation` to be updated. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `QuestionOptionTranslation` being updated. */
  patch: QuestionOptionTranslationPatch;
};

/** All input for the `updateQuestionOptionTranslation` mutation. */
export type UpdateQuestionOptionTranslationInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  lang: Language;
  /** An object where the defined keys will be set on the `QuestionOptionTranslation` being updated. */
  patch: QuestionOptionTranslationPatch;
  questionOptionId: Scalars['Int']['input'];
};

/** The output of our update `QuestionOptionTranslation` mutation. */
export type UpdateQuestionOptionTranslationPayload = {
  __typename?: 'UpdateQuestionOptionTranslationPayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `QuestionOption` that is related to this `QuestionOptionTranslation`. */
  questionOption?: Maybe<QuestionOption>;
  /** The `QuestionOptionTranslation` that was updated by this mutation. */
  questionOptionTranslation?: Maybe<QuestionOptionTranslation>;
  /** An edge for our `QuestionOptionTranslation`. May be used by Relay 1. */
  questionOptionTranslationEdge?: Maybe<QuestionOptionTranslationsEdge>;
};


/** The output of our update `QuestionOptionTranslation` mutation. */
export type UpdateQuestionOptionTranslationPayloadQuestionOptionTranslationEdgeArgs = {
  orderBy?: InputMaybe<Array<QuestionOptionTranslationsOrderBy>>;
};

/** The output of our update `Question` mutation. */
export type UpdateQuestionPayload = {
  __typename?: 'UpdateQuestionPayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** The `Question` that was updated by this mutation. */
  question?: Maybe<Question>;
  /** An edge for our `Question`. May be used by Relay 1. */
  questionEdge?: Maybe<QuestionsEdge>;
};


/** The output of our update `Question` mutation. */
export type UpdateQuestionPayloadQuestionEdgeArgs = {
  orderBy?: InputMaybe<Array<QuestionsOrderBy>>;
};

/** All input for the `updateQuestionTranslationByNodeId` mutation. */
export type UpdateQuestionTranslationByNodeIdInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `QuestionTranslation` to be updated. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `QuestionTranslation` being updated. */
  patch: QuestionTranslationPatch;
};

/** All input for the `updateQuestionTranslation` mutation. */
export type UpdateQuestionTranslationInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  lang: Language;
  /** An object where the defined keys will be set on the `QuestionTranslation` being updated. */
  patch: QuestionTranslationPatch;
  questionId: Scalars['Int']['input'];
};

/** The output of our update `QuestionTranslation` mutation. */
export type UpdateQuestionTranslationPayload = {
  __typename?: 'UpdateQuestionTranslationPayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `Question` that is related to this `QuestionTranslation`. */
  question?: Maybe<Question>;
  /** The `QuestionTranslation` that was updated by this mutation. */
  questionTranslation?: Maybe<QuestionTranslation>;
  /** An edge for our `QuestionTranslation`. May be used by Relay 1. */
  questionTranslationEdge?: Maybe<QuestionTranslationsEdge>;
};


/** The output of our update `QuestionTranslation` mutation. */
export type UpdateQuestionTranslationPayloadQuestionTranslationEdgeArgs = {
  orderBy?: InputMaybe<Array<QuestionTranslationsOrderBy>>;
};

/** All input for the `updateQuestionnaireByNodeId` mutation. */
export type UpdateQuestionnaireByNodeIdInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `Questionnaire` to be updated. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `Questionnaire` being updated. */
  patch: QuestionnairePatch;
};

/** All input for the `updateQuestionnaire` mutation. */
export type UpdateQuestionnaireInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `Questionnaire` being updated. */
  patch: QuestionnairePatch;
};

/** The output of our update `Questionnaire` mutation. */
export type UpdateQuestionnairePayload = {
  __typename?: 'UpdateQuestionnairePayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** The `Questionnaire` that was updated by this mutation. */
  questionnaire?: Maybe<Questionnaire>;
  /** An edge for our `Questionnaire`. May be used by Relay 1. */
  questionnaireEdge?: Maybe<QuestionnairesEdge>;
};


/** The output of our update `Questionnaire` mutation. */
export type UpdateQuestionnairePayloadQuestionnaireEdgeArgs = {
  orderBy?: InputMaybe<Array<QuestionnairesOrderBy>>;
};

/** All input for the `updateQuestionnaireQuestionByNodeId` mutation. */
export type UpdateQuestionnaireQuestionByNodeIdInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `QuestionnaireQuestion` to be updated. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `QuestionnaireQuestion` being updated. */
  patch: QuestionnaireQuestionPatch;
};

/** All input for the `updateQuestionnaireQuestion` mutation. */
export type UpdateQuestionnaireQuestionInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** An object where the defined keys will be set on the `QuestionnaireQuestion` being updated. */
  patch: QuestionnaireQuestionPatch;
  questionId: Scalars['Int']['input'];
  questionnaireId: Scalars['Int']['input'];
};

/** The output of our update `QuestionnaireQuestion` mutation. */
export type UpdateQuestionnaireQuestionPayload = {
  __typename?: 'UpdateQuestionnaireQuestionPayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `Question` that is related to this `QuestionnaireQuestion`. */
  question?: Maybe<Question>;
  /** Reads a single `Questionnaire` that is related to this `QuestionnaireQuestion`. */
  questionnaire?: Maybe<Questionnaire>;
  /** The `QuestionnaireQuestion` that was updated by this mutation. */
  questionnaireQuestion?: Maybe<QuestionnaireQuestion>;
  /** An edge for our `QuestionnaireQuestion`. May be used by Relay 1. */
  questionnaireQuestionEdge?: Maybe<QuestionnaireQuestionsEdge>;
};


/** The output of our update `QuestionnaireQuestion` mutation. */
export type UpdateQuestionnaireQuestionPayloadQuestionnaireQuestionEdgeArgs = {
  orderBy?: InputMaybe<Array<QuestionnaireQuestionsOrderBy>>;
};

/** All input for the `updateQuestionnaireTranslationByNodeId` mutation. */
export type UpdateQuestionnaireTranslationByNodeIdInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `QuestionnaireTranslation` to be updated. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `QuestionnaireTranslation` being updated. */
  patch: QuestionnaireTranslationPatch;
};

/** All input for the `updateQuestionnaireTranslation` mutation. */
export type UpdateQuestionnaireTranslationInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  lang: Language;
  /** An object where the defined keys will be set on the `QuestionnaireTranslation` being updated. */
  patch: QuestionnaireTranslationPatch;
  questionnaireId: Scalars['Int']['input'];
};

/** The output of our update `QuestionnaireTranslation` mutation. */
export type UpdateQuestionnaireTranslationPayload = {
  __typename?: 'UpdateQuestionnaireTranslationPayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `Questionnaire` that is related to this `QuestionnaireTranslation`. */
  questionnaire?: Maybe<Questionnaire>;
  /** The `QuestionnaireTranslation` that was updated by this mutation. */
  questionnaireTranslation?: Maybe<QuestionnaireTranslation>;
  /** An edge for our `QuestionnaireTranslation`. May be used by Relay 1. */
  questionnaireTranslationEdge?: Maybe<QuestionnaireTranslationsEdge>;
};


/** The output of our update `QuestionnaireTranslation` mutation. */
export type UpdateQuestionnaireTranslationPayloadQuestionnaireTranslationEdgeArgs = {
  orderBy?: InputMaybe<Array<QuestionnaireTranslationsOrderBy>>;
};

/** All input for the `updateRoleByNodeId` mutation. */
export type UpdateRoleByNodeIdInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `Role` to be updated. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `Role` being updated. */
  patch: RolePatch;
};

/** All input for the `updateRole` mutation. */
export type UpdateRoleInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `Role` being updated. */
  patch: RolePatch;
};

/** The output of our update `Role` mutation. */
export type UpdateRolePayload = {
  __typename?: 'UpdateRolePayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** The `Role` that was updated by this mutation. */
  role?: Maybe<Role>;
  /** An edge for our `Role`. May be used by Relay 1. */
  roleEdge?: Maybe<RolesEdge>;
};


/** The output of our update `Role` mutation. */
export type UpdateRolePayloadRoleEdgeArgs = {
  orderBy?: InputMaybe<Array<RolesOrderBy>>;
};

/** All input for the `updateRoleTranslationByNodeId` mutation. */
export type UpdateRoleTranslationByNodeIdInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `RoleTranslation` to be updated. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `RoleTranslation` being updated. */
  patch: RoleTranslationPatch;
};

/** All input for the `updateRoleTranslation` mutation. */
export type UpdateRoleTranslationInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  lang: Language;
  /** An object where the defined keys will be set on the `RoleTranslation` being updated. */
  patch: RoleTranslationPatch;
  roleId: Scalars['Int']['input'];
};

/** The output of our update `RoleTranslation` mutation. */
export type UpdateRoleTranslationPayload = {
  __typename?: 'UpdateRoleTranslationPayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `Role` that is related to this `RoleTranslation`. */
  role?: Maybe<Role>;
  /** The `RoleTranslation` that was updated by this mutation. */
  roleTranslation?: Maybe<RoleTranslation>;
  /** An edge for our `RoleTranslation`. May be used by Relay 1. */
  roleTranslationEdge?: Maybe<RoleTranslationsEdge>;
};


/** The output of our update `RoleTranslation` mutation. */
export type UpdateRoleTranslationPayloadRoleTranslationEdgeArgs = {
  orderBy?: InputMaybe<Array<RoleTranslationsOrderBy>>;
};

/** All input for the `updateScorecardCriteriaByNodeId` mutation. */
export type UpdateScorecardCriteriaByNodeIdInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `ScorecardCriteria` to be updated. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `ScorecardCriteria` being updated. */
  patch: ScorecardCriteriaPatch;
};

/** All input for the `updateScorecardCriteria` mutation. */
export type UpdateScorecardCriteriaInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `ScorecardCriteria` being updated. */
  patch: ScorecardCriteriaPatch;
};

/** The output of our update `ScorecardCriteria` mutation. */
export type UpdateScorecardCriteriaPayload = {
  __typename?: 'UpdateScorecardCriteriaPayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `Scorecard` that is related to this `ScorecardCriteria`. */
  scorecard?: Maybe<Scorecard>;
  /** The `ScorecardCriteria` that was updated by this mutation. */
  scorecardCriteria?: Maybe<ScorecardCriteria>;
  /** An edge for our `ScorecardCriteria`. May be used by Relay 1. */
  scorecardCriteriaEdge?: Maybe<ScorecardCriteriaEdge>;
};


/** The output of our update `ScorecardCriteria` mutation. */
export type UpdateScorecardCriteriaPayloadScorecardCriteriaEdgeArgs = {
  orderBy?: InputMaybe<Array<ScorecardCriteriaOrderBy>>;
};

/** All input for the `updateScorecardCriteriaTranslationByNodeId` mutation. */
export type UpdateScorecardCriteriaTranslationByNodeIdInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `ScorecardCriteriaTranslation` to be updated. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `ScorecardCriteriaTranslation` being updated. */
  patch: ScorecardCriteriaTranslationPatch;
};

/** All input for the `updateScorecardCriteriaTranslation` mutation. */
export type UpdateScorecardCriteriaTranslationInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  lang: Language;
  /** An object where the defined keys will be set on the `ScorecardCriteriaTranslation` being updated. */
  patch: ScorecardCriteriaTranslationPatch;
  scorecardCriteriaId: Scalars['Int']['input'];
};

/** The output of our update `ScorecardCriteriaTranslation` mutation. */
export type UpdateScorecardCriteriaTranslationPayload = {
  __typename?: 'UpdateScorecardCriteriaTranslationPayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `ScorecardCriteria` that is related to this `ScorecardCriteriaTranslation`. */
  scorecardCriteria?: Maybe<ScorecardCriteria>;
  /** The `ScorecardCriteriaTranslation` that was updated by this mutation. */
  scorecardCriteriaTranslation?: Maybe<ScorecardCriteriaTranslation>;
  /** An edge for our `ScorecardCriteriaTranslation`. May be used by Relay 1. */
  scorecardCriteriaTranslationEdge?: Maybe<ScorecardCriteriaTranslationsEdge>;
};


/** The output of our update `ScorecardCriteriaTranslation` mutation. */
export type UpdateScorecardCriteriaTranslationPayloadScorecardCriteriaTranslationEdgeArgs = {
  orderBy?: InputMaybe<Array<ScorecardCriteriaTranslationsOrderBy>>;
};

/** All input for the `updateScorecardTranslationByNodeId` mutation. */
export type UpdateScorecardTranslationByNodeIdInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `ScorecardTranslation` to be updated. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `ScorecardTranslation` being updated. */
  patch: ScorecardTranslationPatch;
};

/** All input for the `updateScorecardTranslation` mutation. */
export type UpdateScorecardTranslationInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  lang: Language;
  /** An object where the defined keys will be set on the `ScorecardTranslation` being updated. */
  patch: ScorecardTranslationPatch;
  scorecardId: Scalars['Int']['input'];
};

/** The output of our update `ScorecardTranslation` mutation. */
export type UpdateScorecardTranslationPayload = {
  __typename?: 'UpdateScorecardTranslationPayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `Scorecard` that is related to this `ScorecardTranslation`. */
  scorecard?: Maybe<Scorecard>;
  /** The `ScorecardTranslation` that was updated by this mutation. */
  scorecardTranslation?: Maybe<ScorecardTranslation>;
  /** An edge for our `ScorecardTranslation`. May be used by Relay 1. */
  scorecardTranslationEdge?: Maybe<ScorecardTranslationsEdge>;
};


/** The output of our update `ScorecardTranslation` mutation. */
export type UpdateScorecardTranslationPayloadScorecardTranslationEdgeArgs = {
  orderBy?: InputMaybe<Array<ScorecardTranslationsOrderBy>>;
};

/** All input for the `updateUserByEmail` mutation. */
export type UpdateUserByEmailInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  email: Scalars['String']['input'];
  /** An object where the defined keys will be set on the `User` being updated. */
  patch: UserPatch;
};

/** All input for the `updateUserByNodeId` mutation. */
export type UpdateUserByNodeIdInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `User` to be updated. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `User` being updated. */
  patch: UserPatch;
};

/** All input for the `updateUser` mutation. */
export type UpdateUserInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `User` being updated. */
  patch: UserPatch;
};

/** All input for the `updateUserInvitationByNodeId` mutation. */
export type UpdateUserInvitationByNodeIdInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `UserInvitation` to be updated. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `UserInvitation` being updated. */
  patch: UserInvitationPatch;
};

/** All input for the `updateUserInvitationByToken` mutation. */
export type UpdateUserInvitationByTokenInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** An object where the defined keys will be set on the `UserInvitation` being updated. */
  patch: UserInvitationPatch;
  token: Scalars['UUID']['input'];
};

/** All input for the `updateUserInvitation` mutation. */
export type UpdateUserInvitationInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `UserInvitation` being updated. */
  patch: UserInvitationPatch;
};

/** The output of our update `UserInvitation` mutation. */
export type UpdateUserInvitationPayload = {
  __typename?: 'UpdateUserInvitationPayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `Role` that is related to this `UserInvitation`. */
  role?: Maybe<Role>;
  /** The `UserInvitation` that was updated by this mutation. */
  userInvitation?: Maybe<UserInvitation>;
  /** An edge for our `UserInvitation`. May be used by Relay 1. */
  userInvitationEdge?: Maybe<UserInvitationsEdge>;
};


/** The output of our update `UserInvitation` mutation. */
export type UpdateUserInvitationPayloadUserInvitationEdgeArgs = {
  orderBy?: InputMaybe<Array<UserInvitationsOrderBy>>;
};

/** The output of our update `User` mutation. */
export type UpdateUserPayload = {
  __typename?: 'UpdateUserPayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** The `User` that was updated by this mutation. */
  user?: Maybe<User>;
  /** An edge for our `User`. May be used by Relay 1. */
  userEdge?: Maybe<UsersEdge>;
};


/** The output of our update `User` mutation. */
export type UpdateUserPayloadUserEdgeArgs = {
  orderBy?: InputMaybe<Array<UsersOrderBy>>;
};

/** All input for the `updateUserSettings` mutation. */
export type UpdateUserSettingsInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
  patch: UserPatchRecordInput;
};

/** The output of our `updateUserSettings` mutation. */
export type UpdateUserSettingsPayload = {
  __typename?: 'UpdateUserSettingsPayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  user?: Maybe<User>;
  /** An edge for our `User`. May be used by Relay 1. */
  userEdge?: Maybe<UsersEdge>;
};


/** The output of our `updateUserSettings` mutation. */
export type UpdateUserSettingsPayloadUserEdgeArgs = {
  orderBy?: InputMaybe<Array<UsersOrderBy>>;
};

/** All input for the `updateUserTranslationByNodeId` mutation. */
export type UpdateUserTranslationByNodeIdInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `UserTranslation` to be updated. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `UserTranslation` being updated. */
  patch: UserTranslationPatch;
};

/** All input for the `updateUserTranslation` mutation. */
export type UpdateUserTranslationInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  lang: Language;
  /** An object where the defined keys will be set on the `UserTranslation` being updated. */
  patch: UserTranslationPatch;
  userId: Scalars['Int']['input'];
};

/** The output of our update `UserTranslation` mutation. */
export type UpdateUserTranslationPayload = {
  __typename?: 'UpdateUserTranslationPayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `User` that is related to this `UserTranslation`. */
  user?: Maybe<User>;
  /** The `UserTranslation` that was updated by this mutation. */
  userTranslation?: Maybe<UserTranslation>;
  /** An edge for our `UserTranslation`. May be used by Relay 1. */
  userTranslationEdge?: Maybe<UserTranslationsEdge>;
};


/** The output of our update `UserTranslation` mutation. */
export type UpdateUserTranslationPayloadUserTranslationEdgeArgs = {
  orderBy?: InputMaybe<Array<UserTranslationsOrderBy>>;
};

/** All input for the `updateWebsiteByHost` mutation. */
export type UpdateWebsiteByHostInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  host: Scalars['String']['input'];
  /** An object where the defined keys will be set on the `Website` being updated. */
  patch: WebsitePatch;
};

/** All input for the `updateWebsiteByNodeId` mutation. */
export type UpdateWebsiteByNodeIdInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `Website` to be updated. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `Website` being updated. */
  patch: WebsitePatch;
};

/** All input for the `updateWebsite` mutation. */
export type UpdateWebsiteInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `Website` being updated. */
  patch: WebsitePatch;
};

export type UpdateWebsiteInput__ = {
  id: Scalars['Int']['input'];
  patch: WebsitePatch__;
};

/** The output of our update `Website` mutation. */
export type UpdateWebsitePayload = {
  __typename?: 'UpdateWebsitePayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** The `Website` that was updated by this mutation. */
  website?: Maybe<Website>;
  /** An edge for our `Website`. May be used by Relay 1. */
  websiteEdge?: Maybe<WebsitesEdge>;
};


/** The output of our update `Website` mutation. */
export type UpdateWebsitePayloadWebsiteEdgeArgs = {
  orderBy?: InputMaybe<Array<WebsitesOrderBy>>;
};

export type UpdateWebsitePayload__ = {
  __typename?: 'UpdateWebsitePayload__';
  query?: Maybe<Query>;
  website?: Maybe<Website>;
};

export type User = Node & {
  __typename?: 'User';
  /** Reads and enables pagination through a set of `Candidate`. */
  candidates: UserCandidatesByThreadUserIdAndCandidateIdManyToManyConnection;
  /** Reads and enables pagination through a set of `CompanyUser`. */
  companyUsers: CompanyUsersConnection;
  createdAt: Scalars['Datetime']['output'];
  email: Scalars['String']['output'];
  emailVerified: Scalars['Boolean']['output'];
  /** Reads and enables pagination through a set of `Evaluation`. */
  evaluations: EvaluationsConnection;
  /** Reads and enables pagination through a set of `EventUser`. */
  eventUsers: EventUsersConnection;
  /** Reads and enables pagination through a set of `Event`. */
  events: UserEventsByEventUserUserIdAndEventIdManyToManyConnection;
  id: Scalars['Int']['output'];
  /** Reads and enables pagination through a set of `JobOwner`. */
  jobOwners: JobOwnersConnection;
  /** Reads and enables pagination through a set of `Job`. */
  jobs: UserJobsByJobOwnerUserIdAndJobIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Message`. */
  messages: MessagesConnection;
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  phoneNumber: Scalars['String']['output'];
  photoNormalUrl?: Maybe<Scalars['String']['output']>;
  photoThumbUrl?: Maybe<Scalars['String']['output']>;
  /** Reads and enables pagination through a set of `PipelineStageUser`. */
  pipelineStageUsers: PipelineStageUsersConnection;
  /** Reads and enables pagination through a set of `PipelineStage`. */
  pipelineStages: UserPipelineStagesByPipelineStageUserUserIdAndPipelineStageIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Role`. */
  roles: UserRolesByCompanyUserUserIdAndRoleIdManyToManyConnection;
  /** Reads and enables pagination through a set of `ThreadUser`. */
  threadUsers: ThreadUsersConnection;
  /** Reads and enables pagination through a set of `Thread`. */
  threads: ThreadsConnection;
  /** Reads and enables pagination through a set of `UserTranslation`. */
  translations: UserTranslationsConnection;
  updatedAt: Scalars['Datetime']['output'];
};


export type UserCandidatesArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<CandidateCondition>;
  filter?: InputMaybe<CandidateFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<CandidatesOrderBy>>;
};


export type UserCompanyUsersArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<CompanyUserCondition>;
  filter?: InputMaybe<CompanyUserFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<CompanyUsersOrderBy>>;
};


export type UserEvaluationsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<EvaluationCondition>;
  filter?: InputMaybe<EvaluationFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<EvaluationsOrderBy>>;
};


export type UserEventUsersArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<EventUserCondition>;
  filter?: InputMaybe<EventUserFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<EventUsersOrderBy>>;
};


export type UserEventsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<EventCondition>;
  filter?: InputMaybe<EventFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<EventsOrderBy>>;
};


export type UserJobOwnersArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<JobOwnerCondition>;
  filter?: InputMaybe<JobOwnerFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<JobOwnersOrderBy>>;
};


export type UserJobsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<JobCondition>;
  filter?: InputMaybe<JobFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<JobsOrderBy>>;
};


export type UserMessagesArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<MessageCondition>;
  filter?: InputMaybe<MessageFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<MessagesOrderBy>>;
};


export type UserPipelineStageUsersArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<PipelineStageUserCondition>;
  filter?: InputMaybe<PipelineStageUserFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<PipelineStageUsersOrderBy>>;
};


export type UserPipelineStagesArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<PipelineStageCondition>;
  filter?: InputMaybe<PipelineStageFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<PipelineStagesOrderBy>>;
};


export type UserRolesArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<RoleCondition>;
  filter?: InputMaybe<RoleFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<RolesOrderBy>>;
};


export type UserThreadUsersArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<ThreadUserCondition>;
  filter?: InputMaybe<ThreadUserFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<ThreadUsersOrderBy>>;
};


export type UserThreadsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<ThreadCondition>;
  filter?: InputMaybe<ThreadFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<ThreadsOrderBy>>;
};


export type UserTranslationsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<UserTranslationCondition>;
  filter?: InputMaybe<UserTranslationFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<UserTranslationsOrderBy>>;
};

/** A connection to a list of `Candidate` values, with data from `Thread`. */
export type UserCandidatesByThreadUserIdAndCandidateIdManyToManyConnection = {
  __typename?: 'UserCandidatesByThreadUserIdAndCandidateIdManyToManyConnection';
  /** A list of edges which contains the `Candidate`, info from the `Thread`, and the cursor to aid in pagination. */
  edges: Array<UserCandidatesByThreadUserIdAndCandidateIdManyToManyEdge>;
  /** A list of `Candidate` objects. */
  nodes: Array<Candidate>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Candidate` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `Candidate` edge in the connection, with data from `Thread`. */
export type UserCandidatesByThreadUserIdAndCandidateIdManyToManyEdge = {
  __typename?: 'UserCandidatesByThreadUserIdAndCandidateIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Candidate` at the end of the edge. */
  node: Candidate;
  /** Reads and enables pagination through a set of `Thread`. */
  threads: ThreadsConnection;
};


/** A `Candidate` edge in the connection, with data from `Thread`. */
export type UserCandidatesByThreadUserIdAndCandidateIdManyToManyEdgeThreadsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<ThreadCondition>;
  filter?: InputMaybe<ThreadFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<ThreadsOrderBy>>;
};

/** A condition to be used against `User` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type UserCondition = {
  /** Checks for equality with the object’s `email` field. */
  email?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `phoneNumber` field. */
  phoneNumber?: InputMaybe<Scalars['String']['input']>;
};

/** A connection to a list of `Event` values, with data from `EventUser`. */
export type UserEventsByEventUserUserIdAndEventIdManyToManyConnection = {
  __typename?: 'UserEventsByEventUserUserIdAndEventIdManyToManyConnection';
  /** A list of edges which contains the `Event`, info from the `EventUser`, and the cursor to aid in pagination. */
  edges: Array<UserEventsByEventUserUserIdAndEventIdManyToManyEdge>;
  /** A list of `Event` objects. */
  nodes: Array<Event>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Event` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `Event` edge in the connection, with data from `EventUser`. */
export type UserEventsByEventUserUserIdAndEventIdManyToManyEdge = {
  __typename?: 'UserEventsByEventUserUserIdAndEventIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** Reads and enables pagination through a set of `EventUser`. */
  eventUsers: EventUsersConnection;
  /** The `Event` at the end of the edge. */
  node: Event;
};


/** A `Event` edge in the connection, with data from `EventUser`. */
export type UserEventsByEventUserUserIdAndEventIdManyToManyEdgeEventUsersArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<EventUserCondition>;
  filter?: InputMaybe<EventUserFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<EventUsersOrderBy>>;
};

/** A filter to be used against `User` object types. All fields are combined with a logical ‘and.’ */
export type UserFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<UserFilter>>;
  /** Filter by the object’s `companyUsers` relation. */
  companyUsers?: InputMaybe<UserToManyCompanyUserFilter>;
  /** Some related `companyUsers` exist. */
  companyUsersExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `email` field. */
  email?: InputMaybe<StringFilter>;
  /** Filter by the object’s `evaluations` relation. */
  evaluations?: InputMaybe<UserToManyEvaluationFilter>;
  /** Some related `evaluations` exist. */
  evaluationsExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `eventUsers` relation. */
  eventUsers?: InputMaybe<UserToManyEventUserFilter>;
  /** Some related `eventUsers` exist. */
  eventUsersExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<IntFilter>;
  /** Filter by the object’s `jobOwners` relation. */
  jobOwners?: InputMaybe<UserToManyJobOwnerFilter>;
  /** Some related `jobOwners` exist. */
  jobOwnersExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `messages` relation. */
  messages?: InputMaybe<UserToManyMessageFilter>;
  /** Some related `messages` exist. */
  messagesExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Negates the expression. */
  not?: InputMaybe<UserFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<UserFilter>>;
  /** Filter by the object’s `phoneNumber` field. */
  phoneNumber?: InputMaybe<StringFilter>;
  /** Filter by the object’s `pipelineStageUsers` relation. */
  pipelineStageUsers?: InputMaybe<UserToManyPipelineStageUserFilter>;
  /** Some related `pipelineStageUsers` exist. */
  pipelineStageUsersExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `threadUsers` relation. */
  threadUsers?: InputMaybe<UserToManyThreadUserFilter>;
  /** Some related `threadUsers` exist. */
  threadUsersExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `threads` relation. */
  threads?: InputMaybe<UserToManyThreadFilter>;
  /** Some related `threads` exist. */
  threadsExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `translations` relation. */
  translations?: InputMaybe<UserToManyUserTranslationFilter>;
  /** Some related `translations` exist. */
  translationsExist?: InputMaybe<Scalars['Boolean']['input']>;
};

export type UserInvitation = Node & {
  __typename?: 'UserInvitation';
  createdAt: Scalars['Datetime']['output'];
  deletedAt: Scalars['Datetime']['output'];
  email?: Maybe<Scalars['String']['output']>;
  id: Scalars['Int']['output'];
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  /** Reads a single `Role` that is related to this `UserInvitation`. */
  role?: Maybe<Role>;
  roleId: Scalars['Int']['output'];
  token: Scalars['UUID']['output'];
  userId?: Maybe<Scalars['Int']['output']>;
};

/** A condition to be used against `UserInvitation` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type UserInvitationCondition = {
  /** Checks for equality with the object’s `deletedAt` field. */
  deletedAt?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `roleId` field. */
  roleId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `token` field. */
  token?: InputMaybe<Scalars['UUID']['input']>;
  /** Checks for equality with the object’s `userId` field. */
  userId?: InputMaybe<Scalars['Int']['input']>;
};

/** A filter to be used against `UserInvitation` object types. All fields are combined with a logical ‘and.’ */
export type UserInvitationFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<UserInvitationFilter>>;
  /** Filter by the object’s `deletedAt` field. */
  deletedAt?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<IntFilter>;
  /** Negates the expression. */
  not?: InputMaybe<UserInvitationFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<UserInvitationFilter>>;
  /** Filter by the object’s `role` relation. */
  role?: InputMaybe<RoleFilter>;
  /** Filter by the object’s `roleId` field. */
  roleId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `token` field. */
  token?: InputMaybe<UuidFilter>;
  /** Filter by the object’s `userId` field. */
  userId?: InputMaybe<IntFilter>;
};

/** An input for mutations affecting `UserInvitation` */
export type UserInvitationInput = {
  deletedAt?: InputMaybe<Scalars['Datetime']['input']>;
  email?: InputMaybe<Scalars['String']['input']>;
  role?: InputMaybe<UserInvitationsRoleIdFkeyInput>;
  roleId?: InputMaybe<Scalars['Int']['input']>;
};

/** The globally unique `ID` look up for the row to connect. */
export type UserInvitationNodeIdConnect = {
  /** The globally unique `ID` which identifies a single `userInvitation` to be connected. */
  nodeId: Scalars['ID']['input'];
};

/** The globally unique `ID` look up for the row to update. */
export type UserInvitationOnUserInvitationForUserInvitationsRoleIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `role` to be connected. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `role` being updated. */
  patch: RolePatch;
};

/** The fields on `userInvitation` to look up the row to update. */
export type UserInvitationOnUserInvitationForUserInvitationsRoleIdFkeyUsingUserInvitationsPkeyUpdate = {
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `userInvitation` being updated. */
  patch: UpdateUserInvitationOnUserInvitationForUserInvitationsRoleIdFkeyPatch;
};

/** The fields on `userInvitation` to look up the row to update. */
export type UserInvitationOnUserInvitationForUserInvitationsRoleIdFkeyUsingUserInvitationsTokenKeyUpdate = {
  /** An object where the defined keys will be set on the `userInvitation` being updated. */
  patch: UpdateUserInvitationOnUserInvitationForUserInvitationsRoleIdFkeyPatch;
  token: Scalars['UUID']['input'];
};

/** Represents an update to a `UserInvitation`. Fields that are set will be updated. */
export type UserInvitationPatch = {
  deletedAt?: InputMaybe<Scalars['Datetime']['input']>;
  role?: InputMaybe<UserInvitationsRoleIdFkeyInput>;
  roleId?: InputMaybe<Scalars['Int']['input']>;
};

/** The fields on `userInvitation` to look up the row to connect. */
export type UserInvitationUserInvitationsPkeyConnect = {
  id: Scalars['Int']['input'];
};

/** The fields on `userInvitation` to look up the row to connect. */
export type UserInvitationUserInvitationsTokenKeyConnect = {
  token: Scalars['UUID']['input'];
};

/** A connection to a list of `UserInvitation` values. */
export type UserInvitationsConnection = {
  __typename?: 'UserInvitationsConnection';
  /** A list of edges which contains the `UserInvitation` and cursor to aid in pagination. */
  edges: Array<UserInvitationsEdge>;
  /** A list of `UserInvitation` objects. */
  nodes: Array<UserInvitation>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `UserInvitation` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `UserInvitation` edge in the connection. */
export type UserInvitationsEdge = {
  __typename?: 'UserInvitationsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `UserInvitation` at the end of the edge. */
  node: UserInvitation;
};

/** Methods to use when ordering `UserInvitation`. */
export enum UserInvitationsOrderBy {
  DeletedAtAsc = 'DELETED_AT_ASC',
  DeletedAtDesc = 'DELETED_AT_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  Natural = 'NATURAL',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  RoleIdAsc = 'ROLE_ID_ASC',
  RoleIdDesc = 'ROLE_ID_DESC',
  TokenAsc = 'TOKEN_ASC',
  TokenDesc = 'TOKEN_DESC',
  UserIdAsc = 'USER_ID_ASC',
  UserIdDesc = 'USER_ID_DESC'
}

/** Input for the nested mutation of `role` in the `UserInvitationInput` mutation. */
export type UserInvitationsRoleIdFkeyInput = {
  /** The primary key(s) for `role` for the far side of the relationship. */
  connectById?: InputMaybe<RoleRolesPkeyConnect>;
  /** The primary key(s) for `role` for the far side of the relationship. */
  connectByNodeId?: InputMaybe<RoleNodeIdConnect>;
  /** A `RoleInput` object that will be created and connected to this object. */
  create?: InputMaybe<UserInvitationsRoleIdFkeyRolesCreateInput>;
  /** The primary key(s) and patch data for `role` for the far side of the relationship. */
  updateById?: InputMaybe<RoleOnUserInvitationForUserInvitationsRoleIdFkeyUsingRolesPkeyUpdate>;
  /** The primary key(s) and patch data for `role` for the far side of the relationship. */
  updateByNodeId?: InputMaybe<UserInvitationOnUserInvitationForUserInvitationsRoleIdFkeyNodeIdUpdate>;
};

/** Input for the nested mutation of `userInvitation` in the `RoleInput` mutation. */
export type UserInvitationsRoleIdFkeyInverseInput = {
  /** The primary key(s) for `userInvitation` for the far side of the relationship. */
  connectById?: InputMaybe<Array<UserInvitationUserInvitationsPkeyConnect>>;
  /** The primary key(s) for `userInvitation` for the far side of the relationship. */
  connectByNodeId?: InputMaybe<Array<UserInvitationNodeIdConnect>>;
  /** The primary key(s) for `userInvitation` for the far side of the relationship. */
  connectByToken?: InputMaybe<Array<UserInvitationUserInvitationsTokenKeyConnect>>;
  /** A `UserInvitationInput` object that will be created and connected to this object. */
  create?: InputMaybe<Array<UserInvitationsRoleIdFkeyUserInvitationsCreateInput>>;
  /** The primary key(s) and patch data for `userInvitation` for the far side of the relationship. */
  updateById?: InputMaybe<Array<UserInvitationOnUserInvitationForUserInvitationsRoleIdFkeyUsingUserInvitationsPkeyUpdate>>;
  /** The primary key(s) and patch data for `userInvitation` for the far side of the relationship. */
  updateByNodeId?: InputMaybe<Array<RoleOnUserInvitationForUserInvitationsRoleIdFkeyNodeIdUpdate>>;
  /** The primary key(s) and patch data for `userInvitation` for the far side of the relationship. */
  updateByToken?: InputMaybe<Array<UserInvitationOnUserInvitationForUserInvitationsRoleIdFkeyUsingUserInvitationsTokenKeyUpdate>>;
};

/** The `role` to be created by this mutation. */
export type UserInvitationsRoleIdFkeyRolesCreateInput = {
  abilities: Array<InputMaybe<Roleability>>;
  companyUsers?: InputMaybe<CompanyUsersRoleIdFkeyInverseInput>;
  translations?: InputMaybe<RoleTranslationsRoleIdFkeyInverseInput>;
  userInvitations?: InputMaybe<UserInvitationsRoleIdFkeyInverseInput>;
};

/** The `userInvitation` to be created by this mutation. */
export type UserInvitationsRoleIdFkeyUserInvitationsCreateInput = {
  deletedAt?: InputMaybe<Scalars['Datetime']['input']>;
  email?: InputMaybe<Scalars['String']['input']>;
  role?: InputMaybe<UserInvitationsRoleIdFkeyInput>;
};

/** A connection to a list of `Job` values, with data from `JobOwner`. */
export type UserJobsByJobOwnerUserIdAndJobIdManyToManyConnection = {
  __typename?: 'UserJobsByJobOwnerUserIdAndJobIdManyToManyConnection';
  /** A list of edges which contains the `Job`, info from the `JobOwner`, and the cursor to aid in pagination. */
  edges: Array<UserJobsByJobOwnerUserIdAndJobIdManyToManyEdge>;
  /** A list of `Job` objects. */
  nodes: Array<Job>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Job` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `Job` edge in the connection, with data from `JobOwner`. */
export type UserJobsByJobOwnerUserIdAndJobIdManyToManyEdge = {
  __typename?: 'UserJobsByJobOwnerUserIdAndJobIdManyToManyEdge';
  createdAt: Scalars['Datetime']['output'];
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Job` at the end of the edge. */
  node: Job;
};

/** The globally unique `ID` look up for the row to connect. */
export type UserNodeIdConnect = {
  /** The globally unique `ID` which identifies a single `user` to be connected. */
  nodeId: Scalars['ID']['input'];
};

/** The globally unique `ID` look up for the row to update. */
export type UserOnCompanyUserForCompanyUsersUserIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `companyUser` to be connected. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `companyUser` being updated. */
  patch: CompanyUserPatch;
};

/** The fields on `user` to look up the row to update. */
export type UserOnCompanyUserForCompanyUsersUserIdFkeyUsingUsersEmailKeyUpdate = {
  email: Scalars['String']['input'];
  /** An object where the defined keys will be set on the `user` being updated. */
  patch: UpdateUserOnCompanyUserForCompanyUsersUserIdFkeyPatch;
};

/** The fields on `user` to look up the row to update. */
export type UserOnCompanyUserForCompanyUsersUserIdFkeyUsingUsersPkeyUpdate = {
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `user` being updated. */
  patch: UpdateUserOnCompanyUserForCompanyUsersUserIdFkeyPatch;
};

/** The globally unique `ID` look up for the row to update. */
export type UserOnEvaluationForEvaluationsUserIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `evaluation` to be connected. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `evaluation` being updated. */
  patch: EvaluationPatch;
};

/** The fields on `user` to look up the row to update. */
export type UserOnEvaluationForEvaluationsUserIdFkeyUsingUsersEmailKeyUpdate = {
  email: Scalars['String']['input'];
  /** An object where the defined keys will be set on the `user` being updated. */
  patch: UpdateUserOnEvaluationForEvaluationsUserIdFkeyPatch;
};

/** The fields on `user` to look up the row to update. */
export type UserOnEvaluationForEvaluationsUserIdFkeyUsingUsersPkeyUpdate = {
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `user` being updated. */
  patch: UpdateUserOnEvaluationForEvaluationsUserIdFkeyPatch;
};

/** The globally unique `ID` look up for the row to update. */
export type UserOnEventUserForEventUsersUserIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `eventUser` to be connected. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `eventUser` being updated. */
  patch: EventUserPatch;
};

/** The fields on `user` to look up the row to update. */
export type UserOnEventUserForEventUsersUserIdFkeyUsingUsersEmailKeyUpdate = {
  email: Scalars['String']['input'];
  /** An object where the defined keys will be set on the `user` being updated. */
  patch: UpdateUserOnEventUserForEventUsersUserIdFkeyPatch;
};

/** The fields on `user` to look up the row to update. */
export type UserOnEventUserForEventUsersUserIdFkeyUsingUsersPkeyUpdate = {
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `user` being updated. */
  patch: UpdateUserOnEventUserForEventUsersUserIdFkeyPatch;
};

/** The globally unique `ID` look up for the row to update. */
export type UserOnJobOwnerForJobOwnersUserIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `jobOwner` to be connected. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `jobOwner` being updated. */
  patch: JobOwnerPatch;
};

/** The fields on `user` to look up the row to update. */
export type UserOnJobOwnerForJobOwnersUserIdFkeyUsingUsersEmailKeyUpdate = {
  email: Scalars['String']['input'];
  /** An object where the defined keys will be set on the `user` being updated. */
  patch: UpdateUserOnJobOwnerForJobOwnersUserIdFkeyPatch;
};

/** The fields on `user` to look up the row to update. */
export type UserOnJobOwnerForJobOwnersUserIdFkeyUsingUsersPkeyUpdate = {
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `user` being updated. */
  patch: UpdateUserOnJobOwnerForJobOwnersUserIdFkeyPatch;
};

/** The globally unique `ID` look up for the row to update. */
export type UserOnMessageForMessagesUserIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `message` to be connected. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `message` being updated. */
  patch: MessagePatch;
};

/** The fields on `user` to look up the row to update. */
export type UserOnMessageForMessagesUserIdFkeyUsingUsersEmailKeyUpdate = {
  email: Scalars['String']['input'];
  /** An object where the defined keys will be set on the `user` being updated. */
  patch: UpdateUserOnMessageForMessagesUserIdFkeyPatch;
};

/** The fields on `user` to look up the row to update. */
export type UserOnMessageForMessagesUserIdFkeyUsingUsersPkeyUpdate = {
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `user` being updated. */
  patch: UpdateUserOnMessageForMessagesUserIdFkeyPatch;
};

/** The globally unique `ID` look up for the row to update. */
export type UserOnPipelineStageUserForPipelineStageUsersUserIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `pipelineStageUser` to be connected. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `pipelineStageUser` being updated. */
  patch: PipelineStageUserPatch;
};

/** The fields on `user` to look up the row to update. */
export type UserOnPipelineStageUserForPipelineStageUsersUserIdFkeyUsingUsersEmailKeyUpdate = {
  email: Scalars['String']['input'];
  /** An object where the defined keys will be set on the `user` being updated. */
  patch: UpdateUserOnPipelineStageUserForPipelineStageUsersUserIdFkeyPatch;
};

/** The fields on `user` to look up the row to update. */
export type UserOnPipelineStageUserForPipelineStageUsersUserIdFkeyUsingUsersPkeyUpdate = {
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `user` being updated. */
  patch: UpdateUserOnPipelineStageUserForPipelineStageUsersUserIdFkeyPatch;
};

/** The globally unique `ID` look up for the row to update. */
export type UserOnThreadForThreadsUserIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `thread` to be connected. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `thread` being updated. */
  patch: ThreadPatch;
};

/** The fields on `user` to look up the row to update. */
export type UserOnThreadForThreadsUserIdFkeyUsingUsersEmailKeyUpdate = {
  email: Scalars['String']['input'];
  /** An object where the defined keys will be set on the `user` being updated. */
  patch: UpdateUserOnThreadForThreadsUserIdFkeyPatch;
};

/** The fields on `user` to look up the row to update. */
export type UserOnThreadForThreadsUserIdFkeyUsingUsersPkeyUpdate = {
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `user` being updated. */
  patch: UpdateUserOnThreadForThreadsUserIdFkeyPatch;
};

/** The globally unique `ID` look up for the row to update. */
export type UserOnThreadUserForThreadUsersUserIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `threadUser` to be connected. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `threadUser` being updated. */
  patch: ThreadUserPatch;
};

/** The fields on `user` to look up the row to update. */
export type UserOnThreadUserForThreadUsersUserIdFkeyUsingUsersEmailKeyUpdate = {
  email: Scalars['String']['input'];
  /** An object where the defined keys will be set on the `user` being updated. */
  patch: UpdateUserOnThreadUserForThreadUsersUserIdFkeyPatch;
};

/** The fields on `user` to look up the row to update. */
export type UserOnThreadUserForThreadUsersUserIdFkeyUsingUsersPkeyUpdate = {
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `user` being updated. */
  patch: UpdateUserOnThreadUserForThreadUsersUserIdFkeyPatch;
};

/** The globally unique `ID` look up for the row to update. */
export type UserOnUserTranslationForUserTranslationsUserIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `userTranslation` to be connected. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `userTranslation` being updated. */
  patch: UserTranslationPatch;
};

/** The fields on `user` to look up the row to update. */
export type UserOnUserTranslationForUserTranslationsUserIdFkeyUsingUsersEmailKeyUpdate = {
  email: Scalars['String']['input'];
  /** An object where the defined keys will be set on the `user` being updated. */
  patch: UpdateUserOnUserTranslationForUserTranslationsUserIdFkeyPatch;
};

/** The fields on `user` to look up the row to update. */
export type UserOnUserTranslationForUserTranslationsUserIdFkeyUsingUsersPkeyUpdate = {
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `user` being updated. */
  patch: UpdateUserOnUserTranslationForUserTranslationsUserIdFkeyPatch;
};

/** An input for mutations affecting `UserPassword` */
export type UserPasswordInput = {
  newPassword?: InputMaybe<Scalars['String']['input']>;
  oldPassword?: InputMaybe<Scalars['String']['input']>;
};

/** Represents an update to a `User`. Fields that are set will be updated. */
export type UserPatch = {
  companyUsers?: InputMaybe<CompanyUsersUserIdFkeyInverseInput>;
  email?: InputMaybe<Scalars['String']['input']>;
  evaluations?: InputMaybe<EvaluationsUserIdFkeyInverseInput>;
  eventUsers?: InputMaybe<EventUsersUserIdFkeyInverseInput>;
  jobOwners?: InputMaybe<JobOwnersUserIdFkeyInverseInput>;
  messages?: InputMaybe<MessagesUserIdFkeyInverseInput>;
  photoNormalUrl?: InputMaybe<Scalars['String']['input']>;
  photoThumbUrl?: InputMaybe<Scalars['String']['input']>;
  pipelineStageUsers?: InputMaybe<PipelineStageUsersUserIdFkeyInverseInput>;
  threadUsers?: InputMaybe<ThreadUsersUserIdFkeyInverseInput>;
  threads?: InputMaybe<ThreadsUserIdFkeyInverseInput>;
  translations?: InputMaybe<UserTranslationsUserIdFkeyInverseInput>;
};

/** An input for mutations affecting `UserPatchRecord` */
export type UserPatchRecordInput = {
  passwords?: InputMaybe<UserPasswordInput>;
  translations?: InputMaybe<Array<InputMaybe<UserTranslationInput>>>;
};

/** A connection to a list of `PipelineStage` values, with data from `PipelineStageUser`. */
export type UserPipelineStagesByPipelineStageUserUserIdAndPipelineStageIdManyToManyConnection = {
  __typename?: 'UserPipelineStagesByPipelineStageUserUserIdAndPipelineStageIdManyToManyConnection';
  /** A list of edges which contains the `PipelineStage`, info from the `PipelineStageUser`, and the cursor to aid in pagination. */
  edges: Array<UserPipelineStagesByPipelineStageUserUserIdAndPipelineStageIdManyToManyEdge>;
  /** A list of `PipelineStage` objects. */
  nodes: Array<PipelineStage>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `PipelineStage` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `PipelineStage` edge in the connection, with data from `PipelineStageUser`. */
export type UserPipelineStagesByPipelineStageUserUserIdAndPipelineStageIdManyToManyEdge = {
  __typename?: 'UserPipelineStagesByPipelineStageUserUserIdAndPipelineStageIdManyToManyEdge';
  createdAt: Scalars['Datetime']['output'];
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `PipelineStage` at the end of the edge. */
  node: PipelineStage;
};

/** A connection to a list of `Role` values, with data from `CompanyUser`. */
export type UserRolesByCompanyUserUserIdAndRoleIdManyToManyConnection = {
  __typename?: 'UserRolesByCompanyUserUserIdAndRoleIdManyToManyConnection';
  /** A list of edges which contains the `Role`, info from the `CompanyUser`, and the cursor to aid in pagination. */
  edges: Array<UserRolesByCompanyUserUserIdAndRoleIdManyToManyEdge>;
  /** A list of `Role` objects. */
  nodes: Array<Role>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Role` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `Role` edge in the connection, with data from `CompanyUser`. */
export type UserRolesByCompanyUserUserIdAndRoleIdManyToManyEdge = {
  __typename?: 'UserRolesByCompanyUserUserIdAndRoleIdManyToManyEdge';
  /** Reads and enables pagination through a set of `CompanyUser`. */
  companyUsers: CompanyUsersConnection;
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Role` at the end of the edge. */
  node: Role;
};


/** A `Role` edge in the connection, with data from `CompanyUser`. */
export type UserRolesByCompanyUserUserIdAndRoleIdManyToManyEdgeCompanyUsersArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<CompanyUserCondition>;
  filter?: InputMaybe<CompanyUserFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<CompanyUsersOrderBy>>;
};

/** A filter to be used against many `CompanyUser` object types. All fields are combined with a logical ‘and.’ */
export type UserToManyCompanyUserFilter = {
  /** Every related `CompanyUser` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<CompanyUserFilter>;
  /** No related `CompanyUser` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<CompanyUserFilter>;
  /** Some related `CompanyUser` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<CompanyUserFilter>;
};

/** A filter to be used against many `Evaluation` object types. All fields are combined with a logical ‘and.’ */
export type UserToManyEvaluationFilter = {
  /** Every related `Evaluation` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<EvaluationFilter>;
  /** No related `Evaluation` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<EvaluationFilter>;
  /** Some related `Evaluation` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<EvaluationFilter>;
};

/** A filter to be used against many `EventUser` object types. All fields are combined with a logical ‘and.’ */
export type UserToManyEventUserFilter = {
  /** Every related `EventUser` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<EventUserFilter>;
  /** No related `EventUser` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<EventUserFilter>;
  /** Some related `EventUser` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<EventUserFilter>;
};

/** A filter to be used against many `JobOwner` object types. All fields are combined with a logical ‘and.’ */
export type UserToManyJobOwnerFilter = {
  /** Every related `JobOwner` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<JobOwnerFilter>;
  /** No related `JobOwner` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<JobOwnerFilter>;
  /** Some related `JobOwner` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<JobOwnerFilter>;
};

/** A filter to be used against many `Message` object types. All fields are combined with a logical ‘and.’ */
export type UserToManyMessageFilter = {
  /** Every related `Message` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<MessageFilter>;
  /** No related `Message` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<MessageFilter>;
  /** Some related `Message` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<MessageFilter>;
};

/** A filter to be used against many `PipelineStageUser` object types. All fields are combined with a logical ‘and.’ */
export type UserToManyPipelineStageUserFilter = {
  /** Every related `PipelineStageUser` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<PipelineStageUserFilter>;
  /** No related `PipelineStageUser` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<PipelineStageUserFilter>;
  /** Some related `PipelineStageUser` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<PipelineStageUserFilter>;
};

/** A filter to be used against many `Thread` object types. All fields are combined with a logical ‘and.’ */
export type UserToManyThreadFilter = {
  /** Every related `Thread` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<ThreadFilter>;
  /** No related `Thread` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<ThreadFilter>;
  /** Some related `Thread` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<ThreadFilter>;
};

/** A filter to be used against many `ThreadUser` object types. All fields are combined with a logical ‘and.’ */
export type UserToManyThreadUserFilter = {
  /** Every related `ThreadUser` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<ThreadUserFilter>;
  /** No related `ThreadUser` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<ThreadUserFilter>;
  /** Some related `ThreadUser` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<ThreadUserFilter>;
};

/** A filter to be used against many `UserTranslation` object types. All fields are combined with a logical ‘and.’ */
export type UserToManyUserTranslationFilter = {
  /** Every related `UserTranslation` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<UserTranslationFilter>;
  /** No related `UserTranslation` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<UserTranslationFilter>;
  /** Some related `UserTranslation` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<UserTranslationFilter>;
};

export type UserToken = {
  __typename?: 'UserToken';
  token?: Maybe<Scalars['String']['output']>;
};

export type UserTranslation = Node & {
  __typename?: 'UserTranslation';
  firstname: Scalars['String']['output'];
  fullname?: Maybe<Scalars['String']['output']>;
  initials?: Maybe<Scalars['String']['output']>;
  lang: Language;
  lastname: Scalars['String']['output'];
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  /** Reads a single `User` that is related to this `UserTranslation`. */
  user?: Maybe<User>;
  userId: Scalars['Int']['output'];
};

/** A condition to be used against `UserTranslation` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type UserTranslationCondition = {
  /** Checks for equality with the object’s `firstname` field. */
  firstname?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `lastname` field. */
  lastname?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `userId` field. */
  userId?: InputMaybe<Scalars['Int']['input']>;
};

/** A filter to be used against `UserTranslation` object types. All fields are combined with a logical ‘and.’ */
export type UserTranslationFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<UserTranslationFilter>>;
  /** Filter by the object’s `firstname` field. */
  firstname?: InputMaybe<StringFilter>;
  /** Filter by the object’s `fullname` field. */
  fullname?: InputMaybe<StringFilter>;
  /** Filter by the object’s `initials` field. */
  initials?: InputMaybe<StringFilter>;
  /** Filter by the object’s `lastname` field. */
  lastname?: InputMaybe<StringFilter>;
  /** Negates the expression. */
  not?: InputMaybe<UserTranslationFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<UserTranslationFilter>>;
  /** Filter by the object’s `user` relation. */
  user?: InputMaybe<UserFilter>;
  /** Filter by the object’s `userId` field. */
  userId?: InputMaybe<IntFilter>;
};

/** An input for mutations affecting `UserTranslation` */
export type UserTranslationInput = {
  firstname: Scalars['String']['input'];
  lang: Language;
  lastname: Scalars['String']['input'];
  user?: InputMaybe<UserTranslationsUserIdFkeyInput>;
  userId?: InputMaybe<Scalars['Int']['input']>;
};

/** The globally unique `ID` look up for the row to connect. */
export type UserTranslationNodeIdConnect = {
  /** The globally unique `ID` which identifies a single `userTranslation` to be connected. */
  nodeId: Scalars['ID']['input'];
};

/** The globally unique `ID` look up for the row to delete. */
export type UserTranslationNodeIdDelete = {
  /** The globally unique `ID` which identifies a single `userTranslation` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** The globally unique `ID` look up for the row to update. */
export type UserTranslationOnUserTranslationForUserTranslationsUserIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `user` to be connected. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `user` being updated. */
  patch: UserPatch;
};

/** The fields on `userTranslation` to look up the row to update. */
export type UserTranslationOnUserTranslationForUserTranslationsUserIdFkeyUsingUserTranslationsPkeyUpdate = {
  lang: Language;
  /** An object where the defined keys will be set on the `userTranslation` being updated. */
  patch: UpdateUserTranslationOnUserTranslationForUserTranslationsUserIdFkeyPatch;
  userId: Scalars['Int']['input'];
};

/** Represents an update to a `UserTranslation`. Fields that are set will be updated. */
export type UserTranslationPatch = {
  firstname?: InputMaybe<Scalars['String']['input']>;
  lastname?: InputMaybe<Scalars['String']['input']>;
  user?: InputMaybe<UserTranslationsUserIdFkeyInput>;
  userId?: InputMaybe<Scalars['Int']['input']>;
};

/** The fields on `userTranslation` to look up the row to connect. */
export type UserTranslationUserTranslationsPkeyConnect = {
  lang: Language;
  userId: Scalars['Int']['input'];
};

/** The fields on `userTranslation` to look up the row to delete. */
export type UserTranslationUserTranslationsPkeyDelete = {
  lang: Language;
  userId: Scalars['Int']['input'];
};

/** A connection to a list of `UserTranslation` values. */
export type UserTranslationsConnection = {
  __typename?: 'UserTranslationsConnection';
  /** A list of edges which contains the `UserTranslation` and cursor to aid in pagination. */
  edges: Array<UserTranslationsEdge>;
  /** A list of `UserTranslation` objects. */
  nodes: Array<UserTranslation>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `UserTranslation` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `UserTranslation` edge in the connection. */
export type UserTranslationsEdge = {
  __typename?: 'UserTranslationsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `UserTranslation` at the end of the edge. */
  node: UserTranslation;
};

/** Methods to use when ordering `UserTranslation`. */
export enum UserTranslationsOrderBy {
  FirstnameAsc = 'FIRSTNAME_ASC',
  FirstnameDesc = 'FIRSTNAME_DESC',
  LastnameAsc = 'LASTNAME_ASC',
  LastnameDesc = 'LASTNAME_DESC',
  Natural = 'NATURAL',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  UserIdAsc = 'USER_ID_ASC',
  UserIdDesc = 'USER_ID_DESC'
}

/** Input for the nested mutation of `user` in the `UserTranslationInput` mutation. */
export type UserTranslationsUserIdFkeyInput = {
  /** The primary key(s) for `user` for the far side of the relationship. */
  connectByEmail?: InputMaybe<UserUsersEmailKeyConnect>;
  /** The primary key(s) for `user` for the far side of the relationship. */
  connectById?: InputMaybe<UserUsersPkeyConnect>;
  /** The primary key(s) for `user` for the far side of the relationship. */
  connectByNodeId?: InputMaybe<UserNodeIdConnect>;
  /** The primary key(s) and patch data for `user` for the far side of the relationship. */
  updateByEmail?: InputMaybe<UserOnUserTranslationForUserTranslationsUserIdFkeyUsingUsersEmailKeyUpdate>;
  /** The primary key(s) and patch data for `user` for the far side of the relationship. */
  updateById?: InputMaybe<UserOnUserTranslationForUserTranslationsUserIdFkeyUsingUsersPkeyUpdate>;
  /** The primary key(s) and patch data for `user` for the far side of the relationship. */
  updateByNodeId?: InputMaybe<UserTranslationOnUserTranslationForUserTranslationsUserIdFkeyNodeIdUpdate>;
};

/** Input for the nested mutation of `userTranslation` in the `UserInput` mutation. */
export type UserTranslationsUserIdFkeyInverseInput = {
  /** The primary key(s) for `userTranslation` for the far side of the relationship. */
  connectByNodeId?: InputMaybe<Array<UserTranslationNodeIdConnect>>;
  /** The primary key(s) for `userTranslation` for the far side of the relationship. */
  connectByUserIdAndLang?: InputMaybe<Array<UserTranslationUserTranslationsPkeyConnect>>;
  /** A `UserTranslationInput` object that will be created and connected to this object. */
  create?: InputMaybe<Array<UserTranslationsUserIdFkeyUserTranslationsCreateInput>>;
  /** The primary key(s) for `userTranslation` for the far side of the relationship. */
  deleteByNodeId?: InputMaybe<Array<UserTranslationNodeIdDelete>>;
  /** The primary key(s) for `userTranslation` for the far side of the relationship. */
  deleteByUserIdAndLang?: InputMaybe<Array<UserTranslationUserTranslationsPkeyDelete>>;
  /** Flag indicating whether all other `userTranslation` records that match this relationship should be removed. */
  deleteOthers?: InputMaybe<Scalars['Boolean']['input']>;
  /** The primary key(s) and patch data for `userTranslation` for the far side of the relationship. */
  updateByNodeId?: InputMaybe<Array<UserOnUserTranslationForUserTranslationsUserIdFkeyNodeIdUpdate>>;
  /** The primary key(s) and patch data for `userTranslation` for the far side of the relationship. */
  updateByUserIdAndLang?: InputMaybe<Array<UserTranslationOnUserTranslationForUserTranslationsUserIdFkeyUsingUserTranslationsPkeyUpdate>>;
};

/** The `userTranslation` to be created by this mutation. */
export type UserTranslationsUserIdFkeyUserTranslationsCreateInput = {
  firstname: Scalars['String']['input'];
  lang: Language;
  lastname: Scalars['String']['input'];
  user?: InputMaybe<UserTranslationsUserIdFkeyInput>;
};

/** The fields on `user` to look up the row to connect. */
export type UserUsersEmailKeyConnect = {
  email: Scalars['String']['input'];
};

/** The fields on `user` to look up the row to connect. */
export type UserUsersPkeyConnect = {
  id: Scalars['Int']['input'];
};

/** A connection to a list of `User` values. */
export type UsersConnection = {
  __typename?: 'UsersConnection';
  /** A list of edges which contains the `User` and cursor to aid in pagination. */
  edges: Array<UsersEdge>;
  /** A list of `User` objects. */
  nodes: Array<User>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `User` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `User` edge in the connection. */
export type UsersEdge = {
  __typename?: 'UsersEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `User` at the end of the edge. */
  node: User;
};

/** Methods to use when ordering `User`. */
export enum UsersOrderBy {
  EmailAsc = 'EMAIL_ASC',
  EmailDesc = 'EMAIL_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  Natural = 'NATURAL',
  PhoneNumberAsc = 'PHONE_NUMBER_ASC',
  PhoneNumberDesc = 'PHONE_NUMBER_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC'
}

/** All input for the `verifyEmail` mutation. */
export type VerifyEmailInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  token: Scalars['UUID']['input'];
};

/** The output of our `verifyEmail` mutation. */
export type VerifyEmailPayload = {
  __typename?: 'VerifyEmailPayload';
  boolean?: Maybe<Scalars['Boolean']['output']>;
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};

export type VerifyPaymentInput = {
  invoiceId: Scalars['Int']['input'];
  refId: Scalars['String']['input'];
};

export type VerifyPaymentPayload = {
  __typename?: 'VerifyPaymentPayload';
  status: Scalars['Boolean']['output'];
};

export type Website = Node & {
  __typename?: 'Website';
  backgroundColor: Scalars['Int']['output'];
  companyUrl?: Maybe<Scalars['String']['output']>;
  coverExternalId?: Maybe<Scalars['UUID']['output']>;
  coverUrl?: Maybe<Scalars['String']['output']>;
  createdAt: Scalars['Datetime']['output'];
  defaultLanguage: Language;
  faviconExternalId?: Maybe<Scalars['UUID']['output']>;
  faviconUrl?: Maybe<Scalars['String']['output']>;
  /** Reads and enables pagination through a set of `WebsiteFile`. */
  files: WebsiteFilesConnection;
  footerCode?: Maybe<Scalars['String']['output']>;
  headerCode?: Maybe<Scalars['String']['output']>;
  headerLayout: Scalars['Int']['output'];
  headlineColor: Scalars['Int']['output'];
  homeBoxes?: Maybe<Scalars['JSON']['output']>;
  host?: Maybe<Scalars['String']['output']>;
  id: Scalars['Int']['output'];
  languages: Array<Maybe<Language>>;
  logoExternalId?: Maybe<Scalars['UUID']['output']>;
  logoUrl?: Maybe<Scalars['String']['output']>;
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  otherSettings?: Maybe<Scalars['JSON']['output']>;
  primaryColor: Scalars['Int']['output'];
  textColor: Scalars['Int']['output'];
  updatedAt: Scalars['Datetime']['output'];
};


export type WebsiteFilesArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<WebsiteFileCondition>;
  filter?: InputMaybe<WebsiteFileFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<WebsiteFilesOrderBy>>;
};

export type WebsiteFile = Node & {
  __typename?: 'WebsiteFile';
  createdAt: Scalars['Datetime']['output'];
  externalId: Scalars['UUID']['output'];
  name: Scalars['String']['output'];
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  url?: Maybe<Scalars['String']['output']>;
  /** Reads a single `Website` that is related to this `WebsiteFile`. */
  website?: Maybe<Website>;
  websiteId: Scalars['Int']['output'];
};

/** A condition to be used against `WebsiteFile` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type WebsiteFileCondition = {
  /** Checks for equality with the object’s `externalId` field. */
  externalId?: InputMaybe<Scalars['UUID']['input']>;
  /** Checks for equality with the object’s `websiteId` field. */
  websiteId?: InputMaybe<Scalars['Int']['input']>;
};

/** A filter to be used against `WebsiteFile` object types. All fields are combined with a logical ‘and.’ */
export type WebsiteFileFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<WebsiteFileFilter>>;
  /** Filter by the object’s `externalId` field. */
  externalId?: InputMaybe<UuidFilter>;
  /** Negates the expression. */
  not?: InputMaybe<WebsiteFileFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<WebsiteFileFilter>>;
  /** Filter by the object’s `website` relation. */
  website?: InputMaybe<WebsiteFilter>;
  /** Filter by the object’s `websiteId` field. */
  websiteId?: InputMaybe<IntFilter>;
};

/** An input for mutations affecting `WebsiteFile` */
export type WebsiteFileInput = {
  externalId: Scalars['UUID']['input'];
  name: Scalars['String']['input'];
  website?: InputMaybe<WebsiteFilesWebsiteIdFkeyInput>;
  websiteId?: InputMaybe<Scalars['Int']['input']>;
};

/** The globally unique `ID` look up for the row to connect. */
export type WebsiteFileNodeIdConnect = {
  /** The globally unique `ID` which identifies a single `websiteFile` to be connected. */
  nodeId: Scalars['ID']['input'];
};

/** The globally unique `ID` look up for the row to delete. */
export type WebsiteFileNodeIdDelete = {
  /** The globally unique `ID` which identifies a single `websiteFile` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** The globally unique `ID` look up for the row to update. */
export type WebsiteFileOnWebsiteFileForWebsiteFilesWebsiteIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `website` to be connected. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `website` being updated. */
  patch: WebsitePatch;
};

/** The fields on `websiteFile` to look up the row to update. */
export type WebsiteFileOnWebsiteFileForWebsiteFilesWebsiteIdFkeyUsingWebsiteFilesPkeyUpdate = {
  externalId: Scalars['UUID']['input'];
  /** An object where the defined keys will be set on the `websiteFile` being updated. */
  patch: UpdateWebsiteFileOnWebsiteFileForWebsiteFilesWebsiteIdFkeyPatch;
};

/** Represents an update to a `WebsiteFile`. Fields that are set will be updated. */
export type WebsiteFilePatch = {
  website?: InputMaybe<WebsiteFilesWebsiteIdFkeyInput>;
  websiteId?: InputMaybe<Scalars['Int']['input']>;
};

/** The fields on `websiteFile` to look up the row to connect. */
export type WebsiteFileWebsiteFilesPkeyConnect = {
  externalId: Scalars['UUID']['input'];
};

/** The fields on `websiteFile` to look up the row to delete. */
export type WebsiteFileWebsiteFilesPkeyDelete = {
  externalId: Scalars['UUID']['input'];
};

/** A connection to a list of `WebsiteFile` values. */
export type WebsiteFilesConnection = {
  __typename?: 'WebsiteFilesConnection';
  /** A list of edges which contains the `WebsiteFile` and cursor to aid in pagination. */
  edges: Array<WebsiteFilesEdge>;
  /** A list of `WebsiteFile` objects. */
  nodes: Array<WebsiteFile>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `WebsiteFile` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `WebsiteFile` edge in the connection. */
export type WebsiteFilesEdge = {
  __typename?: 'WebsiteFilesEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `WebsiteFile` at the end of the edge. */
  node: WebsiteFile;
};

/** Methods to use when ordering `WebsiteFile`. */
export enum WebsiteFilesOrderBy {
  ExternalIdAsc = 'EXTERNAL_ID_ASC',
  ExternalIdDesc = 'EXTERNAL_ID_DESC',
  Natural = 'NATURAL',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  WebsiteIdAsc = 'WEBSITE_ID_ASC',
  WebsiteIdDesc = 'WEBSITE_ID_DESC'
}

/** Input for the nested mutation of `website` in the `WebsiteFileInput` mutation. */
export type WebsiteFilesWebsiteIdFkeyInput = {
  /** The primary key(s) for `website` for the far side of the relationship. */
  connectByHost?: InputMaybe<WebsiteWebsitesHostKeyConnect>;
  /** The primary key(s) for `website` for the far side of the relationship. */
  connectById?: InputMaybe<WebsiteWebsitesPkeyConnect>;
  /** The primary key(s) for `website` for the far side of the relationship. */
  connectByNodeId?: InputMaybe<WebsiteNodeIdConnect>;
  /** The primary key(s) and patch data for `website` for the far side of the relationship. */
  updateByHost?: InputMaybe<WebsiteOnWebsiteFileForWebsiteFilesWebsiteIdFkeyUsingWebsitesHostKeyUpdate>;
  /** The primary key(s) and patch data for `website` for the far side of the relationship. */
  updateById?: InputMaybe<WebsiteOnWebsiteFileForWebsiteFilesWebsiteIdFkeyUsingWebsitesPkeyUpdate>;
  /** The primary key(s) and patch data for `website` for the far side of the relationship. */
  updateByNodeId?: InputMaybe<WebsiteFileOnWebsiteFileForWebsiteFilesWebsiteIdFkeyNodeIdUpdate>;
};

/** Input for the nested mutation of `websiteFile` in the `WebsiteInput` mutation. */
export type WebsiteFilesWebsiteIdFkeyInverseInput = {
  /** The primary key(s) for `websiteFile` for the far side of the relationship. */
  connectByExternalId?: InputMaybe<Array<WebsiteFileWebsiteFilesPkeyConnect>>;
  /** The primary key(s) for `websiteFile` for the far side of the relationship. */
  connectByNodeId?: InputMaybe<Array<WebsiteFileNodeIdConnect>>;
  /** A `WebsiteFileInput` object that will be created and connected to this object. */
  create?: InputMaybe<Array<WebsiteFilesWebsiteIdFkeyWebsiteFilesCreateInput>>;
  /** The primary key(s) for `websiteFile` for the far side of the relationship. */
  deleteByExternalId?: InputMaybe<Array<WebsiteFileWebsiteFilesPkeyDelete>>;
  /** The primary key(s) for `websiteFile` for the far side of the relationship. */
  deleteByNodeId?: InputMaybe<Array<WebsiteFileNodeIdDelete>>;
  /** Flag indicating whether all other `websiteFile` records that match this relationship should be removed. */
  deleteOthers?: InputMaybe<Scalars['Boolean']['input']>;
  /** The primary key(s) and patch data for `websiteFile` for the far side of the relationship. */
  updateByExternalId?: InputMaybe<Array<WebsiteFileOnWebsiteFileForWebsiteFilesWebsiteIdFkeyUsingWebsiteFilesPkeyUpdate>>;
  /** The primary key(s) and patch data for `websiteFile` for the far side of the relationship. */
  updateByNodeId?: InputMaybe<Array<WebsiteOnWebsiteFileForWebsiteFilesWebsiteIdFkeyNodeIdUpdate>>;
};

/** The `websiteFile` to be created by this mutation. */
export type WebsiteFilesWebsiteIdFkeyWebsiteFilesCreateInput = {
  externalId: Scalars['UUID']['input'];
  name: Scalars['String']['input'];
  website?: InputMaybe<WebsiteFilesWebsiteIdFkeyInput>;
};

/** A filter to be used against `Website` object types. All fields are combined with a logical ‘and.’ */
export type WebsiteFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<WebsiteFilter>>;
  /** Filter by the object’s `files` relation. */
  files?: InputMaybe<WebsiteToManyWebsiteFileFilter>;
  /** Some related `files` exist. */
  filesExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `host` field. */
  host?: InputMaybe<StringFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<IntFilter>;
  /** Negates the expression. */
  not?: InputMaybe<WebsiteFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<WebsiteFilter>>;
};

/** The globally unique `ID` look up for the row to connect. */
export type WebsiteNodeIdConnect = {
  /** The globally unique `ID` which identifies a single `website` to be connected. */
  nodeId: Scalars['ID']['input'];
};

/** The globally unique `ID` look up for the row to update. */
export type WebsiteOnWebsiteFileForWebsiteFilesWebsiteIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `websiteFile` to be connected. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `websiteFile` being updated. */
  patch: WebsiteFilePatch;
};

/** The fields on `website` to look up the row to update. */
export type WebsiteOnWebsiteFileForWebsiteFilesWebsiteIdFkeyUsingWebsitesHostKeyUpdate = {
  host: Scalars['String']['input'];
  /** An object where the defined keys will be set on the `website` being updated. */
  patch: UpdateWebsiteOnWebsiteFileForWebsiteFilesWebsiteIdFkeyPatch;
};

/** The fields on `website` to look up the row to update. */
export type WebsiteOnWebsiteFileForWebsiteFilesWebsiteIdFkeyUsingWebsitesPkeyUpdate = {
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `website` being updated. */
  patch: UpdateWebsiteOnWebsiteFileForWebsiteFilesWebsiteIdFkeyPatch;
};

/** Represents an update to a `Website`. Fields that are set will be updated. */
export type WebsitePatch = {
  backgroundColor?: InputMaybe<Scalars['Int']['input']>;
  companyUrl?: InputMaybe<Scalars['String']['input']>;
  coverExternalId?: InputMaybe<Scalars['UUID']['input']>;
  defaultLanguage?: InputMaybe<Language>;
  faviconExternalId?: InputMaybe<Scalars['UUID']['input']>;
  files?: InputMaybe<WebsiteFilesWebsiteIdFkeyInverseInput>;
  footerCode?: InputMaybe<Scalars['String']['input']>;
  headerCode?: InputMaybe<Scalars['String']['input']>;
  headerLayout?: InputMaybe<Scalars['Int']['input']>;
  headlineColor?: InputMaybe<Scalars['Int']['input']>;
  homeBoxes?: InputMaybe<Scalars['JSON']['input']>;
  host?: InputMaybe<Scalars['String']['input']>;
  languages?: InputMaybe<Array<InputMaybe<Language>>>;
  logoExternalId?: InputMaybe<Scalars['UUID']['input']>;
  otherSettings?: InputMaybe<Scalars['JSON']['input']>;
  primaryColor?: InputMaybe<Scalars['Int']['input']>;
  textColor?: InputMaybe<Scalars['Int']['input']>;
};

export type WebsitePatch__ = {
  files?: InputMaybe<Array<WebsiteFileInput>>;
  homeBoxes?: InputMaybe<Scalars['JSON']['input']>;
};

/** A filter to be used against many `WebsiteFile` object types. All fields are combined with a logical ‘and.’ */
export type WebsiteToManyWebsiteFileFilter = {
  /** Every related `WebsiteFile` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<WebsiteFileFilter>;
  /** No related `WebsiteFile` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<WebsiteFileFilter>;
  /** Some related `WebsiteFile` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<WebsiteFileFilter>;
};

/** The fields on `website` to look up the row to connect. */
export type WebsiteWebsitesHostKeyConnect = {
  host: Scalars['String']['input'];
};

/** The fields on `website` to look up the row to connect. */
export type WebsiteWebsitesPkeyConnect = {
  id: Scalars['Int']['input'];
};

/** A `Website` edge in the connection. */
export type WebsitesEdge = {
  __typename?: 'WebsitesEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Website` at the end of the edge. */
  node: Website;
};

/** Methods to use when ordering `Website`. */
export enum WebsitesOrderBy {
  HostAsc = 'HOST_ASC',
  HostDesc = 'HOST_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  Natural = 'NATURAL',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC'
}

/** An object where the defined keys will be set on the `candidateFile` being updated. */
export type UpdateCandidateFileOnCandidateFileForCandidateFilesCandidateIdFkeyPatch = {
  candidate?: InputMaybe<CandidateFilesCandidateIdFkeyInput>;
  candidateQuestions?: InputMaybe<CandidateQuestionsFileValueExternalIdFkeyInverseInput>;
};

/** An object where the defined keys will be set on the `candidateFile` being updated. */
export type UpdateCandidateFileOnCandidateQuestionForCandidateQuestionsFileValueExternalIdFkeyPatch = {
  candidate?: InputMaybe<CandidateFilesCandidateIdFkeyInput>;
  candidateId?: InputMaybe<Scalars['Int']['input']>;
  candidateQuestions?: InputMaybe<CandidateQuestionsFileValueExternalIdFkeyInverseInput>;
};

/** An object where the defined keys will be set on the `candidateImportCandidate` being updated. */
export type UpdateCandidateImportCandidateOnCandidateImportCandidateForCandidateImportCandidatesCandidateIdFkeyPatch = {
  candidate?: InputMaybe<CandidateImportCandidatesCandidateIdFkeyInput>;
  candidateImport?: InputMaybe<CandidateImportCandidatesCandidateImportIdFkeyInput>;
  candidateImportId?: InputMaybe<Scalars['Int']['input']>;
};

/** An object where the defined keys will be set on the `candidateImportCandidate` being updated. */
export type UpdateCandidateImportCandidateOnCandidateImportCandidateForCandidateImportCandidatesCandidateImportIdFkeyPatch = {
  candidate?: InputMaybe<CandidateImportCandidatesCandidateIdFkeyInput>;
  candidateId?: InputMaybe<Scalars['Int']['input']>;
  candidateImport?: InputMaybe<CandidateImportCandidatesCandidateImportIdFkeyInput>;
};

/** An object where the defined keys will be set on the `candidateImportFile` being updated. */
export type UpdateCandidateImportFileOnCandidateImportFileForCandidateImportFilesCandidateImportIdFkeyPatch = {
  candidateImport?: InputMaybe<CandidateImportFilesCandidateImportIdFkeyInput>;
};

/** An object where the defined keys will be set on the `candidateImport` being updated. */
export type UpdateCandidateImportOnCandidateImportCandidateForCandidateImportCandidatesCandidateImportIdFkeyPatch = {
  candidateImportCandidates?: InputMaybe<CandidateImportCandidatesCandidateImportIdFkeyInverseInput>;
  files?: InputMaybe<CandidateImportFilesCandidateImportIdFkeyInverseInput>;
};

/** An object where the defined keys will be set on the `candidateImport` being updated. */
export type UpdateCandidateImportOnCandidateImportFileForCandidateImportFilesCandidateImportIdFkeyPatch = {
  candidateImportCandidates?: InputMaybe<CandidateImportCandidatesCandidateImportIdFkeyInverseInput>;
  files?: InputMaybe<CandidateImportFilesCandidateImportIdFkeyInverseInput>;
};

/** An object where the defined keys will be set on the `candidate` being updated. */
export type UpdateCandidateOnCandidateFileForCandidateFilesCandidateIdFkeyPatch = {
  birthday?: InputMaybe<Scalars['Date']['input']>;
  candidateDraftEvaluations?: InputMaybe<DraftEvaluationsCandidateIdFkeyInverseInput>;
  candidateEventDraftEvaluations?: InputMaybe<EventDraftEvaluationsCandidateIdFkeyInverseInput>;
  candidateImportCandidate?: InputMaybe<CandidateImportCandidatesCandidateIdFkeyInverseInput>;
  candidateQuestionnaires?: InputMaybe<CandidateQuestionnairesCandidateIdFkeyInverseInput>;
  candidateQuestions?: InputMaybe<CandidateQuestionsCandidateIdFkeyInverseInput>;
  candidateTags?: InputMaybe<CandidateTagsCandidateIdFkeyInverseInput>;
  emails?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  evaluations?: InputMaybe<EvaluationsCandidateIdFkeyInverseInput>;
  eventCandidates?: InputMaybe<EventCandidatesCandidateIdFkeyInverseInput>;
  files?: InputMaybe<CandidateFilesCandidateIdFkeyInverseInput>;
  gender?: InputMaybe<Gender>;
  jobsApplications?: InputMaybe<JobsApplicationsCandidateIdFkeyInverseInput>;
  language?: InputMaybe<Language>;
  links?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  militaryStatus?: InputMaybe<MilitaryStatus>;
  phones?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  photoExternalId?: InputMaybe<Scalars['UUID']['input']>;
  resumeExternalId?: InputMaybe<Scalars['UUID']['input']>;
  socialLinks?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  sources?: InputMaybe<Array<Scalars['String']['input']>>;
  tags?: InputMaybe<Array<Scalars['String']['input']>>;
  threads?: InputMaybe<ThreadsCandidateIdFkeyInverseInput>;
  translations?: InputMaybe<CandidateTranslationsCandidateIdFkeyInverseInput>;
};

/** An object where the defined keys will be set on the `candidate` being updated. */
export type UpdateCandidateOnCandidateImportCandidateForCandidateImportCandidatesCandidateIdFkeyPatch = {
  birthday?: InputMaybe<Scalars['Date']['input']>;
  candidateDraftEvaluations?: InputMaybe<DraftEvaluationsCandidateIdFkeyInverseInput>;
  candidateEventDraftEvaluations?: InputMaybe<EventDraftEvaluationsCandidateIdFkeyInverseInput>;
  candidateImportCandidate?: InputMaybe<CandidateImportCandidatesCandidateIdFkeyInverseInput>;
  candidateQuestionnaires?: InputMaybe<CandidateQuestionnairesCandidateIdFkeyInverseInput>;
  candidateQuestions?: InputMaybe<CandidateQuestionsCandidateIdFkeyInverseInput>;
  candidateTags?: InputMaybe<CandidateTagsCandidateIdFkeyInverseInput>;
  emails?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  evaluations?: InputMaybe<EvaluationsCandidateIdFkeyInverseInput>;
  eventCandidates?: InputMaybe<EventCandidatesCandidateIdFkeyInverseInput>;
  files?: InputMaybe<CandidateFilesCandidateIdFkeyInverseInput>;
  gender?: InputMaybe<Gender>;
  jobsApplications?: InputMaybe<JobsApplicationsCandidateIdFkeyInverseInput>;
  language?: InputMaybe<Language>;
  links?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  militaryStatus?: InputMaybe<MilitaryStatus>;
  phones?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  photoExternalId?: InputMaybe<Scalars['UUID']['input']>;
  resumeExternalId?: InputMaybe<Scalars['UUID']['input']>;
  socialLinks?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  sources?: InputMaybe<Array<Scalars['String']['input']>>;
  tags?: InputMaybe<Array<Scalars['String']['input']>>;
  threads?: InputMaybe<ThreadsCandidateIdFkeyInverseInput>;
  translations?: InputMaybe<CandidateTranslationsCandidateIdFkeyInverseInput>;
};

/** An object where the defined keys will be set on the `candidate` being updated. */
export type UpdateCandidateOnCandidateQuestionForCandidateQuestionsCandidateIdFkeyPatch = {
  birthday?: InputMaybe<Scalars['Date']['input']>;
  candidateDraftEvaluations?: InputMaybe<DraftEvaluationsCandidateIdFkeyInverseInput>;
  candidateEventDraftEvaluations?: InputMaybe<EventDraftEvaluationsCandidateIdFkeyInverseInput>;
  candidateImportCandidate?: InputMaybe<CandidateImportCandidatesCandidateIdFkeyInverseInput>;
  candidateQuestionnaires?: InputMaybe<CandidateQuestionnairesCandidateIdFkeyInverseInput>;
  candidateQuestions?: InputMaybe<CandidateQuestionsCandidateIdFkeyInverseInput>;
  candidateTags?: InputMaybe<CandidateTagsCandidateIdFkeyInverseInput>;
  emails?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  evaluations?: InputMaybe<EvaluationsCandidateIdFkeyInverseInput>;
  eventCandidates?: InputMaybe<EventCandidatesCandidateIdFkeyInverseInput>;
  files?: InputMaybe<CandidateFilesCandidateIdFkeyInverseInput>;
  gender?: InputMaybe<Gender>;
  jobsApplications?: InputMaybe<JobsApplicationsCandidateIdFkeyInverseInput>;
  language?: InputMaybe<Language>;
  links?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  militaryStatus?: InputMaybe<MilitaryStatus>;
  phones?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  photoExternalId?: InputMaybe<Scalars['UUID']['input']>;
  resumeExternalId?: InputMaybe<Scalars['UUID']['input']>;
  socialLinks?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  sources?: InputMaybe<Array<Scalars['String']['input']>>;
  tags?: InputMaybe<Array<Scalars['String']['input']>>;
  threads?: InputMaybe<ThreadsCandidateIdFkeyInverseInput>;
  translations?: InputMaybe<CandidateTranslationsCandidateIdFkeyInverseInput>;
};

/** An object where the defined keys will be set on the `candidate` being updated. */
export type UpdateCandidateOnCandidateQuestionnaireForCandidateQuestionnairesCandidateIdFkeyPatch = {
  birthday?: InputMaybe<Scalars['Date']['input']>;
  candidateDraftEvaluations?: InputMaybe<DraftEvaluationsCandidateIdFkeyInverseInput>;
  candidateEventDraftEvaluations?: InputMaybe<EventDraftEvaluationsCandidateIdFkeyInverseInput>;
  candidateImportCandidate?: InputMaybe<CandidateImportCandidatesCandidateIdFkeyInverseInput>;
  candidateQuestionnaires?: InputMaybe<CandidateQuestionnairesCandidateIdFkeyInverseInput>;
  candidateQuestions?: InputMaybe<CandidateQuestionsCandidateIdFkeyInverseInput>;
  candidateTags?: InputMaybe<CandidateTagsCandidateIdFkeyInverseInput>;
  emails?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  evaluations?: InputMaybe<EvaluationsCandidateIdFkeyInverseInput>;
  eventCandidates?: InputMaybe<EventCandidatesCandidateIdFkeyInverseInput>;
  files?: InputMaybe<CandidateFilesCandidateIdFkeyInverseInput>;
  gender?: InputMaybe<Gender>;
  jobsApplications?: InputMaybe<JobsApplicationsCandidateIdFkeyInverseInput>;
  language?: InputMaybe<Language>;
  links?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  militaryStatus?: InputMaybe<MilitaryStatus>;
  phones?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  photoExternalId?: InputMaybe<Scalars['UUID']['input']>;
  resumeExternalId?: InputMaybe<Scalars['UUID']['input']>;
  socialLinks?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  sources?: InputMaybe<Array<Scalars['String']['input']>>;
  tags?: InputMaybe<Array<Scalars['String']['input']>>;
  threads?: InputMaybe<ThreadsCandidateIdFkeyInverseInput>;
  translations?: InputMaybe<CandidateTranslationsCandidateIdFkeyInverseInput>;
};

/** An object where the defined keys will be set on the `candidate` being updated. */
export type UpdateCandidateOnCandidateTagForCandidateTagsCandidateIdFkeyPatch = {
  birthday?: InputMaybe<Scalars['Date']['input']>;
  candidateDraftEvaluations?: InputMaybe<DraftEvaluationsCandidateIdFkeyInverseInput>;
  candidateEventDraftEvaluations?: InputMaybe<EventDraftEvaluationsCandidateIdFkeyInverseInput>;
  candidateImportCandidate?: InputMaybe<CandidateImportCandidatesCandidateIdFkeyInverseInput>;
  candidateQuestionnaires?: InputMaybe<CandidateQuestionnairesCandidateIdFkeyInverseInput>;
  candidateQuestions?: InputMaybe<CandidateQuestionsCandidateIdFkeyInverseInput>;
  candidateTags?: InputMaybe<CandidateTagsCandidateIdFkeyInverseInput>;
  emails?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  evaluations?: InputMaybe<EvaluationsCandidateIdFkeyInverseInput>;
  eventCandidates?: InputMaybe<EventCandidatesCandidateIdFkeyInverseInput>;
  files?: InputMaybe<CandidateFilesCandidateIdFkeyInverseInput>;
  gender?: InputMaybe<Gender>;
  jobsApplications?: InputMaybe<JobsApplicationsCandidateIdFkeyInverseInput>;
  language?: InputMaybe<Language>;
  links?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  militaryStatus?: InputMaybe<MilitaryStatus>;
  phones?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  photoExternalId?: InputMaybe<Scalars['UUID']['input']>;
  resumeExternalId?: InputMaybe<Scalars['UUID']['input']>;
  socialLinks?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  sources?: InputMaybe<Array<Scalars['String']['input']>>;
  tags?: InputMaybe<Array<Scalars['String']['input']>>;
  threads?: InputMaybe<ThreadsCandidateIdFkeyInverseInput>;
  translations?: InputMaybe<CandidateTranslationsCandidateIdFkeyInverseInput>;
};

/** An object where the defined keys will be set on the `candidate` being updated. */
export type UpdateCandidateOnCandidateTranslationForCandidateTranslationsCandidateIdFkeyPatch = {
  birthday?: InputMaybe<Scalars['Date']['input']>;
  candidateDraftEvaluations?: InputMaybe<DraftEvaluationsCandidateIdFkeyInverseInput>;
  candidateEventDraftEvaluations?: InputMaybe<EventDraftEvaluationsCandidateIdFkeyInverseInput>;
  candidateImportCandidate?: InputMaybe<CandidateImportCandidatesCandidateIdFkeyInverseInput>;
  candidateQuestionnaires?: InputMaybe<CandidateQuestionnairesCandidateIdFkeyInverseInput>;
  candidateQuestions?: InputMaybe<CandidateQuestionsCandidateIdFkeyInverseInput>;
  candidateTags?: InputMaybe<CandidateTagsCandidateIdFkeyInverseInput>;
  emails?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  evaluations?: InputMaybe<EvaluationsCandidateIdFkeyInverseInput>;
  eventCandidates?: InputMaybe<EventCandidatesCandidateIdFkeyInverseInput>;
  files?: InputMaybe<CandidateFilesCandidateIdFkeyInverseInput>;
  gender?: InputMaybe<Gender>;
  jobsApplications?: InputMaybe<JobsApplicationsCandidateIdFkeyInverseInput>;
  language?: InputMaybe<Language>;
  links?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  militaryStatus?: InputMaybe<MilitaryStatus>;
  phones?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  photoExternalId?: InputMaybe<Scalars['UUID']['input']>;
  resumeExternalId?: InputMaybe<Scalars['UUID']['input']>;
  socialLinks?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  sources?: InputMaybe<Array<Scalars['String']['input']>>;
  tags?: InputMaybe<Array<Scalars['String']['input']>>;
  threads?: InputMaybe<ThreadsCandidateIdFkeyInverseInput>;
  translations?: InputMaybe<CandidateTranslationsCandidateIdFkeyInverseInput>;
};

/** An object where the defined keys will be set on the `candidate` being updated. */
export type UpdateCandidateOnDraftEvaluationForDraftEvaluationsCandidateIdFkeyPatch = {
  birthday?: InputMaybe<Scalars['Date']['input']>;
  candidateDraftEvaluations?: InputMaybe<DraftEvaluationsCandidateIdFkeyInverseInput>;
  candidateEventDraftEvaluations?: InputMaybe<EventDraftEvaluationsCandidateIdFkeyInverseInput>;
  candidateImportCandidate?: InputMaybe<CandidateImportCandidatesCandidateIdFkeyInverseInput>;
  candidateQuestionnaires?: InputMaybe<CandidateQuestionnairesCandidateIdFkeyInverseInput>;
  candidateQuestions?: InputMaybe<CandidateQuestionsCandidateIdFkeyInverseInput>;
  candidateTags?: InputMaybe<CandidateTagsCandidateIdFkeyInverseInput>;
  emails?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  evaluations?: InputMaybe<EvaluationsCandidateIdFkeyInverseInput>;
  eventCandidates?: InputMaybe<EventCandidatesCandidateIdFkeyInverseInput>;
  files?: InputMaybe<CandidateFilesCandidateIdFkeyInverseInput>;
  gender?: InputMaybe<Gender>;
  jobsApplications?: InputMaybe<JobsApplicationsCandidateIdFkeyInverseInput>;
  language?: InputMaybe<Language>;
  links?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  militaryStatus?: InputMaybe<MilitaryStatus>;
  phones?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  photoExternalId?: InputMaybe<Scalars['UUID']['input']>;
  resumeExternalId?: InputMaybe<Scalars['UUID']['input']>;
  socialLinks?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  sources?: InputMaybe<Array<Scalars['String']['input']>>;
  tags?: InputMaybe<Array<Scalars['String']['input']>>;
  threads?: InputMaybe<ThreadsCandidateIdFkeyInverseInput>;
  translations?: InputMaybe<CandidateTranslationsCandidateIdFkeyInverseInput>;
};

/** An object where the defined keys will be set on the `candidate` being updated. */
export type UpdateCandidateOnEvaluationForEvaluationsCandidateIdFkeyPatch = {
  birthday?: InputMaybe<Scalars['Date']['input']>;
  candidateDraftEvaluations?: InputMaybe<DraftEvaluationsCandidateIdFkeyInverseInput>;
  candidateEventDraftEvaluations?: InputMaybe<EventDraftEvaluationsCandidateIdFkeyInverseInput>;
  candidateImportCandidate?: InputMaybe<CandidateImportCandidatesCandidateIdFkeyInverseInput>;
  candidateQuestionnaires?: InputMaybe<CandidateQuestionnairesCandidateIdFkeyInverseInput>;
  candidateQuestions?: InputMaybe<CandidateQuestionsCandidateIdFkeyInverseInput>;
  candidateTags?: InputMaybe<CandidateTagsCandidateIdFkeyInverseInput>;
  emails?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  evaluations?: InputMaybe<EvaluationsCandidateIdFkeyInverseInput>;
  eventCandidates?: InputMaybe<EventCandidatesCandidateIdFkeyInverseInput>;
  files?: InputMaybe<CandidateFilesCandidateIdFkeyInverseInput>;
  gender?: InputMaybe<Gender>;
  jobsApplications?: InputMaybe<JobsApplicationsCandidateIdFkeyInverseInput>;
  language?: InputMaybe<Language>;
  links?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  militaryStatus?: InputMaybe<MilitaryStatus>;
  phones?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  photoExternalId?: InputMaybe<Scalars['UUID']['input']>;
  resumeExternalId?: InputMaybe<Scalars['UUID']['input']>;
  socialLinks?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  sources?: InputMaybe<Array<Scalars['String']['input']>>;
  tags?: InputMaybe<Array<Scalars['String']['input']>>;
  threads?: InputMaybe<ThreadsCandidateIdFkeyInverseInput>;
  translations?: InputMaybe<CandidateTranslationsCandidateIdFkeyInverseInput>;
};

/** An object where the defined keys will be set on the `candidate` being updated. */
export type UpdateCandidateOnEventCandidateForEventCandidatesCandidateIdFkeyPatch = {
  birthday?: InputMaybe<Scalars['Date']['input']>;
  candidateDraftEvaluations?: InputMaybe<DraftEvaluationsCandidateIdFkeyInverseInput>;
  candidateEventDraftEvaluations?: InputMaybe<EventDraftEvaluationsCandidateIdFkeyInverseInput>;
  candidateImportCandidate?: InputMaybe<CandidateImportCandidatesCandidateIdFkeyInverseInput>;
  candidateQuestionnaires?: InputMaybe<CandidateQuestionnairesCandidateIdFkeyInverseInput>;
  candidateQuestions?: InputMaybe<CandidateQuestionsCandidateIdFkeyInverseInput>;
  candidateTags?: InputMaybe<CandidateTagsCandidateIdFkeyInverseInput>;
  emails?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  evaluations?: InputMaybe<EvaluationsCandidateIdFkeyInverseInput>;
  eventCandidates?: InputMaybe<EventCandidatesCandidateIdFkeyInverseInput>;
  files?: InputMaybe<CandidateFilesCandidateIdFkeyInverseInput>;
  gender?: InputMaybe<Gender>;
  jobsApplications?: InputMaybe<JobsApplicationsCandidateIdFkeyInverseInput>;
  language?: InputMaybe<Language>;
  links?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  militaryStatus?: InputMaybe<MilitaryStatus>;
  phones?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  photoExternalId?: InputMaybe<Scalars['UUID']['input']>;
  resumeExternalId?: InputMaybe<Scalars['UUID']['input']>;
  socialLinks?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  sources?: InputMaybe<Array<Scalars['String']['input']>>;
  tags?: InputMaybe<Array<Scalars['String']['input']>>;
  threads?: InputMaybe<ThreadsCandidateIdFkeyInverseInput>;
  translations?: InputMaybe<CandidateTranslationsCandidateIdFkeyInverseInput>;
};

/** An object where the defined keys will be set on the `candidate` being updated. */
export type UpdateCandidateOnEventDraftEvaluationForEventDraftEvaluationsCandidateIdFkeyPatch = {
  birthday?: InputMaybe<Scalars['Date']['input']>;
  candidateDraftEvaluations?: InputMaybe<DraftEvaluationsCandidateIdFkeyInverseInput>;
  candidateEventDraftEvaluations?: InputMaybe<EventDraftEvaluationsCandidateIdFkeyInverseInput>;
  candidateImportCandidate?: InputMaybe<CandidateImportCandidatesCandidateIdFkeyInverseInput>;
  candidateQuestionnaires?: InputMaybe<CandidateQuestionnairesCandidateIdFkeyInverseInput>;
  candidateQuestions?: InputMaybe<CandidateQuestionsCandidateIdFkeyInverseInput>;
  candidateTags?: InputMaybe<CandidateTagsCandidateIdFkeyInverseInput>;
  emails?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  evaluations?: InputMaybe<EvaluationsCandidateIdFkeyInverseInput>;
  eventCandidates?: InputMaybe<EventCandidatesCandidateIdFkeyInverseInput>;
  files?: InputMaybe<CandidateFilesCandidateIdFkeyInverseInput>;
  gender?: InputMaybe<Gender>;
  jobsApplications?: InputMaybe<JobsApplicationsCandidateIdFkeyInverseInput>;
  language?: InputMaybe<Language>;
  links?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  militaryStatus?: InputMaybe<MilitaryStatus>;
  phones?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  photoExternalId?: InputMaybe<Scalars['UUID']['input']>;
  resumeExternalId?: InputMaybe<Scalars['UUID']['input']>;
  socialLinks?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  sources?: InputMaybe<Array<Scalars['String']['input']>>;
  tags?: InputMaybe<Array<Scalars['String']['input']>>;
  threads?: InputMaybe<ThreadsCandidateIdFkeyInverseInput>;
  translations?: InputMaybe<CandidateTranslationsCandidateIdFkeyInverseInput>;
};

/** An object where the defined keys will be set on the `candidate` being updated. */
export type UpdateCandidateOnJobsApplicationForJobsApplicationsCandidateIdFkeyPatch = {
  birthday?: InputMaybe<Scalars['Date']['input']>;
  candidateDraftEvaluations?: InputMaybe<DraftEvaluationsCandidateIdFkeyInverseInput>;
  candidateEventDraftEvaluations?: InputMaybe<EventDraftEvaluationsCandidateIdFkeyInverseInput>;
  candidateImportCandidate?: InputMaybe<CandidateImportCandidatesCandidateIdFkeyInverseInput>;
  candidateQuestionnaires?: InputMaybe<CandidateQuestionnairesCandidateIdFkeyInverseInput>;
  candidateQuestions?: InputMaybe<CandidateQuestionsCandidateIdFkeyInverseInput>;
  candidateTags?: InputMaybe<CandidateTagsCandidateIdFkeyInverseInput>;
  emails?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  evaluations?: InputMaybe<EvaluationsCandidateIdFkeyInverseInput>;
  eventCandidates?: InputMaybe<EventCandidatesCandidateIdFkeyInverseInput>;
  files?: InputMaybe<CandidateFilesCandidateIdFkeyInverseInput>;
  gender?: InputMaybe<Gender>;
  jobsApplications?: InputMaybe<JobsApplicationsCandidateIdFkeyInverseInput>;
  language?: InputMaybe<Language>;
  links?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  militaryStatus?: InputMaybe<MilitaryStatus>;
  phones?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  photoExternalId?: InputMaybe<Scalars['UUID']['input']>;
  resumeExternalId?: InputMaybe<Scalars['UUID']['input']>;
  socialLinks?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  sources?: InputMaybe<Array<Scalars['String']['input']>>;
  tags?: InputMaybe<Array<Scalars['String']['input']>>;
  threads?: InputMaybe<ThreadsCandidateIdFkeyInverseInput>;
  translations?: InputMaybe<CandidateTranslationsCandidateIdFkeyInverseInput>;
};

/** An object where the defined keys will be set on the `candidate` being updated. */
export type UpdateCandidateOnThreadForThreadsCandidateIdFkeyPatch = {
  birthday?: InputMaybe<Scalars['Date']['input']>;
  candidateDraftEvaluations?: InputMaybe<DraftEvaluationsCandidateIdFkeyInverseInput>;
  candidateEventDraftEvaluations?: InputMaybe<EventDraftEvaluationsCandidateIdFkeyInverseInput>;
  candidateImportCandidate?: InputMaybe<CandidateImportCandidatesCandidateIdFkeyInverseInput>;
  candidateQuestionnaires?: InputMaybe<CandidateQuestionnairesCandidateIdFkeyInverseInput>;
  candidateQuestions?: InputMaybe<CandidateQuestionsCandidateIdFkeyInverseInput>;
  candidateTags?: InputMaybe<CandidateTagsCandidateIdFkeyInverseInput>;
  emails?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  evaluations?: InputMaybe<EvaluationsCandidateIdFkeyInverseInput>;
  eventCandidates?: InputMaybe<EventCandidatesCandidateIdFkeyInverseInput>;
  files?: InputMaybe<CandidateFilesCandidateIdFkeyInverseInput>;
  gender?: InputMaybe<Gender>;
  jobsApplications?: InputMaybe<JobsApplicationsCandidateIdFkeyInverseInput>;
  language?: InputMaybe<Language>;
  links?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  militaryStatus?: InputMaybe<MilitaryStatus>;
  phones?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  photoExternalId?: InputMaybe<Scalars['UUID']['input']>;
  resumeExternalId?: InputMaybe<Scalars['UUID']['input']>;
  socialLinks?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  sources?: InputMaybe<Array<Scalars['String']['input']>>;
  tags?: InputMaybe<Array<Scalars['String']['input']>>;
  threads?: InputMaybe<ThreadsCandidateIdFkeyInverseInput>;
  translations?: InputMaybe<CandidateTranslationsCandidateIdFkeyInverseInput>;
};

/** An object where the defined keys will be set on the `candidateQuestion` being updated. */
export type UpdateCandidateQuestionOnCandidateQuestionForCandidateQuestionsCandidateIdFkeyPatch = {
  booleanValue?: InputMaybe<Scalars['Boolean']['input']>;
  candidate?: InputMaybe<CandidateQuestionsCandidateIdFkeyInput>;
  candidateFile?: InputMaybe<CandidateQuestionsFileValueExternalIdFkeyInput>;
  dateValue?: InputMaybe<Scalars['Datetime']['input']>;
  evaluation?: InputMaybe<CandidateQuestionsEvaluationIdFkeyInput>;
  evaluationId?: InputMaybe<Scalars['Int']['input']>;
  fileValueExternalId?: InputMaybe<Scalars['UUID']['input']>;
  numberValue?: InputMaybe<Scalars['Int']['input']>;
  question?: InputMaybe<CandidateQuestionsQuestionIdFkeyInput>;
  questionId?: InputMaybe<Scalars['Int']['input']>;
  questionOption?: InputMaybe<CandidateQuestionsQuestionValueIdFkeyInput>;
  questionOptionId?: InputMaybe<Scalars['Int']['input']>;
  questionnaire?: InputMaybe<CandidateQuestionsQuestionnaireIdFkeyInput>;
  questionnaireId?: InputMaybe<Scalars['Int']['input']>;
  textValue?: InputMaybe<Scalars['String']['input']>;
};

/** An object where the defined keys will be set on the `candidateQuestion` being updated. */
export type UpdateCandidateQuestionOnCandidateQuestionForCandidateQuestionsEvaluationIdFkeyPatch = {
  booleanValue?: InputMaybe<Scalars['Boolean']['input']>;
  candidate?: InputMaybe<CandidateQuestionsCandidateIdFkeyInput>;
  candidateFile?: InputMaybe<CandidateQuestionsFileValueExternalIdFkeyInput>;
  candidateId?: InputMaybe<Scalars['Int']['input']>;
  dateValue?: InputMaybe<Scalars['Datetime']['input']>;
  evaluation?: InputMaybe<CandidateQuestionsEvaluationIdFkeyInput>;
  fileValueExternalId?: InputMaybe<Scalars['UUID']['input']>;
  numberValue?: InputMaybe<Scalars['Int']['input']>;
  question?: InputMaybe<CandidateQuestionsQuestionIdFkeyInput>;
  questionId?: InputMaybe<Scalars['Int']['input']>;
  questionOption?: InputMaybe<CandidateQuestionsQuestionValueIdFkeyInput>;
  questionOptionId?: InputMaybe<Scalars['Int']['input']>;
  questionnaire?: InputMaybe<CandidateQuestionsQuestionnaireIdFkeyInput>;
  questionnaireId?: InputMaybe<Scalars['Int']['input']>;
  textValue?: InputMaybe<Scalars['String']['input']>;
};

/** An object where the defined keys will be set on the `candidateQuestion` being updated. */
export type UpdateCandidateQuestionOnCandidateQuestionForCandidateQuestionsFileValueExternalIdFkeyPatch = {
  booleanValue?: InputMaybe<Scalars['Boolean']['input']>;
  candidate?: InputMaybe<CandidateQuestionsCandidateIdFkeyInput>;
  candidateFile?: InputMaybe<CandidateQuestionsFileValueExternalIdFkeyInput>;
  candidateId?: InputMaybe<Scalars['Int']['input']>;
  dateValue?: InputMaybe<Scalars['Datetime']['input']>;
  evaluation?: InputMaybe<CandidateQuestionsEvaluationIdFkeyInput>;
  evaluationId?: InputMaybe<Scalars['Int']['input']>;
  numberValue?: InputMaybe<Scalars['Int']['input']>;
  question?: InputMaybe<CandidateQuestionsQuestionIdFkeyInput>;
  questionId?: InputMaybe<Scalars['Int']['input']>;
  questionOption?: InputMaybe<CandidateQuestionsQuestionValueIdFkeyInput>;
  questionOptionId?: InputMaybe<Scalars['Int']['input']>;
  questionnaire?: InputMaybe<CandidateQuestionsQuestionnaireIdFkeyInput>;
  questionnaireId?: InputMaybe<Scalars['Int']['input']>;
  textValue?: InputMaybe<Scalars['String']['input']>;
};

/** An object where the defined keys will be set on the `candidateQuestion` being updated. */
export type UpdateCandidateQuestionOnCandidateQuestionForCandidateQuestionsQuestionIdFkeyPatch = {
  booleanValue?: InputMaybe<Scalars['Boolean']['input']>;
  candidate?: InputMaybe<CandidateQuestionsCandidateIdFkeyInput>;
  candidateFile?: InputMaybe<CandidateQuestionsFileValueExternalIdFkeyInput>;
  candidateId?: InputMaybe<Scalars['Int']['input']>;
  dateValue?: InputMaybe<Scalars['Datetime']['input']>;
  evaluation?: InputMaybe<CandidateQuestionsEvaluationIdFkeyInput>;
  evaluationId?: InputMaybe<Scalars['Int']['input']>;
  fileValueExternalId?: InputMaybe<Scalars['UUID']['input']>;
  numberValue?: InputMaybe<Scalars['Int']['input']>;
  question?: InputMaybe<CandidateQuestionsQuestionIdFkeyInput>;
  questionOption?: InputMaybe<CandidateQuestionsQuestionValueIdFkeyInput>;
  questionOptionId?: InputMaybe<Scalars['Int']['input']>;
  questionnaire?: InputMaybe<CandidateQuestionsQuestionnaireIdFkeyInput>;
  questionnaireId?: InputMaybe<Scalars['Int']['input']>;
  textValue?: InputMaybe<Scalars['String']['input']>;
};

/** An object where the defined keys will be set on the `candidateQuestion` being updated. */
export type UpdateCandidateQuestionOnCandidateQuestionForCandidateQuestionsQuestionValueIdFkeyPatch = {
  booleanValue?: InputMaybe<Scalars['Boolean']['input']>;
  candidate?: InputMaybe<CandidateQuestionsCandidateIdFkeyInput>;
  candidateFile?: InputMaybe<CandidateQuestionsFileValueExternalIdFkeyInput>;
  candidateId?: InputMaybe<Scalars['Int']['input']>;
  dateValue?: InputMaybe<Scalars['Datetime']['input']>;
  evaluation?: InputMaybe<CandidateQuestionsEvaluationIdFkeyInput>;
  evaluationId?: InputMaybe<Scalars['Int']['input']>;
  fileValueExternalId?: InputMaybe<Scalars['UUID']['input']>;
  numberValue?: InputMaybe<Scalars['Int']['input']>;
  question?: InputMaybe<CandidateQuestionsQuestionIdFkeyInput>;
  questionId?: InputMaybe<Scalars['Int']['input']>;
  questionOption?: InputMaybe<CandidateQuestionsQuestionValueIdFkeyInput>;
  questionnaire?: InputMaybe<CandidateQuestionsQuestionnaireIdFkeyInput>;
  questionnaireId?: InputMaybe<Scalars['Int']['input']>;
  textValue?: InputMaybe<Scalars['String']['input']>;
};

/** An object where the defined keys will be set on the `candidateQuestion` being updated. */
export type UpdateCandidateQuestionOnCandidateQuestionForCandidateQuestionsQuestionnaireIdFkeyPatch = {
  booleanValue?: InputMaybe<Scalars['Boolean']['input']>;
  candidate?: InputMaybe<CandidateQuestionsCandidateIdFkeyInput>;
  candidateFile?: InputMaybe<CandidateQuestionsFileValueExternalIdFkeyInput>;
  candidateId?: InputMaybe<Scalars['Int']['input']>;
  dateValue?: InputMaybe<Scalars['Datetime']['input']>;
  evaluation?: InputMaybe<CandidateQuestionsEvaluationIdFkeyInput>;
  evaluationId?: InputMaybe<Scalars['Int']['input']>;
  fileValueExternalId?: InputMaybe<Scalars['UUID']['input']>;
  numberValue?: InputMaybe<Scalars['Int']['input']>;
  question?: InputMaybe<CandidateQuestionsQuestionIdFkeyInput>;
  questionId?: InputMaybe<Scalars['Int']['input']>;
  questionOption?: InputMaybe<CandidateQuestionsQuestionValueIdFkeyInput>;
  questionOptionId?: InputMaybe<Scalars['Int']['input']>;
  questionnaire?: InputMaybe<CandidateQuestionsQuestionnaireIdFkeyInput>;
  textValue?: InputMaybe<Scalars['String']['input']>;
};

/** An object where the defined keys will be set on the `candidateQuestionnaire` being updated. */
export type UpdateCandidateQuestionnaireOnCandidateQuestionnaireForCandidateQuestionnairesCandidateIdFkeyPatch = {
  candidate?: InputMaybe<CandidateQuestionnairesCandidateIdFkeyInput>;
  evaluation?: InputMaybe<CandidateQuestionnairesEvaluationIdFkeyInput>;
  evaluationId?: InputMaybe<Scalars['Int']['input']>;
  questionnaire?: InputMaybe<CandidateQuestionnairesQuestionnaireIdFkeyInput>;
  questionnaireId?: InputMaybe<Scalars['Int']['input']>;
};

/** An object where the defined keys will be set on the `candidateQuestionnaire` being updated. */
export type UpdateCandidateQuestionnaireOnCandidateQuestionnaireForCandidateQuestionnairesEvaluationIdFkeyPatch = {
  candidate?: InputMaybe<CandidateQuestionnairesCandidateIdFkeyInput>;
  candidateId?: InputMaybe<Scalars['Int']['input']>;
  evaluation?: InputMaybe<CandidateQuestionnairesEvaluationIdFkeyInput>;
  questionnaire?: InputMaybe<CandidateQuestionnairesQuestionnaireIdFkeyInput>;
  questionnaireId?: InputMaybe<Scalars['Int']['input']>;
};

/** An object where the defined keys will be set on the `candidateQuestionnaire` being updated. */
export type UpdateCandidateQuestionnaireOnCandidateQuestionnaireForCandidateQuestionnairesQuestionnaireIdFkeyPatch = {
  candidate?: InputMaybe<CandidateQuestionnairesCandidateIdFkeyInput>;
  candidateId?: InputMaybe<Scalars['Int']['input']>;
  evaluation?: InputMaybe<CandidateQuestionnairesEvaluationIdFkeyInput>;
  evaluationId?: InputMaybe<Scalars['Int']['input']>;
  questionnaire?: InputMaybe<CandidateQuestionnairesQuestionnaireIdFkeyInput>;
};

/** An object where the defined keys will be set on the `candidateTag` being updated. */
export type UpdateCandidateTagOnCandidateTagForCandidateTagsCandidateIdFkeyPatch = {
  candidate?: InputMaybe<CandidateTagsCandidateIdFkeyInput>;
  tag?: InputMaybe<CandidateTagsTagIdFkeyInput>;
  tagId?: InputMaybe<Scalars['Int']['input']>;
  type?: InputMaybe<CandidateTagType>;
};

/** An object where the defined keys will be set on the `candidateTag` being updated. */
export type UpdateCandidateTagOnCandidateTagForCandidateTagsTagIdFkeyPatch = {
  candidate?: InputMaybe<CandidateTagsCandidateIdFkeyInput>;
  candidateId?: InputMaybe<Scalars['Int']['input']>;
  tag?: InputMaybe<CandidateTagsTagIdFkeyInput>;
  type?: InputMaybe<CandidateTagType>;
};

/** An object where the defined keys will be set on the `candidateTranslation` being updated. */
export type UpdateCandidateTranslationOnCandidateTranslationForCandidateTranslationsCandidateIdFkeyPatch = {
  candidate?: InputMaybe<CandidateTranslationsCandidateIdFkeyInput>;
  name?: InputMaybe<Scalars['String']['input']>;
};

/** An object where the defined keys will be set on the `company` being updated. */
export type UpdateCompanyOnCompanyTranslationForCompanyTranslationsCompanyIdFkeyPatch = {
  category?: InputMaybe<CompanyCategory>;
  companySize?: InputMaybe<CompanySize>;
  createdAt?: InputMaybe<Scalars['Datetime']['input']>;
  draftEvaluations?: InputMaybe<DraftEvaluationsCompanyIdFkeyInverseInput>;
  eventDraftEvaluations?: InputMaybe<EventDraftEvaluationsCompanyIdFkeyInverseInput>;
  id?: InputMaybe<Scalars['Int']['input']>;
  invoices?: InputMaybe<InvoicesCompanyIdFkeyInverseInput>;
  languages?: InputMaybe<Array<InputMaybe<Language>>>;
  slug?: InputMaybe<Scalars['String']['input']>;
  translations?: InputMaybe<CompanyTranslationsCompanyIdFkeyInverseInput>;
  updatedAt?: InputMaybe<Scalars['Datetime']['input']>;
};

/** An object where the defined keys will be set on the `company` being updated. */
export type UpdateCompanyOnDraftEvaluationForDraftEvaluationsCompanyIdFkeyPatch = {
  category?: InputMaybe<CompanyCategory>;
  companySize?: InputMaybe<CompanySize>;
  createdAt?: InputMaybe<Scalars['Datetime']['input']>;
  draftEvaluations?: InputMaybe<DraftEvaluationsCompanyIdFkeyInverseInput>;
  eventDraftEvaluations?: InputMaybe<EventDraftEvaluationsCompanyIdFkeyInverseInput>;
  id?: InputMaybe<Scalars['Int']['input']>;
  invoices?: InputMaybe<InvoicesCompanyIdFkeyInverseInput>;
  languages?: InputMaybe<Array<InputMaybe<Language>>>;
  slug?: InputMaybe<Scalars['String']['input']>;
  translations?: InputMaybe<CompanyTranslationsCompanyIdFkeyInverseInput>;
  updatedAt?: InputMaybe<Scalars['Datetime']['input']>;
};

/** An object where the defined keys will be set on the `company` being updated. */
export type UpdateCompanyOnEventDraftEvaluationForEventDraftEvaluationsCompanyIdFkeyPatch = {
  category?: InputMaybe<CompanyCategory>;
  companySize?: InputMaybe<CompanySize>;
  createdAt?: InputMaybe<Scalars['Datetime']['input']>;
  draftEvaluations?: InputMaybe<DraftEvaluationsCompanyIdFkeyInverseInput>;
  eventDraftEvaluations?: InputMaybe<EventDraftEvaluationsCompanyIdFkeyInverseInput>;
  id?: InputMaybe<Scalars['Int']['input']>;
  invoices?: InputMaybe<InvoicesCompanyIdFkeyInverseInput>;
  languages?: InputMaybe<Array<InputMaybe<Language>>>;
  slug?: InputMaybe<Scalars['String']['input']>;
  translations?: InputMaybe<CompanyTranslationsCompanyIdFkeyInverseInput>;
  updatedAt?: InputMaybe<Scalars['Datetime']['input']>;
};

/** An object where the defined keys will be set on the `company` being updated. */
export type UpdateCompanyOnInvoiceForInvoicesCompanyIdFkeyPatch = {
  category?: InputMaybe<CompanyCategory>;
  companySize?: InputMaybe<CompanySize>;
  createdAt?: InputMaybe<Scalars['Datetime']['input']>;
  draftEvaluations?: InputMaybe<DraftEvaluationsCompanyIdFkeyInverseInput>;
  eventDraftEvaluations?: InputMaybe<EventDraftEvaluationsCompanyIdFkeyInverseInput>;
  id?: InputMaybe<Scalars['Int']['input']>;
  invoices?: InputMaybe<InvoicesCompanyIdFkeyInverseInput>;
  languages?: InputMaybe<Array<InputMaybe<Language>>>;
  slug?: InputMaybe<Scalars['String']['input']>;
  translations?: InputMaybe<CompanyTranslationsCompanyIdFkeyInverseInput>;
  updatedAt?: InputMaybe<Scalars['Datetime']['input']>;
};

/** An object where the defined keys will be set on the `companyTranslation` being updated. */
export type UpdateCompanyTranslationOnCompanyTranslationForCompanyTranslationsCompanyIdFkeyPatch = {
  company?: InputMaybe<CompanyTranslationsCompanyIdFkeyInput>;
  name?: InputMaybe<Scalars['String']['input']>;
};

/** An object where the defined keys will be set on the `competency` being updated. */
export type UpdateCompetencyOnJobCompetencyForJobCompetenciesCompetenceIdFkeyPatch = {
  jobCompetencies?: InputMaybe<JobCompetenciesCompetenceIdFkeyInverseInput>;
  title?: InputMaybe<Scalars['String']['input']>;
};

/** An object where the defined keys will be set on the `department` being updated. */
export type UpdateDepartmentOnDepartmentTranslationForDepartmentTranslationsDepartmentIdFkeyPatch = {
  jobs?: InputMaybe<JobsDepartmentIdFkeyInverseInput>;
  translations?: InputMaybe<DepartmentTranslationsDepartmentIdFkeyInverseInput>;
};

/** An object where the defined keys will be set on the `department` being updated. */
export type UpdateDepartmentOnJobForJobsDepartmentIdFkeyPatch = {
  jobs?: InputMaybe<JobsDepartmentIdFkeyInverseInput>;
  translations?: InputMaybe<DepartmentTranslationsDepartmentIdFkeyInverseInput>;
};

/** An object where the defined keys will be set on the `departmentTranslation` being updated. */
export type UpdateDepartmentTranslationOnDepartmentTranslationForDepartmentTranslationsDepartmentIdFkeyPatch = {
  department?: InputMaybe<DepartmentTranslationsDepartmentIdFkeyInput>;
  title?: InputMaybe<Scalars['String']['input']>;
};

/** An object where the defined keys will be set on the `disqualifyReason` being updated. */
export type UpdateDisqualifyReasonOnDisqualifyReasonTranslationForDisqualifyReasonTranslationsDisqualifyReasonIdFkeyPatch = {
  jobsApplications?: InputMaybe<JobsApplicationsDisqualifyReasonIdFkeyInverseInput>;
  position?: InputMaybe<Scalars['Int']['input']>;
  translations?: InputMaybe<DisqualifyReasonTranslationsDisqualifyReasonIdFkeyInverseInput>;
};

/** An object where the defined keys will be set on the `disqualifyReason` being updated. */
export type UpdateDisqualifyReasonOnJobsApplicationForJobsApplicationsDisqualifyReasonIdFkeyPatch = {
  jobsApplications?: InputMaybe<JobsApplicationsDisqualifyReasonIdFkeyInverseInput>;
  position?: InputMaybe<Scalars['Int']['input']>;
  translations?: InputMaybe<DisqualifyReasonTranslationsDisqualifyReasonIdFkeyInverseInput>;
};

/** An object where the defined keys will be set on the `disqualifyReasonTranslation` being updated. */
export type UpdateDisqualifyReasonTranslationOnDisqualifyReasonTranslationForDisqualifyReasonTranslationsDisqualifyReasonIdFkeyPatch = {
  disqualifyReason?: InputMaybe<DisqualifyReasonTranslationsDisqualifyReasonIdFkeyInput>;
  title?: InputMaybe<Scalars['String']['input']>;
};

/** An object where the defined keys will be set on the `draftEvaluation` being updated. */
export type UpdateDraftEvaluationOnDraftEvaluationForDraftEvaluationsCandidateIdFkeyPatch = {
  candidate?: InputMaybe<DraftEvaluationsCandidateIdFkeyInput>;
  company?: InputMaybe<DraftEvaluationsCompanyIdFkeyInput>;
  companyId?: InputMaybe<Scalars['Int']['input']>;
  createdAt?: InputMaybe<Scalars['Datetime']['input']>;
  deletedAt?: InputMaybe<Scalars['Datetime']['input']>;
  evaluations?: InputMaybe<EvaluationsDraftEvaluationIdFkeyInverseInput>;
  id?: InputMaybe<Scalars['Int']['input']>;
  job?: InputMaybe<DraftEvaluationsJobIdFkeyInput>;
  jobId?: InputMaybe<Scalars['Int']['input']>;
  pipelineStage?: InputMaybe<DraftEvaluationsPipelineStageIdFkeyInput>;
  pipelineStageId?: InputMaybe<Scalars['Int']['input']>;
  scorecardIds?: InputMaybe<Array<InputMaybe<Scalars['Int']['input']>>>;
  userIds?: InputMaybe<Array<InputMaybe<Scalars['Int']['input']>>>;
};

/** An object where the defined keys will be set on the `draftEvaluation` being updated. */
export type UpdateDraftEvaluationOnDraftEvaluationForDraftEvaluationsCompanyIdFkeyPatch = {
  candidate?: InputMaybe<DraftEvaluationsCandidateIdFkeyInput>;
  candidateId?: InputMaybe<Scalars['Int']['input']>;
  company?: InputMaybe<DraftEvaluationsCompanyIdFkeyInput>;
  createdAt?: InputMaybe<Scalars['Datetime']['input']>;
  deletedAt?: InputMaybe<Scalars['Datetime']['input']>;
  evaluations?: InputMaybe<EvaluationsDraftEvaluationIdFkeyInverseInput>;
  id?: InputMaybe<Scalars['Int']['input']>;
  job?: InputMaybe<DraftEvaluationsJobIdFkeyInput>;
  jobId?: InputMaybe<Scalars['Int']['input']>;
  pipelineStage?: InputMaybe<DraftEvaluationsPipelineStageIdFkeyInput>;
  pipelineStageId?: InputMaybe<Scalars['Int']['input']>;
  scorecardIds?: InputMaybe<Array<InputMaybe<Scalars['Int']['input']>>>;
  userIds?: InputMaybe<Array<InputMaybe<Scalars['Int']['input']>>>;
};

/** An object where the defined keys will be set on the `draftEvaluation` being updated. */
export type UpdateDraftEvaluationOnDraftEvaluationForDraftEvaluationsJobIdFkeyPatch = {
  candidate?: InputMaybe<DraftEvaluationsCandidateIdFkeyInput>;
  candidateId?: InputMaybe<Scalars['Int']['input']>;
  company?: InputMaybe<DraftEvaluationsCompanyIdFkeyInput>;
  companyId?: InputMaybe<Scalars['Int']['input']>;
  createdAt?: InputMaybe<Scalars['Datetime']['input']>;
  deletedAt?: InputMaybe<Scalars['Datetime']['input']>;
  evaluations?: InputMaybe<EvaluationsDraftEvaluationIdFkeyInverseInput>;
  id?: InputMaybe<Scalars['Int']['input']>;
  job?: InputMaybe<DraftEvaluationsJobIdFkeyInput>;
  pipelineStage?: InputMaybe<DraftEvaluationsPipelineStageIdFkeyInput>;
  pipelineStageId?: InputMaybe<Scalars['Int']['input']>;
  scorecardIds?: InputMaybe<Array<InputMaybe<Scalars['Int']['input']>>>;
  userIds?: InputMaybe<Array<InputMaybe<Scalars['Int']['input']>>>;
};

/** An object where the defined keys will be set on the `draftEvaluation` being updated. */
export type UpdateDraftEvaluationOnDraftEvaluationForDraftEvaluationsPipelineStageIdFkeyPatch = {
  candidate?: InputMaybe<DraftEvaluationsCandidateIdFkeyInput>;
  candidateId?: InputMaybe<Scalars['Int']['input']>;
  company?: InputMaybe<DraftEvaluationsCompanyIdFkeyInput>;
  companyId?: InputMaybe<Scalars['Int']['input']>;
  createdAt?: InputMaybe<Scalars['Datetime']['input']>;
  deletedAt?: InputMaybe<Scalars['Datetime']['input']>;
  evaluations?: InputMaybe<EvaluationsDraftEvaluationIdFkeyInverseInput>;
  id?: InputMaybe<Scalars['Int']['input']>;
  job?: InputMaybe<DraftEvaluationsJobIdFkeyInput>;
  jobId?: InputMaybe<Scalars['Int']['input']>;
  pipelineStage?: InputMaybe<DraftEvaluationsPipelineStageIdFkeyInput>;
  scorecardIds?: InputMaybe<Array<InputMaybe<Scalars['Int']['input']>>>;
  userIds?: InputMaybe<Array<InputMaybe<Scalars['Int']['input']>>>;
};

/** An object where the defined keys will be set on the `draftEvaluation` being updated. */
export type UpdateDraftEvaluationOnEvaluationForEvaluationsDraftEvaluationIdFkeyPatch = {
  candidate?: InputMaybe<DraftEvaluationsCandidateIdFkeyInput>;
  candidateId?: InputMaybe<Scalars['Int']['input']>;
  company?: InputMaybe<DraftEvaluationsCompanyIdFkeyInput>;
  companyId?: InputMaybe<Scalars['Int']['input']>;
  createdAt?: InputMaybe<Scalars['Datetime']['input']>;
  deletedAt?: InputMaybe<Scalars['Datetime']['input']>;
  evaluations?: InputMaybe<EvaluationsDraftEvaluationIdFkeyInverseInput>;
  id?: InputMaybe<Scalars['Int']['input']>;
  job?: InputMaybe<DraftEvaluationsJobIdFkeyInput>;
  jobId?: InputMaybe<Scalars['Int']['input']>;
  pipelineStage?: InputMaybe<DraftEvaluationsPipelineStageIdFkeyInput>;
  pipelineStageId?: InputMaybe<Scalars['Int']['input']>;
  scorecardIds?: InputMaybe<Array<InputMaybe<Scalars['Int']['input']>>>;
  userIds?: InputMaybe<Array<InputMaybe<Scalars['Int']['input']>>>;
};

/** An object where the defined keys will be set on the `evaluation` being updated. */
export type UpdateEvaluationOnCandidateQuestionForCandidateQuestionsEvaluationIdFkeyPatch = {
  candidate?: InputMaybe<EvaluationsCandidateIdFkeyInput>;
  candidateId?: InputMaybe<Scalars['Int']['input']>;
  candidateQuestionnaires?: InputMaybe<CandidateQuestionnairesEvaluationIdFkeyInverseInput>;
  candidateQuestions?: InputMaybe<CandidateQuestionsEvaluationIdFkeyInverseInput>;
  draftEvaluation?: InputMaybe<EvaluationsDraftEvaluationIdFkeyInput>;
  draftEvaluationId?: InputMaybe<Scalars['Int']['input']>;
  evaluationScorecards?: InputMaybe<EvaluationScorecardsEvaluationIdFkeyInverseInput>;
  eventDraftEvaluation?: InputMaybe<EvaluationsEventDraftEvaluationIdFkeyInput>;
  eventDraftEvaluationId?: InputMaybe<Scalars['Int']['input']>;
  job?: InputMaybe<EvaluationsJobIdFkeyInput>;
  jobId?: InputMaybe<Scalars['Int']['input']>;
  user?: InputMaybe<EvaluationsUserIdFkeyInput>;
  userId?: InputMaybe<Scalars['Int']['input']>;
};

/** An object where the defined keys will be set on the `evaluation` being updated. */
export type UpdateEvaluationOnCandidateQuestionnaireForCandidateQuestionnairesEvaluationIdFkeyPatch = {
  candidate?: InputMaybe<EvaluationsCandidateIdFkeyInput>;
  candidateId?: InputMaybe<Scalars['Int']['input']>;
  candidateQuestionnaires?: InputMaybe<CandidateQuestionnairesEvaluationIdFkeyInverseInput>;
  candidateQuestions?: InputMaybe<CandidateQuestionsEvaluationIdFkeyInverseInput>;
  draftEvaluation?: InputMaybe<EvaluationsDraftEvaluationIdFkeyInput>;
  draftEvaluationId?: InputMaybe<Scalars['Int']['input']>;
  evaluationScorecards?: InputMaybe<EvaluationScorecardsEvaluationIdFkeyInverseInput>;
  eventDraftEvaluation?: InputMaybe<EvaluationsEventDraftEvaluationIdFkeyInput>;
  eventDraftEvaluationId?: InputMaybe<Scalars['Int']['input']>;
  job?: InputMaybe<EvaluationsJobIdFkeyInput>;
  jobId?: InputMaybe<Scalars['Int']['input']>;
  user?: InputMaybe<EvaluationsUserIdFkeyInput>;
  userId?: InputMaybe<Scalars['Int']['input']>;
};

/** An object where the defined keys will be set on the `evaluation` being updated. */
export type UpdateEvaluationOnEvaluationForEvaluationsCandidateIdFkeyPatch = {
  candidate?: InputMaybe<EvaluationsCandidateIdFkeyInput>;
  candidateQuestionnaires?: InputMaybe<CandidateQuestionnairesEvaluationIdFkeyInverseInput>;
  candidateQuestions?: InputMaybe<CandidateQuestionsEvaluationIdFkeyInverseInput>;
  draftEvaluation?: InputMaybe<EvaluationsDraftEvaluationIdFkeyInput>;
  draftEvaluationId?: InputMaybe<Scalars['Int']['input']>;
  evaluationScorecards?: InputMaybe<EvaluationScorecardsEvaluationIdFkeyInverseInput>;
  eventDraftEvaluation?: InputMaybe<EvaluationsEventDraftEvaluationIdFkeyInput>;
  eventDraftEvaluationId?: InputMaybe<Scalars['Int']['input']>;
  job?: InputMaybe<EvaluationsJobIdFkeyInput>;
  jobId?: InputMaybe<Scalars['Int']['input']>;
  user?: InputMaybe<EvaluationsUserIdFkeyInput>;
  userId?: InputMaybe<Scalars['Int']['input']>;
};

/** An object where the defined keys will be set on the `evaluation` being updated. */
export type UpdateEvaluationOnEvaluationForEvaluationsDraftEvaluationIdFkeyPatch = {
  candidate?: InputMaybe<EvaluationsCandidateIdFkeyInput>;
  candidateId?: InputMaybe<Scalars['Int']['input']>;
  candidateQuestionnaires?: InputMaybe<CandidateQuestionnairesEvaluationIdFkeyInverseInput>;
  candidateQuestions?: InputMaybe<CandidateQuestionsEvaluationIdFkeyInverseInput>;
  draftEvaluation?: InputMaybe<EvaluationsDraftEvaluationIdFkeyInput>;
  evaluationScorecards?: InputMaybe<EvaluationScorecardsEvaluationIdFkeyInverseInput>;
  eventDraftEvaluation?: InputMaybe<EvaluationsEventDraftEvaluationIdFkeyInput>;
  eventDraftEvaluationId?: InputMaybe<Scalars['Int']['input']>;
  job?: InputMaybe<EvaluationsJobIdFkeyInput>;
  jobId?: InputMaybe<Scalars['Int']['input']>;
  user?: InputMaybe<EvaluationsUserIdFkeyInput>;
  userId?: InputMaybe<Scalars['Int']['input']>;
};

/** An object where the defined keys will be set on the `evaluation` being updated. */
export type UpdateEvaluationOnEvaluationForEvaluationsEventDraftEvaluationIdFkeyPatch = {
  candidate?: InputMaybe<EvaluationsCandidateIdFkeyInput>;
  candidateId?: InputMaybe<Scalars['Int']['input']>;
  candidateQuestionnaires?: InputMaybe<CandidateQuestionnairesEvaluationIdFkeyInverseInput>;
  candidateQuestions?: InputMaybe<CandidateQuestionsEvaluationIdFkeyInverseInput>;
  draftEvaluation?: InputMaybe<EvaluationsDraftEvaluationIdFkeyInput>;
  draftEvaluationId?: InputMaybe<Scalars['Int']['input']>;
  evaluationScorecards?: InputMaybe<EvaluationScorecardsEvaluationIdFkeyInverseInput>;
  eventDraftEvaluation?: InputMaybe<EvaluationsEventDraftEvaluationIdFkeyInput>;
  job?: InputMaybe<EvaluationsJobIdFkeyInput>;
  jobId?: InputMaybe<Scalars['Int']['input']>;
  user?: InputMaybe<EvaluationsUserIdFkeyInput>;
  userId?: InputMaybe<Scalars['Int']['input']>;
};

/** An object where the defined keys will be set on the `evaluation` being updated. */
export type UpdateEvaluationOnEvaluationForEvaluationsJobIdFkeyPatch = {
  candidate?: InputMaybe<EvaluationsCandidateIdFkeyInput>;
  candidateId?: InputMaybe<Scalars['Int']['input']>;
  candidateQuestionnaires?: InputMaybe<CandidateQuestionnairesEvaluationIdFkeyInverseInput>;
  candidateQuestions?: InputMaybe<CandidateQuestionsEvaluationIdFkeyInverseInput>;
  draftEvaluation?: InputMaybe<EvaluationsDraftEvaluationIdFkeyInput>;
  draftEvaluationId?: InputMaybe<Scalars['Int']['input']>;
  evaluationScorecards?: InputMaybe<EvaluationScorecardsEvaluationIdFkeyInverseInput>;
  eventDraftEvaluation?: InputMaybe<EvaluationsEventDraftEvaluationIdFkeyInput>;
  eventDraftEvaluationId?: InputMaybe<Scalars['Int']['input']>;
  job?: InputMaybe<EvaluationsJobIdFkeyInput>;
  user?: InputMaybe<EvaluationsUserIdFkeyInput>;
  userId?: InputMaybe<Scalars['Int']['input']>;
};

/** An object where the defined keys will be set on the `evaluation` being updated. */
export type UpdateEvaluationOnEvaluationForEvaluationsUserIdFkeyPatch = {
  candidate?: InputMaybe<EvaluationsCandidateIdFkeyInput>;
  candidateId?: InputMaybe<Scalars['Int']['input']>;
  candidateQuestionnaires?: InputMaybe<CandidateQuestionnairesEvaluationIdFkeyInverseInput>;
  candidateQuestions?: InputMaybe<CandidateQuestionsEvaluationIdFkeyInverseInput>;
  draftEvaluation?: InputMaybe<EvaluationsDraftEvaluationIdFkeyInput>;
  draftEvaluationId?: InputMaybe<Scalars['Int']['input']>;
  evaluationScorecards?: InputMaybe<EvaluationScorecardsEvaluationIdFkeyInverseInput>;
  eventDraftEvaluation?: InputMaybe<EvaluationsEventDraftEvaluationIdFkeyInput>;
  eventDraftEvaluationId?: InputMaybe<Scalars['Int']['input']>;
  job?: InputMaybe<EvaluationsJobIdFkeyInput>;
  jobId?: InputMaybe<Scalars['Int']['input']>;
  user?: InputMaybe<EvaluationsUserIdFkeyInput>;
};

/** An object where the defined keys will be set on the `evaluation` being updated. */
export type UpdateEvaluationOnEvaluationScorecardForEvaluationScorecardsEvaluationIdFkeyPatch = {
  candidate?: InputMaybe<EvaluationsCandidateIdFkeyInput>;
  candidateId?: InputMaybe<Scalars['Int']['input']>;
  candidateQuestionnaires?: InputMaybe<CandidateQuestionnairesEvaluationIdFkeyInverseInput>;
  candidateQuestions?: InputMaybe<CandidateQuestionsEvaluationIdFkeyInverseInput>;
  draftEvaluation?: InputMaybe<EvaluationsDraftEvaluationIdFkeyInput>;
  draftEvaluationId?: InputMaybe<Scalars['Int']['input']>;
  evaluationScorecards?: InputMaybe<EvaluationScorecardsEvaluationIdFkeyInverseInput>;
  eventDraftEvaluation?: InputMaybe<EvaluationsEventDraftEvaluationIdFkeyInput>;
  eventDraftEvaluationId?: InputMaybe<Scalars['Int']['input']>;
  job?: InputMaybe<EvaluationsJobIdFkeyInput>;
  jobId?: InputMaybe<Scalars['Int']['input']>;
  user?: InputMaybe<EvaluationsUserIdFkeyInput>;
  userId?: InputMaybe<Scalars['Int']['input']>;
};

/** An object where the defined keys will be set on the `evaluationScorecardCriteria` being updated. */
export type UpdateEvaluationScorecardCriteriaOnEvaluationScorecardCriteriaForEvaluationScorecardCriteriasCriteriaIdFkeyPatch = {
  comment?: InputMaybe<Scalars['String']['input']>;
  evaluationScorecard?: InputMaybe<EvaluationScorecardCriteriasEvaluationScorecardIdFkeyInput>;
  evaluationScorecardId?: InputMaybe<Scalars['Int']['input']>;
  scorecardCriteria?: InputMaybe<EvaluationScorecardCriteriasCriteriaIdFkeyInput>;
};

/** An object where the defined keys will be set on the `evaluationScorecardCriteria` being updated. */
export type UpdateEvaluationScorecardCriteriaOnEvaluationScorecardCriteriaForEvaluationScorecardCriteriasEvaluationScorecardIdFkeyPatch = {
  comment?: InputMaybe<Scalars['String']['input']>;
  criteriaId?: InputMaybe<Scalars['Int']['input']>;
  evaluationScorecard?: InputMaybe<EvaluationScorecardCriteriasEvaluationScorecardIdFkeyInput>;
  scorecardCriteria?: InputMaybe<EvaluationScorecardCriteriasCriteriaIdFkeyInput>;
};

/** An object where the defined keys will be set on the `evaluationScorecard` being updated. */
export type UpdateEvaluationScorecardOnEvaluationScorecardCriteriaForEvaluationScorecardCriteriasEvaluationScorecardIdFkeyPatch = {
  evaluation?: InputMaybe<EvaluationScorecardsEvaluationIdFkeyInput>;
  evaluationId?: InputMaybe<Scalars['Int']['input']>;
  scorecard?: InputMaybe<EvaluationScorecardsScorecardIdFkeyInput>;
  scorecardCriterias?: InputMaybe<EvaluationScorecardCriteriasEvaluationScorecardIdFkeyInverseInput>;
  scorecardId?: InputMaybe<Scalars['Int']['input']>;
};

/** An object where the defined keys will be set on the `evaluationScorecard` being updated. */
export type UpdateEvaluationScorecardOnEvaluationScorecardForEvaluationScorecardsEvaluationIdFkeyPatch = {
  evaluation?: InputMaybe<EvaluationScorecardsEvaluationIdFkeyInput>;
  scorecard?: InputMaybe<EvaluationScorecardsScorecardIdFkeyInput>;
  scorecardCriterias?: InputMaybe<EvaluationScorecardCriteriasEvaluationScorecardIdFkeyInverseInput>;
  scorecardId?: InputMaybe<Scalars['Int']['input']>;
};

/** An object where the defined keys will be set on the `evaluationScorecard` being updated. */
export type UpdateEvaluationScorecardOnEvaluationScorecardForEvaluationScorecardsScorecardIdFkeyPatch = {
  evaluation?: InputMaybe<EvaluationScorecardsEvaluationIdFkeyInput>;
  evaluationId?: InputMaybe<Scalars['Int']['input']>;
  scorecard?: InputMaybe<EvaluationScorecardsScorecardIdFkeyInput>;
  scorecardCriterias?: InputMaybe<EvaluationScorecardCriteriasEvaluationScorecardIdFkeyInverseInput>;
};

/** An object where the defined keys will be set on the `eventDraftEvaluation` being updated. */
export type UpdateEventDraftEvaluationOnEvaluationForEvaluationsEventDraftEvaluationIdFkeyPatch = {
  candidate?: InputMaybe<EventDraftEvaluationsCandidateIdFkeyInput>;
  candidateId?: InputMaybe<Scalars['Int']['input']>;
  company?: InputMaybe<EventDraftEvaluationsCompanyIdFkeyInput>;
  companyId?: InputMaybe<Scalars['Int']['input']>;
  createdAt?: InputMaybe<Scalars['Datetime']['input']>;
  deletedAt?: InputMaybe<Scalars['Datetime']['input']>;
  evaluations?: InputMaybe<EvaluationsEventDraftEvaluationIdFkeyInverseInput>;
  event?: InputMaybe<EventDraftEvaluationsEventIdFkeyInput>;
  eventId?: InputMaybe<Scalars['Int']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  scorecardIds?: InputMaybe<Array<InputMaybe<Scalars['Int']['input']>>>;
  userIds?: InputMaybe<Array<InputMaybe<Scalars['Int']['input']>>>;
};

/** An object where the defined keys will be set on the `eventDraftEvaluation` being updated. */
export type UpdateEventDraftEvaluationOnEventDraftEvaluationForEventDraftEvaluationsCandidateIdFkeyPatch = {
  candidate?: InputMaybe<EventDraftEvaluationsCandidateIdFkeyInput>;
  company?: InputMaybe<EventDraftEvaluationsCompanyIdFkeyInput>;
  companyId?: InputMaybe<Scalars['Int']['input']>;
  createdAt?: InputMaybe<Scalars['Datetime']['input']>;
  deletedAt?: InputMaybe<Scalars['Datetime']['input']>;
  evaluations?: InputMaybe<EvaluationsEventDraftEvaluationIdFkeyInverseInput>;
  event?: InputMaybe<EventDraftEvaluationsEventIdFkeyInput>;
  eventId?: InputMaybe<Scalars['Int']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  scorecardIds?: InputMaybe<Array<InputMaybe<Scalars['Int']['input']>>>;
  userIds?: InputMaybe<Array<InputMaybe<Scalars['Int']['input']>>>;
};

/** An object where the defined keys will be set on the `eventDraftEvaluation` being updated. */
export type UpdateEventDraftEvaluationOnEventDraftEvaluationForEventDraftEvaluationsCompanyIdFkeyPatch = {
  candidate?: InputMaybe<EventDraftEvaluationsCandidateIdFkeyInput>;
  candidateId?: InputMaybe<Scalars['Int']['input']>;
  company?: InputMaybe<EventDraftEvaluationsCompanyIdFkeyInput>;
  createdAt?: InputMaybe<Scalars['Datetime']['input']>;
  deletedAt?: InputMaybe<Scalars['Datetime']['input']>;
  evaluations?: InputMaybe<EvaluationsEventDraftEvaluationIdFkeyInverseInput>;
  event?: InputMaybe<EventDraftEvaluationsEventIdFkeyInput>;
  eventId?: InputMaybe<Scalars['Int']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  scorecardIds?: InputMaybe<Array<InputMaybe<Scalars['Int']['input']>>>;
  userIds?: InputMaybe<Array<InputMaybe<Scalars['Int']['input']>>>;
};

/** An object where the defined keys will be set on the `eventDraftEvaluation` being updated. */
export type UpdateEventDraftEvaluationOnEventDraftEvaluationForEventDraftEvaluationsEventIdFkeyPatch = {
  candidate?: InputMaybe<EventDraftEvaluationsCandidateIdFkeyInput>;
  candidateId?: InputMaybe<Scalars['Int']['input']>;
  company?: InputMaybe<EventDraftEvaluationsCompanyIdFkeyInput>;
  companyId?: InputMaybe<Scalars['Int']['input']>;
  createdAt?: InputMaybe<Scalars['Datetime']['input']>;
  deletedAt?: InputMaybe<Scalars['Datetime']['input']>;
  evaluations?: InputMaybe<EvaluationsEventDraftEvaluationIdFkeyInverseInput>;
  event?: InputMaybe<EventDraftEvaluationsEventIdFkeyInput>;
  id?: InputMaybe<Scalars['Int']['input']>;
  scorecardIds?: InputMaybe<Array<InputMaybe<Scalars['Int']['input']>>>;
  userIds?: InputMaybe<Array<InputMaybe<Scalars['Int']['input']>>>;
};

/** An object where the defined keys will be set on the `event` being updated. */
export type UpdateEventOnEventCandidateForEventCandidatesEventIdFkeyPatch = {
  address?: InputMaybe<Scalars['String']['input']>;
  deletedAt?: InputMaybe<Scalars['Datetime']['input']>;
  description?: InputMaybe<Scalars['String']['input']>;
  endTime?: InputMaybe<Scalars['Datetime']['input']>;
  eventCandidates?: InputMaybe<EventCandidatesEventIdFkeyInverseInput>;
  eventDraftEvaluations?: InputMaybe<EventDraftEvaluationsEventIdFkeyInverseInput>;
  eventScorecards?: InputMaybe<EventScorecardsEventIdFkeyInverseInput>;
  eventUsers?: InputMaybe<EventUsersEventIdFkeyInverseInput>;
  startTime?: InputMaybe<Scalars['Datetime']['input']>;
  title?: InputMaybe<Scalars['String']['input']>;
  type?: InputMaybe<EventType>;
  url?: InputMaybe<Scalars['String']['input']>;
};

/** An object where the defined keys will be set on the `event` being updated. */
export type UpdateEventOnEventDraftEvaluationForEventDraftEvaluationsEventIdFkeyPatch = {
  address?: InputMaybe<Scalars['String']['input']>;
  deletedAt?: InputMaybe<Scalars['Datetime']['input']>;
  description?: InputMaybe<Scalars['String']['input']>;
  endTime?: InputMaybe<Scalars['Datetime']['input']>;
  eventCandidates?: InputMaybe<EventCandidatesEventIdFkeyInverseInput>;
  eventDraftEvaluations?: InputMaybe<EventDraftEvaluationsEventIdFkeyInverseInput>;
  eventScorecards?: InputMaybe<EventScorecardsEventIdFkeyInverseInput>;
  eventUsers?: InputMaybe<EventUsersEventIdFkeyInverseInput>;
  startTime?: InputMaybe<Scalars['Datetime']['input']>;
  title?: InputMaybe<Scalars['String']['input']>;
  type?: InputMaybe<EventType>;
  url?: InputMaybe<Scalars['String']['input']>;
};

/** An object where the defined keys will be set on the `event` being updated. */
export type UpdateEventOnEventScorecardForEventScorecardsEventIdFkeyPatch = {
  address?: InputMaybe<Scalars['String']['input']>;
  deletedAt?: InputMaybe<Scalars['Datetime']['input']>;
  description?: InputMaybe<Scalars['String']['input']>;
  endTime?: InputMaybe<Scalars['Datetime']['input']>;
  eventCandidates?: InputMaybe<EventCandidatesEventIdFkeyInverseInput>;
  eventDraftEvaluations?: InputMaybe<EventDraftEvaluationsEventIdFkeyInverseInput>;
  eventScorecards?: InputMaybe<EventScorecardsEventIdFkeyInverseInput>;
  eventUsers?: InputMaybe<EventUsersEventIdFkeyInverseInput>;
  startTime?: InputMaybe<Scalars['Datetime']['input']>;
  title?: InputMaybe<Scalars['String']['input']>;
  type?: InputMaybe<EventType>;
  url?: InputMaybe<Scalars['String']['input']>;
};

/** An object where the defined keys will be set on the `event` being updated. */
export type UpdateEventOnEventUserForEventUsersEventIdFkeyPatch = {
  address?: InputMaybe<Scalars['String']['input']>;
  deletedAt?: InputMaybe<Scalars['Datetime']['input']>;
  description?: InputMaybe<Scalars['String']['input']>;
  endTime?: InputMaybe<Scalars['Datetime']['input']>;
  eventCandidates?: InputMaybe<EventCandidatesEventIdFkeyInverseInput>;
  eventDraftEvaluations?: InputMaybe<EventDraftEvaluationsEventIdFkeyInverseInput>;
  eventScorecards?: InputMaybe<EventScorecardsEventIdFkeyInverseInput>;
  eventUsers?: InputMaybe<EventUsersEventIdFkeyInverseInput>;
  startTime?: InputMaybe<Scalars['Datetime']['input']>;
  title?: InputMaybe<Scalars['String']['input']>;
  type?: InputMaybe<EventType>;
  url?: InputMaybe<Scalars['String']['input']>;
};

/** An object where the defined keys will be set on the `field` being updated. */
export type UpdateFieldOnFieldForJobFieldsJobIdFkeyPatch = {
  job?: InputMaybe<JobFieldsJobIdFkeyInput>;
  position?: InputMaybe<Scalars['Int']['input']>;
  required?: InputMaybe<Scalars['Boolean']['input']>;
};

/** An object where the defined keys will be set on the `invoice` being updated. */
export type UpdateInvoiceOnInvoiceForInvoicesCompanyIdFkeyPatch = {
  company?: InputMaybe<InvoicesCompanyIdFkeyInput>;
  deletedAt?: InputMaybe<Scalars['Datetime']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  price?: InputMaybe<Scalars['Int']['input']>;
  refId?: InputMaybe<Scalars['String']['input']>;
  status?: InputMaybe<InvoiceStatus>;
  subscription?: InputMaybe<InvoicesSubscriptionIdFkeyInput>;
  subscriptionId?: InputMaybe<Scalars['Int']['input']>;
};

/** An object where the defined keys will be set on the `invoice` being updated. */
export type UpdateInvoiceOnInvoiceForInvoicesSubscriptionIdFkeyPatch = {
  company?: InputMaybe<InvoicesCompanyIdFkeyInput>;
  companyId?: InputMaybe<Scalars['Int']['input']>;
  deletedAt?: InputMaybe<Scalars['Datetime']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  price?: InputMaybe<Scalars['Int']['input']>;
  refId?: InputMaybe<Scalars['String']['input']>;
  status?: InputMaybe<InvoiceStatus>;
  subscription?: InputMaybe<InvoicesSubscriptionIdFkeyInput>;
};

/** An object where the defined keys will be set on the `jobCompetency` being updated. */
export type UpdateJobCompetencyOnJobCompetencyForJobCompetenciesCompetenceIdFkeyPatch = {
  competency?: InputMaybe<JobCompetenciesCompetenceIdFkeyInput>;
  job?: InputMaybe<JobCompetenciesJobIdFkeyInput>;
  jobId?: InputMaybe<Scalars['Int']['input']>;
};

/** An object where the defined keys will be set on the `jobCompetency` being updated. */
export type UpdateJobCompetencyOnJobCompetencyForJobCompetenciesJobIdFkeyPatch = {
  competenceId?: InputMaybe<Scalars['Int']['input']>;
  competency?: InputMaybe<JobCompetenciesCompetenceIdFkeyInput>;
  job?: InputMaybe<JobCompetenciesJobIdFkeyInput>;
};

/** An object where the defined keys will be set on the `jobKnowledge` being updated. */
export type UpdateJobKnowledgeOnJobKnowledgeForJobKnowledgesJobIdFkeyPatch = {
  job?: InputMaybe<JobKnowledgesJobIdFkeyInput>;
  knowledge?: InputMaybe<JobKnowledgesKnowledgeIdFkeyInput>;
  knowledgeId?: InputMaybe<Scalars['Int']['input']>;
};

/** An object where the defined keys will be set on the `jobKnowledge` being updated. */
export type UpdateJobKnowledgeOnJobKnowledgeForJobKnowledgesKnowledgeIdFkeyPatch = {
  job?: InputMaybe<JobKnowledgesJobIdFkeyInput>;
  jobId?: InputMaybe<Scalars['Int']['input']>;
  knowledge?: InputMaybe<JobKnowledgesKnowledgeIdFkeyInput>;
};

/** An object where the defined keys will be set on the `job` being updated. */
export type UpdateJobOnDraftEvaluationForDraftEvaluationsJobIdFkeyPatch = {
  address?: InputMaybe<Scalars['String']['input']>;
  applications?: InputMaybe<JobsApplicationsJobIdFkeyInverseInput>;
  city?: InputMaybe<Scalars['String']['input']>;
  competencies?: InputMaybe<Array<Scalars['String']['input']>>;
  country?: InputMaybe<Scalars['Int']['input']>;
  department?: InputMaybe<JobsDepartmentIdFkeyInput>;
  departmentId?: InputMaybe<Scalars['Int']['input']>;
  draftEvaluations?: InputMaybe<DraftEvaluationsJobIdFkeyInverseInput>;
  education?: InputMaybe<JobEducation>;
  evaluations?: InputMaybe<EvaluationsJobIdFkeyInverseInput>;
  fields?: InputMaybe<JobFieldsJobIdFkeyInverseInput>;
  genders?: InputMaybe<Array<InputMaybe<Gender>>>;
  gradeConditions?: InputMaybe<Array<InputMaybe<GradeCondition>>>;
  hoursPerWeek?: InputMaybe<IntRangeInput>;
  isRemote?: InputMaybe<Scalars['Boolean']['input']>;
  jobCompetencies?: InputMaybe<JobCompetenciesJobIdFkeyInverseInput>;
  jobKnowledges?: InputMaybe<JobKnowledgesJobIdFkeyInverseInput>;
  jobQuestionnaires?: InputMaybe<JobQuestionnairesJobIdFkeyInverseInput>;
  jobSkills?: InputMaybe<JobSkillsJobIdFkeyInverseInput>;
  jobTags?: InputMaybe<JobTagsJobIdFkeyInverseInput>;
  knowledges?: InputMaybe<Array<Scalars['String']['input']>>;
  languages?: InputMaybe<Array<InputMaybe<Language>>>;
  maxAgeCondition?: InputMaybe<Scalars['Int']['input']>;
  militaryStatus?: InputMaybe<Array<InputMaybe<MilitaryStatus>>>;
  minAgeCondition?: InputMaybe<Scalars['Int']['input']>;
  owners?: InputMaybe<JobOwnersJobIdFkeyInverseInput>;
  pipeline?: InputMaybe<JobsPipelineIdFkeyInput>;
  pipelineId?: InputMaybe<Scalars['Int']['input']>;
  position?: InputMaybe<Scalars['Int']['input']>;
  publishedAt?: InputMaybe<Scalars['Datetime']['input']>;
  skills?: InputMaybe<Array<Scalars['String']['input']>>;
  state?: InputMaybe<Scalars['Int']['input']>;
  status?: InputMaybe<JobStatus>;
  tags?: InputMaybe<Array<Scalars['String']['input']>>;
  threads?: InputMaybe<ThreadsJobIdFkeyInverseInput>;
  translations?: InputMaybe<JobTranslationsJobIdFkeyInverseInput>;
  workExperienceCondition?: InputMaybe<Scalars['Int']['input']>;
};

/** An object where the defined keys will be set on the `job` being updated. */
export type UpdateJobOnEvaluationForEvaluationsJobIdFkeyPatch = {
  address?: InputMaybe<Scalars['String']['input']>;
  applications?: InputMaybe<JobsApplicationsJobIdFkeyInverseInput>;
  city?: InputMaybe<Scalars['String']['input']>;
  competencies?: InputMaybe<Array<Scalars['String']['input']>>;
  country?: InputMaybe<Scalars['Int']['input']>;
  department?: InputMaybe<JobsDepartmentIdFkeyInput>;
  departmentId?: InputMaybe<Scalars['Int']['input']>;
  draftEvaluations?: InputMaybe<DraftEvaluationsJobIdFkeyInverseInput>;
  education?: InputMaybe<JobEducation>;
  evaluations?: InputMaybe<EvaluationsJobIdFkeyInverseInput>;
  fields?: InputMaybe<JobFieldsJobIdFkeyInverseInput>;
  genders?: InputMaybe<Array<InputMaybe<Gender>>>;
  gradeConditions?: InputMaybe<Array<InputMaybe<GradeCondition>>>;
  hoursPerWeek?: InputMaybe<IntRangeInput>;
  isRemote?: InputMaybe<Scalars['Boolean']['input']>;
  jobCompetencies?: InputMaybe<JobCompetenciesJobIdFkeyInverseInput>;
  jobKnowledges?: InputMaybe<JobKnowledgesJobIdFkeyInverseInput>;
  jobQuestionnaires?: InputMaybe<JobQuestionnairesJobIdFkeyInverseInput>;
  jobSkills?: InputMaybe<JobSkillsJobIdFkeyInverseInput>;
  jobTags?: InputMaybe<JobTagsJobIdFkeyInverseInput>;
  knowledges?: InputMaybe<Array<Scalars['String']['input']>>;
  languages?: InputMaybe<Array<InputMaybe<Language>>>;
  maxAgeCondition?: InputMaybe<Scalars['Int']['input']>;
  militaryStatus?: InputMaybe<Array<InputMaybe<MilitaryStatus>>>;
  minAgeCondition?: InputMaybe<Scalars['Int']['input']>;
  owners?: InputMaybe<JobOwnersJobIdFkeyInverseInput>;
  pipeline?: InputMaybe<JobsPipelineIdFkeyInput>;
  pipelineId?: InputMaybe<Scalars['Int']['input']>;
  position?: InputMaybe<Scalars['Int']['input']>;
  publishedAt?: InputMaybe<Scalars['Datetime']['input']>;
  skills?: InputMaybe<Array<Scalars['String']['input']>>;
  state?: InputMaybe<Scalars['Int']['input']>;
  status?: InputMaybe<JobStatus>;
  tags?: InputMaybe<Array<Scalars['String']['input']>>;
  threads?: InputMaybe<ThreadsJobIdFkeyInverseInput>;
  translations?: InputMaybe<JobTranslationsJobIdFkeyInverseInput>;
  workExperienceCondition?: InputMaybe<Scalars['Int']['input']>;
};

/** An object where the defined keys will be set on the `job` being updated. */
export type UpdateJobOnFieldForJobFieldsJobIdFkeyPatch = {
  address?: InputMaybe<Scalars['String']['input']>;
  applications?: InputMaybe<JobsApplicationsJobIdFkeyInverseInput>;
  city?: InputMaybe<Scalars['String']['input']>;
  competencies?: InputMaybe<Array<Scalars['String']['input']>>;
  country?: InputMaybe<Scalars['Int']['input']>;
  department?: InputMaybe<JobsDepartmentIdFkeyInput>;
  departmentId?: InputMaybe<Scalars['Int']['input']>;
  draftEvaluations?: InputMaybe<DraftEvaluationsJobIdFkeyInverseInput>;
  education?: InputMaybe<JobEducation>;
  evaluations?: InputMaybe<EvaluationsJobIdFkeyInverseInput>;
  fields?: InputMaybe<JobFieldsJobIdFkeyInverseInput>;
  genders?: InputMaybe<Array<InputMaybe<Gender>>>;
  gradeConditions?: InputMaybe<Array<InputMaybe<GradeCondition>>>;
  hoursPerWeek?: InputMaybe<IntRangeInput>;
  isRemote?: InputMaybe<Scalars['Boolean']['input']>;
  jobCompetencies?: InputMaybe<JobCompetenciesJobIdFkeyInverseInput>;
  jobKnowledges?: InputMaybe<JobKnowledgesJobIdFkeyInverseInput>;
  jobQuestionnaires?: InputMaybe<JobQuestionnairesJobIdFkeyInverseInput>;
  jobSkills?: InputMaybe<JobSkillsJobIdFkeyInverseInput>;
  jobTags?: InputMaybe<JobTagsJobIdFkeyInverseInput>;
  knowledges?: InputMaybe<Array<Scalars['String']['input']>>;
  languages?: InputMaybe<Array<InputMaybe<Language>>>;
  maxAgeCondition?: InputMaybe<Scalars['Int']['input']>;
  militaryStatus?: InputMaybe<Array<InputMaybe<MilitaryStatus>>>;
  minAgeCondition?: InputMaybe<Scalars['Int']['input']>;
  owners?: InputMaybe<JobOwnersJobIdFkeyInverseInput>;
  pipeline?: InputMaybe<JobsPipelineIdFkeyInput>;
  pipelineId?: InputMaybe<Scalars['Int']['input']>;
  position?: InputMaybe<Scalars['Int']['input']>;
  publishedAt?: InputMaybe<Scalars['Datetime']['input']>;
  skills?: InputMaybe<Array<Scalars['String']['input']>>;
  state?: InputMaybe<Scalars['Int']['input']>;
  status?: InputMaybe<JobStatus>;
  tags?: InputMaybe<Array<Scalars['String']['input']>>;
  threads?: InputMaybe<ThreadsJobIdFkeyInverseInput>;
  translations?: InputMaybe<JobTranslationsJobIdFkeyInverseInput>;
  workExperienceCondition?: InputMaybe<Scalars['Int']['input']>;
};

/** An object where the defined keys will be set on the `job` being updated. */
export type UpdateJobOnJobCompetencyForJobCompetenciesJobIdFkeyPatch = {
  address?: InputMaybe<Scalars['String']['input']>;
  applications?: InputMaybe<JobsApplicationsJobIdFkeyInverseInput>;
  city?: InputMaybe<Scalars['String']['input']>;
  competencies?: InputMaybe<Array<Scalars['String']['input']>>;
  country?: InputMaybe<Scalars['Int']['input']>;
  department?: InputMaybe<JobsDepartmentIdFkeyInput>;
  departmentId?: InputMaybe<Scalars['Int']['input']>;
  draftEvaluations?: InputMaybe<DraftEvaluationsJobIdFkeyInverseInput>;
  education?: InputMaybe<JobEducation>;
  evaluations?: InputMaybe<EvaluationsJobIdFkeyInverseInput>;
  fields?: InputMaybe<JobFieldsJobIdFkeyInverseInput>;
  genders?: InputMaybe<Array<InputMaybe<Gender>>>;
  gradeConditions?: InputMaybe<Array<InputMaybe<GradeCondition>>>;
  hoursPerWeek?: InputMaybe<IntRangeInput>;
  isRemote?: InputMaybe<Scalars['Boolean']['input']>;
  jobCompetencies?: InputMaybe<JobCompetenciesJobIdFkeyInverseInput>;
  jobKnowledges?: InputMaybe<JobKnowledgesJobIdFkeyInverseInput>;
  jobQuestionnaires?: InputMaybe<JobQuestionnairesJobIdFkeyInverseInput>;
  jobSkills?: InputMaybe<JobSkillsJobIdFkeyInverseInput>;
  jobTags?: InputMaybe<JobTagsJobIdFkeyInverseInput>;
  knowledges?: InputMaybe<Array<Scalars['String']['input']>>;
  languages?: InputMaybe<Array<InputMaybe<Language>>>;
  maxAgeCondition?: InputMaybe<Scalars['Int']['input']>;
  militaryStatus?: InputMaybe<Array<InputMaybe<MilitaryStatus>>>;
  minAgeCondition?: InputMaybe<Scalars['Int']['input']>;
  owners?: InputMaybe<JobOwnersJobIdFkeyInverseInput>;
  pipeline?: InputMaybe<JobsPipelineIdFkeyInput>;
  pipelineId?: InputMaybe<Scalars['Int']['input']>;
  position?: InputMaybe<Scalars['Int']['input']>;
  publishedAt?: InputMaybe<Scalars['Datetime']['input']>;
  skills?: InputMaybe<Array<Scalars['String']['input']>>;
  state?: InputMaybe<Scalars['Int']['input']>;
  status?: InputMaybe<JobStatus>;
  tags?: InputMaybe<Array<Scalars['String']['input']>>;
  threads?: InputMaybe<ThreadsJobIdFkeyInverseInput>;
  translations?: InputMaybe<JobTranslationsJobIdFkeyInverseInput>;
  workExperienceCondition?: InputMaybe<Scalars['Int']['input']>;
};

/** An object where the defined keys will be set on the `job` being updated. */
export type UpdateJobOnJobForJobsDepartmentIdFkeyPatch = {
  address?: InputMaybe<Scalars['String']['input']>;
  applications?: InputMaybe<JobsApplicationsJobIdFkeyInverseInput>;
  city?: InputMaybe<Scalars['String']['input']>;
  competencies?: InputMaybe<Array<Scalars['String']['input']>>;
  country?: InputMaybe<Scalars['Int']['input']>;
  department?: InputMaybe<JobsDepartmentIdFkeyInput>;
  draftEvaluations?: InputMaybe<DraftEvaluationsJobIdFkeyInverseInput>;
  education?: InputMaybe<JobEducation>;
  evaluations?: InputMaybe<EvaluationsJobIdFkeyInverseInput>;
  fields?: InputMaybe<JobFieldsJobIdFkeyInverseInput>;
  genders?: InputMaybe<Array<InputMaybe<Gender>>>;
  gradeConditions?: InputMaybe<Array<InputMaybe<GradeCondition>>>;
  hoursPerWeek?: InputMaybe<IntRangeInput>;
  isRemote?: InputMaybe<Scalars['Boolean']['input']>;
  jobCompetencies?: InputMaybe<JobCompetenciesJobIdFkeyInverseInput>;
  jobKnowledges?: InputMaybe<JobKnowledgesJobIdFkeyInverseInput>;
  jobQuestionnaires?: InputMaybe<JobQuestionnairesJobIdFkeyInverseInput>;
  jobSkills?: InputMaybe<JobSkillsJobIdFkeyInverseInput>;
  jobTags?: InputMaybe<JobTagsJobIdFkeyInverseInput>;
  knowledges?: InputMaybe<Array<Scalars['String']['input']>>;
  languages?: InputMaybe<Array<InputMaybe<Language>>>;
  maxAgeCondition?: InputMaybe<Scalars['Int']['input']>;
  militaryStatus?: InputMaybe<Array<InputMaybe<MilitaryStatus>>>;
  minAgeCondition?: InputMaybe<Scalars['Int']['input']>;
  owners?: InputMaybe<JobOwnersJobIdFkeyInverseInput>;
  pipeline?: InputMaybe<JobsPipelineIdFkeyInput>;
  pipelineId?: InputMaybe<Scalars['Int']['input']>;
  position?: InputMaybe<Scalars['Int']['input']>;
  publishedAt?: InputMaybe<Scalars['Datetime']['input']>;
  skills?: InputMaybe<Array<Scalars['String']['input']>>;
  state?: InputMaybe<Scalars['Int']['input']>;
  status?: InputMaybe<JobStatus>;
  tags?: InputMaybe<Array<Scalars['String']['input']>>;
  threads?: InputMaybe<ThreadsJobIdFkeyInverseInput>;
  translations?: InputMaybe<JobTranslationsJobIdFkeyInverseInput>;
  workExperienceCondition?: InputMaybe<Scalars['Int']['input']>;
};

/** An object where the defined keys will be set on the `job` being updated. */
export type UpdateJobOnJobForJobsPipelineIdFkeyPatch = {
  address?: InputMaybe<Scalars['String']['input']>;
  applications?: InputMaybe<JobsApplicationsJobIdFkeyInverseInput>;
  city?: InputMaybe<Scalars['String']['input']>;
  competencies?: InputMaybe<Array<Scalars['String']['input']>>;
  country?: InputMaybe<Scalars['Int']['input']>;
  department?: InputMaybe<JobsDepartmentIdFkeyInput>;
  departmentId?: InputMaybe<Scalars['Int']['input']>;
  draftEvaluations?: InputMaybe<DraftEvaluationsJobIdFkeyInverseInput>;
  education?: InputMaybe<JobEducation>;
  evaluations?: InputMaybe<EvaluationsJobIdFkeyInverseInput>;
  fields?: InputMaybe<JobFieldsJobIdFkeyInverseInput>;
  genders?: InputMaybe<Array<InputMaybe<Gender>>>;
  gradeConditions?: InputMaybe<Array<InputMaybe<GradeCondition>>>;
  hoursPerWeek?: InputMaybe<IntRangeInput>;
  isRemote?: InputMaybe<Scalars['Boolean']['input']>;
  jobCompetencies?: InputMaybe<JobCompetenciesJobIdFkeyInverseInput>;
  jobKnowledges?: InputMaybe<JobKnowledgesJobIdFkeyInverseInput>;
  jobQuestionnaires?: InputMaybe<JobQuestionnairesJobIdFkeyInverseInput>;
  jobSkills?: InputMaybe<JobSkillsJobIdFkeyInverseInput>;
  jobTags?: InputMaybe<JobTagsJobIdFkeyInverseInput>;
  knowledges?: InputMaybe<Array<Scalars['String']['input']>>;
  languages?: InputMaybe<Array<InputMaybe<Language>>>;
  maxAgeCondition?: InputMaybe<Scalars['Int']['input']>;
  militaryStatus?: InputMaybe<Array<InputMaybe<MilitaryStatus>>>;
  minAgeCondition?: InputMaybe<Scalars['Int']['input']>;
  owners?: InputMaybe<JobOwnersJobIdFkeyInverseInput>;
  pipeline?: InputMaybe<JobsPipelineIdFkeyInput>;
  position?: InputMaybe<Scalars['Int']['input']>;
  publishedAt?: InputMaybe<Scalars['Datetime']['input']>;
  skills?: InputMaybe<Array<Scalars['String']['input']>>;
  state?: InputMaybe<Scalars['Int']['input']>;
  status?: InputMaybe<JobStatus>;
  tags?: InputMaybe<Array<Scalars['String']['input']>>;
  threads?: InputMaybe<ThreadsJobIdFkeyInverseInput>;
  translations?: InputMaybe<JobTranslationsJobIdFkeyInverseInput>;
  workExperienceCondition?: InputMaybe<Scalars['Int']['input']>;
};

/** An object where the defined keys will be set on the `job` being updated. */
export type UpdateJobOnJobKnowledgeForJobKnowledgesJobIdFkeyPatch = {
  address?: InputMaybe<Scalars['String']['input']>;
  applications?: InputMaybe<JobsApplicationsJobIdFkeyInverseInput>;
  city?: InputMaybe<Scalars['String']['input']>;
  competencies?: InputMaybe<Array<Scalars['String']['input']>>;
  country?: InputMaybe<Scalars['Int']['input']>;
  department?: InputMaybe<JobsDepartmentIdFkeyInput>;
  departmentId?: InputMaybe<Scalars['Int']['input']>;
  draftEvaluations?: InputMaybe<DraftEvaluationsJobIdFkeyInverseInput>;
  education?: InputMaybe<JobEducation>;
  evaluations?: InputMaybe<EvaluationsJobIdFkeyInverseInput>;
  fields?: InputMaybe<JobFieldsJobIdFkeyInverseInput>;
  genders?: InputMaybe<Array<InputMaybe<Gender>>>;
  gradeConditions?: InputMaybe<Array<InputMaybe<GradeCondition>>>;
  hoursPerWeek?: InputMaybe<IntRangeInput>;
  isRemote?: InputMaybe<Scalars['Boolean']['input']>;
  jobCompetencies?: InputMaybe<JobCompetenciesJobIdFkeyInverseInput>;
  jobKnowledges?: InputMaybe<JobKnowledgesJobIdFkeyInverseInput>;
  jobQuestionnaires?: InputMaybe<JobQuestionnairesJobIdFkeyInverseInput>;
  jobSkills?: InputMaybe<JobSkillsJobIdFkeyInverseInput>;
  jobTags?: InputMaybe<JobTagsJobIdFkeyInverseInput>;
  knowledges?: InputMaybe<Array<Scalars['String']['input']>>;
  languages?: InputMaybe<Array<InputMaybe<Language>>>;
  maxAgeCondition?: InputMaybe<Scalars['Int']['input']>;
  militaryStatus?: InputMaybe<Array<InputMaybe<MilitaryStatus>>>;
  minAgeCondition?: InputMaybe<Scalars['Int']['input']>;
  owners?: InputMaybe<JobOwnersJobIdFkeyInverseInput>;
  pipeline?: InputMaybe<JobsPipelineIdFkeyInput>;
  pipelineId?: InputMaybe<Scalars['Int']['input']>;
  position?: InputMaybe<Scalars['Int']['input']>;
  publishedAt?: InputMaybe<Scalars['Datetime']['input']>;
  skills?: InputMaybe<Array<Scalars['String']['input']>>;
  state?: InputMaybe<Scalars['Int']['input']>;
  status?: InputMaybe<JobStatus>;
  tags?: InputMaybe<Array<Scalars['String']['input']>>;
  threads?: InputMaybe<ThreadsJobIdFkeyInverseInput>;
  translations?: InputMaybe<JobTranslationsJobIdFkeyInverseInput>;
  workExperienceCondition?: InputMaybe<Scalars['Int']['input']>;
};

/** An object where the defined keys will be set on the `job` being updated. */
export type UpdateJobOnJobOwnerForJobOwnersJobIdFkeyPatch = {
  address?: InputMaybe<Scalars['String']['input']>;
  applications?: InputMaybe<JobsApplicationsJobIdFkeyInverseInput>;
  city?: InputMaybe<Scalars['String']['input']>;
  competencies?: InputMaybe<Array<Scalars['String']['input']>>;
  country?: InputMaybe<Scalars['Int']['input']>;
  department?: InputMaybe<JobsDepartmentIdFkeyInput>;
  departmentId?: InputMaybe<Scalars['Int']['input']>;
  draftEvaluations?: InputMaybe<DraftEvaluationsJobIdFkeyInverseInput>;
  education?: InputMaybe<JobEducation>;
  evaluations?: InputMaybe<EvaluationsJobIdFkeyInverseInput>;
  fields?: InputMaybe<JobFieldsJobIdFkeyInverseInput>;
  genders?: InputMaybe<Array<InputMaybe<Gender>>>;
  gradeConditions?: InputMaybe<Array<InputMaybe<GradeCondition>>>;
  hoursPerWeek?: InputMaybe<IntRangeInput>;
  isRemote?: InputMaybe<Scalars['Boolean']['input']>;
  jobCompetencies?: InputMaybe<JobCompetenciesJobIdFkeyInverseInput>;
  jobKnowledges?: InputMaybe<JobKnowledgesJobIdFkeyInverseInput>;
  jobQuestionnaires?: InputMaybe<JobQuestionnairesJobIdFkeyInverseInput>;
  jobSkills?: InputMaybe<JobSkillsJobIdFkeyInverseInput>;
  jobTags?: InputMaybe<JobTagsJobIdFkeyInverseInput>;
  knowledges?: InputMaybe<Array<Scalars['String']['input']>>;
  languages?: InputMaybe<Array<InputMaybe<Language>>>;
  maxAgeCondition?: InputMaybe<Scalars['Int']['input']>;
  militaryStatus?: InputMaybe<Array<InputMaybe<MilitaryStatus>>>;
  minAgeCondition?: InputMaybe<Scalars['Int']['input']>;
  owners?: InputMaybe<JobOwnersJobIdFkeyInverseInput>;
  pipeline?: InputMaybe<JobsPipelineIdFkeyInput>;
  pipelineId?: InputMaybe<Scalars['Int']['input']>;
  position?: InputMaybe<Scalars['Int']['input']>;
  publishedAt?: InputMaybe<Scalars['Datetime']['input']>;
  skills?: InputMaybe<Array<Scalars['String']['input']>>;
  state?: InputMaybe<Scalars['Int']['input']>;
  status?: InputMaybe<JobStatus>;
  tags?: InputMaybe<Array<Scalars['String']['input']>>;
  threads?: InputMaybe<ThreadsJobIdFkeyInverseInput>;
  translations?: InputMaybe<JobTranslationsJobIdFkeyInverseInput>;
  workExperienceCondition?: InputMaybe<Scalars['Int']['input']>;
};

/** An object where the defined keys will be set on the `job` being updated. */
export type UpdateJobOnJobQuestionnaireForJobQuestionnairesJobIdFkeyPatch = {
  address?: InputMaybe<Scalars['String']['input']>;
  applications?: InputMaybe<JobsApplicationsJobIdFkeyInverseInput>;
  city?: InputMaybe<Scalars['String']['input']>;
  competencies?: InputMaybe<Array<Scalars['String']['input']>>;
  country?: InputMaybe<Scalars['Int']['input']>;
  department?: InputMaybe<JobsDepartmentIdFkeyInput>;
  departmentId?: InputMaybe<Scalars['Int']['input']>;
  draftEvaluations?: InputMaybe<DraftEvaluationsJobIdFkeyInverseInput>;
  education?: InputMaybe<JobEducation>;
  evaluations?: InputMaybe<EvaluationsJobIdFkeyInverseInput>;
  fields?: InputMaybe<JobFieldsJobIdFkeyInverseInput>;
  genders?: InputMaybe<Array<InputMaybe<Gender>>>;
  gradeConditions?: InputMaybe<Array<InputMaybe<GradeCondition>>>;
  hoursPerWeek?: InputMaybe<IntRangeInput>;
  isRemote?: InputMaybe<Scalars['Boolean']['input']>;
  jobCompetencies?: InputMaybe<JobCompetenciesJobIdFkeyInverseInput>;
  jobKnowledges?: InputMaybe<JobKnowledgesJobIdFkeyInverseInput>;
  jobQuestionnaires?: InputMaybe<JobQuestionnairesJobIdFkeyInverseInput>;
  jobSkills?: InputMaybe<JobSkillsJobIdFkeyInverseInput>;
  jobTags?: InputMaybe<JobTagsJobIdFkeyInverseInput>;
  knowledges?: InputMaybe<Array<Scalars['String']['input']>>;
  languages?: InputMaybe<Array<InputMaybe<Language>>>;
  maxAgeCondition?: InputMaybe<Scalars['Int']['input']>;
  militaryStatus?: InputMaybe<Array<InputMaybe<MilitaryStatus>>>;
  minAgeCondition?: InputMaybe<Scalars['Int']['input']>;
  owners?: InputMaybe<JobOwnersJobIdFkeyInverseInput>;
  pipeline?: InputMaybe<JobsPipelineIdFkeyInput>;
  pipelineId?: InputMaybe<Scalars['Int']['input']>;
  position?: InputMaybe<Scalars['Int']['input']>;
  publishedAt?: InputMaybe<Scalars['Datetime']['input']>;
  skills?: InputMaybe<Array<Scalars['String']['input']>>;
  state?: InputMaybe<Scalars['Int']['input']>;
  status?: InputMaybe<JobStatus>;
  tags?: InputMaybe<Array<Scalars['String']['input']>>;
  threads?: InputMaybe<ThreadsJobIdFkeyInverseInput>;
  translations?: InputMaybe<JobTranslationsJobIdFkeyInverseInput>;
  workExperienceCondition?: InputMaybe<Scalars['Int']['input']>;
};

/** An object where the defined keys will be set on the `job` being updated. */
export type UpdateJobOnJobSkillForJobSkillsJobIdFkeyPatch = {
  address?: InputMaybe<Scalars['String']['input']>;
  applications?: InputMaybe<JobsApplicationsJobIdFkeyInverseInput>;
  city?: InputMaybe<Scalars['String']['input']>;
  competencies?: InputMaybe<Array<Scalars['String']['input']>>;
  country?: InputMaybe<Scalars['Int']['input']>;
  department?: InputMaybe<JobsDepartmentIdFkeyInput>;
  departmentId?: InputMaybe<Scalars['Int']['input']>;
  draftEvaluations?: InputMaybe<DraftEvaluationsJobIdFkeyInverseInput>;
  education?: InputMaybe<JobEducation>;
  evaluations?: InputMaybe<EvaluationsJobIdFkeyInverseInput>;
  fields?: InputMaybe<JobFieldsJobIdFkeyInverseInput>;
  genders?: InputMaybe<Array<InputMaybe<Gender>>>;
  gradeConditions?: InputMaybe<Array<InputMaybe<GradeCondition>>>;
  hoursPerWeek?: InputMaybe<IntRangeInput>;
  isRemote?: InputMaybe<Scalars['Boolean']['input']>;
  jobCompetencies?: InputMaybe<JobCompetenciesJobIdFkeyInverseInput>;
  jobKnowledges?: InputMaybe<JobKnowledgesJobIdFkeyInverseInput>;
  jobQuestionnaires?: InputMaybe<JobQuestionnairesJobIdFkeyInverseInput>;
  jobSkills?: InputMaybe<JobSkillsJobIdFkeyInverseInput>;
  jobTags?: InputMaybe<JobTagsJobIdFkeyInverseInput>;
  knowledges?: InputMaybe<Array<Scalars['String']['input']>>;
  languages?: InputMaybe<Array<InputMaybe<Language>>>;
  maxAgeCondition?: InputMaybe<Scalars['Int']['input']>;
  militaryStatus?: InputMaybe<Array<InputMaybe<MilitaryStatus>>>;
  minAgeCondition?: InputMaybe<Scalars['Int']['input']>;
  owners?: InputMaybe<JobOwnersJobIdFkeyInverseInput>;
  pipeline?: InputMaybe<JobsPipelineIdFkeyInput>;
  pipelineId?: InputMaybe<Scalars['Int']['input']>;
  position?: InputMaybe<Scalars['Int']['input']>;
  publishedAt?: InputMaybe<Scalars['Datetime']['input']>;
  skills?: InputMaybe<Array<Scalars['String']['input']>>;
  state?: InputMaybe<Scalars['Int']['input']>;
  status?: InputMaybe<JobStatus>;
  tags?: InputMaybe<Array<Scalars['String']['input']>>;
  threads?: InputMaybe<ThreadsJobIdFkeyInverseInput>;
  translations?: InputMaybe<JobTranslationsJobIdFkeyInverseInput>;
  workExperienceCondition?: InputMaybe<Scalars['Int']['input']>;
};

/** An object where the defined keys will be set on the `job` being updated. */
export type UpdateJobOnJobTagForJobTagsJobIdFkeyPatch = {
  address?: InputMaybe<Scalars['String']['input']>;
  applications?: InputMaybe<JobsApplicationsJobIdFkeyInverseInput>;
  city?: InputMaybe<Scalars['String']['input']>;
  competencies?: InputMaybe<Array<Scalars['String']['input']>>;
  country?: InputMaybe<Scalars['Int']['input']>;
  department?: InputMaybe<JobsDepartmentIdFkeyInput>;
  departmentId?: InputMaybe<Scalars['Int']['input']>;
  draftEvaluations?: InputMaybe<DraftEvaluationsJobIdFkeyInverseInput>;
  education?: InputMaybe<JobEducation>;
  evaluations?: InputMaybe<EvaluationsJobIdFkeyInverseInput>;
  fields?: InputMaybe<JobFieldsJobIdFkeyInverseInput>;
  genders?: InputMaybe<Array<InputMaybe<Gender>>>;
  gradeConditions?: InputMaybe<Array<InputMaybe<GradeCondition>>>;
  hoursPerWeek?: InputMaybe<IntRangeInput>;
  isRemote?: InputMaybe<Scalars['Boolean']['input']>;
  jobCompetencies?: InputMaybe<JobCompetenciesJobIdFkeyInverseInput>;
  jobKnowledges?: InputMaybe<JobKnowledgesJobIdFkeyInverseInput>;
  jobQuestionnaires?: InputMaybe<JobQuestionnairesJobIdFkeyInverseInput>;
  jobSkills?: InputMaybe<JobSkillsJobIdFkeyInverseInput>;
  jobTags?: InputMaybe<JobTagsJobIdFkeyInverseInput>;
  knowledges?: InputMaybe<Array<Scalars['String']['input']>>;
  languages?: InputMaybe<Array<InputMaybe<Language>>>;
  maxAgeCondition?: InputMaybe<Scalars['Int']['input']>;
  militaryStatus?: InputMaybe<Array<InputMaybe<MilitaryStatus>>>;
  minAgeCondition?: InputMaybe<Scalars['Int']['input']>;
  owners?: InputMaybe<JobOwnersJobIdFkeyInverseInput>;
  pipeline?: InputMaybe<JobsPipelineIdFkeyInput>;
  pipelineId?: InputMaybe<Scalars['Int']['input']>;
  position?: InputMaybe<Scalars['Int']['input']>;
  publishedAt?: InputMaybe<Scalars['Datetime']['input']>;
  skills?: InputMaybe<Array<Scalars['String']['input']>>;
  state?: InputMaybe<Scalars['Int']['input']>;
  status?: InputMaybe<JobStatus>;
  tags?: InputMaybe<Array<Scalars['String']['input']>>;
  threads?: InputMaybe<ThreadsJobIdFkeyInverseInput>;
  translations?: InputMaybe<JobTranslationsJobIdFkeyInverseInput>;
  workExperienceCondition?: InputMaybe<Scalars['Int']['input']>;
};

/** An object where the defined keys will be set on the `job` being updated. */
export type UpdateJobOnJobTranslationForJobTranslationsJobIdFkeyPatch = {
  address?: InputMaybe<Scalars['String']['input']>;
  applications?: InputMaybe<JobsApplicationsJobIdFkeyInverseInput>;
  city?: InputMaybe<Scalars['String']['input']>;
  competencies?: InputMaybe<Array<Scalars['String']['input']>>;
  country?: InputMaybe<Scalars['Int']['input']>;
  department?: InputMaybe<JobsDepartmentIdFkeyInput>;
  departmentId?: InputMaybe<Scalars['Int']['input']>;
  draftEvaluations?: InputMaybe<DraftEvaluationsJobIdFkeyInverseInput>;
  education?: InputMaybe<JobEducation>;
  evaluations?: InputMaybe<EvaluationsJobIdFkeyInverseInput>;
  fields?: InputMaybe<JobFieldsJobIdFkeyInverseInput>;
  genders?: InputMaybe<Array<InputMaybe<Gender>>>;
  gradeConditions?: InputMaybe<Array<InputMaybe<GradeCondition>>>;
  hoursPerWeek?: InputMaybe<IntRangeInput>;
  isRemote?: InputMaybe<Scalars['Boolean']['input']>;
  jobCompetencies?: InputMaybe<JobCompetenciesJobIdFkeyInverseInput>;
  jobKnowledges?: InputMaybe<JobKnowledgesJobIdFkeyInverseInput>;
  jobQuestionnaires?: InputMaybe<JobQuestionnairesJobIdFkeyInverseInput>;
  jobSkills?: InputMaybe<JobSkillsJobIdFkeyInverseInput>;
  jobTags?: InputMaybe<JobTagsJobIdFkeyInverseInput>;
  knowledges?: InputMaybe<Array<Scalars['String']['input']>>;
  languages?: InputMaybe<Array<InputMaybe<Language>>>;
  maxAgeCondition?: InputMaybe<Scalars['Int']['input']>;
  militaryStatus?: InputMaybe<Array<InputMaybe<MilitaryStatus>>>;
  minAgeCondition?: InputMaybe<Scalars['Int']['input']>;
  owners?: InputMaybe<JobOwnersJobIdFkeyInverseInput>;
  pipeline?: InputMaybe<JobsPipelineIdFkeyInput>;
  pipelineId?: InputMaybe<Scalars['Int']['input']>;
  position?: InputMaybe<Scalars['Int']['input']>;
  publishedAt?: InputMaybe<Scalars['Datetime']['input']>;
  skills?: InputMaybe<Array<Scalars['String']['input']>>;
  state?: InputMaybe<Scalars['Int']['input']>;
  status?: InputMaybe<JobStatus>;
  tags?: InputMaybe<Array<Scalars['String']['input']>>;
  threads?: InputMaybe<ThreadsJobIdFkeyInverseInput>;
  translations?: InputMaybe<JobTranslationsJobIdFkeyInverseInput>;
  workExperienceCondition?: InputMaybe<Scalars['Int']['input']>;
};

/** An object where the defined keys will be set on the `job` being updated. */
export type UpdateJobOnJobsApplicationForJobsApplicationsJobIdFkeyPatch = {
  address?: InputMaybe<Scalars['String']['input']>;
  applications?: InputMaybe<JobsApplicationsJobIdFkeyInverseInput>;
  city?: InputMaybe<Scalars['String']['input']>;
  competencies?: InputMaybe<Array<Scalars['String']['input']>>;
  country?: InputMaybe<Scalars['Int']['input']>;
  department?: InputMaybe<JobsDepartmentIdFkeyInput>;
  departmentId?: InputMaybe<Scalars['Int']['input']>;
  draftEvaluations?: InputMaybe<DraftEvaluationsJobIdFkeyInverseInput>;
  education?: InputMaybe<JobEducation>;
  evaluations?: InputMaybe<EvaluationsJobIdFkeyInverseInput>;
  fields?: InputMaybe<JobFieldsJobIdFkeyInverseInput>;
  genders?: InputMaybe<Array<InputMaybe<Gender>>>;
  gradeConditions?: InputMaybe<Array<InputMaybe<GradeCondition>>>;
  hoursPerWeek?: InputMaybe<IntRangeInput>;
  isRemote?: InputMaybe<Scalars['Boolean']['input']>;
  jobCompetencies?: InputMaybe<JobCompetenciesJobIdFkeyInverseInput>;
  jobKnowledges?: InputMaybe<JobKnowledgesJobIdFkeyInverseInput>;
  jobQuestionnaires?: InputMaybe<JobQuestionnairesJobIdFkeyInverseInput>;
  jobSkills?: InputMaybe<JobSkillsJobIdFkeyInverseInput>;
  jobTags?: InputMaybe<JobTagsJobIdFkeyInverseInput>;
  knowledges?: InputMaybe<Array<Scalars['String']['input']>>;
  languages?: InputMaybe<Array<InputMaybe<Language>>>;
  maxAgeCondition?: InputMaybe<Scalars['Int']['input']>;
  militaryStatus?: InputMaybe<Array<InputMaybe<MilitaryStatus>>>;
  minAgeCondition?: InputMaybe<Scalars['Int']['input']>;
  owners?: InputMaybe<JobOwnersJobIdFkeyInverseInput>;
  pipeline?: InputMaybe<JobsPipelineIdFkeyInput>;
  pipelineId?: InputMaybe<Scalars['Int']['input']>;
  position?: InputMaybe<Scalars['Int']['input']>;
  publishedAt?: InputMaybe<Scalars['Datetime']['input']>;
  skills?: InputMaybe<Array<Scalars['String']['input']>>;
  state?: InputMaybe<Scalars['Int']['input']>;
  status?: InputMaybe<JobStatus>;
  tags?: InputMaybe<Array<Scalars['String']['input']>>;
  threads?: InputMaybe<ThreadsJobIdFkeyInverseInput>;
  translations?: InputMaybe<JobTranslationsJobIdFkeyInverseInput>;
  workExperienceCondition?: InputMaybe<Scalars['Int']['input']>;
};

/** An object where the defined keys will be set on the `job` being updated. */
export type UpdateJobOnThreadForThreadsJobIdFkeyPatch = {
  address?: InputMaybe<Scalars['String']['input']>;
  applications?: InputMaybe<JobsApplicationsJobIdFkeyInverseInput>;
  city?: InputMaybe<Scalars['String']['input']>;
  competencies?: InputMaybe<Array<Scalars['String']['input']>>;
  country?: InputMaybe<Scalars['Int']['input']>;
  department?: InputMaybe<JobsDepartmentIdFkeyInput>;
  departmentId?: InputMaybe<Scalars['Int']['input']>;
  draftEvaluations?: InputMaybe<DraftEvaluationsJobIdFkeyInverseInput>;
  education?: InputMaybe<JobEducation>;
  evaluations?: InputMaybe<EvaluationsJobIdFkeyInverseInput>;
  fields?: InputMaybe<JobFieldsJobIdFkeyInverseInput>;
  genders?: InputMaybe<Array<InputMaybe<Gender>>>;
  gradeConditions?: InputMaybe<Array<InputMaybe<GradeCondition>>>;
  hoursPerWeek?: InputMaybe<IntRangeInput>;
  isRemote?: InputMaybe<Scalars['Boolean']['input']>;
  jobCompetencies?: InputMaybe<JobCompetenciesJobIdFkeyInverseInput>;
  jobKnowledges?: InputMaybe<JobKnowledgesJobIdFkeyInverseInput>;
  jobQuestionnaires?: InputMaybe<JobQuestionnairesJobIdFkeyInverseInput>;
  jobSkills?: InputMaybe<JobSkillsJobIdFkeyInverseInput>;
  jobTags?: InputMaybe<JobTagsJobIdFkeyInverseInput>;
  knowledges?: InputMaybe<Array<Scalars['String']['input']>>;
  languages?: InputMaybe<Array<InputMaybe<Language>>>;
  maxAgeCondition?: InputMaybe<Scalars['Int']['input']>;
  militaryStatus?: InputMaybe<Array<InputMaybe<MilitaryStatus>>>;
  minAgeCondition?: InputMaybe<Scalars['Int']['input']>;
  owners?: InputMaybe<JobOwnersJobIdFkeyInverseInput>;
  pipeline?: InputMaybe<JobsPipelineIdFkeyInput>;
  pipelineId?: InputMaybe<Scalars['Int']['input']>;
  position?: InputMaybe<Scalars['Int']['input']>;
  publishedAt?: InputMaybe<Scalars['Datetime']['input']>;
  skills?: InputMaybe<Array<Scalars['String']['input']>>;
  state?: InputMaybe<Scalars['Int']['input']>;
  status?: InputMaybe<JobStatus>;
  tags?: InputMaybe<Array<Scalars['String']['input']>>;
  threads?: InputMaybe<ThreadsJobIdFkeyInverseInput>;
  translations?: InputMaybe<JobTranslationsJobIdFkeyInverseInput>;
  workExperienceCondition?: InputMaybe<Scalars['Int']['input']>;
};

/** An object where the defined keys will be set on the `jobOwner` being updated. */
export type UpdateJobOwnerOnJobOwnerForJobOwnersJobIdFkeyPatch = {
  job?: InputMaybe<JobOwnersJobIdFkeyInput>;
  user?: InputMaybe<JobOwnersUserIdFkeyInput>;
  userId?: InputMaybe<Scalars['Int']['input']>;
};

/** An object where the defined keys will be set on the `jobOwner` being updated. */
export type UpdateJobOwnerOnJobOwnerForJobOwnersUserIdFkeyPatch = {
  job?: InputMaybe<JobOwnersJobIdFkeyInput>;
  jobId?: InputMaybe<Scalars['Int']['input']>;
  user?: InputMaybe<JobOwnersUserIdFkeyInput>;
};

/** An object where the defined keys will be set on the `jobQuestionnaire` being updated. */
export type UpdateJobQuestionnaireOnJobQuestionnaireForJobQuestionnairesJobIdFkeyPatch = {
  job?: InputMaybe<JobQuestionnairesJobIdFkeyInput>;
  questionnaire?: InputMaybe<JobQuestionnairesQuestionnaireIdFkeyInput>;
  questionnaireId?: InputMaybe<Scalars['Int']['input']>;
};

/** An object where the defined keys will be set on the `jobQuestionnaire` being updated. */
export type UpdateJobQuestionnaireOnJobQuestionnaireForJobQuestionnairesQuestionnaireIdFkeyPatch = {
  job?: InputMaybe<JobQuestionnairesJobIdFkeyInput>;
  jobId?: InputMaybe<Scalars['Int']['input']>;
  questionnaire?: InputMaybe<JobQuestionnairesQuestionnaireIdFkeyInput>;
};

/** An object where the defined keys will be set on the `jobSkill` being updated. */
export type UpdateJobSkillOnJobSkillForJobSkillsJobIdFkeyPatch = {
  job?: InputMaybe<JobSkillsJobIdFkeyInput>;
  skill?: InputMaybe<JobSkillsSkillIdFkeyInput>;
  skillId?: InputMaybe<Scalars['Int']['input']>;
};

/** An object where the defined keys will be set on the `jobSkill` being updated. */
export type UpdateJobSkillOnJobSkillForJobSkillsSkillIdFkeyPatch = {
  job?: InputMaybe<JobSkillsJobIdFkeyInput>;
  jobId?: InputMaybe<Scalars['Int']['input']>;
  skill?: InputMaybe<JobSkillsSkillIdFkeyInput>;
};

/** An object where the defined keys will be set on the `jobTag` being updated. */
export type UpdateJobTagOnJobTagForJobTagsJobIdFkeyPatch = {
  job?: InputMaybe<JobTagsJobIdFkeyInput>;
  tag?: InputMaybe<JobTagsTagIdFkeyInput>;
  tagId?: InputMaybe<Scalars['Int']['input']>;
};

/** An object where the defined keys will be set on the `jobTag` being updated. */
export type UpdateJobTagOnJobTagForJobTagsTagIdFkeyPatch = {
  job?: InputMaybe<JobTagsJobIdFkeyInput>;
  jobId?: InputMaybe<Scalars['Int']['input']>;
  tag?: InputMaybe<JobTagsTagIdFkeyInput>;
};

/** An object where the defined keys will be set on the `jobTranslation` being updated. */
export type UpdateJobTranslationOnJobTranslationForJobTranslationsJobIdFkeyPatch = {
  description?: InputMaybe<Scalars['Html']['input']>;
  fieldOfStudy?: InputMaybe<Scalars['String']['input']>;
  job?: InputMaybe<JobTranslationsJobIdFkeyInput>;
  orientation?: InputMaybe<Scalars['String']['input']>;
  requirements?: InputMaybe<Scalars['Html']['input']>;
  title?: InputMaybe<Scalars['String']['input']>;
};

/** An object where the defined keys will be set on the `jobsApplication` being updated. */
export type UpdateJobsApplicationOnJobsApplicationForJobsApplicationsCandidateIdFkeyPatch = {
  candidate?: InputMaybe<JobsApplicationsCandidateIdFkeyInput>;
  coverLetter?: InputMaybe<Scalars['String']['input']>;
  disqualifyReason?: InputMaybe<JobsApplicationsDisqualifyReasonIdFkeyInput>;
  disqualifyReasonId?: InputMaybe<Scalars['Int']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  job?: InputMaybe<JobsApplicationsJobIdFkeyInput>;
  jobId?: InputMaybe<Scalars['Int']['input']>;
  pipelineStage?: InputMaybe<JobsApplicationsPipelineStageIdFkeyInput>;
  pipelineStageId?: InputMaybe<Scalars['Int']['input']>;
};

/** An object where the defined keys will be set on the `jobsApplication` being updated. */
export type UpdateJobsApplicationOnJobsApplicationForJobsApplicationsDisqualifyReasonIdFkeyPatch = {
  candidate?: InputMaybe<JobsApplicationsCandidateIdFkeyInput>;
  candidateId?: InputMaybe<Scalars['Int']['input']>;
  coverLetter?: InputMaybe<Scalars['String']['input']>;
  disqualifyReason?: InputMaybe<JobsApplicationsDisqualifyReasonIdFkeyInput>;
  id?: InputMaybe<Scalars['Int']['input']>;
  job?: InputMaybe<JobsApplicationsJobIdFkeyInput>;
  jobId?: InputMaybe<Scalars['Int']['input']>;
  pipelineStage?: InputMaybe<JobsApplicationsPipelineStageIdFkeyInput>;
  pipelineStageId?: InputMaybe<Scalars['Int']['input']>;
};

/** An object where the defined keys will be set on the `jobsApplication` being updated. */
export type UpdateJobsApplicationOnJobsApplicationForJobsApplicationsJobIdFkeyPatch = {
  candidate?: InputMaybe<JobsApplicationsCandidateIdFkeyInput>;
  candidateId?: InputMaybe<Scalars['Int']['input']>;
  coverLetter?: InputMaybe<Scalars['String']['input']>;
  disqualifyReason?: InputMaybe<JobsApplicationsDisqualifyReasonIdFkeyInput>;
  disqualifyReasonId?: InputMaybe<Scalars['Int']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  job?: InputMaybe<JobsApplicationsJobIdFkeyInput>;
  pipelineStage?: InputMaybe<JobsApplicationsPipelineStageIdFkeyInput>;
  pipelineStageId?: InputMaybe<Scalars['Int']['input']>;
};

/** An object where the defined keys will be set on the `jobsApplication` being updated. */
export type UpdateJobsApplicationOnJobsApplicationForJobsApplicationsPipelineStageIdFkeyPatch = {
  candidate?: InputMaybe<JobsApplicationsCandidateIdFkeyInput>;
  candidateId?: InputMaybe<Scalars['Int']['input']>;
  coverLetter?: InputMaybe<Scalars['String']['input']>;
  disqualifyReason?: InputMaybe<JobsApplicationsDisqualifyReasonIdFkeyInput>;
  disqualifyReasonId?: InputMaybe<Scalars['Int']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  job?: InputMaybe<JobsApplicationsJobIdFkeyInput>;
  jobId?: InputMaybe<Scalars['Int']['input']>;
  pipelineStage?: InputMaybe<JobsApplicationsPipelineStageIdFkeyInput>;
};

/** An object where the defined keys will be set on the `knowledge` being updated. */
export type UpdateKnowledgeOnJobKnowledgeForJobKnowledgesKnowledgeIdFkeyPatch = {
  jobKnowledges?: InputMaybe<JobKnowledgesKnowledgeIdFkeyInverseInput>;
  title?: InputMaybe<Scalars['String']['input']>;
};

/** An object where the defined keys will be set on the `messageFile` being updated. */
export type UpdateMessageFileOnMessageFileForMessageFilesMessageIdFkeyPatch = {
  message?: InputMaybe<MessageFilesMessageIdFkeyInput>;
};

/** An object where the defined keys will be set on the `message` being updated. */
export type UpdateMessageOnMessageFileForMessageFilesMessageIdFkeyPatch = {
  files?: InputMaybe<MessageFilesMessageIdFkeyInverseInput>;
  thread?: InputMaybe<MessagesThreadIdFkeyInput>;
  threadId?: InputMaybe<Scalars['Int']['input']>;
  user?: InputMaybe<MessagesUserIdFkeyInput>;
  userId?: InputMaybe<Scalars['Int']['input']>;
};

/** An object where the defined keys will be set on the `message` being updated. */
export type UpdateMessageOnMessageForMessagesThreadIdFkeyPatch = {
  files?: InputMaybe<MessageFilesMessageIdFkeyInverseInput>;
  thread?: InputMaybe<MessagesThreadIdFkeyInput>;
  user?: InputMaybe<MessagesUserIdFkeyInput>;
  userId?: InputMaybe<Scalars['Int']['input']>;
};

/** An object where the defined keys will be set on the `message` being updated. */
export type UpdateMessageOnMessageForMessagesUserIdFkeyPatch = {
  files?: InputMaybe<MessageFilesMessageIdFkeyInverseInput>;
  thread?: InputMaybe<MessagesThreadIdFkeyInput>;
  threadId?: InputMaybe<Scalars['Int']['input']>;
  user?: InputMaybe<MessagesUserIdFkeyInput>;
};

/** An object where the defined keys will be set on the `pipeline` being updated. */
export type UpdatePipelineOnJobForJobsPipelineIdFkeyPatch = {
  jobs?: InputMaybe<JobsPipelineIdFkeyInverseInput>;
  stages?: InputMaybe<PipelineStagesPipelineIdFkeyInverseInput>;
  translations?: InputMaybe<PipelineTranslationsPipelineIdFkeyInverseInput>;
};

/** An object where the defined keys will be set on the `pipeline` being updated. */
export type UpdatePipelineOnPipelineStageForPipelineStagesPipelineIdFkeyPatch = {
  jobs?: InputMaybe<JobsPipelineIdFkeyInverseInput>;
  stages?: InputMaybe<PipelineStagesPipelineIdFkeyInverseInput>;
  translations?: InputMaybe<PipelineTranslationsPipelineIdFkeyInverseInput>;
};

/** An object where the defined keys will be set on the `pipeline` being updated. */
export type UpdatePipelineOnPipelineTranslationForPipelineTranslationsPipelineIdFkeyPatch = {
  jobs?: InputMaybe<JobsPipelineIdFkeyInverseInput>;
  stages?: InputMaybe<PipelineStagesPipelineIdFkeyInverseInput>;
  translations?: InputMaybe<PipelineTranslationsPipelineIdFkeyInverseInput>;
};

/** An object where the defined keys will be set on the `pipelineStage` being updated. */
export type UpdatePipelineStageOnDraftEvaluationForDraftEvaluationsPipelineStageIdFkeyPatch = {
  draftEvaluations?: InputMaybe<DraftEvaluationsPipelineStageIdFkeyInverseInput>;
  jobsApplications?: InputMaybe<JobsApplicationsPipelineStageIdFkeyInverseInput>;
  pipeline?: InputMaybe<PipelineStagesPipelineIdFkeyInput>;
  pipelineId?: InputMaybe<Scalars['Int']['input']>;
  position?: InputMaybe<Scalars['Int']['input']>;
  stageScorecards?: InputMaybe<PipelineStageScorecardsPipelineStageIdFkeyInverseInput>;
  stageUsers?: InputMaybe<PipelineStageUsersPipelineStageIdFkeyInverseInput>;
  translations?: InputMaybe<PipelineStageTranslationsPipelineStageIdFkeyInverseInput>;
  type?: InputMaybe<PipelineStageType>;
};

/** An object where the defined keys will be set on the `pipelineStage` being updated. */
export type UpdatePipelineStageOnJobsApplicationForJobsApplicationsPipelineStageIdFkeyPatch = {
  draftEvaluations?: InputMaybe<DraftEvaluationsPipelineStageIdFkeyInverseInput>;
  jobsApplications?: InputMaybe<JobsApplicationsPipelineStageIdFkeyInverseInput>;
  pipeline?: InputMaybe<PipelineStagesPipelineIdFkeyInput>;
  pipelineId?: InputMaybe<Scalars['Int']['input']>;
  position?: InputMaybe<Scalars['Int']['input']>;
  stageScorecards?: InputMaybe<PipelineStageScorecardsPipelineStageIdFkeyInverseInput>;
  stageUsers?: InputMaybe<PipelineStageUsersPipelineStageIdFkeyInverseInput>;
  translations?: InputMaybe<PipelineStageTranslationsPipelineStageIdFkeyInverseInput>;
  type?: InputMaybe<PipelineStageType>;
};

/** An object where the defined keys will be set on the `pipelineStage` being updated. */
export type UpdatePipelineStageOnPipelineStageForPipelineStagesPipelineIdFkeyPatch = {
  draftEvaluations?: InputMaybe<DraftEvaluationsPipelineStageIdFkeyInverseInput>;
  jobsApplications?: InputMaybe<JobsApplicationsPipelineStageIdFkeyInverseInput>;
  pipeline?: InputMaybe<PipelineStagesPipelineIdFkeyInput>;
  position?: InputMaybe<Scalars['Int']['input']>;
  stageScorecards?: InputMaybe<PipelineStageScorecardsPipelineStageIdFkeyInverseInput>;
  stageUsers?: InputMaybe<PipelineStageUsersPipelineStageIdFkeyInverseInput>;
  translations?: InputMaybe<PipelineStageTranslationsPipelineStageIdFkeyInverseInput>;
  type?: InputMaybe<PipelineStageType>;
};

/** An object where the defined keys will be set on the `pipelineStage` being updated. */
export type UpdatePipelineStageOnPipelineStageScorecardForPipelineStageScorecardsPipelineStageIdFkeyPatch = {
  draftEvaluations?: InputMaybe<DraftEvaluationsPipelineStageIdFkeyInverseInput>;
  jobsApplications?: InputMaybe<JobsApplicationsPipelineStageIdFkeyInverseInput>;
  pipeline?: InputMaybe<PipelineStagesPipelineIdFkeyInput>;
  pipelineId?: InputMaybe<Scalars['Int']['input']>;
  position?: InputMaybe<Scalars['Int']['input']>;
  stageScorecards?: InputMaybe<PipelineStageScorecardsPipelineStageIdFkeyInverseInput>;
  stageUsers?: InputMaybe<PipelineStageUsersPipelineStageIdFkeyInverseInput>;
  translations?: InputMaybe<PipelineStageTranslationsPipelineStageIdFkeyInverseInput>;
  type?: InputMaybe<PipelineStageType>;
};

/** An object where the defined keys will be set on the `pipelineStage` being updated. */
export type UpdatePipelineStageOnPipelineStageTranslationForPipelineStageTranslationsPipelineStageIdFkeyPatch = {
  draftEvaluations?: InputMaybe<DraftEvaluationsPipelineStageIdFkeyInverseInput>;
  jobsApplications?: InputMaybe<JobsApplicationsPipelineStageIdFkeyInverseInput>;
  pipeline?: InputMaybe<PipelineStagesPipelineIdFkeyInput>;
  pipelineId?: InputMaybe<Scalars['Int']['input']>;
  position?: InputMaybe<Scalars['Int']['input']>;
  stageScorecards?: InputMaybe<PipelineStageScorecardsPipelineStageIdFkeyInverseInput>;
  stageUsers?: InputMaybe<PipelineStageUsersPipelineStageIdFkeyInverseInput>;
  translations?: InputMaybe<PipelineStageTranslationsPipelineStageIdFkeyInverseInput>;
  type?: InputMaybe<PipelineStageType>;
};

/** An object where the defined keys will be set on the `pipelineStage` being updated. */
export type UpdatePipelineStageOnPipelineStageUserForPipelineStageUsersPipelineStageIdFkeyPatch = {
  draftEvaluations?: InputMaybe<DraftEvaluationsPipelineStageIdFkeyInverseInput>;
  jobsApplications?: InputMaybe<JobsApplicationsPipelineStageIdFkeyInverseInput>;
  pipeline?: InputMaybe<PipelineStagesPipelineIdFkeyInput>;
  pipelineId?: InputMaybe<Scalars['Int']['input']>;
  position?: InputMaybe<Scalars['Int']['input']>;
  stageScorecards?: InputMaybe<PipelineStageScorecardsPipelineStageIdFkeyInverseInput>;
  stageUsers?: InputMaybe<PipelineStageUsersPipelineStageIdFkeyInverseInput>;
  translations?: InputMaybe<PipelineStageTranslationsPipelineStageIdFkeyInverseInput>;
  type?: InputMaybe<PipelineStageType>;
};

/** An object where the defined keys will be set on the `pipelineStageScorecard` being updated. */
export type UpdatePipelineStageScorecardOnPipelineStageScorecardForPipelineStageScorecardsPipelineStageIdFkeyPatch = {
  pipelineStage?: InputMaybe<PipelineStageScorecardsPipelineStageIdFkeyInput>;
  scorecard?: InputMaybe<PipelineStageScorecardsScorecardIdFkeyInput>;
  scorecardId?: InputMaybe<Scalars['Int']['input']>;
};

/** An object where the defined keys will be set on the `pipelineStageScorecard` being updated. */
export type UpdatePipelineStageScorecardOnPipelineStageScorecardForPipelineStageScorecardsScorecardIdFkeyPatch = {
  pipelineStage?: InputMaybe<PipelineStageScorecardsPipelineStageIdFkeyInput>;
  pipelineStageId?: InputMaybe<Scalars['Int']['input']>;
  scorecard?: InputMaybe<PipelineStageScorecardsScorecardIdFkeyInput>;
};

/** An object where the defined keys will be set on the `pipelineStageTranslation` being updated. */
export type UpdatePipelineStageTranslationOnPipelineStageTranslationForPipelineStageTranslationsPipelineStageIdFkeyPatch = {
  pipelineStage?: InputMaybe<PipelineStageTranslationsPipelineStageIdFkeyInput>;
  title?: InputMaybe<Scalars['String']['input']>;
};

/** An object where the defined keys will be set on the `pipelineStageUser` being updated. */
export type UpdatePipelineStageUserOnPipelineStageUserForPipelineStageUsersPipelineStageIdFkeyPatch = {
  pipelineStage?: InputMaybe<PipelineStageUsersPipelineStageIdFkeyInput>;
  user?: InputMaybe<PipelineStageUsersUserIdFkeyInput>;
  userId?: InputMaybe<Scalars['Int']['input']>;
};

/** An object where the defined keys will be set on the `pipelineStageUser` being updated. */
export type UpdatePipelineStageUserOnPipelineStageUserForPipelineStageUsersUserIdFkeyPatch = {
  pipelineStage?: InputMaybe<PipelineStageUsersPipelineStageIdFkeyInput>;
  pipelineStageId?: InputMaybe<Scalars['Int']['input']>;
  user?: InputMaybe<PipelineStageUsersUserIdFkeyInput>;
};

/** An object where the defined keys will be set on the `pipelineTranslation` being updated. */
export type UpdatePipelineTranslationOnPipelineTranslationForPipelineTranslationsPipelineIdFkeyPatch = {
  pipeline?: InputMaybe<PipelineTranslationsPipelineIdFkeyInput>;
  title?: InputMaybe<Scalars['String']['input']>;
};

/** An object where the defined keys will be set on the `question` being updated. */
export type UpdateQuestionOnCandidateQuestionForCandidateQuestionsQuestionIdFkeyPatch = {
  candidateQuestions?: InputMaybe<CandidateQuestionsQuestionIdFkeyInverseInput>;
  options?: InputMaybe<QuestionOptionsQuestionIdFkeyInverseInput>;
  questionnaireQuestions?: InputMaybe<QuestionnaireQuestionsQuestionIdFkeyInverseInput>;
  required?: InputMaybe<Scalars['Boolean']['input']>;
  translations?: InputMaybe<QuestionTranslationsQuestionIdFkeyInverseInput>;
  type?: InputMaybe<QuestionType>;
};

/** An object where the defined keys will be set on the `question` being updated. */
export type UpdateQuestionOnQuestionOptionForQuestionOptionsQuestionIdFkeyPatch = {
  candidateQuestions?: InputMaybe<CandidateQuestionsQuestionIdFkeyInverseInput>;
  options?: InputMaybe<QuestionOptionsQuestionIdFkeyInverseInput>;
  questionnaireQuestions?: InputMaybe<QuestionnaireQuestionsQuestionIdFkeyInverseInput>;
  required?: InputMaybe<Scalars['Boolean']['input']>;
  translations?: InputMaybe<QuestionTranslationsQuestionIdFkeyInverseInput>;
  type?: InputMaybe<QuestionType>;
};

/** An object where the defined keys will be set on the `question` being updated. */
export type UpdateQuestionOnQuestionTranslationForQuestionTranslationsQuestionIdFkeyPatch = {
  candidateQuestions?: InputMaybe<CandidateQuestionsQuestionIdFkeyInverseInput>;
  options?: InputMaybe<QuestionOptionsQuestionIdFkeyInverseInput>;
  questionnaireQuestions?: InputMaybe<QuestionnaireQuestionsQuestionIdFkeyInverseInput>;
  required?: InputMaybe<Scalars['Boolean']['input']>;
  translations?: InputMaybe<QuestionTranslationsQuestionIdFkeyInverseInput>;
  type?: InputMaybe<QuestionType>;
};

/** An object where the defined keys will be set on the `question` being updated. */
export type UpdateQuestionOnQuestionnaireQuestionForQuestionnaireQuestionsQuestionIdFkeyPatch = {
  candidateQuestions?: InputMaybe<CandidateQuestionsQuestionIdFkeyInverseInput>;
  options?: InputMaybe<QuestionOptionsQuestionIdFkeyInverseInput>;
  questionnaireQuestions?: InputMaybe<QuestionnaireQuestionsQuestionIdFkeyInverseInput>;
  required?: InputMaybe<Scalars['Boolean']['input']>;
  translations?: InputMaybe<QuestionTranslationsQuestionIdFkeyInverseInput>;
  type?: InputMaybe<QuestionType>;
};

/** An object where the defined keys will be set on the `questionOption` being updated. */
export type UpdateQuestionOptionOnCandidateQuestionForCandidateQuestionsQuestionValueIdFkeyPatch = {
  candidateQuestions?: InputMaybe<CandidateQuestionsQuestionValueIdFkeyInverseInput>;
  position?: InputMaybe<Scalars['Int']['input']>;
  question?: InputMaybe<QuestionOptionsQuestionIdFkeyInput>;
  questionId?: InputMaybe<Scalars['Int']['input']>;
  translations?: InputMaybe<QuestionOptionTranslationsQuestionOptionIdFkeyInverseInput>;
};

/** An object where the defined keys will be set on the `questionOption` being updated. */
export type UpdateQuestionOptionOnQuestionOptionForQuestionOptionsQuestionIdFkeyPatch = {
  candidateQuestions?: InputMaybe<CandidateQuestionsQuestionValueIdFkeyInverseInput>;
  position?: InputMaybe<Scalars['Int']['input']>;
  question?: InputMaybe<QuestionOptionsQuestionIdFkeyInput>;
  translations?: InputMaybe<QuestionOptionTranslationsQuestionOptionIdFkeyInverseInput>;
};

/** An object where the defined keys will be set on the `questionOption` being updated. */
export type UpdateQuestionOptionOnQuestionOptionTranslationForQuestionOptionTranslationsQuestionOptionIdFkeyPatch = {
  candidateQuestions?: InputMaybe<CandidateQuestionsQuestionValueIdFkeyInverseInput>;
  position?: InputMaybe<Scalars['Int']['input']>;
  question?: InputMaybe<QuestionOptionsQuestionIdFkeyInput>;
  questionId?: InputMaybe<Scalars['Int']['input']>;
  translations?: InputMaybe<QuestionOptionTranslationsQuestionOptionIdFkeyInverseInput>;
};

/** An object where the defined keys will be set on the `questionOptionTranslation` being updated. */
export type UpdateQuestionOptionTranslationOnQuestionOptionTranslationForQuestionOptionTranslationsQuestionOptionIdFkeyPatch = {
  questionOption?: InputMaybe<QuestionOptionTranslationsQuestionOptionIdFkeyInput>;
  value?: InputMaybe<Scalars['String']['input']>;
};

/** An object where the defined keys will be set on the `questionTranslation` being updated. */
export type UpdateQuestionTranslationOnQuestionTranslationForQuestionTranslationsQuestionIdFkeyPatch = {
  description?: InputMaybe<Scalars['Html']['input']>;
  hint?: InputMaybe<Scalars['String']['input']>;
  question?: InputMaybe<QuestionTranslationsQuestionIdFkeyInput>;
  title?: InputMaybe<Scalars['String']['input']>;
};

/** An object where the defined keys will be set on the `questionnaire` being updated. */
export type UpdateQuestionnaireOnCandidateQuestionForCandidateQuestionsQuestionnaireIdFkeyPatch = {
  candidateQuestionnaires?: InputMaybe<CandidateQuestionnairesQuestionnaireIdFkeyInverseInput>;
  candidateQuestions?: InputMaybe<CandidateQuestionsQuestionnaireIdFkeyInverseInput>;
  category?: InputMaybe<Scalars['String']['input']>;
  deletedAt?: InputMaybe<Scalars['Datetime']['input']>;
  jobQuestionnaires?: InputMaybe<JobQuestionnairesQuestionnaireIdFkeyInverseInput>;
  questionnaireQuestions?: InputMaybe<QuestionnaireQuestionsQuestionnaireIdFkeyInverseInput>;
  translations?: InputMaybe<QuestionnaireTranslationsQuestionnaireIdFkeyInverseInput>;
};

/** An object where the defined keys will be set on the `questionnaire` being updated. */
export type UpdateQuestionnaireOnCandidateQuestionnaireForCandidateQuestionnairesQuestionnaireIdFkeyPatch = {
  candidateQuestionnaires?: InputMaybe<CandidateQuestionnairesQuestionnaireIdFkeyInverseInput>;
  candidateQuestions?: InputMaybe<CandidateQuestionsQuestionnaireIdFkeyInverseInput>;
  category?: InputMaybe<Scalars['String']['input']>;
  deletedAt?: InputMaybe<Scalars['Datetime']['input']>;
  jobQuestionnaires?: InputMaybe<JobQuestionnairesQuestionnaireIdFkeyInverseInput>;
  questionnaireQuestions?: InputMaybe<QuestionnaireQuestionsQuestionnaireIdFkeyInverseInput>;
  translations?: InputMaybe<QuestionnaireTranslationsQuestionnaireIdFkeyInverseInput>;
};

/** An object where the defined keys will be set on the `questionnaire` being updated. */
export type UpdateQuestionnaireOnJobQuestionnaireForJobQuestionnairesQuestionnaireIdFkeyPatch = {
  candidateQuestionnaires?: InputMaybe<CandidateQuestionnairesQuestionnaireIdFkeyInverseInput>;
  candidateQuestions?: InputMaybe<CandidateQuestionsQuestionnaireIdFkeyInverseInput>;
  category?: InputMaybe<Scalars['String']['input']>;
  deletedAt?: InputMaybe<Scalars['Datetime']['input']>;
  jobQuestionnaires?: InputMaybe<JobQuestionnairesQuestionnaireIdFkeyInverseInput>;
  questionnaireQuestions?: InputMaybe<QuestionnaireQuestionsQuestionnaireIdFkeyInverseInput>;
  translations?: InputMaybe<QuestionnaireTranslationsQuestionnaireIdFkeyInverseInput>;
};

/** An object where the defined keys will be set on the `questionnaire` being updated. */
export type UpdateQuestionnaireOnQuestionnaireQuestionForQuestionnaireQuestionsQuestionnaireIdFkeyPatch = {
  candidateQuestionnaires?: InputMaybe<CandidateQuestionnairesQuestionnaireIdFkeyInverseInput>;
  candidateQuestions?: InputMaybe<CandidateQuestionsQuestionnaireIdFkeyInverseInput>;
  category?: InputMaybe<Scalars['String']['input']>;
  deletedAt?: InputMaybe<Scalars['Datetime']['input']>;
  jobQuestionnaires?: InputMaybe<JobQuestionnairesQuestionnaireIdFkeyInverseInput>;
  questionnaireQuestions?: InputMaybe<QuestionnaireQuestionsQuestionnaireIdFkeyInverseInput>;
  translations?: InputMaybe<QuestionnaireTranslationsQuestionnaireIdFkeyInverseInput>;
};

/** An object where the defined keys will be set on the `questionnaire` being updated. */
export type UpdateQuestionnaireOnQuestionnaireTranslationForQuestionnaireTranslationsQuestionnaireIdFkeyPatch = {
  candidateQuestionnaires?: InputMaybe<CandidateQuestionnairesQuestionnaireIdFkeyInverseInput>;
  candidateQuestions?: InputMaybe<CandidateQuestionsQuestionnaireIdFkeyInverseInput>;
  category?: InputMaybe<Scalars['String']['input']>;
  deletedAt?: InputMaybe<Scalars['Datetime']['input']>;
  jobQuestionnaires?: InputMaybe<JobQuestionnairesQuestionnaireIdFkeyInverseInput>;
  questionnaireQuestions?: InputMaybe<QuestionnaireQuestionsQuestionnaireIdFkeyInverseInput>;
  translations?: InputMaybe<QuestionnaireTranslationsQuestionnaireIdFkeyInverseInput>;
};

/** An object where the defined keys will be set on the `questionnaireQuestion` being updated. */
export type UpdateQuestionnaireQuestionOnQuestionnaireQuestionForQuestionnaireQuestionsQuestionIdFkeyPatch = {
  position?: InputMaybe<Scalars['Int']['input']>;
  question?: InputMaybe<QuestionnaireQuestionsQuestionIdFkeyInput>;
  questionnaire?: InputMaybe<QuestionnaireQuestionsQuestionnaireIdFkeyInput>;
  questionnaireId?: InputMaybe<Scalars['Int']['input']>;
};

/** An object where the defined keys will be set on the `questionnaireQuestion` being updated. */
export type UpdateQuestionnaireQuestionOnQuestionnaireQuestionForQuestionnaireQuestionsQuestionnaireIdFkeyPatch = {
  position?: InputMaybe<Scalars['Int']['input']>;
  question?: InputMaybe<QuestionnaireQuestionsQuestionIdFkeyInput>;
  questionId?: InputMaybe<Scalars['Int']['input']>;
  questionnaire?: InputMaybe<QuestionnaireQuestionsQuestionnaireIdFkeyInput>;
};

/** An object where the defined keys will be set on the `questionnaireTranslation` being updated. */
export type UpdateQuestionnaireTranslationOnQuestionnaireTranslationForQuestionnaireTranslationsQuestionnaireIdFkeyPatch = {
  questionnaire?: InputMaybe<QuestionnaireTranslationsQuestionnaireIdFkeyInput>;
  title?: InputMaybe<Scalars['String']['input']>;
};

/** An object where the defined keys will be set on the `role` being updated. */
export type UpdateRoleOnCompanyUserForCompanyUsersRoleIdFkeyPatch = {
  abilities?: InputMaybe<Array<InputMaybe<Roleability>>>;
  companyUsers?: InputMaybe<CompanyUsersRoleIdFkeyInverseInput>;
  translations?: InputMaybe<RoleTranslationsRoleIdFkeyInverseInput>;
  userInvitations?: InputMaybe<UserInvitationsRoleIdFkeyInverseInput>;
};

/** An object where the defined keys will be set on the `role` being updated. */
export type UpdateRoleOnRoleTranslationForRoleTranslationsRoleIdFkeyPatch = {
  abilities?: InputMaybe<Array<InputMaybe<Roleability>>>;
  companyUsers?: InputMaybe<CompanyUsersRoleIdFkeyInverseInput>;
  translations?: InputMaybe<RoleTranslationsRoleIdFkeyInverseInput>;
  userInvitations?: InputMaybe<UserInvitationsRoleIdFkeyInverseInput>;
};

/** An object where the defined keys will be set on the `role` being updated. */
export type UpdateRoleOnUserInvitationForUserInvitationsRoleIdFkeyPatch = {
  abilities?: InputMaybe<Array<InputMaybe<Roleability>>>;
  companyUsers?: InputMaybe<CompanyUsersRoleIdFkeyInverseInput>;
  translations?: InputMaybe<RoleTranslationsRoleIdFkeyInverseInput>;
  userInvitations?: InputMaybe<UserInvitationsRoleIdFkeyInverseInput>;
};

/** An object where the defined keys will be set on the `roleTranslation` being updated. */
export type UpdateRoleTranslationOnRoleTranslationForRoleTranslationsRoleIdFkeyPatch = {
  role?: InputMaybe<RoleTranslationsRoleIdFkeyInput>;
  title?: InputMaybe<Scalars['String']['input']>;
};

/** An object where the defined keys will be set on the `scorecardCriteria` being updated. */
export type UpdateScorecardCriteriaOnEvaluationScorecardCriteriaForEvaluationScorecardCriteriasCriteriaIdFkeyPatch = {
  commentable?: InputMaybe<Scalars['Boolean']['input']>;
  evaluationScorecardCriteria?: InputMaybe<EvaluationScorecardCriteriasCriteriaIdFkeyInverseInput>;
  required?: InputMaybe<Scalars['Boolean']['input']>;
  scorecard?: InputMaybe<ScorecardCriteriasScorecardIdFkeyInput>;
  scorecardId?: InputMaybe<Scalars['Int']['input']>;
  translations?: InputMaybe<ScorecardCriteriaTranslationsScorecardCriteriaIdFkeyInverseInput>;
};

/** An object where the defined keys will be set on the `scorecardCriteria` being updated. */
export type UpdateScorecardCriteriaOnScorecardCriteriaForScorecardCriteriasScorecardIdFkeyPatch = {
  commentable?: InputMaybe<Scalars['Boolean']['input']>;
  evaluationScorecardCriteria?: InputMaybe<EvaluationScorecardCriteriasCriteriaIdFkeyInverseInput>;
  required?: InputMaybe<Scalars['Boolean']['input']>;
  scorecard?: InputMaybe<ScorecardCriteriasScorecardIdFkeyInput>;
  translations?: InputMaybe<ScorecardCriteriaTranslationsScorecardCriteriaIdFkeyInverseInput>;
};

/** An object where the defined keys will be set on the `scorecardCriteria` being updated. */
export type UpdateScorecardCriteriaOnScorecardCriteriaTranslationForScorecardCriteriaTranslationsScorecardCriteriaIdFkeyPatch = {
  commentable?: InputMaybe<Scalars['Boolean']['input']>;
  evaluationScorecardCriteria?: InputMaybe<EvaluationScorecardCriteriasCriteriaIdFkeyInverseInput>;
  required?: InputMaybe<Scalars['Boolean']['input']>;
  scorecard?: InputMaybe<ScorecardCriteriasScorecardIdFkeyInput>;
  scorecardId?: InputMaybe<Scalars['Int']['input']>;
  translations?: InputMaybe<ScorecardCriteriaTranslationsScorecardCriteriaIdFkeyInverseInput>;
};

/** An object where the defined keys will be set on the `scorecardCriteriaTranslation` being updated. */
export type UpdateScorecardCriteriaTranslationOnScorecardCriteriaTranslationForScorecardCriteriaTranslationsScorecardCriteriaIdFkeyPatch = {
  scorecardCriteria?: InputMaybe<ScorecardCriteriaTranslationsScorecardCriteriaIdFkeyInput>;
  title?: InputMaybe<Scalars['String']['input']>;
};

/** An object where the defined keys will be set on the `scorecard` being updated. */
export type UpdateScorecardOnEvaluationScorecardForEvaluationScorecardsScorecardIdFkeyPatch = {
  criterias?: InputMaybe<ScorecardCriteriasScorecardIdFkeyInverseInput>;
  evaluationScorecards?: InputMaybe<EvaluationScorecardsScorecardIdFkeyInverseInput>;
  eventScorecards?: InputMaybe<EventScorecardsScorecardIdFkeyInverseInput>;
  pipelineStageScorecards?: InputMaybe<PipelineStageScorecardsScorecardIdFkeyInverseInput>;
  translations?: InputMaybe<ScorecardTranslationsScorecardIdFkeyInverseInput>;
};

/** An object where the defined keys will be set on the `scorecard` being updated. */
export type UpdateScorecardOnEventScorecardForEventScorecardsScorecardIdFkeyPatch = {
  criterias?: InputMaybe<ScorecardCriteriasScorecardIdFkeyInverseInput>;
  evaluationScorecards?: InputMaybe<EvaluationScorecardsScorecardIdFkeyInverseInput>;
  eventScorecards?: InputMaybe<EventScorecardsScorecardIdFkeyInverseInput>;
  pipelineStageScorecards?: InputMaybe<PipelineStageScorecardsScorecardIdFkeyInverseInput>;
  translations?: InputMaybe<ScorecardTranslationsScorecardIdFkeyInverseInput>;
};

/** An object where the defined keys will be set on the `scorecard` being updated. */
export type UpdateScorecardOnPipelineStageScorecardForPipelineStageScorecardsScorecardIdFkeyPatch = {
  criterias?: InputMaybe<ScorecardCriteriasScorecardIdFkeyInverseInput>;
  evaluationScorecards?: InputMaybe<EvaluationScorecardsScorecardIdFkeyInverseInput>;
  eventScorecards?: InputMaybe<EventScorecardsScorecardIdFkeyInverseInput>;
  pipelineStageScorecards?: InputMaybe<PipelineStageScorecardsScorecardIdFkeyInverseInput>;
  translations?: InputMaybe<ScorecardTranslationsScorecardIdFkeyInverseInput>;
};

/** An object where the defined keys will be set on the `scorecard` being updated. */
export type UpdateScorecardOnScorecardCriteriaForScorecardCriteriasScorecardIdFkeyPatch = {
  criterias?: InputMaybe<ScorecardCriteriasScorecardIdFkeyInverseInput>;
  evaluationScorecards?: InputMaybe<EvaluationScorecardsScorecardIdFkeyInverseInput>;
  eventScorecards?: InputMaybe<EventScorecardsScorecardIdFkeyInverseInput>;
  pipelineStageScorecards?: InputMaybe<PipelineStageScorecardsScorecardIdFkeyInverseInput>;
  translations?: InputMaybe<ScorecardTranslationsScorecardIdFkeyInverseInput>;
};

/** An object where the defined keys will be set on the `scorecard` being updated. */
export type UpdateScorecardOnScorecardTranslationForScorecardTranslationsScorecardIdFkeyPatch = {
  criterias?: InputMaybe<ScorecardCriteriasScorecardIdFkeyInverseInput>;
  evaluationScorecards?: InputMaybe<EvaluationScorecardsScorecardIdFkeyInverseInput>;
  eventScorecards?: InputMaybe<EventScorecardsScorecardIdFkeyInverseInput>;
  pipelineStageScorecards?: InputMaybe<PipelineStageScorecardsScorecardIdFkeyInverseInput>;
  translations?: InputMaybe<ScorecardTranslationsScorecardIdFkeyInverseInput>;
};

/** An object where the defined keys will be set on the `scorecardTranslation` being updated. */
export type UpdateScorecardTranslationOnScorecardTranslationForScorecardTranslationsScorecardIdFkeyPatch = {
  scorecard?: InputMaybe<ScorecardTranslationsScorecardIdFkeyInput>;
  title?: InputMaybe<Scalars['String']['input']>;
};

/** An object where the defined keys will be set on the `skill` being updated. */
export type UpdateSkillOnJobSkillForJobSkillsSkillIdFkeyPatch = {
  jobSkills?: InputMaybe<JobSkillsSkillIdFkeyInverseInput>;
  title?: InputMaybe<Scalars['String']['input']>;
};

/** An object where the defined keys will be set on the `subscription` being updated. */
export type UpdateSubscriptionOnInvoiceForInvoicesSubscriptionIdFkeyPatch = {
  description?: InputMaybe<Scalars['String']['input']>;
  duration?: InputMaybe<Scalars['Int']['input']>;
  durationType?: InputMaybe<DurationType>;
  grade?: InputMaybe<Scalars['Int']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  invoices?: InputMaybe<InvoicesSubscriptionIdFkeyInverseInput>;
  maxCandidates?: InputMaybe<Scalars['Int']['input']>;
  maxJobs?: InputMaybe<Scalars['Int']['input']>;
  maxUser?: InputMaybe<Scalars['Int']['input']>;
  price?: InputMaybe<Scalars['Int']['input']>;
  title?: InputMaybe<Scalars['String']['input']>;
};

/** An object where the defined keys will be set on the `tag` being updated. */
export type UpdateTagOnCandidateTagForCandidateTagsTagIdFkeyPatch = {
  candidateTags?: InputMaybe<CandidateTagsTagIdFkeyInverseInput>;
  jobTags?: InputMaybe<JobTagsTagIdFkeyInverseInput>;
  title?: InputMaybe<Scalars['String']['input']>;
};

/** An object where the defined keys will be set on the `tag` being updated. */
export type UpdateTagOnJobTagForJobTagsTagIdFkeyPatch = {
  candidateTags?: InputMaybe<CandidateTagsTagIdFkeyInverseInput>;
  jobTags?: InputMaybe<JobTagsTagIdFkeyInverseInput>;
  title?: InputMaybe<Scalars['String']['input']>;
};

/** An object where the defined keys will be set on the `thread` being updated. */
export type UpdateThreadOnMessageForMessagesThreadIdFkeyPatch = {
  candidate?: InputMaybe<ThreadsCandidateIdFkeyInput>;
  candidateId?: InputMaybe<Scalars['Int']['input']>;
  job?: InputMaybe<ThreadsJobIdFkeyInput>;
  jobId?: InputMaybe<Scalars['Int']['input']>;
  messages?: InputMaybe<MessagesThreadIdFkeyInverseInput>;
  threadUsers?: InputMaybe<ThreadUsersThreadIdFkeyInverseInput>;
  user?: InputMaybe<ThreadsUserIdFkeyInput>;
  userId?: InputMaybe<Scalars['Int']['input']>;
};

/** An object where the defined keys will be set on the `thread` being updated. */
export type UpdateThreadOnThreadForThreadsCandidateIdFkeyPatch = {
  candidate?: InputMaybe<ThreadsCandidateIdFkeyInput>;
  job?: InputMaybe<ThreadsJobIdFkeyInput>;
  jobId?: InputMaybe<Scalars['Int']['input']>;
  messages?: InputMaybe<MessagesThreadIdFkeyInverseInput>;
  threadUsers?: InputMaybe<ThreadUsersThreadIdFkeyInverseInput>;
  user?: InputMaybe<ThreadsUserIdFkeyInput>;
  userId?: InputMaybe<Scalars['Int']['input']>;
};

/** An object where the defined keys will be set on the `thread` being updated. */
export type UpdateThreadOnThreadForThreadsJobIdFkeyPatch = {
  candidate?: InputMaybe<ThreadsCandidateIdFkeyInput>;
  candidateId?: InputMaybe<Scalars['Int']['input']>;
  job?: InputMaybe<ThreadsJobIdFkeyInput>;
  messages?: InputMaybe<MessagesThreadIdFkeyInverseInput>;
  threadUsers?: InputMaybe<ThreadUsersThreadIdFkeyInverseInput>;
  user?: InputMaybe<ThreadsUserIdFkeyInput>;
  userId?: InputMaybe<Scalars['Int']['input']>;
};

/** An object where the defined keys will be set on the `thread` being updated. */
export type UpdateThreadOnThreadForThreadsUserIdFkeyPatch = {
  candidate?: InputMaybe<ThreadsCandidateIdFkeyInput>;
  candidateId?: InputMaybe<Scalars['Int']['input']>;
  job?: InputMaybe<ThreadsJobIdFkeyInput>;
  jobId?: InputMaybe<Scalars['Int']['input']>;
  messages?: InputMaybe<MessagesThreadIdFkeyInverseInput>;
  threadUsers?: InputMaybe<ThreadUsersThreadIdFkeyInverseInput>;
  user?: InputMaybe<ThreadsUserIdFkeyInput>;
};

/** An object where the defined keys will be set on the `thread` being updated. */
export type UpdateThreadOnThreadUserForThreadUsersThreadIdFkeyPatch = {
  candidate?: InputMaybe<ThreadsCandidateIdFkeyInput>;
  candidateId?: InputMaybe<Scalars['Int']['input']>;
  job?: InputMaybe<ThreadsJobIdFkeyInput>;
  jobId?: InputMaybe<Scalars['Int']['input']>;
  messages?: InputMaybe<MessagesThreadIdFkeyInverseInput>;
  threadUsers?: InputMaybe<ThreadUsersThreadIdFkeyInverseInput>;
  user?: InputMaybe<ThreadsUserIdFkeyInput>;
  userId?: InputMaybe<Scalars['Int']['input']>;
};

/** An object where the defined keys will be set on the `threadUser` being updated. */
export type UpdateThreadUserOnThreadUserForThreadUsersThreadIdFkeyPatch = {
  lastReadAt?: InputMaybe<Scalars['Datetime']['input']>;
  thread?: InputMaybe<ThreadUsersThreadIdFkeyInput>;
  user?: InputMaybe<ThreadUsersUserIdFkeyInput>;
  userId?: InputMaybe<Scalars['Int']['input']>;
};

/** An object where the defined keys will be set on the `threadUser` being updated. */
export type UpdateThreadUserOnThreadUserForThreadUsersUserIdFkeyPatch = {
  lastReadAt?: InputMaybe<Scalars['Datetime']['input']>;
  thread?: InputMaybe<ThreadUsersThreadIdFkeyInput>;
  threadId?: InputMaybe<Scalars['Int']['input']>;
  user?: InputMaybe<ThreadUsersUserIdFkeyInput>;
};

/** An object where the defined keys will be set on the `userInvitation` being updated. */
export type UpdateUserInvitationOnUserInvitationForUserInvitationsRoleIdFkeyPatch = {
  deletedAt?: InputMaybe<Scalars['Datetime']['input']>;
  role?: InputMaybe<UserInvitationsRoleIdFkeyInput>;
};

/** An object where the defined keys will be set on the `user` being updated. */
export type UpdateUserOnCompanyUserForCompanyUsersUserIdFkeyPatch = {
  companyUsers?: InputMaybe<CompanyUsersUserIdFkeyInverseInput>;
  email?: InputMaybe<Scalars['String']['input']>;
  evaluations?: InputMaybe<EvaluationsUserIdFkeyInverseInput>;
  eventUsers?: InputMaybe<EventUsersUserIdFkeyInverseInput>;
  jobOwners?: InputMaybe<JobOwnersUserIdFkeyInverseInput>;
  messages?: InputMaybe<MessagesUserIdFkeyInverseInput>;
  photoNormalUrl?: InputMaybe<Scalars['String']['input']>;
  photoThumbUrl?: InputMaybe<Scalars['String']['input']>;
  pipelineStageUsers?: InputMaybe<PipelineStageUsersUserIdFkeyInverseInput>;
  threadUsers?: InputMaybe<ThreadUsersUserIdFkeyInverseInput>;
  threads?: InputMaybe<ThreadsUserIdFkeyInverseInput>;
  translations?: InputMaybe<UserTranslationsUserIdFkeyInverseInput>;
};

/** An object where the defined keys will be set on the `user` being updated. */
export type UpdateUserOnEvaluationForEvaluationsUserIdFkeyPatch = {
  companyUsers?: InputMaybe<CompanyUsersUserIdFkeyInverseInput>;
  email?: InputMaybe<Scalars['String']['input']>;
  evaluations?: InputMaybe<EvaluationsUserIdFkeyInverseInput>;
  eventUsers?: InputMaybe<EventUsersUserIdFkeyInverseInput>;
  jobOwners?: InputMaybe<JobOwnersUserIdFkeyInverseInput>;
  messages?: InputMaybe<MessagesUserIdFkeyInverseInput>;
  photoNormalUrl?: InputMaybe<Scalars['String']['input']>;
  photoThumbUrl?: InputMaybe<Scalars['String']['input']>;
  pipelineStageUsers?: InputMaybe<PipelineStageUsersUserIdFkeyInverseInput>;
  threadUsers?: InputMaybe<ThreadUsersUserIdFkeyInverseInput>;
  threads?: InputMaybe<ThreadsUserIdFkeyInverseInput>;
  translations?: InputMaybe<UserTranslationsUserIdFkeyInverseInput>;
};

/** An object where the defined keys will be set on the `user` being updated. */
export type UpdateUserOnEventUserForEventUsersUserIdFkeyPatch = {
  companyUsers?: InputMaybe<CompanyUsersUserIdFkeyInverseInput>;
  email?: InputMaybe<Scalars['String']['input']>;
  evaluations?: InputMaybe<EvaluationsUserIdFkeyInverseInput>;
  eventUsers?: InputMaybe<EventUsersUserIdFkeyInverseInput>;
  jobOwners?: InputMaybe<JobOwnersUserIdFkeyInverseInput>;
  messages?: InputMaybe<MessagesUserIdFkeyInverseInput>;
  photoNormalUrl?: InputMaybe<Scalars['String']['input']>;
  photoThumbUrl?: InputMaybe<Scalars['String']['input']>;
  pipelineStageUsers?: InputMaybe<PipelineStageUsersUserIdFkeyInverseInput>;
  threadUsers?: InputMaybe<ThreadUsersUserIdFkeyInverseInput>;
  threads?: InputMaybe<ThreadsUserIdFkeyInverseInput>;
  translations?: InputMaybe<UserTranslationsUserIdFkeyInverseInput>;
};

/** An object where the defined keys will be set on the `user` being updated. */
export type UpdateUserOnJobOwnerForJobOwnersUserIdFkeyPatch = {
  companyUsers?: InputMaybe<CompanyUsersUserIdFkeyInverseInput>;
  email?: InputMaybe<Scalars['String']['input']>;
  evaluations?: InputMaybe<EvaluationsUserIdFkeyInverseInput>;
  eventUsers?: InputMaybe<EventUsersUserIdFkeyInverseInput>;
  jobOwners?: InputMaybe<JobOwnersUserIdFkeyInverseInput>;
  messages?: InputMaybe<MessagesUserIdFkeyInverseInput>;
  photoNormalUrl?: InputMaybe<Scalars['String']['input']>;
  photoThumbUrl?: InputMaybe<Scalars['String']['input']>;
  pipelineStageUsers?: InputMaybe<PipelineStageUsersUserIdFkeyInverseInput>;
  threadUsers?: InputMaybe<ThreadUsersUserIdFkeyInverseInput>;
  threads?: InputMaybe<ThreadsUserIdFkeyInverseInput>;
  translations?: InputMaybe<UserTranslationsUserIdFkeyInverseInput>;
};

/** An object where the defined keys will be set on the `user` being updated. */
export type UpdateUserOnMessageForMessagesUserIdFkeyPatch = {
  companyUsers?: InputMaybe<CompanyUsersUserIdFkeyInverseInput>;
  email?: InputMaybe<Scalars['String']['input']>;
  evaluations?: InputMaybe<EvaluationsUserIdFkeyInverseInput>;
  eventUsers?: InputMaybe<EventUsersUserIdFkeyInverseInput>;
  jobOwners?: InputMaybe<JobOwnersUserIdFkeyInverseInput>;
  messages?: InputMaybe<MessagesUserIdFkeyInverseInput>;
  photoNormalUrl?: InputMaybe<Scalars['String']['input']>;
  photoThumbUrl?: InputMaybe<Scalars['String']['input']>;
  pipelineStageUsers?: InputMaybe<PipelineStageUsersUserIdFkeyInverseInput>;
  threadUsers?: InputMaybe<ThreadUsersUserIdFkeyInverseInput>;
  threads?: InputMaybe<ThreadsUserIdFkeyInverseInput>;
  translations?: InputMaybe<UserTranslationsUserIdFkeyInverseInput>;
};

/** An object where the defined keys will be set on the `user` being updated. */
export type UpdateUserOnPipelineStageUserForPipelineStageUsersUserIdFkeyPatch = {
  companyUsers?: InputMaybe<CompanyUsersUserIdFkeyInverseInput>;
  email?: InputMaybe<Scalars['String']['input']>;
  evaluations?: InputMaybe<EvaluationsUserIdFkeyInverseInput>;
  eventUsers?: InputMaybe<EventUsersUserIdFkeyInverseInput>;
  jobOwners?: InputMaybe<JobOwnersUserIdFkeyInverseInput>;
  messages?: InputMaybe<MessagesUserIdFkeyInverseInput>;
  photoNormalUrl?: InputMaybe<Scalars['String']['input']>;
  photoThumbUrl?: InputMaybe<Scalars['String']['input']>;
  pipelineStageUsers?: InputMaybe<PipelineStageUsersUserIdFkeyInverseInput>;
  threadUsers?: InputMaybe<ThreadUsersUserIdFkeyInverseInput>;
  threads?: InputMaybe<ThreadsUserIdFkeyInverseInput>;
  translations?: InputMaybe<UserTranslationsUserIdFkeyInverseInput>;
};

/** An object where the defined keys will be set on the `user` being updated. */
export type UpdateUserOnThreadForThreadsUserIdFkeyPatch = {
  companyUsers?: InputMaybe<CompanyUsersUserIdFkeyInverseInput>;
  email?: InputMaybe<Scalars['String']['input']>;
  evaluations?: InputMaybe<EvaluationsUserIdFkeyInverseInput>;
  eventUsers?: InputMaybe<EventUsersUserIdFkeyInverseInput>;
  jobOwners?: InputMaybe<JobOwnersUserIdFkeyInverseInput>;
  messages?: InputMaybe<MessagesUserIdFkeyInverseInput>;
  photoNormalUrl?: InputMaybe<Scalars['String']['input']>;
  photoThumbUrl?: InputMaybe<Scalars['String']['input']>;
  pipelineStageUsers?: InputMaybe<PipelineStageUsersUserIdFkeyInverseInput>;
  threadUsers?: InputMaybe<ThreadUsersUserIdFkeyInverseInput>;
  threads?: InputMaybe<ThreadsUserIdFkeyInverseInput>;
  translations?: InputMaybe<UserTranslationsUserIdFkeyInverseInput>;
};

/** An object where the defined keys will be set on the `user` being updated. */
export type UpdateUserOnThreadUserForThreadUsersUserIdFkeyPatch = {
  companyUsers?: InputMaybe<CompanyUsersUserIdFkeyInverseInput>;
  email?: InputMaybe<Scalars['String']['input']>;
  evaluations?: InputMaybe<EvaluationsUserIdFkeyInverseInput>;
  eventUsers?: InputMaybe<EventUsersUserIdFkeyInverseInput>;
  jobOwners?: InputMaybe<JobOwnersUserIdFkeyInverseInput>;
  messages?: InputMaybe<MessagesUserIdFkeyInverseInput>;
  photoNormalUrl?: InputMaybe<Scalars['String']['input']>;
  photoThumbUrl?: InputMaybe<Scalars['String']['input']>;
  pipelineStageUsers?: InputMaybe<PipelineStageUsersUserIdFkeyInverseInput>;
  threadUsers?: InputMaybe<ThreadUsersUserIdFkeyInverseInput>;
  threads?: InputMaybe<ThreadsUserIdFkeyInverseInput>;
  translations?: InputMaybe<UserTranslationsUserIdFkeyInverseInput>;
};

/** An object where the defined keys will be set on the `user` being updated. */
export type UpdateUserOnUserTranslationForUserTranslationsUserIdFkeyPatch = {
  companyUsers?: InputMaybe<CompanyUsersUserIdFkeyInverseInput>;
  email?: InputMaybe<Scalars['String']['input']>;
  evaluations?: InputMaybe<EvaluationsUserIdFkeyInverseInput>;
  eventUsers?: InputMaybe<EventUsersUserIdFkeyInverseInput>;
  jobOwners?: InputMaybe<JobOwnersUserIdFkeyInverseInput>;
  messages?: InputMaybe<MessagesUserIdFkeyInverseInput>;
  photoNormalUrl?: InputMaybe<Scalars['String']['input']>;
  photoThumbUrl?: InputMaybe<Scalars['String']['input']>;
  pipelineStageUsers?: InputMaybe<PipelineStageUsersUserIdFkeyInverseInput>;
  threadUsers?: InputMaybe<ThreadUsersUserIdFkeyInverseInput>;
  threads?: InputMaybe<ThreadsUserIdFkeyInverseInput>;
  translations?: InputMaybe<UserTranslationsUserIdFkeyInverseInput>;
};

/** An object where the defined keys will be set on the `userTranslation` being updated. */
export type UpdateUserTranslationOnUserTranslationForUserTranslationsUserIdFkeyPatch = {
  firstname?: InputMaybe<Scalars['String']['input']>;
  lastname?: InputMaybe<Scalars['String']['input']>;
  user?: InputMaybe<UserTranslationsUserIdFkeyInput>;
};

/** An object where the defined keys will be set on the `websiteFile` being updated. */
export type UpdateWebsiteFileOnWebsiteFileForWebsiteFilesWebsiteIdFkeyPatch = {
  website?: InputMaybe<WebsiteFilesWebsiteIdFkeyInput>;
};

/** An object where the defined keys will be set on the `website` being updated. */
export type UpdateWebsiteOnWebsiteFileForWebsiteFilesWebsiteIdFkeyPatch = {
  backgroundColor?: InputMaybe<Scalars['Int']['input']>;
  companyUrl?: InputMaybe<Scalars['String']['input']>;
  coverExternalId?: InputMaybe<Scalars['UUID']['input']>;
  defaultLanguage?: InputMaybe<Language>;
  faviconExternalId?: InputMaybe<Scalars['UUID']['input']>;
  files?: InputMaybe<WebsiteFilesWebsiteIdFkeyInverseInput>;
  footerCode?: InputMaybe<Scalars['String']['input']>;
  headerCode?: InputMaybe<Scalars['String']['input']>;
  headerLayout?: InputMaybe<Scalars['Int']['input']>;
  headlineColor?: InputMaybe<Scalars['Int']['input']>;
  homeBoxes?: InputMaybe<Scalars['JSON']['input']>;
  host?: InputMaybe<Scalars['String']['input']>;
  languages?: InputMaybe<Array<InputMaybe<Language>>>;
  logoExternalId?: InputMaybe<Scalars['UUID']['input']>;
  otherSettings?: InputMaybe<Scalars['JSON']['input']>;
  primaryColor?: InputMaybe<Scalars['Int']['input']>;
  textColor?: InputMaybe<Scalars['Int']['input']>;
};

export type UpdateCompanyMutationVariables = Exact<{
  input: UpdateCompanyInput;
}>;


export type UpdateCompanyMutation = { __typename?: 'Mutation', updateCompany?: { __typename?: 'UpdateCompanyPayload', company?: { __typename?: 'Company', nodeId: string, id: number, languages: Array<Language | null>, category: CompanyCategory, companySize: CompanySize, customWebsiteHost?: string | null, logoUrl?: string | null, translations: { __typename?: 'CompanyTranslationsConnection', nodes: Array<{ __typename?: 'CompanyTranslation', nodeId: string, name: string, lang: Language }> } } | null } | null };

export type CompaniesQueryVariables = Exact<{ [key: string]: never; }>;


export type CompaniesQuery = { __typename?: 'Query', companies?: { __typename?: 'CompaniesConnection', nodes: Array<{ __typename?: 'Company', id: number, nodeId: string, translations: { __typename?: 'CompanyTranslationsConnection', nodes: Array<{ __typename?: 'CompanyTranslation', nodeId: string, lang: Language, name: string }> } }> } | null };

export type CandidateQueryVariables = Exact<{
  id: Scalars['Int']['input'];
}>;


export type CandidateQuery = { __typename?: 'Query', candidate?: { __typename?: 'Candidate', id: number, photoUrl?: string | null, resumeUrl?: string | null } | null };

export type JobsQueryVariables = Exact<{
  filter?: InputMaybe<JobFilter>;
  orderBy?: InputMaybe<Array<JobsOrderBy> | JobsOrderBy>;
  first?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
}>;


export type JobsQuery = { __typename?: 'Query', jobs?: { __typename?: 'JobsConnection', nodes: Array<{ __typename?: 'Job', nodeId: string, id: number, status: JobStatus, canManageCandidates?: boolean | null, translations: { __typename?: 'JobTranslationsConnection', nodes: Array<{ __typename?: 'JobTranslation', lang: Language, nodeId: string, title: string }> }, department?: { __typename?: 'Department', nodeId: string, translations: { __typename?: 'DepartmentTranslationsConnection', nodes: Array<{ __typename?: 'DepartmentTranslation', nodeId: string, lang: Language, title: string }> } } | null }>, pageInfo: { __typename?: 'PageInfo', hasNextPage: boolean, hasPreviousPage: boolean } } | null };

export type UsersQueryVariables = Exact<{
  first?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<UsersOrderBy> | UsersOrderBy>;
  filter?: InputMaybe<UserFilter>;
}>;


export type UsersQuery = { __typename?: 'Query', users?: { __typename?: 'UsersConnection', nodes: Array<{ __typename?: 'User', id: number, nodeId: string, translations: { __typename?: 'UserTranslationsConnection', nodes: Array<{ __typename?: 'UserTranslation', nodeId: string, lang: Language, fullname?: string | null, initials?: string | null }> } }> } | null };

export type CandidatesQueryVariables = Exact<{ [key: string]: never; }>;


export type CandidatesQuery = { __typename?: 'Query', candidates?: { __typename?: 'CandidatesConnection', nodes: Array<{ __typename?: 'Candidate', id: number, translations: { __typename?: 'CandidateTranslationsConnection', nodes: Array<{ __typename?: 'CandidateTranslation', candidate?: { __typename?: 'Candidate', photoUrl?: string | null, translations: { __typename?: 'CandidateTranslationsConnection', nodes: Array<{ __typename?: 'CandidateTranslation', name: string, candidateId: number }> }, jobs: { __typename?: 'CandidateJobsByJobsApplicationCandidateIdAndJobIdManyToManyConnection', nodes: Array<{ __typename?: 'Job', translations: { __typename?: 'JobTranslationsConnection', nodes: Array<{ __typename?: 'JobTranslation', title: string }> } }> } } | null }> } }> } | null };


export const UpdateCompanyDocument = gql`
    mutation UpdateCompany($input: UpdateCompanyInput!) {
  updateCompany(input: $input) {
    company {
      nodeId
      id
      translations {
        nodes {
          nodeId
          name
          lang
        }
      }
      languages
      category
      companySize
      customWebsiteHost
      logoUrl
    }
  }
}
    `;
export type UpdateCompanyMutationFn = Apollo.MutationFunction<UpdateCompanyMutation, UpdateCompanyMutationVariables>;

/**
 * __useUpdateCompanyMutation__
 *
 * To run a mutation, you first call `useUpdateCompanyMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateCompanyMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateCompanyMutation, { data, loading, error }] = useUpdateCompanyMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useUpdateCompanyMutation(baseOptions?: Apollo.MutationHookOptions<UpdateCompanyMutation, UpdateCompanyMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UpdateCompanyMutation, UpdateCompanyMutationVariables>(UpdateCompanyDocument, options);
      }
export type UpdateCompanyMutationHookResult = ReturnType<typeof useUpdateCompanyMutation>;
export type UpdateCompanyMutationResult = Apollo.MutationResult<UpdateCompanyMutation>;
export type UpdateCompanyMutationOptions = Apollo.BaseMutationOptions<UpdateCompanyMutation, UpdateCompanyMutationVariables>;
export const CompaniesDocument = gql`
    query Companies {
  companies {
    nodes {
      id
      nodeId
      translations {
        nodes {
          nodeId
          lang
          name
        }
      }
    }
  }
}
    `;

/**
 * __useCompaniesQuery__
 *
 * To run a query within a React component, call `useCompaniesQuery` and pass it any options that fit your needs.
 * When your component renders, `useCompaniesQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useCompaniesQuery({
 *   variables: {
 *   },
 * });
 */
export function useCompaniesQuery(baseOptions?: Apollo.QueryHookOptions<CompaniesQuery, CompaniesQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<CompaniesQuery, CompaniesQueryVariables>(CompaniesDocument, options);
      }
export function useCompaniesLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<CompaniesQuery, CompaniesQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<CompaniesQuery, CompaniesQueryVariables>(CompaniesDocument, options);
        }
export function useCompaniesSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<CompaniesQuery, CompaniesQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<CompaniesQuery, CompaniesQueryVariables>(CompaniesDocument, options);
        }
export type CompaniesQueryHookResult = ReturnType<typeof useCompaniesQuery>;
export type CompaniesLazyQueryHookResult = ReturnType<typeof useCompaniesLazyQuery>;
export type CompaniesSuspenseQueryHookResult = ReturnType<typeof useCompaniesSuspenseQuery>;
export type CompaniesQueryResult = Apollo.QueryResult<CompaniesQuery, CompaniesQueryVariables>;
export const CandidateDocument = gql`
    query Candidate($id: Int!) {
  candidate(id: $id) {
    id
    photoUrl
    resumeUrl
  }
}
    `;

/**
 * __useCandidateQuery__
 *
 * To run a query within a React component, call `useCandidateQuery` and pass it any options that fit your needs.
 * When your component renders, `useCandidateQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useCandidateQuery({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useCandidateQuery(baseOptions: Apollo.QueryHookOptions<CandidateQuery, CandidateQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<CandidateQuery, CandidateQueryVariables>(CandidateDocument, options);
      }
export function useCandidateLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<CandidateQuery, CandidateQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<CandidateQuery, CandidateQueryVariables>(CandidateDocument, options);
        }
export function useCandidateSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<CandidateQuery, CandidateQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<CandidateQuery, CandidateQueryVariables>(CandidateDocument, options);
        }
export type CandidateQueryHookResult = ReturnType<typeof useCandidateQuery>;
export type CandidateLazyQueryHookResult = ReturnType<typeof useCandidateLazyQuery>;
export type CandidateSuspenseQueryHookResult = ReturnType<typeof useCandidateSuspenseQuery>;
export type CandidateQueryResult = Apollo.QueryResult<CandidateQuery, CandidateQueryVariables>;
export const JobsDocument = gql`
    query Jobs($filter: JobFilter, $orderBy: [JobsOrderBy!], $first: Int, $offset: Int) {
  jobs(filter: $filter, orderBy: $orderBy, first: $first, offset: $offset) {
    nodes {
      nodeId
      id
      translations {
        nodes {
          lang
          nodeId
          title
        }
      }
      status
      department {
        nodeId
        translations {
          nodes {
            nodeId
            lang
            title
          }
        }
      }
      canManageCandidates
    }
    pageInfo {
      hasNextPage
      hasPreviousPage
    }
  }
}
    `;

/**
 * __useJobsQuery__
 *
 * To run a query within a React component, call `useJobsQuery` and pass it any options that fit your needs.
 * When your component renders, `useJobsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useJobsQuery({
 *   variables: {
 *      filter: // value for 'filter'
 *      orderBy: // value for 'orderBy'
 *      first: // value for 'first'
 *      offset: // value for 'offset'
 *   },
 * });
 */
export function useJobsQuery(baseOptions?: Apollo.QueryHookOptions<JobsQuery, JobsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<JobsQuery, JobsQueryVariables>(JobsDocument, options);
      }
export function useJobsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<JobsQuery, JobsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<JobsQuery, JobsQueryVariables>(JobsDocument, options);
        }
export function useJobsSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<JobsQuery, JobsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<JobsQuery, JobsQueryVariables>(JobsDocument, options);
        }
export type JobsQueryHookResult = ReturnType<typeof useJobsQuery>;
export type JobsLazyQueryHookResult = ReturnType<typeof useJobsLazyQuery>;
export type JobsSuspenseQueryHookResult = ReturnType<typeof useJobsSuspenseQuery>;
export type JobsQueryResult = Apollo.QueryResult<JobsQuery, JobsQueryVariables>;
export const UsersDocument = gql`
    query Users($first: Int, $offset: Int, $orderBy: [UsersOrderBy!], $filter: UserFilter) {
  users(first: $first, offset: $offset, orderBy: $orderBy, filter: $filter) {
    nodes {
      id
      nodeId
      translations {
        nodes {
          nodeId
          lang
          fullname
          initials
        }
      }
    }
  }
}
    `;

/**
 * __useUsersQuery__
 *
 * To run a query within a React component, call `useUsersQuery` and pass it any options that fit your needs.
 * When your component renders, `useUsersQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useUsersQuery({
 *   variables: {
 *      first: // value for 'first'
 *      offset: // value for 'offset'
 *      orderBy: // value for 'orderBy'
 *      filter: // value for 'filter'
 *   },
 * });
 */
export function useUsersQuery(baseOptions?: Apollo.QueryHookOptions<UsersQuery, UsersQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<UsersQuery, UsersQueryVariables>(UsersDocument, options);
      }
export function useUsersLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<UsersQuery, UsersQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<UsersQuery, UsersQueryVariables>(UsersDocument, options);
        }
export function useUsersSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<UsersQuery, UsersQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<UsersQuery, UsersQueryVariables>(UsersDocument, options);
        }
export type UsersQueryHookResult = ReturnType<typeof useUsersQuery>;
export type UsersLazyQueryHookResult = ReturnType<typeof useUsersLazyQuery>;
export type UsersSuspenseQueryHookResult = ReturnType<typeof useUsersSuspenseQuery>;
export type UsersQueryResult = Apollo.QueryResult<UsersQuery, UsersQueryVariables>;
export const CandidatesDocument = gql`
    query Candidates {
  candidates {
    nodes {
      id
      translations {
        nodes {
          candidate {
            photoUrl
            translations {
              nodes {
                name
                candidateId
              }
            }
            jobs {
              nodes {
                translations {
                  nodes {
                    title
                  }
                }
              }
            }
          }
        }
      }
    }
  }
}
    `;

/**
 * __useCandidatesQuery__
 *
 * To run a query within a React component, call `useCandidatesQuery` and pass it any options that fit your needs.
 * When your component renders, `useCandidatesQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useCandidatesQuery({
 *   variables: {
 *   },
 * });
 */
export function useCandidatesQuery(baseOptions?: Apollo.QueryHookOptions<CandidatesQuery, CandidatesQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<CandidatesQuery, CandidatesQueryVariables>(CandidatesDocument, options);
      }
export function useCandidatesLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<CandidatesQuery, CandidatesQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<CandidatesQuery, CandidatesQueryVariables>(CandidatesDocument, options);
        }
export function useCandidatesSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<CandidatesQuery, CandidatesQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<CandidatesQuery, CandidatesQueryVariables>(CandidatesDocument, options);
        }
export type CandidatesQueryHookResult = ReturnType<typeof useCandidatesQuery>;
export type CandidatesLazyQueryHookResult = ReturnType<typeof useCandidatesLazyQuery>;
export type CandidatesSuspenseQueryHookResult = ReturnType<typeof useCandidatesSuspenseQuery>;
export type CandidatesQueryResult = Apollo.QueryResult<CandidatesQuery, CandidatesQueryVariables>;
